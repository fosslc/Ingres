
/*
** Copyright (c) 2004 Ingres Corporation
*/
#include    <compat.h>
#include    <gl.h>
#include    <sl.h>
#include    <iicommon.h>
#include    <qu.h>
#include    <lo.h>
#include    <si.h>
#include    <nm.h>
#include    <cs.h>
#include    <mu.h>
#include    <gca.h>
#include    <gc.h>
#include    <gcaint.h>
#include    <gcr.h>

/**
**
**  Name: gcarestore.C - Contains the function gca_restore.
**
**  Description:
**        
**      gcarestore.c contains the following functions:
**
**          gca_restore() - save current context prior to process switching
**
**
**  History:
**      23-Apr-87 (jbowers)
**          Initial module implementation
**      30-Sept-87 (jbowers)
**          Changed to move restore mechanism down into GCrestore in CL.
**	16-May-89 (GordonW)
**	    check return from gca_alloc call.
**	20-Sep-89 (seiwald)
**	    Restoring association table now handled by gca_rs_acb().
**	25-Oct-89 (seiwald)
**	    Shortened gcainternal.h to gcaint.h.
**	08-Mar-90 (seiwald)
**	    Removed references to gca_alloc, gca_free.
**	31-Dec-90 (seiwald)
**	    Bulk of GCA_SAVE and GCA_RESTORE moved into mainline from CL, 
**	    using a new version independent GCA_SAVE_DATA structure.
**	    Previously, the CL (GCsave/GCrestore) was responsible for
**	    transporting the user, GCA, and CL level data between parent 
**	    and child.  Now GCA handles that, using the old save file 
**	    mechanism but with a version independent format.  GCsave and 
**	    GCrestore simply format and interpret the CL level data.
**	14-Mar-91 (seiwald)
**	    Call gca_del_acb(), not gca_free() to free the ACB on restore
**	    failure, as the latter would leave the ACB list corrupted.  
**	10-Apr-91 (seiwald)
**	    Use SIfopen() rather than the obsolescent SIopen().
**	17-aug-91 (leighb) DeskTop Porting Change:
**	    GCrestore must be declared a VOID, not a STATUS.
**	07-Jan-93 (edg)
**	    Removed FUNC_EXTERN's (now in gcaint.h) and #include gcagref.h.
**	14-jul-93 (ed)
**	    replacing <dbms.h> by <gl.h> <sl.h> <iicommon.h> <dbdbms.h>
**	25-aug-93 (ed)
**	    remove dbdbms.h
**	10-Oct-95 (gordy)
**	    Completion moved to gca_service().
**	20-Nov-95 (gordy)
**	    Added prototypes.
**	21-Nov-95 (gordy)
**	    Added gcr.h for embedded Comm Server configuration.
**	18-Feb-97 (gordy)
**	    Moved heterogeneous boolean to flags.
**	10-Apr-97 (gordy)
**	    GCA and GC service parameters separated.
**	18-Dec-97 (gordy)
**	    ACB now deleted in gca_complete(), flag for deletion.
**	29-Dec-97 (gordy)
**	    Return size_advise in service parms for processing by
**	    gca_service() rather than ACB.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	11-aug-2005 (clach04/thogo01)
**	    115053 
**	    New routine gcu_restore() added to allow access to the gca_savename
**	    file. This is now used in gca_restore() instead of accessing the
**	    file directly. gcu_restore is also used by Enterprise Access 
**	    (gateway) to get access to GC internals.
**/


/*{
** Name: gca_restore()	- Save current GCA context and status
**
** Description:
**        
**      gca_restore is invoked by the user after switching to a new 
**      process.  It allows GCA to restore internal data structures and status  
**      that were saved by gca_save in the parent process.  If user data were
**	saved, these are restored also.
**        
**      The data to be restored were saved by gca_save, which invokes GCsave
**	to save the user data, the ACB and the LCB in a system-specific way.  
**	GCrestore is invoked to perform the restore, using the save_name
**	generated by gca_save and returned to the user.
**      
**      The Association Table queue must be reconstructed.  
**
** Inputs:
**      svc_parms                       Pointer to the collective parm list 
**                                      created by gca_call.  The following
**                                      elements of svc_parms are used by 
**                                      gca_restore:
**
**      .parameter list                 Pointer to the invoker's service
**                                      parameter list.  The folloing 
**                                      elements of the parameter list are 
**                                      used by gca_restore:
**
**      .gca_save_id                    An identifier passed by the user to 
**                                      be used to identify the saved data for
**                                      subsequent restoration.
**
** Outputs:
**      .gca_ptr_user_data              Pointer to a block of user data which
**                                      has been restored.
**      .gca_length_user_data           Length of the user's data block.
**      .gca_status			The element of .parameter_list in which
**                                      the result of the save operation is 
**                                      reported to the user.
**	    E_GC0000_OK
**	    E_GC0015_BAD_SAVE_NAME
**	    E_GC0016_RESTORE_FAIL
**
**	Returns:
**	    VOID
**
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      24-APR-87 (jbowers)
**          Initial function implementation
**	10-Oct-95 (gordy)
**	    Completion moved to gca_service().
**	18-Feb-97 (gordy)
**	    Moved heterogeneous boolean to flags.
**	10-Apr-97 (gordy)
**	    GCA and GC service parameters separated.
**	18-Dec-97 (gordy)
**	    ACB now deleted in gca_complete(), flag for deletion.
**	29-Dec-97 (gordy)
**	    Return size_advise in service parms for processing by
**	    gca_service() rather than ACB.
*/

VOID
gca_restore( GCA_SVC_PARMS *svc_parms )
{
    GCA_RS_PARMS        *rs_parms = (GCA_RS_PARMS *)svc_parms->parameter_list;
    GCA_SAVE_DATA	gca_data;
    PTR			buffer;
    i4			length;

    /* Initialize status in service invoker's parameter list  */

    rs_parms->gca_status = E_GCFFFF_IN_PROCESS;
    svc_parms->acb = NULL;
    buffer = NULL;

    /*
    ** Read and verify saved data header info.
    */
    length = sizeof( gca_data );

    svc_parms->gc_parms.status = 
	gcu_restore( rs_parms->gca_save_name, FALSE, &length, (PTR)&gca_data );

    if ( svc_parms->gc_parms.status != OK )  goto complete;

    if ( length < sizeof( gca_data )  ||
	 gca_data.save_level_major != GCA_SAVE_LEVEL_MAJOR )
    {
	svc_parms->gc_parms.status = E_GC0015_BAD_SAVE_NAME;
	goto complete;
    }

    /*
    ** Read all saved data
    */
    length = sizeof( gca_data ) + gca_data.cl_save_size + 
				  gca_data.user_save_size;

    if ( ! (buffer = (PTR)gca_alloc( length )) )
    {
	svc_parms->gc_parms.status = E_GC0013_ASSFL_MEM;
	goto complete;
    }

    svc_parms->gc_parms.status = 
	gcu_restore( rs_parms->gca_save_name, TRUE, &length, (PTR)buffer );

    if ( svc_parms->gc_parms.status != OK )  goto complete;

    if ( length < (sizeof( gca_data ) + gca_data.cl_save_size + 
					gca_data.user_save_size) )
    {
	svc_parms->gc_parms.status = E_GC0015_BAD_SAVE_NAME;
	goto complete;
    }

    /*
    ** Setup ACB for the restored connection.
    */
    if ( ! (svc_parms->acb = gca_rs_acb( gca_data.assoc_id )) )
    {
	svc_parms->gc_parms.status = E_GC0013_ASSFL_MEM;
	goto complete;
    }

    svc_parms->acb->flags.heterogeneous = gca_data.heterogeneous;

    /* 
    ** Do CL restore 
    */
    svc_parms->gc_parms.svc_buffer = (PTR)((u_i1 *)buffer + sizeof(gca_data));
    svc_parms->gc_parms.svc_send_length = gca_data.cl_save_size;
    svc_parms->gc_parms.size_advise = gca_data.size_advise;
    GCrestore( &svc_parms->gc_parms );

    /*
    ** Return user data.  Caller is responsible for
    ** freeing the returned buffer, so move user data
    ** to start of allocated buffer.
    */
    MEcopy( (PTR)((u_i1 *)buffer + sizeof(gca_data) + gca_data.cl_save_size), 
	    gca_data.user_save_size, buffer );
    rs_parms->gca_ptr_user_data = buffer;
    rs_parms->gca_length_user_data = gca_data.user_save_size;

complete:

    /* 
    ** Clean up the mess. 
    */
    if ( svc_parms->gc_parms.status != OK )
    {
	if ( buffer )  gca_free( buffer );
	if ( svc_parms->acb )  svc_parms->acb->flags.delete_acb = TRUE;
    }

    /*
    ** Completion signaled in gca_service().
    */
    return;
}

STATUS
gcu_restore( char *id, bool clear, i4 *length, PTR buff )
{
    LOCATION	loc;
    FILE	*fd = NULL;
    STATUS	read_status = OK;
    STATUS	status = OK;
    i4		len = *length;

    *length = 0;			/* No data read thus far */

    /*
    ** The ID is the path and filename of the
    ** data to be restored.  Open the file and
    ** read the data.
    */
    LOfroms( PATH & FILENAME, id, &loc );
    if ( SIfopen( &loc, "r", SI_VAR, 0, &fd ) != OK )
    {
        status = E_GC0017_RSTR_OPEN;
        goto complete;
    }
    
    read_status = SIread( fd, len, &len, buff );

    if ( read_status != OK && read_status != ENDFILE )
    {
        status = E_GC0018_RSTR_READ;
        goto complete;
    }

    *length = len;

  complete:

    if ( fd )  SIclose( fd );
    if ( clear )  LOdelete( &loc );

    return( status );
}

