/*
** Copyright (c) 1993, 2009 Ingres Corporation
*/

#include <compat.h>
#ifndef VMS
#include <systypes.h>
#endif
#include <sql.h>                    /* ODBC Core definitions */
#include <sqlext.h>                 /* ODBC extensions */
#include <sqlstate.h>               /* ODBC driver sqlstate codes */
#include <sqlcmd.h>

#include <gl.h>
#include <iicommon.h>
#include <cm.h>
#include <cv.h>
#include <me.h>
#include <st.h> 
#include <tr.h>
#include <erodbc.h>
#include <iiapi.h>

#include <sqlca.h>
#include <idmsxsq.h>                /* control block typedefs */
#include <idmsutil.h>               /* utility stuff */
#include "caidoopt.h"              /* connect options */
#include "idmsoinf.h"               /* information definitions */
#include "idmsoids.h"               /* string ids */
#include <idmseini.h>               /* ini file keys */
#include "idmsodbc.h"               /* ODBC driver definitions             */
#include "idmsover.h"

#ifndef SQL_CATALOG_NAME
#define SQL_CATALOG_NAME   10003    /* defined only in ODBC 3.0 */
#endif

/*
** Name: INFO.C
**
** Description:
**	Information routines for ODBC driver.
**
** History:
**	18-mar-1993 (rosda01)
**	    Initial coding
**	14-mar-1995 (rosda01)
**	    ODBC 2.0 upgrade...
**	27-mar-1997 (thoda04)
**	    Modified for Ingres OpenSQL datatypes
**	18-apr-1997 (thoda04)
**	    SQL_IC_UPPER for non-Ingres server classes
**	29-apr-1997 (tenje01)
**	    fixed SQL_DATABASE_NAME, SQL_DBMS_VER, SQL_DRIVER_NAME  
**	20-may-1997 (tenje01)
**	    fixed SQL_DBMS_VER for Desktop 
**	21-may-1997 (tenje01)
**	    fixed fn functions for non-ingres class
**	05-jun-1997 (tenje01)
**	    returned server class for SQL_DBMS_NAME instead of Ingres 
**	18-jun-1997 (tenje01)
**	    fixed SQL_PROCEDURE_TERM, SQL_PROCEDURES for db2
**	20-jun-1997 (tenje01)
**	    removed 6 changes 
**	30-jul-1997 (thoda04)
**	    fixed SQL_OUTER_JOINS to return "N" for non-Ingres
**	01-aug-1997 (thoda04)
**	    Outer join support for DESKTOP and Oracle
**	01-aug-1997 (thoda04)
**	    Return " " for SQL_IDENTIFIER_QUOTE_CHAR if pre-OI 
**	14-aug-1997 (tenje01)
**	    fixed SQL_DBMS_VER for DCOM
**	26-sep-1997 (thoda04)
**	    Return SQL_DBMS_NAME as upper case. 
**	18-nov-1997 (thoda04)
**	    DB_NAME_CASE from iicapabilities support
**	02-dec-1997 (thoda04)
**	    Get SQL_ACTIVE_STATEMENTS from DBC.
**	05-dec-1997 (thoda04)
**	    Use idmsover.h for driver version info (SQL_DRIVER_VER)
**	05-dec-1997 (tenje01)
**	    conver C run-time functions to CL
**	06-feb-1998 (thoda04)
**	    Fixed sizes from 16-bit to 32-bit
**	14-jan-1999 (thoda04)
**	    Fixed SQL_MAX_CURSOR_NAME_LEN, SQL_MAX_OWNER_NAME_LEN,
**	    SQL_MAX_TABLE_NAME_LEN, SQL_MAX_COLUMN_NAME_LEN.
**	25-feb-1999 (thoda04)
**	    Ported to UNIX.
**	25-mar-1999 (thoda04)
**	    Updates for other product packaging
**	30-jun-1999 (thoda04)
**	    Removed "abort" from keyword list (b97576).
**	08-jul-1999 (Bobby Ward)
**	    Changed UtGetIniString from a variable  
**	    of 9 to size0f(sz) which is a constant of
**	    33 Bug # 97832	
**	01-may-2000 (loera01)
**	    Bug 100747: Replaced check for "INGRES" in the registry with
**	    isServerClassINGRES macro, so that user-defined server classes
**	    are interpreted as Ingres classes.
**	24-may-2000 (thoda04)
**	    Additional isServerClassINGRES conversions
**	    for user-defined server class support
**	05-oct-2000 (thoda04)
**	    Display full version for SQL_DBMS_VER
**	30-oct-2000 (thoda04)
**	    Added option to return NULL for TABLE_SCHEM
**	11-dec-2000 (thoda04)
**	    Upgrade to 3.5 specifications
**	16-jul-2001 (somsa01)
**	    Cleaned up compiler warnings.
**	25-jul-2001 (thoda04)
**	    Add support for SQL_WLONGVARCHAR (Unicode blobs)
**	18-jan-2002 (thoda04)
**	    If release >= 2.5, return 'Y' if SQL_EXPRESSIONS_IN_ORDERBY
**	18-jan-2002 (thoda04)
**	    If release >= 2.5, return 'N' if SQL_ORDER_BY_COLUMNS_IN_SELECT
**      20-apr-2002 (loera01) Bug 107536
**          Mark pseudo-query generated by SQLGetTypeInfo() with STMT_INTERNAL flag, 
**      18-jul-2002 (loera01) Bug 108300
**          For SQLGetTypeInfo_InternalCall(): if the ODBC version is 
**          initialized to version 2, remap date or date/time datatypes 
**          internally to version 2 if the driver manager mapped them to
**          version 3.
**     22-aug-2002 (loera01) Bug 108573
**          For SQLGetInfo_Common(), treat a zero return from CMcmpcase()
**          as indicative of a character match--not the other way around.
**     30-jul-2002  Fei Wei SIR #108411
**          Made change to functions SQLGetInfo and SQLGetTypeInfo to support DBMS 
**          change to allow the VARCHAR limit to 32k; added internal function GetSQLMaxLen.
**     11-sep-2002 (loera01) Bug 108609
**          Removed redundant call to LockDbc() in SQLGetInfo_Common().
**     06-nov-2002 (loera01)
**          Cleaned up casting for ANSI compliance.
**      14-feb-2003 (loera01) SIR 109643
**          Minimize platform-dependency in code.  Make backward-compatible
**          with earlier Ingres versions.
**    04-dec-2003 (loera01)
**          Changed STMT_TYPEINFO to CATLG_TYPEINFO.
**	23-apr-2004 (somsa01)
**	    Include systypes.h to avoid compile errors on HP.
**    29-apr-2004 (loera01)
**          Add SQL_BIGINT to list of supported types for SQLGetTypeInfo().
**	11-Jun-2004 (somsa01)
**	    Cleaned up code for Open Source.
**     15-nov-2004 (Ralph.Loen@ca.com) Bug 113462
**          Use IItrace global block to handle tracing.
**    20-sep-2005 (weife01) Bug 115207
**          SQLGetInfo for attribute SQL_MAX_STATEMENT_LEN return 0, means no limit now.
**     17-nov-2004 (Ralph.Loen@ca.com) Bug 113483
**          Add support for SQL_WCHAR, SQL_WVARHAR, and SQL_WLONGVARCHAR.
**     06-jan-2006 (loera01) Bug 115625
**          In SQLGetInfo_Common(), copy only two bytes from i2temp--not
**          four bytes.
**    20-jun-2006 (Ralph Loen) SIR 116275
**          Update InfoBitTable with CONVERT scalar functions.
**    29-jun-2006 (Ralph Loen) SIR 116319
**          Change syntax compliance level from SQL_OSC_CORE to 
**          SQL_OSC_EXTENDED.
**     10-Aug-2006 (Ralph Loen) SIR 116477
**          Add support for ISO dates, times, and intervals (first phase).
**          Primarily affects SQLGetInfo() and SQLGetTypeInfo() in this file.
**     28-Sep-2006 (Ralph Loen) SIR 116477
**          Adjusted treatment of ISO date/times according to new API/ADF rules.
**     03-Oct-2006 (Ralph Loen) SIR 116477
**          Dynamic parameters for dates and timestamps are now sent as binary
**          values for backward-compatibility with ingresdate.
**     06-jun-2007 (weife01) Bug 118460
**          In SQLGetInfo_Common(), SQL_CREATE_VIEW is missing from case switch, 
**          and SQL_CATALOG_LOCATION is updated from SQL_QUALIFIER_LOCATION
**          from 2.0 driver.
**     20-jun-2007 (weife01) Bug 118504
**          In SQLGetInfo_Common(), add support for infotype SQL_DTC_TRANSITION_COST. 
**     31-aug-2007 (thoda04) Bug 119020
**          Add SQL_CVT_WVARCHAR | SQL_CVT_WLONGVARCHAR to INGRES_CVT_ALL
**     09-Jan-2008 (Ralph Loen) SIR 119723
**          In SQLGetInfo(), add support for static scrollable cursors.  
**          Correctly initialize default value for cursor attributes.
**     30-Jan-2008 (Ralph Loen) SIR 119723
**          Added info in support of keyset-driven cursors.
**     28-may-2008 (weife01) Bug 120430
**          Return szUsername to SQLGetInfo with SQL_USER_NAME if SQLConnect()
**          has NULL value for szUID.
**     02-Oct-2008 (Ralph Loen) SIR 117537
**          In SQLGetTypeInfo(), set the max precision to max_decprec in the
**          connection handle instead of a hard-coded value of 31 for
**          decimal datatypes.
**     14-Nov-2008 (Ralph Loen) SIR 121228
**          Add support for OPT_INGRESDATE configuration parameter.  If set,
**          SQLGetTypeInfo() returns INGRESDATE rather than ANSIDATE.
**     19-Nov-2008 (Ralph Loen) SIR 121228
**          In SQLGetTypeInfo_InternalCall(), expose support for ANSI 
**          timestamps and intervals, even if OPT_INGRESDATE is set. 
**     14-Dec-2008 (Ralph Loen) Bug 121384
**          Revised GetSQLMaxLen() so that the output length argument is
**          DWORD instead of UCHAR.  In SQLGetTypeInfo_internalCall(),
**          invoke GetSQLMaxLen() when the data type and precision tuple   
**          pointers are explicitly known, instead of re-positioning the
**          tuple pointers.  Invoke GetSQLMaxLen() only when necessary,
**          i.e., when the data type is non-atomic not a blob, and not
**          Unicode.
**     15-Dec-2008 (Ralph Loen) Bug 121384
**          Make sure default lengths are retained in GetSQLMaxLen() finds
**          no cached length for the given data type.
**     15-Dec-2008 (Ralph Loen) Bug 121393
**         In GetSQLMaxLen(), add cases SQL_WCHAR and SQL_WVARCHAR with
**         searches for sql_max_nchr_column_len and sql_max_nvchar_column_len,
**         respectively.
**     22-Dec-2008 (Ralph Loen) Bug 121418
**         Add SQL_CVT_NUMERIC to list of supported conversions in
**         SQL_CVT_ALL.
**     08-Jan-2009 (Ralph Loen) Bug 121482
**         Add SQL_CA1_NEXT, SQL_CA1_ABSOLUTE and SQL_CA1_RELATIVE
**         to SQL_KEYSET_CURSOR_ATTRIBUTES1 
**     23-Jan-2009 (Ralph Loen) Bug 121535
**         Always return SQL_UNSPECIFIED for SQL_CURSOR_SENSITIVY in
**         SQLGetInfo().
**     23-Mar-2009 (Ralph Loen) Bug 121838
**         Add support for SQLGetFunctions().
**     19-may-2009 (Ralph Loen) Bug 122082
**         Add handle locking/unlocking and internal tracing to
**         SQLGetFunctions().
**     16-Sep-2009 (Ralph Loen) Bug 122597
**         In SQLGetInfo_Common(), return support for SQL_FD_FETCH_NEXT,
**         SQL_FD_FETCH_FIRST, SQL_FD_FETCH_LAST, SQL_FD_FETCH_PRIOR,
**         SQL_FD_FETCH_ABSOLUTE and SQL_FD_FETCH_RELATIVE if the API
**         connection level indicates support for scrollable cursors.
**     15-Oct-2009 (Ralph Loen) Bug 122675 
**         In SQLGetInfo_Common(), clear SQL_CVT_WCHAR, SQL_CVT_WVARCHAR,
**         SQL_CVT_WLONGVARCHAR bits from infoBit capabilities mask if
**         attribute is an SQL_CONVERT attribute and the target does
**         not support Unicode (pdbc->is_unicode_enabled == FALSE).
**     04-Dec-2009 (Ralph Loen) Bug 123014
**         SQLGetInfo_Common(), add support for SQL_CVT_BINARY, SQL_CVT_WCHAR,
**         SQL_CVT_WVARCHAR, SQL_CVT_WLONGVARCHAR, SQL_CVT_CHAR,
**         SQL_CVT_BIGINT, SQL_CVT_FLOAT, SQL_CVT_DOUBLE, SQL_CVT_REAL,
**         SQL_CONVERT_DOUBLE, SQL_CONVERT_FLOAT, SQL_CONVERT_REAL, and
**         SQL_CONVERT_WLONGVARCHAR.
**     14-Dec-2009 (Ralph Loen) Bug 123058
**         In GetSQLMaxLen(), use I4ASSIGN_MACRO instead of MEcopy() to 
**         assign the maximum length of variable-length data types to
**         the output lenPtr argument of GetSQLMaxLen().  Make the lenPtr
**         argument an i4 instead of a DWORD to silence compiler warnings.
**     08-Feb-2010 (Ralph Loen) SIR 123266
**         Added support for booleans as SQL_BIT, contingent on the API 
**         connection level.
**     05-Mar-2010 (Ralph Loen) SIR 123378
**         Changed Name field of tdescTypeInfo to OBJECT_NAME_SIZE to
**         allow for larger names of descriptor info.
**     28-Jun-2010 (Ralph Loen) Bug 123983 
**         Adjusted column size in dataTypeInfo to better match ODBC specs.
**         In SQLGetTypeInfo(), adjust minimum and maximum scale of 
**         date/time data types to according to specifications. 
*/

static RETCODE SQL_API SQLGetInfo_Common(
    LPDBC   pdbc,
    UWORD   fInfoType,
    SQLPOINTER  rgbInfoValueParameter,
    SWORD   cbInfoValueMax,
    SWORD     *pcbInfoValue);

#define INGRES_CVT_ALL SQL_CVT_INTEGER | SQL_CVT_LONGVARBINARY | \
SQL_CVT_LONGVARCHAR | SQL_CVT_DECIMAL | SQL_CVT_NUMERIC | SQL_CVT_SMALLINT | \
SQL_CVT_TINYINT | SQL_CVT_VARBINARY | SQL_CVT_VARCHAR | SQL_CVT_BIT | \
SQL_CVT_WCHAR | SQL_CVT_WVARCHAR | SQL_CVT_WLONGVARCHAR | \
SQL_CVT_BINARY | SQL_CVT_WCHAR | SQL_CVT_WVARCHAR | SQL_CVT_WLONGVARCHAR | \
SQL_CVT_CHAR | SQL_CVT_BIGINT | SQL_CVT_FLOAT | SQL_CVT_DOUBLE | SQL_CVT_REAL

/*
**  SQLGetInfo 32 bit unsigned integer constant values:
*/
static const UDWORD InfoBitTable[] =
{
    SQL_AGGREGATE_FUNCTIONS,        SQL_AF_ALL      |
                                    SQL_AF_AVG      |
                                    SQL_AF_COUNT    |
                                    SQL_AF_DISTINCT |
                                    SQL_AF_MAX      |
                                    SQL_AF_MIN      |
                                    SQL_AF_SUM,
    SQL_ALTER_DOMAIN,               0,
    SQL_ALTER_TABLE,                0,
    SQL_ASYNC_MODE,                 SQL_AM_NONE,
    SQL_BATCH_ROW_COUNT,            0,
    SQL_BATCH_SUPPORT,              0,
    SQL_BOOKMARK_PERSISTENCE,       0,
    SQL_CONVERT_BIGINT,             INGRES_CVT_ALL,
    SQL_CONVERT_BINARY,             INGRES_CVT_ALL,
    SQL_CONVERT_BIT,                INGRES_CVT_ALL,
    SQL_CONVERT_CHAR,               INGRES_CVT_ALL,
    SQL_CONVERT_DATE,               SQL_CVT_DATE | SQL_CVT_TIME 
                                        | SQL_CVT_DATE | SQL_CVT_CHAR
                                        | SQL_CVT_VARCHAR | SQL_CVT_WCHAR
                                        | SQL_CVT_WVARCHAR,
    SQL_CONVERT_DECIMAL,            INGRES_CVT_ALL,
    SQL_CONVERT_DOUBLE,             INGRES_CVT_ALL,
    SQL_CONVERT_FLOAT,              INGRES_CVT_ALL,
    SQL_CONVERT_FUNCTIONS,          SQL_FN_CVT_CONVERT,
    SQL_CONVERT_INTERVAL_DAY_TIME,  0,
    SQL_CONVERT_INTERVAL_YEAR_MONTH,0,
    SQL_CONVERT_INTEGER,            INGRES_CVT_ALL,
    SQL_CONVERT_LONGVARBINARY,      INGRES_CVT_ALL,
    SQL_CONVERT_LONGVARCHAR,        INGRES_CVT_ALL,
    SQL_CONVERT_NUMERIC,            INGRES_CVT_ALL,
    SQL_CONVERT_REAL,               INGRES_CVT_ALL,
    SQL_CONVERT_SMALLINT,           INGRES_CVT_ALL,
    SQL_CONVERT_TIME,               SQL_CVT_TIME | SQL_CVT_DATE | SQL_CVT_CHAR
                                       | SQL_CVT_VARCHAR | SQL_CVT_WCHAR 
                                       | SQL_CVT_WVARCHAR,
    SQL_CONVERT_TIMESTAMP,          SQL_CVT_TIMESTAMP | SQL_CVT_TIME 
                                       | SQL_CVT_DATE | SQL_CVT_CHAR
                                       | SQL_CVT_VARCHAR | SQL_CVT_WCHAR
                                       | SQL_CVT_WVARCHAR,
    SQL_CONVERT_TINYINT,            INGRES_CVT_ALL,
    SQL_CONVERT_VARBINARY,          INGRES_CVT_ALL,
    SQL_CONVERT_VARCHAR,            INGRES_CVT_ALL,
    SQL_CONVERT_WCHAR,              INGRES_CVT_ALL,
    SQL_CONVERT_WLONGVARCHAR,       INGRES_CVT_ALL,
    SQL_CONVERT_WVARCHAR,           INGRES_CVT_ALL,
    SQL_CREATE_ASSERTION,           0,
    SQL_CREATE_CHARACTER_SET,       0,
    SQL_CREATE_COLLATION,           0,
    SQL_CREATE_DOMAIN,              0,
    SQL_CREATE_SCHEMA,              SQL_CS_CREATE_SCHEMA |
                                    SQL_CS_AUTHORIZATION,
    SQL_CREATE_TABLE,               SQL_CT_CREATE_TABLE,
    SQL_CREATE_TRANSLATION,         0,
    SQL_CREATE_VIEW,                SQL_CV_CREATE_VIEW | SQL_CV_CHECK_OPTION,
    SQL_CURSOR_SENSITIVITY,         SQL_UNSPECIFIED,
    SQL_DATETIME_LITERALS,          SQL_DL_SQL92_DATE |
                                    SQL_DL_SQL92_TIME |
                                    SQL_DL_SQL92_TIMESTAMP,
    SQL_DDL_INDEX,                  SQL_DI_CREATE_INDEX |
                                    SQL_DI_DROP_INDEX,
    SQL_DEFAULT_TXN_ISOLATION,      SQL_TXN_SERIALIZABLE,
/*  SQL_DRIVER_HDBC,                0,   implemented by DM
    SQL_DRIVER_HENV,                0,   implemented by DM
    SQL_DRIVER_HDESC,               0,   implemented by DM
    SQL_DRIVER_HLIB,                0,   implemented by DM
    SQL_DRIVER_HSTMT,               0,   implemented by DM */
    SQL_DROP_ASSERTION,             0,
    SQL_DROP_CHARACTER_SET,         0,
    SQL_DROP_COLLATION,             0,
    SQL_DROP_DOMAIN,                0,
    SQL_DROP_SCHEMA,                0,
    SQL_DROP_TABLE,                 SQL_DT_DROP_TABLE,
    SQL_DROP_TRANSLATION,           0,
	SQL_DTC_TRANSITION_COST,        0,
    SQL_DROP_VIEW,                  SQL_DV_DROP_VIEW,
    SQL_DYNAMIC_CURSOR_ATTRIBUTES1, 0,
    SQL_DYNAMIC_CURSOR_ATTRIBUTES2, 0,
    SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1,
                                    SQL_CA1_NEXT,
    SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2,
                                    0,
    SQL_FETCH_DIRECTION,            SQL_FD_FETCH_NEXT,
    SQL_GETDATA_EXTENSIONS,         SQL_GD_ANY_COLUMN | 
                                    SQL_GD_ANY_ORDER | 
                                    SQL_GD_BOUND,
    SQL_INDEX_KEYWORDS,             SQL_IK_ASC |
                                    SQL_IK_DESC,
    SQL_INFO_SCHEMA_VIEWS,          0,
    SQL_INSERT_STATEMENT,           SQL_IS_INSERT_LITERALS |
                                    SQL_IS_INSERT_SEARCHED |
                                    SQL_IS_SELECT_INTO,
    SQL_KEYSET_CURSOR_ATTRIBUTES1,  0,
    SQL_KEYSET_CURSOR_ATTRIBUTES2,  0,
    SQL_LOCK_TYPES,                 0,  /* fixme */
    SQL_MAX_ASYNC_CONCURRENT_STATEMENTS,
                                    0,
    SQL_MAX_BINARY_LITERAL_LEN,     0,
    SQL_MAX_CHAR_LITERAL_LEN,       0,
    SQL_MAX_INDEX_SIZE,             0,
    SQL_MAX_ROW_SIZE,               2008,
    SQL_MAX_STATEMENT_LEN,          0,
    SQL_NUMERIC_FUNCTIONS,          SQL_FN_NUM_ABS | SQL_FN_NUM_ATAN | 
                                    SQL_FN_NUM_COS | SQL_FN_NUM_EXP | 
                                    SQL_FN_NUM_LOG  | SQL_FN_NUM_MOD |
                                    SQL_FN_NUM_SIN | SQL_FN_NUM_SQRT,
    SQL_ODBC_INTERFACE_CONFORMANCE, SQL_OIC_CORE,
    SQL_OJ_CAPABILITIES,            SQL_OJ_LEFT | SQL_OJ_RIGHT | SQL_OJ_FULL |
                                    SQL_OJ_NOT_ORDERED | SQL_OJ_ALL_COMPARISON_OPS,
    SQL_OWNER_USAGE,                SQL_OU_DML_STATEMENTS | 
                                    SQL_OU_TABLE_DEFINITION | 
                                    SQL_OU_PROCEDURE_INVOCATION |
                                    SQL_OU_INDEX_DEFINITION | 
                                    SQL_OU_PRIVILEGE_DEFINITION,
    SQL_PARAM_ARRAY_ROW_COUNTS,     SQL_PARC_BATCH,
    SQL_PARAM_ARRAY_SELECTS,        SQL_PAS_BATCH,
    SQL_POS_OPERATIONS,             0,
    SQL_POSITIONED_STATEMENTS,      SQL_PS_POSITIONED_DELETE | 
                                    SQL_PS_POSITIONED_UPDATE | 
                                    SQL_PS_SELECT_FOR_UPDATE,
    SQL_QUALIFIER_USAGE,            0,
    SQL_SCROLL_CONCURRENCY,         SQL_SCCO_READ_ONLY | 
                                    SQL_SCCO_LOCK      | 
                                    SQL_SCCO_OPT_VALUES,
    SQL_SCROLL_OPTIONS,             SQL_SO_FORWARD_ONLY,
    SQL_SQL_CONFORMANCE,            SQL_SC_SQL92_ENTRY,
    SQL_SQL92_DATETIME_FUNCTIONS,   0,
                             /*     SQL_SDF_CURRENT_DATE     |
                                    SQL_SDF_CURRENT_TIME     |
                                    SQL_SDF_CURRENT_TIMESTAMP, */
    SQL_SQL92_FOREIGN_KEY_DELETE_RULE,
                                    0,
    SQL_SQL92_FOREIGN_KEY_UPDATE_RULE,
                                    0,
    SQL_SQL92_GRANT,                SQL_SG_DELETE_TABLE      |
                                    SQL_SG_INSERT_TABLE      |
                                    SQL_SG_REFERENCES_COLUMN |
                                    SQL_SG_REFERENCES_TABLE  |
                                    SQL_SG_SELECT_TABLE      |
                                    SQL_SG_UPDATE_COLUMN     |
                                    SQL_SG_UPDATE_TABLE      |
                                    SQL_SG_WITH_GRANT_OPTION,
    SQL_SQL92_NUMERIC_VALUE_FUNCTIONS,
                                    0,
    SQL_SQL92_PREDICATES,           SQL_SP_BETWEEN    |
                                    SQL_SP_COMPARISON |
                                    SQL_SP_EXISTS     |
                                    SQL_SP_IN         |
                                    SQL_SP_ISNOTNULL  |
                                    SQL_SP_LIKE,
    SQL_SQL92_RELATIONAL_JOIN_OPERATORS,
                                    SQL_SRJO_FULL_OUTER_JOIN |
                                    SQL_SRJO_LEFT_OUTER_JOIN |
                                    SQL_SRJO_RIGHT_OUTER_JOIN,
    SQL_SQL92_REVOKE,               SQL_SR_CASCADE           |
                                    SQL_SR_DELETE_TABLE      |
                                    SQL_SR_GRANT_OPTION_FOR  |
                                    SQL_SR_INSERT_TABLE      |
                                    SQL_SR_SELECT_TABLE      |
                                    SQL_SR_UPDATE_TABLE,
    SQL_SQL92_ROW_VALUE_CONSTRUCTOR,0,
    SQL_SQL92_STRING_FUNCTIONS,     0,
    SQL_SQL92_VALUE_EXPRESSIONS,    SQL_SRVC_VALUE_EXPRESSION |
                                    SQL_SRVC_NULL             |
                                    SQL_SRVC_ROW_SUBQUERY,
    SQL_STANDARD_CLI_CONFORMANCE,   0,
    SQL_STATIC_CURSOR_ATTRIBUTES1,  0,
    SQL_STATIC_CURSOR_ATTRIBUTES2,  0,
    SQL_STATIC_SENSITIVITY,         0,
    SQL_STRING_FUNCTIONS,           SQL_FN_STR_CONCAT | SQL_FN_STR_LCASE  | 
                                    SQL_FN_STR_LEFT   | SQL_FN_STR_LENGTH | 
                                    SQL_FN_STR_RIGHT  |
                                    SQL_FN_STR_RTRIM  | SQL_FN_STR_UCASE,
    SQL_SUBQUERIES,                 SQL_SQ_CORRELATED_SUBQUERIES | 
                                    SQL_SQ_COMPARISON | SQL_SQ_EXISTS | 
                                    SQL_SQ_IN | SQL_SQ_QUANTIFIED,
    SQL_SYSTEM_FUNCTIONS,           SQL_FN_SYS_DBNAME | SQL_FN_SYS_USERNAME | 
                                    SQL_FN_SYS_IFNULL,
    SQL_TIMEDATE_ADD_INTERVALS,     0,
    SQL_TIMEDATE_DIFF_INTERVALS,    0,
    SQL_TIMEDATE_FUNCTIONS,         SQL_FN_TD_CURDATE | SQL_FN_TD_CURTIME | 
                                    SQL_FN_TD_DAYNAME | SQL_FN_TD_DAYOFMONTH | 
                                    SQL_FN_TD_DAYOFWEEK | SQL_FN_TD_DAYOFYEAR |
                                    SQL_FN_TD_HOUR | SQL_FN_TD_MINUTE | 
                                    SQL_FN_TD_MONTH | SQL_FN_TD_MONTHNAME | 
                                    SQL_FN_TD_NOW | SQL_FN_TD_QUARTER |
                                    SQL_FN_TD_SECOND | SQL_FN_TD_WEEK | 
                                    SQL_FN_TD_YEAR,
    SQL_TXN_ISOLATION_OPTION,       SQL_TXN_READ_UNCOMMITTED | 
                                    SQL_TXN_READ_COMMITTED |
                                    SQL_TXN_REPEATABLE_READ | 
                                    SQL_TXN_SERIALIZABLE,
    SQL_UNION,                      SQL_U_UNION | SQL_U_UNION_ALL,
    MAX_INFO_TYPE
};

/*
**  SQLGetInfo 16 bit integer constant values:
*/
static const UWORD InfoIntTable[] =
{
    SQL_ACTIVE_CONNECTIONS,         0,
    SQL_ACTIVE_ENVIRONMENTS,        0,
    SQL_ACTIVE_STATEMENTS,          0,
    SQL_CATALOG_LOCATION,           0,
    SQL_CONCAT_NULL_BEHAVIOR,       SQL_CB_NULL,  /* SQL r.g "Nulls" chapter */
    SQL_CORRELATION_NAME,           SQL_CN_ANY,
    SQL_FILE_USAGE,                 SQL_FILE_NOT_SUPPORTED,
    SQL_GROUP_BY,                   SQL_GB_GROUP_BY_CONTAINS_SELECT,
    SQL_IDENTIFIER_CASE,            SQL_IC_LOWER,
    SQL_MAX_COLUMN_NAME_LEN,        32,
    SQL_MAX_COLUMNS_IN_GROUP_BY,    MAX_COLUMNS_INGRES,
    SQL_MAX_COLUMNS_IN_INDEX,       MAX_COLUMNS_INGRES,
    SQL_MAX_COLUMNS_IN_ORDER_BY,    MAX_COLUMNS_INGRES,
    SQL_MAX_COLUMNS_IN_SELECT,      MAX_COLUMNS_INGRES,
    SQL_MAX_COLUMNS_IN_TABLE,       MAX_COLUMNS_INGRES,
    SQL_MAX_CURSOR_NAME_LEN,        64,
    SQL_MAX_IDENTIFIER_LEN,         32,
    SQL_MAX_OWNER_NAME_LEN,         32,
    SQL_MAX_PROCEDURE_NAME_LEN,     32,   
    SQL_MAX_QUALIFIER_NAME_LEN,     0,
    SQL_MAX_TABLE_NAME_LEN,         32,
    SQL_MAX_TABLES_IN_SELECT,       30,
    SQL_MAX_USER_NAME_LEN,          32,
    SQL_NON_NULLABLE_COLUMNS,       SQL_NNC_NON_NULL,
    SQL_NULL_COLLATION,             SQL_NC_HIGH,
    SQL_ODBC_API_CONFORMANCE,       SQL_OAC_LEVEL1,
    SQL_ODBC_SAG_CLI_CONFORMANCE,   SQL_OSCC_COMPLIANT,
    SQL_ODBC_SQL_CONFORMANCE,       SQL_OSC_EXTENDED,
    SQL_QUOTED_IDENTIFIER_CASE,     SQL_IC_LOWER,
    SQL_TXN_CAPABLE,                SQL_TC_ALL,
    MAX_INFO_TYPE
};

/*
**  SQLGetInfo string constant values:
*/
static const struct tInfoStrTable
{
    UWORD  fInfoType;
    char * string;
} InfoStrTable[]
     =
{
    SQL_ACCESSIBLE_PROCEDURES,      "N\0",
    SQL_COLUMN_ALIAS,               "Y\0",              
    SQL_CATALOG_NAME,               "N\0",              
    SQL_COLLATION_SEQ,              "ISO 8859-1",              
    SQL_DBMS_NAME,                  "Ingres\0",
    SQL_DESCRIBE_PARAMETER,         "N\0",              
/*  SQL_DM_VER,                     "##.##.####\0",   implemented by DM */
    SQL_DRIVER_VER,                 VER_FILEVERSION_STR,
    SQL_EXPRESSIONS_IN_ORDERBY,     "N\0",
    SQL_IDENTIFIER_QUOTE_CHAR,      "\042\0",   /* fix me */
    SQL_KEYWORDS, "copy,do,elseif,endif,endloop,endwhile,if,integrity,\
message,modify,permit,relocate,return,save,savepoint,until,while\0",
    SQL_LIKE_ESCAPE_CLAUSE,         "Y\0",
    SQL_MAX_ROW_SIZE_INCLUDES_LONG, "N\0",
    SQL_MULT_RESULT_SETS,           "N\0",
    SQL_MULTIPLE_ACTIVE_TXN,        "Y\0",
    SQL_NEED_LONG_DATA_LEN,         "Y\0",
    SQL_ODBC_VER,                   "03.50.0000\0",  /* implemented by DM */
    SQL_ODBC_SQL_OPT_IEF,           "N\0",
    SQL_ORDER_BY_COLUMNS_IN_SELECT, "Y\0",
    SQL_OUTER_JOINS,                "Y\0",
    SQL_OWNER_TERM,                 "Username\0",
    SQL_PROCEDURE_TERM,             "database procedure\0",
    SQL_PROCEDURES,                 "Y\0", 
    SQL_QUALIFIER_NAME_SEPARATOR,   "\0",
    SQL_QUALIFIER_TERM,             "\0",
    SQL_ROW_UPDATES,                "N\0",
    SQL_SEARCH_PATTERN_ESCAPE,      "\\\0",
    SQL_SPECIAL_CHARACTERS,         "@#$\0",
    SQL_TABLE_TERM,                 "TABLE\0",
    SQL_XOPEN_CLI_YEAR,             "1995\0",
    MAX_INFO_TYPE,                  NULL
};



 static const struct tdataTypeInfo
{
    i2      ingtype;    
#define IITYPE_OPENSQL -1
#define IITYPE_ALL 0
#define IITYPE_INGRES 1
#define IITYPE_INGRES_ISODATES 2
    char   *type_name;
    i2      data_type;
    i4      precision;                    
    char * literal_prefix;                      
    char * literal_suffix;                            
    char * create_params;                                  
    i2      searchable;
    i2      subcode;  
} dataTypeInfo[]   =
{
    { IITYPE_INGRES,"LONG NVARCHAR",SQL_WLONGVARCHAR, 
        MAXI4 / DB_ELMSZ, "'","'",          "",SQL_UNSEARCHABLE, 0 },
    { IITYPE_INGRES,"NVARCHAR",    SQL_WVARCHAR,
        2000 / DB_ELMSZ, "'","'","max length",SQL_SEARCHABLE, 0 },
    { IITYPE_INGRES,"NCHAR",       SQL_WCHAR,
        2000 / DB_ELMSZ, "'","'",    "length",SQL_SEARCHABLE, 0 },
    { IITYPE_INGRES,"BOOLEAN",    SQL_BIT,
        1, "",   "",         "",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_INGRES,"INTEGER1",    SQL_TINYINT,
        3, "",   "",         "",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_INGRES,"LONG BYTE",   SQL_LONGVARBINARY, 
        MAXI4, "X'", "'",        "",SQL_UNSEARCHABLE, 0 },
    { IITYPE_INGRES,"BYTE VARYING",SQL_VARBINARY,      
        2000, "X'", "'",  "length",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_INGRES,"BYTE",        SQL_BINARY,         
        2000, "X'", "'",  "length",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_INGRES,"LONG VARCHAR",SQL_LONGVARCHAR,   MAXI4, "'",  "'",        "",SQL_UNSEARCHABLE},
    { IITYPE_ALL,"CHAR",        SQL_CHAR,           
        2000, "'",  "'",  "length",SQL_SEARCHABLE, 0 },
    { IITYPE_ALL,"DECIMAL",     SQL_DECIMAL,          
        31, "",   "",   "precision,scale", SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_ALL,"INTEGER",     SQL_INTEGER,          
        10, "", "",           "",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_INGRES,"INTEGER8",      SQL_BIGINT,           
        20, "", "",           "",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_ALL,"SMALLINT",    SQL_SMALLINT,          
        5, "", "",           "",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_ALL,"FLOAT",       SQL_FLOAT,
        53, "", "",  "precision",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_ALL,"REAL",        SQL_REAL,
        24, "", "",           "",SQL_ALL_EXCEPT_LIKE, 0 },
    { IITYPE_INGRES_ISODATES,"ANSIDATE",        SQL_DATE,             
        10, "'","'",          "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_DATE },
    { IITYPE_INGRES_ISODATES,"ANSIDATE",        SQL_TYPE_DATE,        
        10, "'","'",          "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_DATE },
    { IITYPE_INGRES_ISODATES,"TIMESTAMP",   SQL_TIMESTAMP,        
        29, "'","'",          "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_TIMESTAMP },
    { IITYPE_INGRES_ISODATES,"TIMESTAMP",   SQL_TYPE_TIMESTAMP,   
        29, "'","'",          "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_TIMESTAMP },
    { IITYPE_INGRES_ISODATES,"TIME",        SQL_TIME,             
        18, "'","'",          "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_TIME },
    { IITYPE_INGRES_ISODATES,"TIME",        SQL_TYPE_TIME,        
        18, "'","'",          "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_TIME },
    { IITYPE_INGRES_ISODATES,"INTERVAL YEAR TO MONTH",SQL_INTERVAL_YEAR_TO_MONTH,
        3,"'","'","",SQL_ALL_EXCEPT_LIKE, SQL_CODE_YEAR_TO_MONTH },
    { IITYPE_INGRES_ISODATES,"INTERVAL DAY TO SECOND",SQL_INTERVAL_DAY_TO_SECOND,
        19,"'","'",      "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_DAY },
    { IITYPE_ALL,"DATE",    SQL_TYPE_TIMESTAMP,   
        26, "'","'",        "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_DATE },
    { IITYPE_ALL,"DATE",    SQL_TIMESTAMP,        
        26, "'","'",        "",SQL_ALL_EXCEPT_LIKE, SQL_CODE_DATE },
    { IITYPE_ALL,"VARCHAR", SQL_VARCHAR,        
        2000, "'","'","max length",SQL_SEARCHABLE, 0 },
    { IITYPE_ALL,"",            0,                     
        0, "", "",           "",0, 0}
  };

/*
**  SQLGetInfo
**
**  Return general information about the driver and data source
**  associated with a connection.
**
**  On entry: pdbc          -->connection block.
**            fInfoType      = type of information.
**            rgbInfoValue  -->where to return information.
**            cbInfoValueMax = length if information buffer.
**            pcbInfoValue  -->length of information to return.
**
**  Returns:  SQL_SUCCESS
**            SQL_SUCCESS_WITH_INFO
**            SQL_ERROR
*/
RETCODE SQL_API SQLGetInfo(
    SQLHDBC hdbc,
    UWORD   fInfoType,
    SQLPOINTER  rgbInfoValueParameter,
    SWORD   cbInfoValueMax,
    SWORD     *pcbInfoValue)
{
    LPDBC   pdbc    = (LPDBC)hdbc;

    if (!LockDbc (pdbc)) 
       return SQL_INVALID_HANDLE;

    return(SQLGetInfo_Common(pdbc, fInfoType, rgbInfoValueParameter,
                             cbInfoValueMax, pcbInfoValue));
}


/*
**  SQLGetInfo_InternalCall
**
**  Call the common code.without locking the DBC
**
**  On entry: pstmt  -->statement control block.
**            fOption = free options
**
**  Returns:  SQL status
*/
RETCODE SQL_API SQLGetInfo_InternalCall(
    LPDBC   pdbc,
    UWORD   fInfoType,
    SQLPOINTER  rgbInfoValueParameter,
    SWORD   cbInfoValueMax,
    SWORD     *pcbInfoValue)

{
    if (!LockDbc_Trusted (pdbc)) 
       return SQL_INVALID_HANDLE;

    return(SQLGetInfo_Common(pdbc, fInfoType, rgbInfoValueParameter,
                             cbInfoValueMax, pcbInfoValue));
}

#define SQL_OJ_CAPABILITIES_MERANT 65003

/*
**  SQLGetInfo_Common
**
**  Return general information about the driver and data source
**  associated with a connection.
**
**  On entry: pdbc          -->connection block.
**            fInfoType      = type of information.
**            rgbInfoValue  -->where to return information.
**            cbInfoValueMax = length if information buffer.
**            pcbInfoValue  -->length of information to return.
**
**  Returns:  SQL_SUCCESS
**            SQL_SUCCESS_WITH_INFO
**            SQL_ERROR
*/
static RETCODE SQL_API SQLGetInfo_Common(
    LPDBC   pdbc,
    UWORD   fInfoType,
    SQLPOINTER  rgbInfoValueParameter,
    SWORD   cbInfoValueMax,
    SWORD     *pcbInfoValue)
{
    PTR     rgbInfoValue = (PTR)rgbInfoValueParameter;
    CHAR    sz[33];
    LPSTR   lpsz;
    const struct tInfoStrTable     * pInfoStr;
    CHAR      * s;
    i2      i2temp;
    i2      i2sizeofSWORD = sizeof(SWORD);
    i4      i4temp;
    UDWORD  infoBit;
    RETCODE rc = SQL_ERROR;

    if (IItrace.fTrace >= ODBC_EX_TRACE)
        TraceOdbc (SQL_API_SQLGETINFO, pdbc, fInfoType,
            rgbInfoValue, cbInfoValueMax, pcbInfoValue);

    ErrResetDbc (pdbc);        /* clear any errors on DBC */

    if (fInfoType == SQL_OJ_CAPABILITIES_MERANT)  /* if strange Merant value, */
        fInfoType =  SQL_OJ_CAPABILITIES;         /* massage back to MS value */

    switch (fInfoType)
    {
    /*
    **  Info is a 16 bit integer constant:
    */
    case SQL_ACTIVE_CONNECTIONS:
    case SQL_ACTIVE_ENVIRONMENTS:
	case SQL_CATALOG_LOCATION:
    case SQL_CONCAT_NULL_BEHAVIOR:
    case SQL_CORRELATION_NAME:
    case SQL_FILE_USAGE:
    case SQL_GROUP_BY:
    case SQL_MAX_COLUMN_NAME_LEN:
    case SQL_MAX_COLUMNS_IN_GROUP_BY:
    case SQL_MAX_COLUMNS_IN_INDEX:
    case SQL_MAX_COLUMNS_IN_ORDER_BY:
    case SQL_MAX_COLUMNS_IN_SELECT:
    case SQL_MAX_COLUMNS_IN_TABLE:
    case SQL_MAX_CURSOR_NAME_LEN:
    case SQL_MAX_IDENTIFIER_LEN:
    case SQL_MAX_OWNER_NAME_LEN:
    case SQL_MAX_PROCEDURE_NAME_LEN:
    case SQL_MAX_QUALIFIER_NAME_LEN:
    case SQL_MAX_TABLE_NAME_LEN:
    case SQL_MAX_TABLES_IN_SELECT:
    case SQL_MAX_USER_NAME_LEN:
    case SQL_NON_NULLABLE_COLUMNS:
    case SQL_NULL_COLLATION:
    case SQL_ODBC_API_CONFORMANCE:
    case SQL_ODBC_SAG_CLI_CONFORMANCE:
    case SQL_ODBC_SQL_CONFORMANCE:
    case SQL_TXN_CAPABLE:
      {
        const UWORD     * p;

/*      if (cbInfoValueMax < sizeof (SWORD))   we may assume it's large enough
            return ErrUnlockDbc (SQL_22003, pdbc);  */

        p = InfoIntTable;
        {
            while (*p < MAX_INFO_TYPE)
            {
                if (*p == fInfoType)
                {
                    rc = SQL_SUCCESS;
                    if (rgbInfoValue)
                        I2ASSIGN_MACRO(*(p+1), *rgbInfoValue);
                    if (pcbInfoValue)
                        I2ASSIGN_MACRO(i2sizeofSWORD, *pcbInfoValue);
                    break;
                }
                p += 2;
            }
        }

        if (rc == SQL_ERROR)
        {
            rc = ErrState (SQL_HY000, pdbc, F_OD0063_IDS_ERR_RESOURCE, pdbc->fInfo, RT_INFOINT);
            UnlockDbc (pdbc);
            return rc; 
        }
		
		/* 16-bit overrides for non-Ingres server classes */
        if (!isServerClassINGRES(pdbc))   
        {
			switch(fInfoType)
            {
			case SQL_MAX_PROCEDURE_NAME_LEN:
                i2temp                     = OPENSQL_MAX_IDENTIFIER_LEN;
                I2ASSIGN_MACRO(i2temp, *rgbInfoValue);
				break;

			case SQL_MAX_TABLES_IN_SELECT:
                i2temp                     = OPENSQL_MAX_TABLES_IN_SQL;
                I2ASSIGN_MACRO(i2temp, *rgbInfoValue);
				break;

			case SQL_MAX_COLUMNS_IN_GROUP_BY:
			case SQL_MAX_COLUMNS_IN_INDEX:
			case SQL_MAX_COLUMNS_IN_ORDER_BY:
                i2temp                     = OPENSQL_MAX_COLUMNS_IN_INDEX;
                I2ASSIGN_MACRO(i2temp, *rgbInfoValue);
                break;
			
			case SQL_MAX_COLUMNS_IN_SELECT:
			case SQL_MAX_COLUMNS_IN_TABLE:
                i2temp                     = OPENSQL_MAX_COLUMNS_IN_TABLE;
                I2ASSIGN_MACRO(i2temp, *rgbInfoValue);
                break;
            default:
                break;
            }  /* end switch */
        }   /* end if (!isServerClassINGRES(pdbc)) */


		/* final overrides for all platforms, usually from iidbcapabilities */
        i2temp = 0;
        switch(fInfoType)
        {
            case SQL_MAX_COLUMNS_IN_TABLE:
                if (pdbc->max_columns_in_table)
                   i2temp = pdbc->max_columns_in_table;
                break;

            case SQL_MAX_COLUMN_NAME_LEN:
                if (pdbc->max_column_name_length)
                   i2temp = pdbc->max_column_name_length;
                break;

            case SQL_MAX_OWNER_NAME_LEN:
                if (pdbc->max_schema_name_length)
                   i2temp = pdbc->max_schema_name_length;
                if (pdbc->fOptions & OPT_CATSCHEMA_IS_NULL)
                   i2temp = 0;
                break;

            case SQL_MAX_TABLE_NAME_LEN:
                if (pdbc->max_table_name_length)
                   i2temp = pdbc->max_table_name_length;
                break;

            case SQL_MAX_USER_NAME_LEN:
                if (pdbc->max_schema_name_length)
                   i2temp = pdbc->max_schema_name_length;
                break;

            default:
                break;
        }  /* end switch of final iidbcapabilities overrides */

        if (i2temp)
           I2ASSIGN_MACRO(i2temp, *rgbInfoValue);

        UnlockDbc (pdbc);
        return SQL_SUCCESS;
      }  /* end 16-bit cases */



    case SQL_ACTIVE_STATEMENTS:  /* if cursor loops, 0; else select loops, 1 */
        if (rgbInfoValue)
           { i2temp = (i2)(pdbc->fActiveStatementsMax);
             I2ASSIGN_MACRO(i2temp, *rgbInfoValue);
           }
        if (pcbInfoValue)
             I2ASSIGN_MACRO(i2sizeofSWORD, *pcbInfoValue);
        UnlockDbc (pdbc);
        return SQL_SUCCESS;

    case SQL_IDENTIFIER_CASE:
    case SQL_QUOTED_IDENTIFIER_CASE:
        if (fInfoType==SQL_IDENTIFIER_CASE)  s=&pdbc->db_name_case;
        else                                 s=&pdbc->db_delimited_case;
        if (rgbInfoValue)
           { i2temp = (i2)((CMcmpcase(s,"U") == 0) ? SQL_IC_UPPER :
                           (CMcmpcase(s,"M") == 0) ? SQL_IC_MIXED :
                                              SQL_IC_LOWER);
             I2ASSIGN_MACRO(i2temp, *rgbInfoValue);
           }
        if (pcbInfoValue)
             I2ASSIGN_MACRO(i2sizeofSWORD, *pcbInfoValue);
        UnlockDbc (pdbc);
        return SQL_SUCCESS;

    case SQL_CURSOR_COMMIT_BEHAVIOR:
    case SQL_CURSOR_ROLLBACK_BEHAVIOR:

/*      if (cbInfoValueMax < sizeof (SWORD))  we may assume it's large enough
            return ErrUnlockDbc (SQL_22003, pdbc);  */

        if (rgbInfoValue)
           { i2temp = (i2)(pdbc->fCommit);
             I2ASSIGN_MACRO(i2temp, *rgbInfoValue);
           }
        if (pcbInfoValue)
             I2ASSIGN_MACRO(i2sizeofSWORD, *pcbInfoValue);

        UnlockDbc (pdbc);
        return SQL_SUCCESS;

    /*
    **  Info is a 32 bit integer, uinteger, bitmask, or binary constant:
    */
    case SQL_AGGREGATE_FUNCTIONS:
    case SQL_ALTER_DOMAIN:
    case SQL_ALTER_TABLE:
    case SQL_ASYNC_MODE:
    case SQL_BATCH_ROW_COUNT:
    case SQL_BATCH_SUPPORT:
    case SQL_BOOKMARK_PERSISTENCE:
    case SQL_CONVERT_BIGINT:
    case SQL_CONVERT_BINARY:
    case SQL_CONVERT_BIT:
    case SQL_CONVERT_CHAR:
    case SQL_CONVERT_DATE:
    case SQL_CONVERT_DECIMAL:
    case SQL_CONVERT_DOUBLE:
    case SQL_CONVERT_FLOAT:
    case SQL_CONVERT_FUNCTIONS:
    case SQL_CONVERT_INTEGER:
    case SQL_CONVERT_LONGVARBINARY:
    case SQL_CONVERT_LONGVARCHAR:
    case SQL_CONVERT_NUMERIC:
    case SQL_CONVERT_REAL:
    case SQL_CONVERT_SMALLINT:
    case SQL_CONVERT_TIME:
    case SQL_CONVERT_TIMESTAMP:
    case SQL_CONVERT_TINYINT:
    case SQL_CONVERT_VARBINARY:
    case SQL_CONVERT_VARCHAR:
    case SQL_CONVERT_WVARCHAR:
    case SQL_CONVERT_WLONGVARCHAR:
    case SQL_CONVERT_WCHAR:
    case SQL_CREATE_ASSERTION:
    case SQL_CREATE_CHARACTER_SET:
    case SQL_CREATE_COLLATION:
    case SQL_CREATE_DOMAIN:
    case SQL_CREATE_SCHEMA:
    case SQL_CREATE_TABLE:
    case SQL_CREATE_TRANSLATION:
	case SQL_CREATE_VIEW:
    case SQL_CURSOR_SENSITIVITY:
    case SQL_DATETIME_LITERALS:
/*  case SQL_DRIVER_HDBC:           implemented by DM
    case SQL_DRIVER_HENV:           implemented by DM
    case SQL_DRIVER_HDESC:          implemented by DM
    case SQL_DRIVER_HLIB:           implemented by DM
    case SQL_DRIVER_HSTMT:          implemented by DM */
    case SQL_DDL_INDEX:
    case SQL_DROP_ASSERTION:
    case SQL_DROP_CHARACTER_SET:
    case SQL_DROP_COLLATION:
    case SQL_DROP_DOMAIN:
    case SQL_DROP_SCHEMA:
    case SQL_DROP_TABLE:
    case SQL_DROP_TRANSLATION:
    case SQL_DROP_VIEW:
	case SQL_DTC_TRANSITION_COST:
    case SQL_DYNAMIC_CURSOR_ATTRIBUTES1:
    case SQL_DYNAMIC_CURSOR_ATTRIBUTES2:
    case SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES1:
    case SQL_FORWARD_ONLY_CURSOR_ATTRIBUTES2:
    case SQL_FETCH_DIRECTION:
    case SQL_GETDATA_EXTENSIONS:
    case SQL_INDEX_KEYWORDS:
    case SQL_INFO_SCHEMA_VIEWS:
    case SQL_INSERT_STATEMENT:
    case SQL_KEYSET_CURSOR_ATTRIBUTES1:
    case SQL_KEYSET_CURSOR_ATTRIBUTES2:
    case SQL_LOCK_TYPES:
    case SQL_MAX_ASYNC_CONCURRENT_STATEMENTS:
    case SQL_MAX_BINARY_LITERAL_LEN:
    case SQL_MAX_CHAR_LITERAL_LEN:
    case SQL_MAX_INDEX_SIZE:
    case SQL_MAX_ROW_SIZE:
    case SQL_MAX_STATEMENT_LEN:
    case SQL_NUMERIC_FUNCTIONS:
    case SQL_ODBC_INTERFACE_CONFORMANCE:
    case SQL_OJ_CAPABILITIES:
    case SQL_OWNER_USAGE:
    case SQL_PARAM_ARRAY_ROW_COUNTS:
    case SQL_PARAM_ARRAY_SELECTS:
    case SQL_POS_OPERATIONS:
    case SQL_POSITIONED_STATEMENTS:
    case SQL_QUALIFIER_USAGE:
    case SQL_SCROLL_CONCURRENCY:
    case SQL_SCROLL_OPTIONS:
    case SQL_SQL_CONFORMANCE:
    case SQL_SQL92_DATETIME_FUNCTIONS:
    case SQL_SQL92_FOREIGN_KEY_DELETE_RULE:
    case SQL_SQL92_FOREIGN_KEY_UPDATE_RULE:
    case SQL_SQL92_GRANT:
    case SQL_SQL92_NUMERIC_VALUE_FUNCTIONS:
    case SQL_SQL92_PREDICATES:
    case SQL_SQL92_RELATIONAL_JOIN_OPERATORS:
    case SQL_SQL92_REVOKE:
    case SQL_SQL92_ROW_VALUE_CONSTRUCTOR:
    case SQL_SQL92_STRING_FUNCTIONS:
    case SQL_SQL92_VALUE_EXPRESSIONS:
    case SQL_STANDARD_CLI_CONFORMANCE:
    case SQL_STATIC_CURSOR_ATTRIBUTES1:
    case SQL_STATIC_CURSOR_ATTRIBUTES2:
    case SQL_STATIC_SENSITIVITY:
    case SQL_STRING_FUNCTIONS:
    case SQL_SUBQUERIES:
    case SQL_SYSTEM_FUNCTIONS:
    case SQL_TIMEDATE_ADD_INTERVALS:
    case SQL_TIMEDATE_DIFF_INTERVALS:
    case SQL_TIMEDATE_FUNCTIONS:
    case SQL_TXN_ISOLATION_OPTION:
    case SQL_UNION:

/*      if (cbInfoValueMax < sizeof (UDWORD))  we may assume it's large enough
            return ErrUnlockDbc (SQL_22003, pdbc);  */

        if (!GetInfoBit (pdbc, fInfoType, &infoBit))
        {
            rc = ErrState (SQL_HY000, pdbc, F_OD0063_IDS_ERR_RESOURCE, pdbc->fInfo, RT_INFOBIT);
            UnlockDbc (pdbc);
            return rc; 
        }
        switch(fInfoType)
        {
            case SQL_CONVERT_BIGINT:
            case SQL_CONVERT_BINARY:
            case SQL_CONVERT_BIT:
            case SQL_CONVERT_CHAR:
            case SQL_CONVERT_DATE:
            case SQL_CONVERT_DECIMAL:
            case SQL_CONVERT_DOUBLE:
            case SQL_CONVERT_FLOAT:
            case SQL_CONVERT_FUNCTIONS:
            case SQL_CONVERT_INTERVAL_DAY_TIME:
            case SQL_CONVERT_INTERVAL_YEAR_MONTH:
            case SQL_CONVERT_INTEGER:
            case SQL_CONVERT_LONGVARBINARY:
            case SQL_CONVERT_LONGVARCHAR:
            case SQL_CONVERT_NUMERIC:
            case SQL_CONVERT_REAL:
            case SQL_CONVERT_SMALLINT:
            case SQL_CONVERT_TIME:
            case SQL_CONVERT_TIMESTAMP:
            case SQL_CONVERT_TINYINT:
            case SQL_CONVERT_VARBINARY:
            case SQL_CONVERT_VARCHAR:
            case SQL_CONVERT_WCHAR:
            case SQL_CONVERT_WLONGVARCHAR:
            case SQL_CONVERT_WVARCHAR:
                if (pdbc->is_unicode_enabled == FALSE)
                {
                    infoBit &= ~SQL_CVT_WCHAR;
                    infoBit &= ~SQL_CVT_WLONGVARCHAR;
                    infoBit &= ~SQL_CVT_WVARCHAR;
                }
        }
        if (fInfoType == SQL_CONVERT_BIT && pdbc->fAPILevel < IIAPI_LEVEL_6)
             infoBit &= ~SQL_CVT_BIT;

        MEcopy((PTR)&infoBit, sizeof(UDWORD), (PTR)rgbInfoValue);
        if (pcbInfoValue)
        {
	     i2temp = sizeof(UDWORD);
	     I2ASSIGN_MACRO(i2temp, *pcbInfoValue);
        }
        /*
        ** If scrollable result sets are supported in the target DBMS,
        ** report what we support for static and keyset cursors.
        */
        if (pdbc->fAPILevel >= IIAPI_LEVEL_5)
        {
            if (fInfoType == SQL_SCROLL_OPTIONS)
            {
                i4temp = SQL_SO_FORWARD_ONLY | SQL_SO_STATIC | 
                    SQL_SO_KEYSET_DRIVEN;
	        I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }
            else if (fInfoType == SQL_STATIC_CURSOR_ATTRIBUTES1)
            {
                i4temp = SQL_CA1_NEXT | SQL_CA1_ABSOLUTE 
                    | SQL_CA1_RELATIVE | SQL_CA1_LOCK_NO_CHANGE;
	        I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }
            else if (fInfoType == SQL_KEYSET_CURSOR_ATTRIBUTES1)
            {
                i4temp = SQL_CA1_NEXT | SQL_CA1_ABSOLUTE | SQL_CA1_RELATIVE |
                    SQL_CA1_LOCK_NO_CHANGE | SQL_CA1_LOCK_EXCLUSIVE |
                    SQL_CA1_LOCK_UNLOCK | SQL_CA1_POS_POSITION |
                    SQL_CA1_POS_UPDATE | SQL_CA1_POS_DELETE | 
                    SQL_CA1_POSITIONED_UPDATE | SQL_CA1_POSITIONED_DELETE |
                    SQL_CA1_SELECT_FOR_UPDATE;
	        I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }
            else if (fInfoType == SQL_STATIC_CURSOR_ATTRIBUTES2)
            {
                i4temp = SQL_CA2_READ_ONLY_CONCURRENCY;
	        I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }
            else if (fInfoType == SQL_KEYSET_CURSOR_ATTRIBUTES2)
            {
                i4temp = SQL_CA2_READ_ONLY_CONCURRENCY |
                    SQL_CA2_LOCK_CONCURRENCY | SQL_CA2_OPT_ROWVER_CONCURRENCY |
                    SQL_CA2_OPT_VALUES_CONCURRENCY | 
                    SQL_CA2_MAX_ROWS_SELECT | SQL_CA2_MAX_ROWS_INSERT |
                    SQL_CA2_MAX_ROWS_DELETE | SQL_CA2_MAX_ROWS_UPDATE ;
	        I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }
            else if (fInfoType == SQL_FETCH_DIRECTION)
            {
                i4temp = SQL_FD_FETCH_NEXT |
                    SQL_FD_FETCH_FIRST |
                    SQL_FD_FETCH_LAST |
                    SQL_FD_FETCH_PRIOR |
                    SQL_FD_FETCH_ABSOLUTE |
                    SQL_FD_FETCH_RELATIVE;
	        I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }
        }

        if (fInfoType == SQL_TXN_ISOLATION_OPTION)
        {
            if (pdbc->fRelease < fReleaseRELEASE20)
               {i4temp = SQL_TXN_READ_UNCOMMITTED | SQL_TXN_SERIALIZABLE;
                I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
               }
        }

		/* 32-bit overrides */
        if (fInfoType==SQL_OJ_CAPABILITIES)
           {
            if      (isServerClassOPINGDT(pdbc))          /* DESKTOP outer join*/ 
               {i4temp = SQL_OJ_LEFT+SQL_OJ_ALL_COMPARISON_OPS;
                I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
               }
            else if (isServerClassORACLE(pdbc))           /* ORACLE  outer join*/ 
               {i4temp = SQL_OJ_LEFT+SQL_OJ_ALL_COMPARISON_OPS;
                I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
               }
            else if (!isServerClassAnIngresEngine(pdbc))  /* not Ingres type engine */
               {i4temp = OPENSQL_OJ_CAPABILITIES;
                I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
               }
           }

        if (fInfoType == SQL_OWNER_USAGE  &&  pdbc->fOptions & OPT_CATSCHEMA_IS_NULL)
            {i4temp = 0;                     /* if NULLing schema columns */
             I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }

        /* Get SQL_MAX_ROW_SIZE from iidbcapabilities */
        if (fInfoType == SQL_MAX_ROW_SIZE)
        {
            if (pdbc->max_row_length)
                 i4temp = pdbc->max_row_length;
            else 
                 i4temp = DB_MAXTUP;   
            I4ASSIGN_MACRO(i4temp,*(SWORD     *)rgbInfoValue);
        }


        if (!isServerClassINGRES(pdbc))  /* not ServerClass="INGRES"*/   
        {
            i4temp = -1;   /* assume no hits on the following case stmt */

            switch(fInfoType)
            {
            case SQL_DDL_INDEX:
                i4temp = OPENSQL_DDL_INDEX;
                break;

   	    case SQL_MAX_ROW_SIZE:
                if (pdbc->max_row_length)
                    i4temp = pdbc->max_row_length;
                else
                    i4temp = OPENSQL_MAX_ROW_SIZE;
                break;

            case SQL_INDEX_KEYWORDS:
                i4temp = OPENSQL_INDEX_KEYWORDS;
                break;

            case SQL_MAX_CHAR_LITERAL_LEN:
                i4temp = OPENSQL_MAX_CHAR_LITERAL_LEN;
                break;

            case SQL_NUMERIC_FUNCTIONS:
                i4temp = OPENSQL_NUMERIC_FUNCTIONS;
                break;

            case SQL_SQL92_GRANT:
                i4temp = OPENSQL_SQL92_GRANT;
                break;

            case SQL_SQL92_RELATIONAL_JOIN_OPERATORS:
                i4temp = OPENSQL_SQL92_RELATIONAL_JOIN_OPERATORS;
                break;

            case SQL_SQL92_REVOKE:
                i4temp = OPENSQL_SQL92_REVOKE;
                break;

            case SQL_STRING_FUNCTIONS:
                i4temp = OPENSQL_STRING_FUNCTIONS;
                break;

            case SQL_TIMEDATE_FUNCTIONS:
                i4temp = OPENSQL_TIMEDATE_FUNCTIONS;
                break;

            case SQL_SYSTEM_FUNCTIONS:
                i4temp = OPENSQL_SYSTEM_FUNCTIONS;
                break;
            default:
                break;
            }

            if (i4temp != -1)  
                I4ASSIGN_MACRO(i4temp, *rgbInfoValue);

        }   /* end if (!isServerClassINGRES(pdbc)) */

        UnlockDbc (pdbc);
        return SQL_SUCCESS;

    case SQL_DEFAULT_TXN_ISOLATION:

/*      if (cbInfoValueMax < sizeof (UDWORD))   we may assume it's large enough
            return ErrUnlockDbc (SQL_22003, pdbc);  */

        if (pcbInfoValue)
        {
            i2temp = sizeof(UDWORD);
	    I2ASSIGN_MACRO(i2temp, *pcbInfoValue);
        }

        if (rgbInfoValue)
            {i4temp = pdbc->fIsolationDSN;
             I4ASSIGN_MACRO(i4temp, *rgbInfoValue);
            }

        UnlockDbc (pdbc);
        return SQL_SUCCESS;

    /*
    **  Info is a string constant:
    */
    case SQL_ACCESSIBLE_PROCEDURES:
    case SQL_CATALOG_NAME:
    case SQL_COLUMN_ALIAS:
    case SQL_COLLATION_SEQ:
 /* case SQL_DBMS_NAME: */
    case SQL_DESCRIBE_PARAMETER:
 /* case SQL_DM_VER:   implemented by DM */
    case SQL_DRIVER_VER:
    case SQL_EXPRESSIONS_IN_ORDERBY:
    case SQL_IDENTIFIER_QUOTE_CHAR:
    case SQL_KEYWORDS:
    case SQL_LIKE_ESCAPE_CLAUSE:
    case SQL_MAX_ROW_SIZE_INCLUDES_LONG:
    case SQL_MULT_RESULT_SETS:
    case SQL_MULTIPLE_ACTIVE_TXN:
    case SQL_NEED_LONG_DATA_LEN:
    case SQL_ODBC_SQL_OPT_IEF:
    case SQL_ODBC_VER:   /* normally impl'ed by DM; here for static link test*/
    case SQL_ORDER_BY_COLUMNS_IN_SELECT:
    case SQL_OWNER_TERM:
    case SQL_PROCEDURE_TERM:
    case SQL_PROCEDURES:
    case SQL_QUALIFIER_NAME_SEPARATOR:
    case SQL_QUALIFIER_TERM:
    case SQL_ROW_UPDATES:
    case SQL_SEARCH_PATTERN_ESCAPE:
    case SQL_SPECIAL_CHARACTERS:
    case SQL_TABLE_TERM:
    case SQL_XOPEN_CLI_YEAR:

        for (pInfoStr = InfoStrTable; 
               pInfoStr->fInfoType < MAX_INFO_TYPE; 
                 pInfoStr++)
        {
                lpsz = pInfoStr->string;
                if (pInfoStr->fInfoType == fInfoType)
                {
                    if (fInfoType==SQL_DRIVER_VER  &&  CMspace(lpsz) )
                       {
                        STcopy(lpsz,sz);   /* copy " x.xx.xxxx" to work area */
                        lpsz=sz;     /* lpsz->work area that is writable */
                        CMcpychar("0",lpsz);   /* change leading space of version to '0' */
                       }
                    rc = GetChar (NULL, lpsz, rgbInfoValue, cbInfoValueMax, pcbInfoValue);
                    break;
                }
        }
        if (rc == SQL_ERROR)
        {
            rc = ErrState (SQL_HY000, pdbc, F_OD0063_IDS_ERR_RESOURCE, pdbc->fInfo, RT_INFOSTR);
            UnlockDbc (pdbc);
            return rc; 
        }

		/* char string overrides */
        if (fInfoType == SQL_IDENTIFIER_QUOTE_CHAR  &&  isOld6xRelease(pdbc))
        {
          rc = GetChar (NULL, " ", rgbInfoValue, cbInfoValueMax, pcbInfoValue);
        }

        if (fInfoType == SQL_OWNER_TERM  &&  pdbc->fOptions & OPT_CATSCHEMA_IS_NULL)
        {
          rc = GetChar (NULL, "",  rgbInfoValue, cbInfoValueMax, pcbInfoValue);
        }

        if (fInfoType == SQL_EXPRESSIONS_IN_ORDERBY  &&  isServerClassINGRES(pdbc)
                                           &&  pdbc->fRelease >= fReleaseRELEASE25)
            goto returnszY;

        if (fInfoType == SQL_ORDER_BY_COLUMNS_IN_SELECT  &&  isServerClassINGRES(pdbc)
                                           &&  pdbc->fRelease >= fReleaseRELEASE25)
            goto returnszN;

        break;

    case SQL_ACCESSIBLE_TABLES:

        sz[0] = (CHAR)((pdbc->fOptions & OPT_ACCESSIBLE) ? 'Y' : 'N');
        goto returnsz0;

    case SQL_OUTER_JOINS:
        if      (isServerClassAnIngresEngine(pdbc)) 
                 lpsz="Y";
        else
            if (isServerClassOPINGDT(pdbc))  
                 lpsz="P"; 
            else
                if (isServerClassORACLE(pdbc))  
                    lpsz="P";
                else
                    lpsz="N";
        rc = GetChar (NULL, lpsz, rgbInfoValue, cbInfoValueMax, pcbInfoValue);
      break;

    case SQL_DRIVER_ODBC_VER:

/*      STcopy (SQL_SPEC_STRING, sz);     Merant can't handle "03.52"; */
        STcopy ("03.50"        , sz);  /*      he drops it to "02.00" */
        goto returnsz;

    case SQL_DRIVER_NAME:

        rc = GetChar (NULL, DRIVER_NAME, rgbInfoValue, cbInfoValueMax, pcbInfoValue);
        break;

    case SQL_DATA_SOURCE_NAME:

        rc = GetChar (NULL,
            (pdbc->fStatus & DBC_DRIVER) ? "" : pdbc->szDSN,
            rgbInfoValue, cbInfoValueMax, pcbInfoValue);
        break;

    case SQL_SERVER_NAME:
/*      UtGetIniString (pdbc->szDSN, KEY_SERVER, "", sz, sizeof (sz)); */
        STcopy (pdbc->szVNODE, sz);
        goto returnsz;

    case SQL_DATABASE_NAME:
        STcopy (pdbc->szDATABASE, sz);
        goto returnsz;

    case SQL_DBMS_NAME:
        STcopy (pdbc->szSERVERTYPE, sz);
        CVupper(sz);  /* return as upper case to be */
                      /* compatible with other drivers*/
        goto returnsz;

    case SQL_DBMS_VER:

        STprintf(sz, "%02.2d.%02.2d.%04.4d",
                (i4)( pdbc->fRelease / 1000000),
                (i4)((pdbc->fRelease % 1000000) / 10000),
                (i4)( pdbc->fRelease % 10000));
        goto returnsz;

    case SQL_DATA_SOURCE_READ_ONLY:

        sz[0] = (CHAR)((pdbc->fOptions & OPT_READONLY)   ? 'Y' : 'N');
        goto returnsz0;

    returnszN:           /* return "N" for option */

        sz[0] = 'N';
        goto returnsz0;

    returnszY:           /* return "Y" for option */

        sz[0] = 'Y';
        goto returnsz0;

    returnsz0:

        sz[1] = EOS;

    returnsz:

        rc = GetChar (NULL, sz, rgbInfoValue, cbInfoValueMax, pcbInfoValue);
        break;

    case SQL_USER_NAME:

		if( pdbc->szUID && *(pdbc->szUID) )
			rc = GetChar (NULL, pdbc->szUID, rgbInfoValue, cbInfoValueMax, pcbInfoValue);
		else
			rc = GetChar (NULL, pdbc->szUsername, rgbInfoValue, cbInfoValueMax, pcbInfoValue);
        break;

    default:

        return ErrUnlockDbc (SQL_HY096, pdbc); /* invalid information type */
    }

    if (rc == SQL_SUCCESS_WITH_INFO)
        ErrState (SQL_01004, pdbc);

    UnlockDbc (pdbc);
    return rc;
}

/*
**  SQLGetFunctions
**
**  Return information about the functions supported in the driver.
**
**  On entry: hdbc            connection handle.
**            FunctionId      Type of individual function or set of functions.
**            Supported       An array or individual boolean indicating
**                            whether the functions are supported.
**
**  Returns:  SQL_SUCCESS     The Driver Manager identifies errors such
**                            as invalid function ID.
*/

SQLRETURN  SQL_API SQLGetFunctions(SQLHDBC hdbc,
    SQLUSMALLINT FunctionId, SQLUSMALLINT *Supported)
{
    LPDBC pdbc = (LPDBC)hdbc;
    i4 i;
    i4 supportMask;
 
    if (!LockDbc (pdbc)) 
       return SQL_INVALID_HANDLE;

    if (IItrace.fTrace >= ODBC_EX_TRACE)
        TraceOdbc( SQL_API_SQLGETFUNCTIONS, pdbc, FunctionId, Supported );

    ErrResetDbc (pdbc);        /* clear any errors on DBC */

    switch (FunctionId)
    {
    /*
    ** In order to meet the requirements of Level 3, the supportability, or 
    ** lack thereof, is packed onto one of the members of an array 
    ** allocated in the caller which is a set of 250 4-byte integers.
    ** The macro function that accesses this array is named SQL_FUNC_EXISTS.
    */
    case SQL_API_ODBC3_ALL_FUNCTIONS:
    {
        /*
        ** Check Level 1 and 2 functions first.
        */
        for (i = 0; i < SQL_API_ODBC3_ALL_FUNCTIONS_SIZE; i++)
            Supported[i] = 0;

        for (i = 0; i <  SQL_API_MAX_LEVEL_2_VALUE; i++)
        {
            supportMask = 1 << ( i & 0x000F );
            switch (i)
            {
            case SQL_API_SQLDESCRIBEPARAM:
            {
                if (pdbc->fAPILevel < IIAPI_LEVEL_4)
                    Supported[ i >> 4 ] &= ~supportMask;
                else
                    Supported[ i >> 4 ] |= supportMask;

                break;
            }
            case SQL_API_SQLSETPOS:
            {
                if (pdbc->fAPILevel < IIAPI_LEVEL_5)
                    Supported[ i >> 4 ] &= ~supportMask;
                else
                    Supported[ i >> 4 ] |= supportMask;

                break;
            }
            case SQL_API_SQLSETPARAM:
            case SQL_API_SQLBULKOPERATIONS:
                Supported[ i >> 4 ] &= ~supportMask;
                break;

            default:
                Supported[ i >> 4 ] |= supportMask;
                break;

            }
        } 
        /*
        ** Ingres supports all level 3 functions.
        */
        for (i = SQL_API_MIN_LEVEL_3_VALUE; i < SQL_API_MAX_LEVEL_3_VALUE; i++)
        {
            supportMask = 1 << ( i & 0x000F );
            Supported[ i >> 4 ] |= supportMask;
        }
        
        break;
    }
    case SQL_API_ALL_FUNCTIONS:
    {
        /*
        ** The Level 2 version of SQLGetFunctions() is more straightforward.
        ** The return array is treated as a set of booleans.  TRUE means 
        ** the function is supported, FALSE means no support.
        */
        for (i = 0; i <  SQL_API_MAX_LEVEL_2_VALUE; i++)
        {
            switch(i)
            {
            case SQL_API_SQLDESCRIBEPARAM:

                if (pdbc->fAPILevel < IIAPI_LEVEL_4)
                    Supported[i] = FALSE;
                else
                    Supported[i] = TRUE;

                break;

            case SQL_API_SQLSETPOS:

                if (pdbc->fAPILevel < IIAPI_LEVEL_5)
                    Supported[i] = FALSE;
                else
                    Supported[i] = TRUE;

                break;

            case SQL_API_SQLSETPARAM:
            case SQL_API_SQLBULKOPERATIONS:

                Supported[i] = FALSE;

                break;

            default: 

                Supported[i] = TRUE;

                break;
            }
        }
        break;
    }
    /*
    ** The FunctionId argument can support queries for individual functions.
    ** In that case, a pointer to a single boolean is returned.
    */
    case SQL_API_SQLDESCRIBEPARAM:
    {
        if (pdbc->fAPILevel < IIAPI_LEVEL_4)
            *Supported = FALSE;
        else
            *Supported = TRUE;

        break;
    }
    case SQL_API_SQLSETPOS:
    {
        if (pdbc->fAPILevel < IIAPI_LEVEL_5)
            *Supported = FALSE;
        else
            *Supported = TRUE;

        break;
    }
    case SQL_API_SQLBULKOPERATIONS:
    case SQL_API_SQLSETPARAM:

        *Supported = FALSE;

        break;

    default:

        *Supported = TRUE;

        break;
    }
    UnlockDbc (pdbc);
    return SQL_SUCCESS;
}

/*
**  GetTuplePtrs
**
**  Return data pointer and null indicator pointer into tuple.
**
**  On entry: pstmt   -->statement block.
**            tp      -->tuple row.
**            colno    = column number.
**
**  On exit:  *dp     --> data in tuple.
**            *np     --> null indicator in tuple
**
**  Returns:  nothing
*/
void GetTuplePtrs(LPSTMT pstmt, char * tp, int colno, char ** dp, i4 **np)
{
    LPDESCFLD pird = pstmt->pIRD->pcol + colno;     /* pird->descriptor field */

    *dp = tp + pird->cbDataOffset;

    if (pird->cbNullOffset)
        *np = (i4*)(tp + pird->cbNullOffset);
	else
        *np = NULL;
    return;
}


/*
**  SQLGetTypeInfo
**
**  Return information about data types supported by the data source.
**
**  On entry: pstmt   -->statement block.
**            fSqlType = ODBC SQL data type.
**
**  On exit:  Information is returned as a result set.
**
**  Returns:  SQL_SUCCESS
**            SQL_ERROR
*/

 static const struct tdescTypeInfo
 {   char          Name[OBJECT_NAME_SIZE];   /* column name */
     i2            fIngApiType;        /* Ingres API data type */
     SQLINTEGER    OctetLength;        /* length in bytes of data */
     SQLSMALLINT   Nullable;           /* SQL_NULLABLE if columns can have NULLs.
                                          SQL_NO_NULLS if columns has no NULLs. */
 } descTypeInfo[]
=
 {
  "TYPE_NAME",         IIAPI_VCH_TYPE, 30, SQL_NO_NULLS,
  "DATA_TYPE",         IIAPI_INT_TYPE,  2, SQL_NO_NULLS,
  "COLUMN_SIZE",       IIAPI_INT_TYPE,  4, SQL_NULLABLE,
  "LITERAL_PREFIX",    IIAPI_VCH_TYPE,  6, SQL_NULLABLE,
  "LITERAL_SUFFIX",    IIAPI_VCH_TYPE,  6, SQL_NULLABLE,
  "CREATE_PARAMS",     IIAPI_VCH_TYPE, 18, SQL_NULLABLE,
  "NULLABLE",          IIAPI_INT_TYPE,  2, SQL_NO_NULLS,
  "CASE_SENSITIVE",    IIAPI_INT_TYPE,  2, SQL_NO_NULLS,
  "SEARCHABLE",        IIAPI_INT_TYPE,  2, SQL_NO_NULLS,
  "UNSIGNED_ATTRIBUTE",IIAPI_INT_TYPE,  2, SQL_NULLABLE,
  "FIXED_PREC_SCALE",  IIAPI_INT_TYPE,  2, SQL_NO_NULLS,
  "AUTO_UNIQUE_VALUE", IIAPI_INT_TYPE,  2, SQL_NULLABLE,
  "LOCAL_TYPE_NAME",   IIAPI_VCH_TYPE,  4, SQL_NULLABLE,
  "MINIMUM_SCALE",     IIAPI_INT_TYPE,  4, SQL_NULLABLE,
  "MAXIMUM_SCALE",     IIAPI_INT_TYPE,  4, SQL_NULLABLE,
  "SQL_DATA_TYPE",     IIAPI_INT_TYPE,  4, SQL_NO_NULLS,
  "SQL_DATETIME_SUB",  IIAPI_INT_TYPE,  4, SQL_NULLABLE,
  "NUM_PREC_RADIX",    IIAPI_INT_TYPE,  4, SQL_NULLABLE,
  "INTERVAL_PRECISION", IIAPI_INT_TYPE, 4, SQL_NULLABLE
 };

#define QRY_TYPE_TYPE_NAME       1
#define QRY_TYPE_DATA_TYPE       2
#define QRY_TYPE_PRECISION       3
#define QRY_TYPE_PREFIX          4
#define QRY_TYPE_SUFFIX          5
#define QRY_TYPE_CREATE_PARAMS   6
#define QRY_TYPE_NULLABLE        7
#define QRY_TYPE_CASE_SENSITIVE  8
#define QRY_TYPE_SEARCHABLE      9
#define QRY_TYPE_UNSIGNED_ATTR  10
#define QRY_TYPE_MONEY          11
#define QRY_TYPE_AUTO_INCR      12
#define QRY_TYPE_LOCAL_NAME     13
#define QRY_TYPE_MIN_SCALE      14
#define QRY_TYPE_MAX_SCALE      15
#define QRY_TYPE_SQL_DATA_TYPE  16
#define QRY_TYPE_DATETIME_SUB   17
#define QRY_TYPE_NUM_PREC_RADIX 18
#define QRY_TYPE_INTERVAL_PRECISION 19

RETCODE SQL_API SQLGetTypeInfo(
    SQLHSTMT  hstmt,
    SWORD     fSqlType)
{
    return SQLGetTypeInfo_InternalCall(
              hstmt,
              fSqlType);
}

RETCODE SQL_API SQLGetTypeInfo_InternalCall(
    SQLHSTMT  hstmt,
    SWORD     fSqlType)
{
    LPSTMT  pstmt = (LPSTMT)hstmt;
    RETCODE rc;
    CHAR     * p;
    int     i;
    UWORD   cb;
    LPDBC   pdbc;
    LPDESC    pIRD = pstmt->pIRD;   /* Implementation Row Descriptor Header */
    LPDESC    pARD = pstmt->pARD;   /* Application Row Descriptor Header */
    LPDESCFLD pird;                 /* IRD row field */
    i2        dsCount;
    i2        ODBCVersion;          /* ODBC 2.x or 3.x behavior */
    SWORD     tempType;
    i4        APILevel = pstmt->fAPILevel;
    i4        dateConnLevel = pstmt->dateConnLevel;

    if (!LockStmt (pstmt)) return SQL_INVALID_HANDLE;

    if (IItrace.fTrace >= ODBC_EX_TRACE)
        TraceOdbc (SQL_API_SQLGETTYPEINFO, pstmt, fSqlType);

    if (pstmt->fStatus & STMT_OPEN)
        return ErrUnlockStmt (SQL_24000, pstmt);

    ErrResetStmt (pstmt);        /* clear ODBC error status on STMT */
    ResetStmt (pstmt, TRUE);     /* clear STMT state and free buffers */
    pdbc = pstmt->pdbcOwner;
    ODBCVersion = pdbc->penvOwner->ODBCVersion;
                                 /* SQL_OV_ODBC2 or SQL_OV_ODBC3 */ 

    /*
    **  "Prepare" the constant query:
    */
    pstmt->fCatalog = CATLG_TYPEINFO;

    dsCount = (i2)(sizeof(descTypeInfo)/sizeof(descTypeInfo[0]));

    pIRD = pstmt->pIRD;               /* pIRD->Implementation Row Descriptor */
    ResetDescriptorFields(pIRD, 0, pIRD->Count);  /* clear all desc fields */
    /*
    **  Ensure that IRD and ARD row descriptors are large enough.
    **  If too few then re-allocate.
    */
    if (dsCount > pIRD->CountAllocated)
        if (ReallocDescriptor(pIRD, dsCount) == NULL)
           {
            RETCODE rc = ErrState (SQL_HY001, pstmt, F_OD0001_IDS_BIND_ARRAY);
            UnlockStmt (pstmt);
            return rc;
           }

    if (dsCount > pARD->CountAllocated)
        if (ReallocDescriptor(pARD, dsCount) == NULL)
           {
            RETCODE rc = ErrState (SQL_HY001, pstmt, F_OD0001_IDS_BIND_ARRAY);
            UnlockStmt (pstmt);
            return rc;
           }

    pIRD->Count = dsCount;
    pird = pIRD->pcol + 1;    /* pird -> 1st IRD field (after bookmark) */

    for (i=0; i < dsCount; i++, pird++)
        {   /* copy descTypeInfo struct into IRD descriptor */
         STcopy(descTypeInfo[i].Name, pird->Name);
         pird->fIngApiType = descTypeInfo[i].fIngApiType;
         pird->OctetLength = descTypeInfo[i].OctetLength;
         pird->Nullable    = descTypeInfo[i].Nullable;
         SetDescDefaultsFromType(pdbc, pird);
                         /* Set precision, scale, and other defaults*/
        }

    rc = PrepareConstant (pstmt);

    if (rc != SQL_SUCCESS)
    {
        UnlockStmt (pstmt);
        return rc;
    }

    /*
    **  Pretend to "execute" the constant query:
    **
    **  1. Load Fetch buffer resource for driver we are impersonating.
    **  2. Find first row for type and count rows "returned".
    **  3. Set cursor as if we opened it and to end of fetch,
    **     as if we already fetched a buffer.
    */
    pstmt->crowBuffer  = 0;

    pstmt->prowCurrent = 
      pstmt->pFetchBuffer = 
         MEreqmem(0, pstmt->cbrow * 
                       (sizeof(dataTypeInfo)/sizeof(dataTypeInfo[0])+1), 
                  TRUE, NULL);  

    if (!pstmt->prowCurrent)
    {
        rc = ErrState (SQL_HY000, pdbc, F_OD0063_IDS_ERR_RESOURCE, pdbc->fInfoType, RT_INFOTYPE);
        UnlockStmt (pstmt);
        return rc;
    }

    p = pstmt->prowCurrent;

    for (i=0; dataTypeInfo[i].data_type; i++)  /* loop through the data types */
    {
        char * dp;   /* data pointer in tuple for the column */
        i4   * np;   /* null indicator pointer in tuple for the column */
        i2   * i2p;  /* varchar length pointer in tuple for the column */
        i4   * i4p;  /* varchar length pointer in tuple for the column */
        i4     precision;
        i2     case_sensitive;
        i2     unsigned_attribute;
        i2     maximum_scale;
        i2     minimum_scale;
        i2     sql_data_type = -1;
        i2     interval_precision = 10;
        i4     len;
        
        if (dataTypeInfo[i].ingtype != 0)
        {
            if (isServerClassINGRES(pdbc))
            { 
                if (dataTypeInfo[i].ingtype < 0)
                    continue;  /* ingres engine and opensql data type */
            }
            else
            { 
                if (dataTypeInfo[i].ingtype > 0)
                    continue;  /* non-ingres engine and ingres data type */
            }
        }
        if (dataTypeInfo[i].data_type == SQL_BIGINT && APILevel <
            IIAPI_LEVEL_3)
            continue;

        if (dataTypeInfo[i].data_type == SQL_BIT && APILevel <
            IIAPI_LEVEL_6)
            continue;

        switch (dataTypeInfo[i].data_type)
        {
        case SQL_TIMESTAMP:
        case SQL_DATE:
        case SQL_TIME:          
            if (ODBCVersion >= SQL_OV_ODBC3) /* skip if 3.x */
                continue;
            break;
            
        case SQL_TYPE_TIMESTAMP:
        case SQL_TYPE_DATE:
        case SQL_TYPE_TIME:
            if (ODBCVersion <= SQL_OV_ODBC2) /* skip if 2.x */
                continue;

            if ((dataTypeInfo[i].ingtype == IITYPE_INGRES) &&
                APILevel > IIAPI_LEVEL_3) /* Use ISO dates, not Ingres dates */
                continue;

            break;
        }
        switch (dataTypeInfo[i].data_type)
        {
        case SQL_TIMESTAMP:
        case SQL_TYPE_TIMESTAMP:
        case SQL_TIME:
        case SQL_TYPE_TIME:
            if ((dataTypeInfo[i].ingtype == IITYPE_INGRES_ISODATES) &&
                APILevel < IIAPI_LEVEL_4)
                continue;
        
            if ((dataTypeInfo[i].ingtype == IITYPE_INGRES) &&
                APILevel > IIAPI_LEVEL_3)
                continue;

            if ((dataTypeInfo[i].ingtype == IITYPE_ALL) &&
                (dataTypeInfo[i].data_type == SQL_TIMESTAMP) &&
                APILevel > IIAPI_LEVEL_3)
                continue;

            if ((dataTypeInfo[i].ingtype == IITYPE_ALL) &&
                (dataTypeInfo[i].data_type == SQL_TYPE_TIMESTAMP) &&
                APILevel > IIAPI_LEVEL_3)
                continue;

            sql_data_type = SQL_DATETIME;

            break;

        case SQL_DATE:
        case SQL_TYPE_DATE:
            if ((dataTypeInfo[i].ingtype == IITYPE_INGRES_ISODATES) &&
                dateConnLevel < IIAPI_LEVEL_4)
                continue;
        
            if ((dataTypeInfo[i].ingtype == IITYPE_INGRES) &&
                dateConnLevel > IIAPI_LEVEL_3)
                continue;

            if ((dataTypeInfo[i].ingtype == IITYPE_ALL) &&
                (dataTypeInfo[i].data_type == SQL_TIMESTAMP) &&
                dateConnLevel > IIAPI_LEVEL_3)
                continue;

            if ((dataTypeInfo[i].ingtype == IITYPE_ALL) &&
                (dataTypeInfo[i].data_type == SQL_TYPE_TIMESTAMP) &&
                dateConnLevel > IIAPI_LEVEL_3)
                continue;

            sql_data_type = SQL_DATETIME;

            break;

        case SQL_INTERVAL_YEAR_TO_MONTH:
        case SQL_INTERVAL_YEAR:
        case SQL_INTERVAL_MONTH:
        case SQL_INTERVAL_DAY_TO_SECOND:
        case SQL_INTERVAL_DAY:
        case SQL_INTERVAL_HOUR:
        case SQL_INTERVAL_MINUTE:
        case SQL_INTERVAL_SECOND:
        case SQL_INTERVAL_DAY_TO_HOUR:
        case SQL_INTERVAL_DAY_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_MINUTE:
        case SQL_INTERVAL_HOUR_TO_SECOND:
        case SQL_INTERVAL_MINUTE_TO_SECOND:            
            if ((dataTypeInfo[i].ingtype == IITYPE_INGRES_ISODATES) &&
                APILevel < IIAPI_LEVEL_4)
                continue;

            sql_data_type = SQL_INTERVAL;

            break;
        }

        if (dataTypeInfo[i].data_type == SQL_WCHAR     ||
            dataTypeInfo[i].data_type == SQL_WVARCHAR  ||
            dataTypeInfo[i].data_type == SQL_WLONGVARCHAR)
        {
            if (!(pdbc->fOptions & OPT_UNICODE)) 
                continue;   /* skip WCHAR if not supported by server */
        }
        
        if (dataTypeInfo[i].data_type == SQL_LONGVARCHAR  ||
            dataTypeInfo[i].data_type == SQL_CHAR         ||
            dataTypeInfo[i].data_type == SQL_VARCHAR)
            case_sensitive = 1;
        else   
            case_sensitive = 0;
        
        if (dataTypeInfo[i].data_type == SQL_TINYINT      ||
            dataTypeInfo[i].data_type == SQL_DECIMAL      ||
            dataTypeInfo[i].data_type == SQL_INTEGER      ||
            dataTypeInfo[i].data_type == SQL_SMALLINT     ||
            dataTypeInfo[i].data_type == SQL_FLOAT        ||
            dataTypeInfo[i].data_type == SQL_REAL)
            unsigned_attribute =  0;
        else 
            unsigned_attribute = -1;
        
        precision = dataTypeInfo[i].precision;
        switch (dataTypeInfo[i].data_type)
        {
        case SQL_WCHAR:
        case SQL_WVARCHAR:
            if (pdbc->fRelease >= fReleaseRELEASE30) 
                precision = (32000 / DB_ELMSZ);
            case_sensitive = 1;
            break;
        
        default:
            break;
        } 
        
        switch (dataTypeInfo[i].data_type) 
        {
        case SQL_DECIMAL:
            maximum_scale = pdbc->max_decprec;
            minimum_scale = 0;
            break;
        
        case SQL_TIMESTAMP:
        case SQL_TYPE_TIMESTAMP:
            maximum_scale = APILevel < IIAPI_LEVEL_4 ? 0 : 9;
            minimum_scale = 0;
            break;

        case SQL_TIME:
        case SQL_TYPE_TIME:
            maximum_scale = APILevel < IIAPI_LEVEL_4 ? 0 : 9;
            minimum_scale = 0;
            break;

        case SQL_INTERVAL_DAY_TO_SECOND:
            maximum_scale = 9;
            minimum_scale = 0;
            break;
            
        default:  
            maximum_scale = -1;
            minimum_scale = -1;
            break;
        }
    
        p += pstmt->cbrow;       /* p->tuple to fill in */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_TYPE_NAME, &dp, &np);
        i2p = (i2*) dp;    /* i2p->varchar length in column's data area */
        *i2p = (i2)STlength(dataTypeInfo[i].type_name);
        STcopy(dataTypeInfo[i].type_name, dp+2);
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_DATA_TYPE, &dp, &np);
        i2p  = (i2*) dp;
        *i2p = dataTypeInfo[i].data_type;
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_PRECISION, &dp, &np);
        i4p  = (i4*) dp;
        if (dataTypeInfo[i].data_type == SQL_NUMERIC ||
            dataTypeInfo[i].data_type == SQL_DECIMAL)
            *i4p =  pdbc->max_decprec;
        else
            *i4p = precision;

        /*
        ** Search the cached values for length as specified in
        ** iidbcapabilities.  Override the default if nonzero.
        */
        switch(dataTypeInfo[i].data_type)
        {
        case SQL_CHAR:
        case SQL_VARCHAR:
        case SQL_VARBINARY:
        case SQL_BINARY:
        case SQL_WCHAR:
        case SQL_WVARCHAR:
            GetSQLMaxLen (pstmt, dataTypeInfo[i].data_type, i4p);
            break;
        }
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_PREFIX, &dp, &np);
        i2p  = (i2*) dp;
        len = (i4)STlength(dataTypeInfo[i].literal_prefix);
        if (len)
        { 
            *i2p = (i2)len;
            STcopy(dataTypeInfo[i].literal_prefix, dp+2);
        }
        else 
            *np = -1;      /* mark as null */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_SUFFIX, &dp, &np);
        i2p  = (i2*) dp;
        len = (i4)STlength(dataTypeInfo[i].literal_suffix);
        if (len)
        { 
            *i2p = (i2)len;
            STcopy(dataTypeInfo[i].literal_suffix, dp+2);
        }
        else 
            *np = -1;      /* mark as null */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_CREATE_PARAMS, &dp, &np);
        i2p  = (i2*) dp;
        len = (i4)STlength(dataTypeInfo[i].create_params);
        if (len)
        { 
            *i2p = (i2)len;
            STcopy(dataTypeInfo[i].create_params, dp+2);
        }
        else 
            *np = -1;      /* mark as null */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_NULLABLE, &dp, &np);
        i2p  = (i2*) dp;
        *i2p = SQL_NULLABLE;
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_CASE_SENSITIVE, &dp, &np);
        i2p  = (i2*) dp;
        *i2p = case_sensitive;
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_SEARCHABLE, &dp, &np);
        i2p  = (i2*) dp;
        *i2p = dataTypeInfo[i].searchable;
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_UNSIGNED_ATTR, &dp, &np);
        i2p  = (i2*) dp;
        if (unsigned_attribute >= 0)
            *i2p = unsigned_attribute;
        else 
            *np = -1;      /* mark as null */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_MONEY, &dp, &np);
        i2p  = (i2*) dp;
        *i2p = 0;
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_AUTO_INCR, &dp, &np);
        i2p  = (i2*) dp;
        if (unsigned_attribute >= 0)  /* auto_increment same as unsigned attr */
            *i2p = unsigned_attribute;
        else 
            *np = -1;      /* mark as null */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_LOCAL_NAME, &dp, &np);
        *np = -1;          /* mark as null */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_MIN_SCALE, &dp, &np);
        i4p  = (i4*) dp;
        if (minimum_scale >= 0)  /* auto_increment same as unsigned attr */
            *i4p = minimum_scale;
        else 
            *np = -1;      /* mark as null */
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_MAX_SCALE, &dp, &np);
        i4p  = (i4*) dp;
        if (maximum_scale >= 0)  /* auto_increment same as unsigned attr */
            *i4p = maximum_scale;
        else 
            *np = -1;      /* mark as null */
            
        GetTuplePtrs(pstmt, p, QRY_TYPE_SQL_DATA_TYPE, &dp, &np);
        i4p  = (i4*) dp;
        if ((sql_data_type == SQL_DATETIME) || (sql_data_type == 
            SQL_INTERVAL))    
            *i4p = sql_data_type;
        else 
            *i4p = dataTypeInfo[i].data_type; 
        
        GetTuplePtrs(pstmt, p, QRY_TYPE_DATETIME_SUB, &dp, &np);
        i4p  = (i4*) dp;
        if ((sql_data_type == SQL_DATETIME) || (sql_data_type == 
            SQL_INTERVAL))    
            *i4p = dataTypeInfo[i].subcode;
        else 
            *np = -1;      /* mark as null */
 
        GetTuplePtrs(pstmt, p, QRY_TYPE_NUM_PREC_RADIX, &dp, &np);
        i4p  = (i4*) dp;
        if ((dataTypeInfo[i].data_type == SQL_DECIMAL))
            *i4p = 10;
        else 
            *np = -1;      /* mark as null */
 
        i4p  = (i4*) dp;
        if ((sql_data_type == SQL_DATETIME) || (sql_data_type ==
            SQL_INTERVAL))
            *i4p = interval_precision;
        else
            *np = -1;      /* mark as null */

            
    }  /* end for loop */
     
    p = pstmt->prowCurrent + pstmt->cbrow;   /* p-> 1st tuple */

    /*
    **  Compute offset of SqlType in row:
    */
    pird = pIRD->pcol + QRY_TYPE_DATA_TYPE;    /* pird -> DATA_TYPE (SQL data type) */
    cb = (UWORD)pird->cbDataOffset;

    if (fSqlType == SQL_ALL_TYPES)
    {
        /*
        ** Count all rows:
        */
        while (*(SWORD     *)p)
        {
            pstmt->crowBuffer++;
            p += pstmt->cbrow;          
        }
    }
    else
    {
        tempType = fSqlType;
        if (ODBCVersion <= SQL_OV_ODBC2) 
        {
            if (fSqlType == SQL_TYPE_TIMESTAMP)
                tempType = SQL_TIMESTAMP;    
            else if (fSqlType == SQL_TYPE_TIME)
                tempType = SQL_TIME;    
            else if (fSqlType == SQL_TYPE_DATE)
                tempType = SQL_DATE;    
        }
        /*
        **  Find first row for type:
        */
        while (*(SWORD     *)p && *(SWORD *)(p + cb) != tempType)
        {
            pstmt->prowCurrent = p;
            p += pstmt->cbrow;
        }
        /*
        **  Count rows for type:
        */
        while (*(SWORD     *)p && *(SWORD *)(p + cb) == tempType)
        {
            pstmt->crowBuffer++;
            p += pstmt->cbrow;
        }
        
    }
    pstmt->fStatus |= STMT_OPEN + STMT_EOF + STMT_INTERNAL;

    UnlockStmt (pstmt);
    return SQL_SUCCESS;
}
/*
**  GetInfoBit
**
**  Find value in SQLGetInfo bitmask table.
**
**  On entry: pdbc      -->connection block.
**            fInfoType  = type of information.
**            pInfoValue-->where to return information.
**
**  On exit:  pInfoValue = bit mask if found.
**
**  Returns:  TRUE if found
**            FALSE if not
*/
BOOL GetInfoBit(
    LPDBC   pdbc,
    UWORD   fInfoType,
    UDWORD     * pInfoValue)
{
    BOOL    rc = FALSE;

    const UDWORD     * p;

    for(p=InfoBitTable; *p < MAX_INFO_TYPE; p +=2)
        {
            if (*p == fInfoType)
            {
                if (pInfoValue) 
                   *pInfoValue = *(p + 1);
                rc = TRUE;
                break;
            }
        }
    return rc;
}

/*
**  GetSQLMaxLen
**
**  Get the maximum length of a dynamically-assigned data type.
**
**  On entry: pstmt    -->statement handle.
**            fSqlType -->type of information.
**            p        -->tuple pointer.
**
**  On exit:  The precision field of the tuple is updated with the length
**            from the statement handle if the data type is char, varchar, 
**            binary, or varbinary, else the default value is retained.
**        
**            The lengths of these data types may vary depending on the
**            settings in the iidbcapabilities catalog.
**
**  Returns:  void.
*/
void GetSQLMaxLen(
    LPSTMT   pstmt, 
    SWORD   fSqlType,
    i4     *lenPtr)
{
    i4 maxLen = 0;
    LPDBC pdbc = pstmt->pdbcOwner;

    switch ( fSqlType )
    {
        case SQL_CHAR :
            if(pdbc->max_char_column_length > 0)
                maxLen = pdbc->max_char_column_length; 
            break;
        case SQL_VARCHAR:
            if(pdbc->max_vchr_column_length > 0)
                maxLen = pdbc->max_vchr_column_length;            
            break;
        case SQL_BINARY:
            if(pdbc->max_byte_column_length > 0)
                maxLen = pdbc->max_byte_column_length;
            break;
        case SQL_VARBINARY:
            if(pdbc->max_vbyt_column_length > 0)
                maxLen = pdbc->max_vbyt_column_length;
            break;
        case SQL_WCHAR:
            if(pdbc->max_nchr_column_length > 0)
                maxLen = pdbc->max_nchr_column_length;
            break;
        case SQL_WVARCHAR:
            if(pdbc->max_nvchr_column_length > 0)
                maxLen = pdbc->max_nvchr_column_length;
            break;
    }
    if (maxLen > 0)
   	 I4ASSIGN_MACRO(maxLen, *lenPtr);

    return;
}
