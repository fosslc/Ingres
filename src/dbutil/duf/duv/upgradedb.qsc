/*  
** Copyright (c) 1989, 2010 Ingres Corporation
**
*/
EXEC SQL include sqlca;
 
#include    <compat.h>
#include    <gl.h>
#include    <iicommon.h>
#include    <dbdbms.h>
#include    <adf.h>
#include    <qeaiproc.h> 
#include    <tr.h>
#include    <pc.h>
#include    <me.h>
#include    <si.h>
#include    <cs.h>
#include    <ex.h>
#include    <st.h>
#include    <ut.h>
#include    <cv.h>
#include    <lo.h>
#include    <er.h>
#include    <duf.h>
#include    <lk.h>
#include    <di.h>
#include    <nm.h>
#include    <bt.h>
#include    <dmf.h>
#include    <duerr.h>
#include    <duenv.h>
##include   <dudbms.qsh>
#include    <duu.h>
#include    <lg.h>
#include    <dm.h>
#include    <dmp.h>
#include    <dm0c.h>
#include    <pm.h>
/* 24-may-1995 b68770        */
#include    <tm.h>
/* 24-may-1995 b68770        */
#include    <duvfiles.h>
##include   <upgradedb.qsh>
##include   <dustar.qsh>
#include    <duucatdef.h>
#include    <generr.h>
/*
** values below are copied from dudbms.qh.  Since these are needed for SQL
** and this is currrently a QUEL only file, these values are copied here.
** At some future date, we should change dudbms.qsh to make sql definitions as
** well as QUEL ones.
*/
EXEC SQL begin declare section;
    #define	DU_SQL_NONE	    100  /* no tuples meet qualification*/
    #define	DU_OPERATIVE	    16
    #define	DU_CONVERTING	    32
    #define	DU_UPGRADING	    64

    #define	DU_0DBMINOR	     0
    #define	DU_1DBMINOR	     1
    #define	DU_2DBMINOR	     2
    #define	DU_3DBMINOR	     3


    #define	DBDB_SESSIONID	    1	    /* session identifier for iidbdb
					    ** session */
    #define	DB_SESSIONID	    2	    /* session identifier for non-iidbdb
					    ** session */
    #define     STAR_SESSIONID      3       /* session identifier for user star
                                            ** session */
EXEC SQL end declare section;


#define		OLD_DB_MAXNAME		24	/* for DB_MAXNAME conversion */

/* relstat bits, should be in sync with TCB bits in back!dmf!hdr dmp.h */
#define		DU_RELSTAT_DUPLICATES		0x00200000L

/*

**  Name: UPGRADEDB.QSC - Convert 6.x INGRES database or installation to the
**			  current ingres release level.
**
**  Description:
**      This program will convert a previous version 6 INGRES database
**	to the current release.
**
**	Routines in this file are arranged more or less at random.
**	Please fix me someday.
**
**  History:
**      09-jun-89 (ralph)
**          Adapted to 7.0 from jrb's cv60to61 utility
**	09-aug-89 (ralph)
**	    Added cv_sequence() and it's invocation in cv_database
**	13-aug-89 (ralph)
**	    Allow conversion to continue when database is inoperative if
**	    the DU_CONVERTING flag is also on in iidatabase.access
**	26-aug-89 (ralph)
**	    Do not convert if database is being journaled
**	    Allow conversion for any Release 6 database
**	16-sep-89 (ralph)
**	    Check server version to ensure it is 7.0.
**	    Destroy temporary work tables prior to creating them.
**	    Destroy new catalogs prior to creating them.
**	    Check for errors more frequently in conversion subroutines.
**	    Added cv_altcolumns for converting iialt_columns.
**	    Changed ii_sequence_value to ii_sequence_values & related changes.
**	22-sep-89 (ralph)
**	    Renamed to UPGRADEDB.QSC.
**	    Changed current version from 7.0 to 6.3.
**	    Allow conversion of 7.0 databases to 6.3 format.
**	11-oct-89 (ralph)
**	    Allow conversion of 7.0 databases even if journaled
**	19-oct-89 (ralph)
**	    Delete config files in the dump directory.
**	14-dec-89 (ralph)
**	    Allow conversion of 6.3 database if one was specified on the
**	    command line.  If -all specified, continue to bypass conversion.
**	19-apr-90 (ralph)
**	    Changed iidbprivileges definition, and allowed it to be recreated.
**	    Allow iidbdb to be converted even if already 6.3 when specified.
**	07-jun-90 (ralph)
**	    Add logic to qualify fe/be conversion separately.
**	02-jul-90 (ralph)
**	    Added 6.3/02 iidbcapabilities entries
**	    Ensure user is authorized to convert database as follows:
**		If "-all" is specified, user must be superuser
**		If dbname is specified, user must be superuser or DBA.
**	16-jul-90 (ralph)
**	    Correct typo when destroying previous ii_sequence_value[s]
**	13-sep-90 (ralph)
**	    Correct merge conflict resolutions
**	2-oct-90 (pete)
**	    Remove function 'cv_sequence', which creates ii_sequence_values
**	    and a database procedure based on that (_ii_sequence_value).
**	    These are now handled by upgradefe.
**     10-oct-90 (hhsiung)
**          Rework a statement to get rid of compiler warning about not
**          able to take the address of this object.
**	10-dec-90 (neil)
**	    Alerters: include iievent in 6.3/04 conversion.
**	    Modify method to create iipermits (may need *recreation* if
**	    new format but with iievent).
**	9-jan-91 (stevet)
**	    Added IIUGinit call to initialize CM attribute table.
**	1-feb-1991 (bryanp)
**	    Added support for Btree index compression: dbcmptlvl => 6.34,
**	    standard catalogs changes to iitables, iiphysical_tables, and
**	    iiindexes. Added new internal subroutines cv_tables, cv_indexes,
**	    and cv_physical_tables. set_cmptlvl returns new value.
**	    Also picked up some miscellaneous catalog changes from the Front
**	    Ends group (Pete):
**		ING6.3 ==> ING6.4, 00603 ==> 00604 (iidbcapabilities)
**		new column in iidbconstants -- system_owner
**			This change required adding cv_dbconstants.
**		correct definition of iiphysical_tables.duplicate_rows.
**		new column 'column_updateable' in iicolumns.
**		sort direction in iiindex_columns no longer hard coded.
**			This change required adding cv_index_columns.
**	28-mar-1991 (bryanp)
**	    Repaired previous change by changing DU_3DBV63 to DU_5DBV634 in the
**	    relevant places.
**	07-may-91 (teresa)
**	    Fix bug 37439 by using DU_UPGRADING bitflag instead of DU_CONVERTING
**	    which allows upgradedb to distinguish a db marked for upgrade from
**	    an unconverted v5 db.
**	22-jul-91 (teresa)
**	    Extracted messages to erduf.msg and made several modifications to
**	    meet coding standards.  Also did major restructuring due to some
**	    architectual bugs.  Changed the message/logging mechanism to be
**	    more compatible with the rest of DUF.
**	16-apr-92 (teresa)
**	    Pick up ingres63p change 265521:
**		2-apr-92 (seg)
**		Needed different constant for "upgradedb", so replaced all 
**		literals (ERX("upgradedb")) with a variable reference and
**		ifdef'ed the variable's initialization.
**	05-oct-92 (jpk)
**		Remove references to MSB of relstat, cv_relstat() routine.
**	08-oct-92 (robf)
**	     Add support for new C2-SXA gateway catalogs (iigw06_relation,
**	     iigw06_attribute, iiaudittables) plus the new iidbdb catalog 
**           iiaudit.
**      20-nov-92 (bonobo)
**          Updated MING hint to include CUFLIB.
**	7-Jan-1993 (daveb)
**	    forward declare open_target().  HP compiler fataled bool not being int.
**      26-apr-1993 (bryanp)
**          6.5 Cluster support:
**		Include <lg.h> to pick up logging system typedefs
**	8-aug-93 (ed)
**		unnest dbms.h
**	26-oct-93 (robf)
**	   DU_USUPER --> DU_USECURITY
**	16-nov-93 (rblumer)
**	    added value for new 'upper_case' argument to duc_iischema function
**	    call in new_for_65_syscats.
**	    This argument is FALSE for 6.4 databases, since only lower-case
**	    databases were allowed in 6.4.
**	20-nov-1993 (jpk)
**	    Populate iischema.  Drop and rebuild rules, procedures, 
**	    and integrities as well as views and permits.
**	13-oct-93 (swm)
**	    Bug #56448
**	    Removed d_print() function because it accepts a variable number
**	    of variable-sized arguments, which is not portable. It could
**	    not become a varargs function as this practice is outlawed in
**	    main line code.
**	    Replaced invocations of the function with calls to SIprintf. This
**	    works because SIprintf is a varargs function.
**	    Tidied up previous history comment.
**	29-Jan-1994 (jpk)
**	    Bug #58408.
**	    Made those SIprintfs depend on upg_dbg_out flag.
**	01-feb-1994 (wolf) 
**	    Move the #include cs.h ahead of #include lk.h so the compiler
**	    knows what a CS_SID is.
**	10-mar-94 (swm)
**	    Bug #60474
**	    Added missing control block argument in several invocations
**	    of du_talk function. Errors should now be logged correctly.
**	8-jul-94 (robf)
**          Updated for ES 1.1
**      10-nov-94 (chech02)
**          Bug #56476
**          deleted 'register iiprocedure as link' stmt in cv_star_cats().
**      03-feb-95 (chech02)
**          Bug# 66464, 66467, 64589, 64590
**            1. Use 'CREATE TABLE tmp_tble' to create tmporary tables, 
**               instead of ' DECLARE GLOBAL TEMPORARY TABLE'.
**            2. set session authorization to '$ingres' in cv_permits().  
**            3. add chk_create_workdir() to create $II_SYSTEM/ingres/work/
**               default/dbname if not exists.
**          
**      02-feb-1995 (sarjo01) Bug 65613
**          cv_initialize(): Removed du_chk1_dbname() call which gave error
**          if dbname was qualified with vnode::
**      17-feb-1995 (chech02) Bug 66923
**          Check journing first before doing order_critical_65es().
**      08-mar-1995 (chech02) Bug 67365
**          1. Add rm_iitmp_tables() to remove all iitmp_ tables.
**          2. If a super user, then add 'operator' and 'create location'
**             privileges to the super user. 
**      20-mar-1995 (canor01) Bug 67535
**          Connect as $ingres so back end knows this is an
**          administrative procedure
**      21-mar-1995 (chech02) Bug 67443
**          Not allow to upgrade from the non-sql92 installtion to the sql92
**          installtion.
**      27-mar-1995 (chech02) 67532
**          Cant access views in stardb. Added cv_user_star_iiviews() to
**          populate user views in stardb.
**      29-mar-1995 (chech02) 67789
**          In Release 6.4 create permit insert was allowed on aggregate views
**          that is not permitted in 1.1. Modified exec_txt() to test for sql 
**          return code of -34000 when attempting to create a permit.
**      26-apr-1995 (wolf) 68397
**          Unix pathname used in chk_create_workdir() causes a/v on VMS.
**      24-may-1995 (lawst01) 68770
**          Initialize 'dbp_create_date' field for a procedure - when 
**          converting from 6.4 database. Field currently contains 0
**          will use upgrade date in field.
**      2-jun-1995 (chech02) 68695
**          Close 'iidbdb' session before call to upgradefe on the star
**          database.
**      2-jun-1995 (chech02) 68696
**          Even the current level of the database is 11/03, calls
**          upgradefe to display the status of front end catalogs.
**      2-jun-1995 (lawst01) 69067
**          Change permissions on PEworld function call to "+r+w+x" from "+r+w"
**      5-jul-1995 (chech02) 65613
**          Allowed upgradedb to process dbnames in 'vnode::dbname' format.
**      5-sep-1995 (chech02)
**          1. Before forking to upgradedb, database shall be closed and 
**             opened db without exclusive lock. 
**          2. Used LOingpath() to create work sub dirtory.                   
**      21-sep-1995 (chech02) b71412
**          Since the system table iistatistics has been changed, we just 
**          need to delete all rows from iistatistics to fix this bug.
**      25-sep-1995 (chech02) b71608
**          Added duc_iierror() to create internal db procedure iierror.
**      03-nov-1995 (lawst01) b71777
**          Added 'grant_select_64_11' to 'grant select on table to public'
**          if the TCB_PRTUPS (0x00000004) flag is set - tuple exists in
**          iiprotect table and the TCB_PROTECT (0x00002000) flag is not
**          set. In 64 for a grant select on table-name to public no entry
**          was stored in the ii protect table, so it is necessary to
**          issue the grant select ... after the database is upgraded.
**	09-nov-1995 (canor01)
**	    Initial upgrade from V65ES_LEVEL to V12_LEVEL, which currently
**	    consists of upgrading the iitables view.
**	10-nov-95 (nick)
**	    Call duc_modify_iihistogram() rather than use QUEL explicitly
**	    in order_critical_65().
**	13-nov-95 (prida01)  71292
**	    On a star database upgradedb doesn't upgrade iistats and iidd_stats
**	    properly.
**	5-dec-95 (stephenb)
**	    open_target() may fail in such a way as to leave us switched
**	    into a bad connection (notably when the target database is 
**	    inconsistent), this causes problems upgrading subsequent databases.
**	    Makse sure we switch back to the iidbdb connection before
**	    continuing
**	05-Jan-96 (nive)
**	    In function cv_65_iiextend, added code to
**	    update iiextend to pad lname and dname upto 32 length 
**	    while upgrading dbs from R6. Also, pad lname ii_work upto
**	    32 length during its insertion into iiextend. (Bug 71480)
**	21-Feb-96 (prida01)
**	    When upgrading a database of form vnode::database the vnode
**	    is needed for connecting to the database, but causes problems
**	    when checking database directories exist etc. Remove it when
**	    not needed.
**      06-mar-1996 (nanpr01)
**          Added upgrade code for 2.0 upgrade - Variable Page Size Project. 
**	 4-apr-96 (nick)
**	    Upgrade iimulti_locations.
**	31-may-96 (prida01)
**	    Modify vnode change to work for local databases bug 76245
**      31-May-96 (fanra01)
**          Changed collect_dbs to return a success or failure status to affect
**          the upgr_exit.
**	13-jun-1996 (nick)
**	    LINT directed changes.
**	22-july-1996 (angusm)
**		Intersolv ODBC driver support changes - add calls to add
**		catalogs 'iiproc_params','iiproc_access', and ensure that
**		'iiaccess' is rebuilt.
**	22-Aug-96 (hanch04)
**		Remove comments around prototype add_dbname.
**      28-sep-96 (mcgem01)
**              Global data moved to duvdata.c
**      16-Oct-1996 (hanch04)
**          Added relversion, reltotwid for 2.0
**	    Modifed iiattribute to have more room for new columns.
**		1.  Insert new attributes into iiattribute table.
**		2.  Disconnect and reconnect to flush caches.
**		3.  Modify iiattribute to hash, 64 bytes read in,
**			96 written out.  
**		4.  Drop iicolumns view and recreate.
**		5.  Update fields in iirelation.
**		6.  Update new fields in iiattribute to defaults.
**	28-jan-97 (inkdo01)
**	    Added cv_20_hashdate_tables to normalize hashed date columns
**	    following bug fix for 74033.
**	09-may-96 (mcgem01)
**	    Change the minor release id to 1 so that we now detect the need
**	    to uggrade 2.0 beta databases, to include reltcpri the
**	    (table cache priority).  Add table_pagesize, table_relversion, 
**	    table_reltotwid and reltcpri to iitables.
**	17-aug-1997 (hanch04)
**	    Connect to iidbdb with +w flag to wait for lock.
**	22-aug-97 (kinpa04)
**	    Change level check from 'level' to 'upgd_cb.Dbname_ptr->level'
**	    while handling databases since 'level' is set to that of
**	    the last database in query list.
**	22-aug-1997 (nanpr01)
**	    FIPS upgrade fails with  E_DU6019 CANT_UPGRADESQL92 message.
**	    bug 84356 & 74447.
**	04-feb-1998 (hanch04)
**	    Change the minor release id to 0, added DU_6DBV85
**	06-Mar-1998 (kosma01)
**	    AIX 4.x loses $ingres authorization when before converting
**	    6.4 Ingres iistatistics. Reauthorize in cv_65_iistatistics
**      13-mar-98 (nicph02)
**              Added cleanup routine rm_iiqef_procedures to get rid of
**              temp iiQEF_ procedures as the upgradedb terminates
**              (bug 89164)
**	02-apr-1998 (i4jo01)
**	    Crash when creating internal procedure iierror.
**	    Needed parameter when calling duc_iierror. (b90225)
**      03-Aug-1998 (wanya01)
**          Add a new flag -c for concurrent upgradedb.
**          If -c is specified, we will connect to iidbdb without taking
**          exclusive lock on it.
**	30-oct-1998 (kitch01)
**		Bug 92451. Add 0 days instead of 0 hours. This will still allow
**		the date to be normalized but without appending 00:00:00 to
**		date only date values. Function cv_20_hashdate_tables().
**	09-nov-1998 (mcgem01)
**	    Changed table version to "II2.5"
**      21-apr-1999 (hanch04)
**          replace STindex with STchr
**      28-apr-1999 (hanch04)
**          Replaced STlcopy with STncpy
**	12-may-99 (stephenb)
**	    Add function changed_cats_25() for 2.5 catalog changes
**	21-may-1999 (hanch04)
**	    Replace STbcompare with STcasecmp,STncasecmp,STcmp,STncmp
**      27-may-99 (hanch04)
**	    Add function chmod_data_600().
**      03-aug-1999 (stial01)
**          create/modify iiextended_relation if it doesn't exist
**          Call iiQEF_convert_table for all tables having (blob) extensions
**      01-jun-1999 (kitch01)
**	   As part of the fix for 97040, recreate the iilog_help view during
**	   an upgrade.
**      08-jul-99 (chash01) rms gateway code merge, set dbmstype to DU_DBRMS 
**           if test says RMS.
**        12-dec-97 (chash01)
**          for rms gateway, converting views and imported table causes
**          error, they must be excluded.
**       1-oct-1999 (mosjo01) SIR 97564
**          Reposition ex.h after cs.h to avoid compiler error on _jmpbuf.
**       5-feb-2001 (horda03) Bug 103873.
**          du_error() removes the '\t' following the Ingres error code in the
**          returned error message, if the message is not a WARNING nor an
**          INFORMATIONAL. If the message stills contaiNs '\t', then the first
**          part of the message will be lost. Similarly, if the message does
**          not contain a '\t' the Ingres error code will be displayed.
**      19-jan-2000 (stial01)
**          Call iiQEF_convert_table for btree/rtree tables (so the dbms can 
**          validate keys per page calculations, fixed error handling.
**	31-jan-2000 (hanch04)
**	    Call new_for_65_syscats_iidbdb before changed_for_65_syscats_iidbdb
**      19-May-2000 (hweho01)
**          Reposition cs.h before ex.h avoids compiler errors with __jmpbuf
**          on AIX 4.3 platform.
**	29-aug-2000 (somsa01)
**	    In changed_cats_25(), changed c3 cursor to 'c4', as c3 is
**	    already in use in this file.
**	3-nov-00 (inkdo01)
**	    Minor changes to iistats, iihistograms stdcat views require
**	    drop/recreate (for composite histograms).
**	09-nov-2000 (somsa01)
**	    In cv_65_iirule(), check to make sure the iiruleidx and
**	    iiruleidx1 indices exist.
**	17-nov-2000 (somsa01)
**	    Modified the last change such that the iirule indices are
**	    created for all databases less than 2.5 .
**      02-Mar-2001 (hanch04)
**          Bumped release id to external "II 2.6" internal 860 or 8.6
**	02-Mar-2001 (jenjo02)
**	    Added changed_for_26_iidbdb_cats(), cv_26_iilocations().
**	02-Apr-2001 (jenjo02)
**	    Added cv_26_iiextend().
**      16-apr-2001 (stial01)
**          Added changed_for_26_stdcats
**      27-apr-2001 (stial01)
**          Added new_for_26_dbprocs to drop / re-create iiqef_create_db
**          because of new ucollation parameter for unicode databases
**          Moved call to grant_select_64_11 (it was causing errors)
**	11-May-2001 (jenjo02)
**	    rawblocks moved from iilocations to iiextend, rawpct added
**	    to iilocations.
**      16-may-2001 (stial01)
**          If upgradedb iidbdb, upgrade imadb and icedb as well (B104731)
**	23-May-2001 (jenjo02)
**	    Added installation of iiQEF_check_loc_area procedure
**	    to new_for_26_dbprocs().
**	1-aug-2001 (stephenb)
**	    Fix reference to STncpy(), it causes a fatal compile error
**	    on i64_aix.
**      03-oct-2001 (stial01)
**          Changes for new 2.6 iiextend columns (rawstart, rawblocks) (b105956)
**      04-oct-2001 (stial01)
**          grant_select_64_11() grant select with grant option (b78332)
**	15-Oct-2001 (jenjo02)
**	    Deleted short-lived iiQEF_check_loc_area. Area directories
**	    are now made by CREATE/ALTER LOCATION.
**      09-jan-2002 (stial01)
**          Using unloaddb to fix query trees, new -tree option (SIR 106745)
**      13-mar-2002 (stial01)
**          Remove references to location structure members
**      27-mar-2002 (stial01)
**          cv_database() Disable error check after drop procedure iiqef_create_db,
**          fix_qry_trees() make sure filename < DI_FILENAME_MAX
**          cv_iidbdb() move set_cmptlv before add_dbname
**      08-may-2002 (stial01)
**          fix_dbservice() check dbmsinfo('lp64') to see if SERVER is lp64
**      09-may-2002 (stial01)
**          fix_dbservice() call ii_update_config with newdbservice flags
**	26-jun-2002 (hanch04)
**	    Make copies of some system catalogs so that the saved rows
**	    can be inserted into the updated tables.
**	    Re-ordered some steps to allow a 6.4 database to upgrade.
**	    Modify the query for checking that fix_qry_trees worked.
**	01-Oct-2002 (hanje04)
**	    BUG 108823
**	    Include duu.h so that the duu functions are correctly prototyped.
**	    Having a default return type of i4 was causing problems on 64bit
**	    Linux (and potentially others) where there was no prototype and 
**	    the function was returning a char *.
**      19-dec-2002 (stial01)
**          fix_qry_trees() recreate internal procedures before executing
**          unloaddb script - we need may reference iierror.
**          Also when validating procedure count, don't count system procs.
**      07-jan-2003 (stial01)
**          Added fix_ref_constraints()
**      08-jan-2003 (stial01)
**          fix_ref_constraints: need to make sure we process only referential
**          constraints - as check constraints may have rules which reference
**          iierror - which has not been redefined yet
**      09-jan-2003 (stial01)
**          renamed fix_ref_constraints -> fix_sysgen_rules, handles all system
**          generated rules (ref and check constraints)
**      12-feb-2003 (stial01)
**          fix_qry_tree() clean up validation of view,integ,proc counts.
**          Strip include iiud.scr from copy.in (b109623)
**      14-feb-2003 (stial01)
**          fixed iidbdb connect options [3a], added -l so we lock database,
**          so we don't exceed locks per_tx_limit  (b109644)
**      07-Apr-2003 (hanch04)
**          Bumped release id to external "II 2.65" internal 865 or 8.65
**	11-apr-2003 (devjo01)
**	    - b109489: Correct problem where directory paths for locations
**	      were being truncated at 32 chars. (Root cause was a side effect
**	      of ancient unresolved b54123!)
**	    - b110050: Capture and surpress "unloaddb" output so user does
**	      not instructions for unloading and reloading his database,
**	      which are misleading in this context.
**	    - Cleanup compiler warnings. (add forward declare static func
**	      fix_dbservice, fix missing return value in non-void func.)
**	10-Jul-2003 (schka70)
**	    "chmod 0600 *" is no good for db's with lots of tables.
**	    Use xargs instead.  Also, translate locations names properly.
**      24-jul-2003 (stial01)
**          Fixed disconnect timing problem causing unloaddb to fail (b110617)
**      21-aug-2003 (ashco01) 
**          Problem: INGSRV#2479, Bug: 110760
**          chmod_data_600() can add considerable run-time overhead when
**          upgrading several thousand databases. Added II_UPGRADEDB_CHMOD
**          environment variable to disable chmod during upgradedb, allowing
**          the customer to manually chmod the data files when convenient.
**	14-Nov-2003 (wanfr01)
**	    Bug 110915, INGCBT492
**	    Rules can not be directly recreated if they were part of a foreign
**	    key constraint against a table not owned by the constraint owner.
**	    Added code to drop/recreate the constraint instead.
**      02-dec-2003 (chash01)
**          bug111385, upgradedb fails on rms gateway database with E_DM011A.
**          Modify the dbname_ptr string to remove "/rms" when execute
**          ii_update_config(), and add it back afterwards. Change is in
**          cv_upgrade().
**      05-dec-2003 (chash01)
**          For bug 111385, I missed third arg for STindex().
**      13-Jan-2004 (sheco02)
**          Bumped release id to external "II 3.0" internal 900 or 9.0
**     28-jan-04 (chash01) bug 111713/INGDBA275. interestingly, some RMS
**         gateway registered table/index has relspec=11
**         (btree) thus we have to eliminate them for update. 
**         test relstat for TCB_GATEWAY bit set, select those
**         that do not have this bit set.
**     09-feb-04 (chash01) bug 111713/INGDBA275 actually is the result of
**         not knowing TIDP is part of key (by Ingres definition). Change
**         in gwrms.c will fix this bug.  The code change indicated in
**         last comment is unneccessary and is now removed.  The change in
**         1997 that excludes the RMS gateway table from updating
**         is now taken care of in dmu_convert() and is no longer needed.  
**         It is removed also. 
**	11-mar-2004 (somsa01)
**	   When upgrading iidbdb, upgrade icetutor and icesvr as well. Also,
**	    split convert part of collect_dbs() into convert_dbs() to allow
**	    for multiple calls to collect_dbs() for adding multiple system
**	    databases. Also, removed some unused variables. Also, in
**	    set_cmptlvl(), Added use of DU_6DBV865 (Release 3).
**	26-Aug-2004 (schka24)
**	    Implement r3 upgrading, changes too numerous to list.
**	    Various bug fixes: large-page catalog tables, cross-user ref
**	    constraints with quel permits, 6.4 grant detritus, minor things.
**	27-oct-2004 (somsa01)
**	    Corrected CMDLINE setting for Windows.
**	27-oct-2004 (somsa01)
**	    Updated runs of unloaddb to be executed via PCcmdline(), so
**	    that we have better control of "-u" passing.
**	30-Dec-2004 (schka24)
**	    Changes for 3.0.2: attcollid, remove iixprotect.
**	    Also, rearrange functionality so that upgradedb itself doesn't
**	    have to run set-user-id to ingres.  Don't try to convert iidbdb
**	    if we're not ingres, create logs in an open directory, etc.
**	13-jul-2005 (abbjo03)
**	    Back out change of 27-oct-2004 as it causes errors when unloaddb
**	    is run on VMS.    
**      17-Jan-2005 (hweho01)
**          Bumped release level 9.02 to 9.04.
**      27-feb-2006 (stial01)
**          Add +w to sql CMDLINE so sql waits for upgradedb disconnect, b115750
**      02-mar-2006 (stial01)
**          fix_qry_trees() Make sure errors get reported to upgrade.log
**      27-Apr-2006 (hweho01)
**          Changed release level to 9.10.
**      20-oct-2006 (stial01)
**          Database level should not advance for ingres2006r2
**	12-Apr-2008 (kschendel)
**	    Need to include adf.h now.
**      16-jun-2008 (stial01)
**          Write to debug log, unless -n (nolog) specified
**      02-oct-2008 (stial01)
**          fix_qry_trees, unloaddb -uninterrupted, run unloaddb sql script
**          with autocommit on, continue if error
**     24-oct-2008 (stial01)
**          Modularize create objects for increased ingres names (SIR 121123)
**      11-dec-2008 (stial01)
**          Move tbl_lacks_col here, write dbg output to debug log
**      14-dec-2008 (stial01)
**          If db is not at current level, drop/recreate standard catalog views
**          Remove unnecessary code to drop/recreate stdcat view iiproc_params
**      07-apr-2009 (stial01)
**          Added duv_upgrade_be_catalog()
**      14-apr-2009 (stial01)
**          Updated duv_upgrade_be_catalog to create attribute list
**      14-Apr-2009 (hweho01) Bug 121922
**          On AIX, error 'E_DU600D_BAD_IIDBDB_RECONNECT' occurred  
**          when upgradedb tried to connect iidbdb for the second time. 
**          This is not a platform specific problem. To avoid the error, 
**          defined DISCONNECT_WAIT_TIME for using with PCsleep, ensure 
**          the disconnection has been processed when issuing the  
**          second connect.  
**	26-Aug-2009 (kschendel) b121804
**	    Bool prototypes to keep gcc 4.3 happy.
**	 1-Oct-09 (gordy)
**	    Added SQL_MAX_PROCEDURE_NAME_LEN.
**	20-Oct-2009 (thaju02) B122712
**	    For upgradedb -c, do not connect to iidbdb with -A6 -l options. 
**	    For upgradedb -c, commit iidbdb session before open_target() 
**	    to avoid possible hang situation involving iidatabase table 
**	    lock. 
**	12-Nov-2009 (kschendel) SIR 122882
**	    cmptlvl is now interpreted as u_i4, not char[4].
**      14-dec-2009 (joea)
**          Add changed_for_r10 to handle 10.0 conversions.  Change call
**          to duc_init_iidefaults in new_for_65_syscats.
**      10-Feb-2010 (maspa05) b122651
**          New flag has been added to relstat2 TCB2_PHYSLOCK_CONCUR
**          This is being set by the set_mand_relflags function - which
**          is a generic "set mandatory relstat, relstat2" function
**          Also added modify_physlock_tbls which modifies
**          TCB2_PHYSLOCK_CONCUR tables back to their intended 
**          hash structure
**	27-Apr-2010 (kschendel) SIR 123639
**	    Integrate Datallegro change to byte-ize the bitmap columns
**	    in iiprotect, iipriv, iiintegrity, and iirule.
**	    Fix iirule upgrade from 6.4, not sure when it was broken.
**	    Reorganize rather massively;  try to get away from a zillion
**	    little routines that check for specific changes.  Adapt Alison's
**	    be catalog updater so that it can be used for nearly all the
**	    updates.
**	18-May-2010 (frima01) Bug 123753
**	    In fix_dbservice skip update of config file for distributed
**	    database, cause there is none. Set tree_convert to true,
**	    fixing qry trees is neccessary for Ingres 10. Only allow star db
**	    owner to upgrade a star db to ensure access to private vnodes.
**      27-may-2010 (maspa05) SIR 123793
**          Delete from ii_encodings and ii_encoded_forms. This means that
**          when upgrading from int.lnx to a64.lnx encoded IL will get 
**          re-created when the applications are re-compiled. Also
**          update the alter_date in ii_objects to force re-compile of
**          all application components
**	03-Jun-2010 (frima01) Bug 123753
**	    Have iistats updated for Ingres 10 distributed databases.
*/
 
/*
MODE =          SETUID

NOODLIBS =	DBUTILLIB SQLCALIB LIBQLIB FMTLIB AFELIB ADFLIB \
			LIBQGCALIB CUFLIB GCFLIB COMPATLIB MALLOCLIB


NEEDLIBS =      DBUTILLIB SQLCALIB GNLIB UFLIB RUNSYSLIB RUNTIMELIB \
		FDLIB FTLIB FEDSLIB \
                LIBQSYSLIB LIBQLIB UGLIB FMTLIB AFELIB \
                LIBQGCALIB CUFLIB GCFLIB ADFLIB \
                COMPATLIB MALLOCLIB

OWNER =         INGUSER

MODE =		SETUID
 
PROGRAM =       upgradedb
*/


/*
** global variables 
*/

GLOBALREF DU_UPGRADE_CB	upgr_cb;	/* upgradedb control block */
static  char vnode[DB_MAXNAME+1];

/* externally referenced routines */
FUNC_EXTERN	DU_STATUS	dui_bldDefClientList();
FUNC_EXTERN	DU_STATUS	du_fclose();
FUNC_EXTERN	VOID		du_get_usrname();
FUNC_EXTERN     DU_STATUS	du_log();
FUNC_EXTERN     VOID		du_talk( );
FUNC_EXTERN	STATUS		setauth(char *owner);

FUNC_EXTERN	bool		rel_exists(char *rel_name);
FUNC_EXTERN	STATUS		ensure_not_exists(char *name);
FUNC_EXTERN	VOID     	duc_create_catalog(char *catalog);
FUNC_EXTERN	VOID     	duc_modify_catalog(char *catalog);
FUNC_EXTERN	VOID     	duc_iidd_physical_tables();
FUNC_EXTERN	DU_STATUS	duc_create_specific_stdcat_view(
			char *dbname, char *viewname, bool upcase);
FUNC_EXTERN	STATUS		duc_drop_stdcat_views(char *dbname, bool star_flag);
FUNC_EXTERN     STATUS          duc_grant_stdcat_views(char *dbname, bool star_flag);
FUNC_EXTERN	DU_STATUS	duc_modify_pagesize(i4 pagesize,
					bool star_flag, DU_ERROR *errcb);
FUNC_EXTERN	bool		proc_exists(char *);
FUNC_EXTERN DB_STATUS duc_init_iidefault(bool is_upgrade, DU_ERROR *errcb);
FUNC_EXTERN void duc_init_iiprofile();


GLOBALREF	bool		upg_dbg_out;
static          bool            upg_concurrent;
static		bool		upg_trees;
static		bool		upgrade_iidd_stats;
GLOBALREF	DUU_CATDEF	*Dus_allcat_defs[];
GLOBALREF DUC_CATDEF Duc_catdef[];

static		STATUS		fix_sysgen_rules();

/*
[@static_variable_or_function_definitions@]
*/

static char *upgradedb_name = 
	ERx("upgradedb");

static VOID	append_clientlist();
static VOID	add_dbname(); 
static void	chk_create_workdir(char *dbname);
static VOID	collect_dbs();
static STATUS	convert_dbs();
static VOID	cv_database();
static VOID	cv_dbaccess();
static VOID	cv_dbcap();
static VOID	cv_iidbdb();
static VOID	cv_initialize();
static VOID	cv_online();
static VOID	cv_iiprotect(char *dbname);
static VOID	cv_star_cats();
static VOID	cv_upgrade();
static VOID	du_create_logdir(DU_FILE *fp, char *logdir, char *subdir);
static VOID	du_fopen(DU_FILE *fp, char *filename);
static VOID	fe_dictinst();

static VOID	starto64();
static VOID	star_2pc();
static VOID	update_iidatabase();
static DU_STATUS validate_db();
static VOID	star_std_cats();
static bool	open_target(i4 open_mode);
#define CONNECT_EXCL	1
#define CONNECT_SHARE	0
static bool	needs_widening(char *tname, char *cname);
static VOID	make_copy_of(char *dname, char *tname);
static DU_STATUS copy_existing_columns(char *dbname, char *tblname);
static VOID     cv_65_star_iistats(char *dname);
static VOID	cv_iiintegrity(char *dname);
static VOID	cv_iirule(char *dname);
static VOID	fix_qry_trees(char *dbname, char *conn_dbname, bool star_db, i4 level);
static VOID	fix_copy_in(LOCATION *in, LOCATION *out, bool fix_iiud);

static VOID	cv_iipriv(char *dbname);
static VOID 	cv_65es_iisecuritystate(char *dbname);
static VOID	cv_iiaudit(char *dbname);
FUNC_EXTERN STATUS 	populate_secalarm(char *dbname);
FUNC_EXTERN VOID	populate_iischema();
STATUS	handle_ex(EX_ARGS *ex_parms);
static VOID 	star_20_std_cats(bool upcase);
static VOID 	cv_20_hashdate_tables(char    *dbname);
static VOID     rm_iiqef_procedures();
static VOID	convert_tables_25(char		*dbname);
static VOID	chmod_data_600();

static STATUS	fix_dbservice(char     *dbname);
static VOID	fix_syscat_grants(char *dbname);
static bool	fix_64_grants(char *dbname,
				LOCATION *grant_fix_loc,
				char *grant_fix_loc_buf);
static bool	fix_constraints(char *dbname,
				i4 level,
				LOCATION *ref_fix_loc,
				char *ref_fix_loc_buf);
static VOID upgr_exit(i4 line, DU_STATUS exit_stat, i4 msg_id);
static bool tbl_lacks_col(char *tname, char *cname);

static void UpgrExitOnError(i4 sqlcode);
static void cv_bitmap_cols(char *db, char *tbl, i4 n);
static DU_STATUS upgrade_catalog_list(char *db, char **table_list);
static DU_STATUS duv_modify_catalog(char *dbname, char *tablename);
static void do_early_updates(DBNAME_NODE *dbinfo);
static void populate_catalogs(DBNAME_NODE *dbinfo);
static void populate_iidbdb_catalogs(i4 level);
static void regrant_catalogs(char *dbname);

#define DISCONNECT_WAIT_TIME	20000

static DU_STATUS modify_physlock_tbls();

/*{
** Name: main	- Entry point for UPGRADEDB
** Description:
**
**	    main calls the proper functions for UPGRADEDB to startup,
**	    mark databases inoperative, check their cmptlvl's in iidbdb,
**	    convert them, and mark them operative again.
** Inputs:
**      argc		Command line argument count.
**	argv		Pointer to base of array of argument strings.
**
** Outputs:
**	none
**
**	Returns:
**	    OK		If completed successfully.
**	    FAIL	If error encountered or user terminated.
**
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      06-jun-89 (ralph)
**          Initial creation and coding.
**	06-jul-90 (ralph)
**	    Pass username and userstat parameters to various routines for
**	    verifying user permission to perform upgrade.
**	09-jan-91 (stevet)
**	    Added IIUGinit call to initialize CM attribute table.
**	08-apr-91 (bonobo)
**	    Added mysteriously absent MEadvise call.
**	22-jul-91 (teresa)
**	    Extracted messages to erduf.msg and made several modifications to
**	    meet coding standards. 
**	05-oct-92 (jpk)
**	    Added checking for CSinitiate() return status
**      31-May-96 (fanra01)
**          Initialise status to OK and added check of return from collect_dbs
**	13-sep-96 (nick)
**	    If we don't call EXsetclient() we won't catch user interrupts.
**	12-mar-2004 (somsa01)
**	    collect_dbs() is strictly used to add db names to the master
**	    list. convert_dbs() is now used to do the database conversions.
**	19-Apr-2007 (bonro01)
**	    Detect internal error in cv_initialize() and exit with Fail
**	    return code.
**	19-Nov-2008 (hweho01) 
**	    Change the database level for 9.3 release.
**	10-Jun-2009 (hweho01) 
**	    Change the release level for 10.0.
*/
main (argc, argv)
i4	argc;
char	*argv[];
{
    bool	dbdb_specified;
    char	username[DB_MAXNAME+1];
    i4	userstat; 
    DU_ERROR	errcb;
    STATUS	status = OK;

    upg_dbg_out = FALSE;

    (void)EXsetclient(EX_INGRES_TOOL);

    MEadvise(ME_INGRES_ALLOC);

    /* Call IIUGinit to initialize CM attribute table */
    if( IIUGinit() != OK)
    {
	upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
    }

    /* setup error handling, open log file, and check arguments */
    cv_initialize(argc, argv, &errcb);


    /*
    ** declare an exception handler (note: we always PCexit in the handler
    ** so EXdeclare here does not check for a returned value)
    */

    EXdeclare(handle_ex, &upgr_cb.Context_ex);	    
 
    /* declare error handler for esqlc errors */

    EXEC SQL whenever sqlerror call handle_esqlerr;


    /* Check iidbdb -- convert it before any other databases.  This routine
    ** will leave the iidbdb open with system catalog update priv unless there
    ** was an error converting the iidbdb */

    dbdb_specified = (STcompare(upgr_cb.du_dbname, DU_DBDBNAME) == 0);
    cv_iidbdb(dbdb_specified, username, &userstat);

    if (upgr_cb.Iidbdbok == FALSE)
	upgr_exit(__LINE__, DU_FAIL_EXIT, W_DU1850_IIDBDB_ERR);

    /* Process any databases the user specified (other than iidbdb) */

    /* Convert target databases, unless just iidbdb was specified */
    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU008C_COLLECT_DBS, 0);
    if (!dbdb_specified)
	collect_dbs(upgr_cb.du_dbname, username, userstat);
    else
    {
	if (upgr_cb.imadb_cvt)
	    collect_dbs("imadb", username, userstat);
	if (upgr_cb.icedb_cvt)
	    collect_dbs("icedb", username, userstat);
	if (upgr_cb.icesvr_cvt)
	    collect_dbs("icesvr", username, userstat);
	if (upgr_cb.icetutor_cvt)
	    collect_dbs("icetutor", username, userstat);
    }

    status = convert_dbs();

    if (status == OK)
    {
        upgr_exit(__LINE__, DU_OK_EXIT, I_DU0081_UPGRADEDB_DONE);
    }
    else
    {
        upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
    }

}

/*{
** Name: set_cmptlvl	- Sets internal compat level from dbcmptlvl/dbcmptminor
**
** Description:
**	    Sets an internal compatibility level from values for
**	    dbcmptlvl and dbcmptminor passed in.
**
**	This routine made more sense when the dbcmptlvl values were
**	sort-of-strings.  Now that they've been integerized, we're
**	basically translating from one integer to a different one.
**	It's not worth changing all of upgradedb, though.
**
** Inputs:
**	    cmptlvl		the value for dbcmptlvl
**	    minorlvl		the value for dbcmptminor
**	    
** Outputs:
**	    none
**	    
**	Returns:
**	    level	    the internal compat level, defined as Vxxx_LEVEL
**	    
**	Side Effects:
**	    none
**	    
** History:
**	07-jun-81 (ralph)
**	    Initial creation
**	22-sep-89 (ralph)
**	    Added return of 63.
**	1-feb-1991 (bryanp)
**	    Added DU_5DBV634, returning 64
**      10-may-91 (markm)
**          Trim white space from end of compat level string
**	22-jul-91 (teresa)
**	    Extracted messages to erduf.msg
**	8-jul-94 (robf)
**          Added  support for ES 1.1, major 7.0, minor 2
**      06-mar-1996 (nanpr01)
**          Added  support for Variable Page Size Project updates.
**	    major 8.0, minor 0. Changes are in iirelation catalog,
**	    and std system catalog iitables, iiindexes and iiphysical_tables.
**	12-mar-2004 (somsa01)
**	    Added major 9.0 (Release 3), minor 0.
**	12-Nov-2009 (kschendel) SIR 122882
**	    Rework for integerized dbcmptlvl.
*/
i4
set_cmptlvl(u_i4 cmptlvl, i4 minorlvl)
{
	i4	level;
	i4     len;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> in set_cmptlvl(%d, %d)\n", cmptlvl, minorlvl);
    }

    if (upgr_cb.upgtrace[UPG05_COMPATLVL])
    {
	upgr_cb.this_trace = UPG05_COMPATLVL;
	/* simulate the db having gone away */
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00B5_TRACE_POINT, 2, 
		 sizeof(upgr_cb.this_trace), &upgr_cb.this_trace);
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0083_COMPAT_INFO,  2,
		sizeof(cmptlvl), &cmptlvl);
    }

    if (cmptlvl == DU_0DBV60)
	level = V60_LEVEL;

    else if (cmptlvl == DU_1DBV61A && (minorlvl == DU_3DBMINOR))
	level = V61_LEVEL;

    else if (cmptlvl == DU_2DBV62 && (minorlvl == DU_0DBMINOR))
	level = V62_LEVEL;

    else if (cmptlvl == DU_3DBV63 && (minorlvl == DU_0DBMINOR))
	level = V63_LEVEL;

    else if (cmptlvl == DU_5DBV634 && (minorlvl == DU_0DBMINOR))
	level = V64_LEVEL;

    else if (cmptlvl == DU_4DBV70 && (minorlvl == DU_0DBMINOR))
	level = V65_LEVEL;

    else if (cmptlvl == DU_4DBV70 && (minorlvl == DU_2DBMINOR))
	level = V65ES_LEVEL;

    else if (cmptlvl == DU_4DBV70 && (minorlvl == DU_3DBMINOR))
	level = V12_LEVEL;

    else if (cmptlvl == DU_6DBV80 && (minorlvl == DU_0DBMINOR))
	level = V20_LEVEL;

    else if (cmptlvl == DU_6DBV80 && (minorlvl == DU_1DBMINOR))
	level = V20TCP_LEVEL;

    else if (cmptlvl == DU_6DBV85 && (minorlvl == DU_0DBMINOR))
	level = V25_LEVEL;

    else if (cmptlvl == DU_6DBV86 && (minorlvl == DU_0DBMINOR))
	level = V26_LEVEL;

    else if (cmptlvl == DU_6DBV865 && (minorlvl == DU_0DBMINOR))
	level = V30_LEVEL;

    else if (cmptlvl == DU_6DBV902 && (minorlvl == DU_0DBMINOR))
	level = V302_LEVEL;

    else if (cmptlvl == DU_6DBV904 && (minorlvl == DU_0DBMINOR))
	level = V904_LEVEL;

    else if (cmptlvl == DU_6DBV930 && (minorlvl == DU_0DBMINOR))
	level = V930_LEVEL;

    else if ((cmptlvl == DU_6DBV1000 || cmptlvl == DU_DBV1000)
      && (minorlvl == DU_0DBMINOR))
	level = V1000_LEVEL;

    else

	level = UNKNOWN_LEVEL;

    if (upgr_cb.upgtrace[UPG05_COMPATLVL])
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0084_COMPAT_INFO, 2,
		sizeof(level), &level);
	
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> we are at level %d\n", level);
    }
    return (level);
} 

/*{
** Name: cv_initialize	- UPGRADEDB initialization procedures
**
** Description:
**	    This routine sets up UPGRADEDB's runtime environment by opening a
**	    log file, declaring an SQL error handler, and checking for the
**	    proper command line arguments and setting any upgradedb trace
**	    points (specified via II_UPGRADEDB_TRACE)
**	    
** Inputs:
**	nargs		    number of command line arguments
**	argv		    array of command line arguments
**
** Outputs:
**	    none
**	
**	Returns:
**	    nothing
**
** Side Effects:
**	Handler is declared.
**
** History:
**	06-aug-91 (teresa)
**	    Rewrote from cv_startup. Changed to recognize some command flags,
**	    extracted messages to erduf.msg and made several modifications to
**	    meet coding standards.  Also changed initialization of log file
**	    to use a DUF compatible mechanism and added -nolog logic.
[@history_template@]...
**	24-jan-1994 (gmanning)
**	    Change register to register i4  for NT environment.
**      02-feb-1995 (sarjo01) Bug 65613
**          Removed du_chk1_dbname() call which gave error if dbname
**          was qualified with vnode::
**      08-jul-1999 (chash01)
**          set dbms type to DU_DBRMS if tested as RMS.
**	10-Sep-2004 (schka24)
**	    Init catalog-modify data in case of large-page-catalog database.
*/
static VOID
cv_initialize(nargs, argv, errcb)
i4	    nargs;
char	    *argv[];
DU_ERROR    *errcb;
{
    i4	    handle_equelerr();
    bool	    open_log_file=TRUE;
    char	    datestr[TM_SIZE_STAMP+1];
    char	    *sep = "*************************************************";
    i4	    length;
    register i4     i;
    char	    *p;
    char	    *tmp;

    static i4	    dbname_arg = 0;
    static i4	    cdbname_arg = 0;
    char	    *dbms="";
    char	    *tail_str;
    char            *colon_ptr;
    i4              num_clients = 0;	/* nmbr dict client names on cmd line */
    bool	    client_flag = FALSE; /* true if -f flag given */


    MEadvise(ME_INGRES_ALLOC);	    /* CL will allocate memory */
    upgr_cb.Iidbdbok = TRUE;
    upgr_cb.du_msg = errcb;

    /* Get the process's user name */
    du_get_usrname(upgr_cb.duowner);
    if (du_chk2_usrname(upgr_cb.duowner) != OK)
    {
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU3000_BAD_USRNAME, 2,
		0, upgr_cb.duowner);
	upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
    }

    /* initialize the log file name to the default.  This may be reset
    ** if the undocumented -l flag is specified */
    STcopy(ERx("upgrade.log"),upgr_cb.du_logname);
    STcopy(ERx("upgrade.dbg"),upgr_cb.du_dbgname);
    
    /* scan input parameters to see if -nolog (or -n) is specified.  If so,
    ** then skip opening upgradedb log file.  Also check to see if -l is
    ** specified to rename log file */
    for (i= 1; (nargs - i); i++)
    {
	if (argv[i][0] == '-')	/* see if its a flag --if so, which? */
	{   
	    CVlower(argv[i]);	/* force to lower case */
	    if (argv[i][1]=='n')	/* check for nolog */
		open_log_file=FALSE;
	    if (argv[i][1]=='l')
	    {
	        /* this is an undocumented flag.  Format is -lNAME where
		** NAME is an alternate log file filename, replacing the
		** default of "upgrade.log".  This will be ignored if
		** -n is also specified.
		*/
		STcopy(&argv[i][2], upgr_cb.du_logname);
	    }
	}
    }

    /* We may need the log directory regardless, as a work area */
    du_create_logdir(&upgr_cb.du_log, upgradedb_name, upgr_cb.duowner);

    /* Call again to get dbg file path initialized */
    du_create_logdir(&upgr_cb.du_dbg, upgradedb_name, upgr_cb.duowner);

    if (open_log_file)
    {
	/* -n or -nolog were not specified, so open upgradedb log file
	** as:  ii_config:[<login_name>]upgrade.log
	*/
	du_fopen(&upgr_cb.du_log, upgr_cb.du_logname );
	du_fopen(&upgr_cb.du_dbg, upgr_cb.du_dbgname );

	/* put id and timestamp into log */
	TMcvtsecs ( TMsecs(), datestr);		/* get datestring */
	length = STnlength ( sizeof(datestr), datestr);
	datestr[length] = '\0';	/* null terminate */
	du_log( upgr_cb.du_skiplog, &upgr_cb.du_log, sep);
	du_log( upgr_cb.du_skiplog, &upgr_cb.du_log, DU_UPGRADEDB);
	du_log( upgr_cb.du_skiplog, &upgr_cb.du_log, datestr);
	du_log( upgr_cb.du_skiplog, &upgr_cb.du_log, sep);

	du_log( upgr_cb.du_skiplog, &upgr_cb.du_dbg, sep);
	du_log( upgr_cb.du_skiplog, &upgr_cb.du_dbg, DU_UPGRADEDB);
	du_log( upgr_cb.du_skiplog, &upgr_cb.du_dbg, datestr);
	du_log( upgr_cb.du_skiplog, &upgr_cb.du_dbg, sep);
    }

    /* for now upgradedb does not do much of the fancy stuff that verifydb
    ** does.  So set up defaults.  Note that memory is only allocated for 1
    ** db name.  users may only specify a single database name at this time,
    ** or they may specify the -all flag
    */
    upgr_cb.du_scope = DU_SPECIFY;
    upgr_cb.du_mode  = DU_RUN;

    /* initialize debugging output to be enabled unless logging turned off.
    ** (This means that debugging is ON by default!  which given the
    ** perplexities of upgrading, is maybe no bad thing.)
    */
    upg_dbg_out = open_log_file;

    /* Initialize concurrent upgrade to be disabled by default */
    upg_concurrent = FALSE;

    /* Initialize upgrade trees to be disabled by default */
    upg_trees = FALSE;

    /* now parse command line arguments */
    while (--nargs)
    {
	p   = *(++argv);
	switch (p[0])
	{
	  case '/':
	    CVlower(p);
	    if ( !STcompare( p, DU_SLASHD) ||  !STcompare( p, DU_STARTAIL))
	    {
		/* this is a distributed database */
		upgr_cb.du_dbmstype = DU_DBSTAR;
	    }
	    else if ( !STcompare( p, DU_RMSTAIL) )
	    {
		/* this is a RMS gateway database */
		upgr_cb.du_dbmstype = DU_DBRMS;
		
	    }
	    else
		upgr_cb.du_dbmstype = DU_DBINGRES;

	    break;

	  case '-':
	    switch (p[1])
	    {
	      case 'a':
		if(MEcmp((PTR)p, (PTR)"-all", (u_i2)4)==DU_IDENTICAL)
		    upgr_cb.du_scope = DU_INSTLTN;
	        break;
	      case 'u':
		if (du_chk2_usrname(&p[2]) != OK)
		{
		    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6000_UPGRADEDB_USAGE, 0);
		    upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
		}
		else
		{
		    STcopy(&p[2], upgr_cb.du_user);
		    break;
		}

	      case 'l':
	        /* this is an undocumented flag.  Format is -lNAME where
		** NAME is an alternate log file filename, replacing the
		** default of "upgrade.log".  This flag is handled in the
		** earlier pre-scan loop, so here all we do is break.
		*/
		break;

	      case 'd':
	        /* this is an undocumented flag; it enables (voluminous)
		** debugging output.
		*/
		upg_dbg_out = TRUE;
		break;

              case 'c':
                upg_concurrent = TRUE;
                break;

	      case 'n':
		open_log_file=FALSE;
		upgr_cb.du_skiplog = TRUE;
		upg_dbg_out = FALSE;
		break;

              case 'f':

		client_flag = TRUE;
                tmp = STskipblank(&p[2], (i4) DU_MAX_CLIENT_NAME);
                if ( (tmp != (char *) NULL) && (*tmp != EOS))
		    append_clientlist ( upgr_cb.du_feclients,
					&p[2],
					&upgr_cb.du_fecnt );
	
		/* multiple client names can appear following the -f
		** flag (e.g. -fingres visibuild windows_4gl).
		** Scan for more client names, or another flag,
		** or end of arguments.
		*/

		/* nargs & argv should be incremented together, so don't do
		** it as part of the conditional on nargs (e.g. "if (--nargs)").
		*/
		for (--nargs, p = *(++argv); nargs ; --nargs, p = *(++argv))
		{
		    if (p[0] == '-' || p[0] == '+' || p[0] == '/')
		    {
			/* uh oh, another flag. we're done with client list */
			break;
		    }
		    else
			append_clientlist ( upgr_cb.du_feclients,
					    p,
					    &upgr_cb.du_fecnt );
		}

		/* We're pointing at either last argument in list, which is
		** a client name, or at a flag that follows -f flag. Either way
		** we've gone one too far. Back up one argument to let outer
		** loop handle it.
		*/
		nargs++;
		argv--;

                break;

	      case 't':
		if(MEcmp((PTR)p, (PTR)"-tree", (u_i2)5)==DU_IDENTICAL)
		    upg_trees = TRUE;
	        break;

	      default:
		upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6000_UPGRADEDB_USAGE);

	    }	/* end of switch (p[1]) */
	    break;
	  default:
	    /* Must be a database name parameter -- must determine if it is
	    ** a Local DB (LDB) or Distributed DB (DDB) request or a gateway
	    */
	    if (dbname_arg != 0)
	    {
		    /* specified database name twice */
		    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6014_DBNAME_TWICE, 0);
		    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6000_UPGRADEDB_USAGE);
	    }
	    dbname_arg++;
	    tail_str = STchr(p, '/');
	    if (tail_str)
	    {
		/* Something is prepended to name.  See if it is a valid 
		** distributed request flag --
		*/
		CVlower(tail_str);
		if ( !STcompare(tail_str, DU_SLASHD) || 
		     !STcompare(tail_str, DU_STARTAIL))
		{
		    upgr_cb.du_dbmstype = DU_DBSTAR;
		    *tail_str = EOS; /* take flag off of ddb name */
		}

		/* -- or an RMS Gateway database */
		else if (!STcompare(tail_str, DU_RMSTAIL))
		{
		    upgr_cb.du_dbmstype = DU_DBRMS;
		    *tail_str = EOS; /* take flag off of db name */
		}
		else
		{
		    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU3010_BAD_DBNAME, 2, 0, p);
		    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6000_UPGRADEDB_USAGE);
		}
	    }

            CVlower (p);
            STcopy(p, upgr_cb.du_dbname);
	    if (((colon_ptr = STchr(p, ':')) != NULL) &&
		STchr(colon_ptr + 1, ':') == (colon_ptr + 1))
            {
	      STncpy( vnode, p, colon_ptr - p);
	      vnode[colon_ptr-p] = '\0';
            }
	    else
	      vnode[0] = '\0';

	}   /* end of switch(p[0]) */
    }	/* end of while loop */

    /* Check if -f flag was given with no clients */
    if (client_flag && (upgr_cb.du_fecnt == 0))
    {
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU3514_EMPTY_CLIENT_LIST, 2,
		 (i4 *) NULL, upgradedb_name );
	upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
    }

    /* Check if a database name was given or -all was specified */
    if ( (upgr_cb.du_dbname[0] == EOS) && (upgr_cb.du_nscopes == 0) &&
         (upgr_cb.du_scope != DU_INSTLTN)
       )
    {
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU3014_NO_DBNAME, 0);
	upgr_exit(__LINE__, DU_FAIL_EXIT,E_DU6000_UPGRADEDB_USAGE);
    }

    if (! upgr_cb.du_nscopes )
    {
	if (upgr_cb.du_scope == DU_INSTLTN)
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0082_UPGRADEDB_BEGIN, 2, 
		    0, ERx("-all") );
	else
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0082_UPGRADEDB_BEGIN, 2, 
		    0, upgr_cb.du_dbname);
    }
    else
	;  /* not implemented yet -- only dbname or -all are allowed now */

    /* declare error handler for equelc errors */

    _VOID_ IIseterr(handle_equelerr);

    /* implement UPGRADEDB Tracepoints */
    {
	i4		    ctr1;
	char                *trace = NULL;

	NMgtAt("II_UPGRADEDB_TRACE", &trace);
	if ((trace != NULL) && (*trace != '\0'))
	{
	    char    *comma;
	    char    commavalue = ',';
	    i4 trace_point;

	    /* initialize all trace points to false.  This is redundant since
	    ** the structure is zerofilled, but do it anyhow for clairity */
	    for (ctr1=0; ctr1<MAX_TRACE_PTS; ctr1++)
		upgr_cb.upgtrace[ctr1]=FALSE;

	    /* start loop to set trace points */
	    do
	    {
		if (comma = STchr(trace, commavalue))
		    *comma = '\0';
		if (CVal(trace, &trace_point))
		    break;
		trace = &comma[1];
		if (trace_point < 0 ||
		    trace_point >= MAX_TRACE_PTS)
		{
		    continue;
		}
		upgr_cb.upgtrace[trace_point]=TRUE;

	    } while (comma);
	}
    }

    /* Set up stuff needed for nonstandard pagesize databases.
    ** These get their catalogs modified after upgrading is done,
    ** a la sysmod.
    */
    Dus_allcat_defs[DU_CORE_CATS]       = &Dub_01corecat_defs[0];
    Dus_allcat_defs[DU_DBMS_CATS]       = &Dub_11dbmscat_defs[0];
    Dus_allcat_defs[DU_IIDBDB_CATS]     = &Dub_31iidbdbcat_defs[0];
    Dus_allcat_defs[DU_DDB_CATS]        = &Dub_41ddbcat_defs[0];
    Dus_allcat_defs[DU_SCI_CATS]        = &Dui_51scicat_defs[0];

    dub_corecats_def();
    if( dub_dbmscats_def() != E_DU_OK )
	upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
    dub_ddbcats_def();
    dub_iidbdbcats_def();     
}

/*{
** Name:  append_clientlist()  - validates a client and adds it to the 
**				 client list.
**
** Description:
**	Check if the client list is ok. Currently, just checks if
**	"nofeclients" appears with some other client.  If the client is
**	compatible with the other clients, then it adds the new client to
**	the list.  Otherwise it prints an error and branches to the exit
**	handler.
**
** Inputs:
**	clients 	list of clients saved so far.
**	new		current client to be added to list.
**	num_clients	running counter of clients added to list.
**
** Outputs:
**	clients		"new" is appended to the list.
**	num_clients	incremented if client is added to list.
**
** Returns:
**	None.
**
** Exceptions:
**	None.
**
** Side Effects:
**	May branch to exit handler if "NOFECLIENTS" is used in conjunction with
**	any other client name.
**
** History:
**	07-aug-91 (teresa)
**	    Initial creation
*/
static VOID
append_clientlist(clients, new, num_clients)
char	*clients;
char	*new;
i4	*num_clients;
{
	if ( (STcasecmp(clients, ERx("nofeclients") ) == 0)
	     ||
	     (*clients != EOS
	      && (STcasecmp(new, ERx("nofeclients") ) == 0)
	     ) )
	{
	    /* There is already a client named "nofeclients", so
	    ** it's not legal to see any other client names used in conjunction
	    ** with this.  Print error and abort.
	    */
	    du_talk(__LINE__,  DU_ALWAYS, &upgr_cb, E_DU6015_BAD_CLIENT_NM, 2,
			0, ERx("nofeclients"));
	    upgr_exit(__LINE__,  DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
	}
	else
	{
	    /* Clint name is valid, so  append name to  the list we already
	    ** already have (which may be empty). NOTE: multiple -f flags
	    ** are allowed, but not documented (LRC wanted it that way!).
	    */
	    if (*num_clients == 0)
		/* 1st one on list */
		STcopy (new, clients);
	    else
		/* append to list */
		STpolycat (3, clients, ERx(" "), new, clients);

	    (*num_clients)++ ;

	}
}

/*{
** Name: cv_iidbdb	 - Convert the iidbdb
**
** Description:
**	    This routine assumes that we are connected to the iidbdb as
**	    $ingres with system catalog update privilege.  It extracts
**	    the cmptlvl of the iidbdb and then calls the appropriate
**	    conversion functions to convert the iidbdb to current format.
**
** Inputs:
**	dbdb_specified		Convert the iidbdb if already at current level
**	
** Outputs:
**	usernamep		Buffer to contain current user name
**	userstatp		Pointer to i4 for user status from iiuser
**	
** History:
**	05-nov-88 (jrb)
**	    Inital creation.
**	28-nov-88 (jrb)
**	    Added "abort" parameter so we could abort conversion if db is
**	    of improper compat level.
**	14-jun-89 (ralph)
**	    Adapted jrb's process_iidbdb() routine to 7.0 requirements
**	16-sep-89 (ralph)
**	    Check server version to ensure it is 7.0.
**	19-oct-89 (ralph)
**	    Delete config files in the dump directory.
**	19-apr-90 (ralph)
**	    Allow iidbdb to be converted even if already 6.3 when specified.
**	06-jul-90 (ralph)
**	    Return user name and status
**      10-may-91 (markm)
**          Fix for Beta - disallow any journaled 6.3 databases to be upgraded
**          and if database is at 6.3 level do not delete the config file
**          in the dmp directory.
**       3-jun-91 (markm)
**          Changed the way that upgradedb gets the username. Because
**          it runs setuid ingres dbmsinfo('username') on UNIX always
**          returns 'ingres' - changed so calls du_get_usrname() which
**          calls IDname() and gets the "actual" username not "effective"
**          Also added check for super-user status on upgrading the iidbdb.
**	22-jul-91 (teresa)
**	    Extracted messages to erduf.msg and made several modifications to
**	    meet coding standards. 
**	22-jul-91 (teresa)
**	    Extracted messages to erduf.msg and made several modifications to
**	    meet coding standards.
**	10-Jan-93 (jpk)
**	    add +U to first connect to iidbdb.  Needed to convert
**	    for increase iirelation tuple width, DB_MAXNAME, and
**	    file extend as soon as connect to server complete.
**	    For same reason added call to order_critical_65() as
**	    soon as server returns control to upgradedb.
**	19-Oct-1993 (jpk)
**	    go back to area name II_DATABASE instead of "default";
**	    Rachael's fix to internal database procedure makes
**	    this the correct parameter to pass it.
**	15-Feb-1994 (jpk)
**	    move order critical routine to after control block
**	    structure has been allocated.
**      13-jul-94 (robf)
**          Rework pre-65 conversions to be a bit more selective 
**      02-mar-95 (lawst01)  bug 67253
**          Remove 'extra' if test before the test to mark the access_flag
**          for iidbdb operable.
**      20-mar-1995 (canor01) Bug 67535
**          Connect as $ingres so back end knows this is an
**          administrative procedure
**      06-mar-1996 (nanpr01)
**          Added upgrade code for 2.0 upgrade - Variable Page Size Project. 
**      13-mar-98 (nicph02)
**          Added call to rm_iiqef_procedures to drop iiqef_ procedures.
**	27-Aug-2004 (schka24)
**	    r3 upgrade calls.  Remove journal check, server disables journaling
**	    at core catalog conversion.  Remove concurrent-upgrade option for
**	    iidbdb during its conversion.
**	4-Jan-2005 (schka24)
**	    Mods to make iidbdb connect work for ordinary users; we're
**	    removing the set-user-id privilege from upgradedb.
**	14-Feb-2005 (bonro01)
**	    Move code that sets upgrade flags for imadb, icedb, icesvr, and
**	    icetutor, after exit_cv_iidbdb1: label so that these databases
**	    are also upgraded during a 64-bit add-on upgrade along with
**	    the iidbdb.
**      07-apr-2005 (stial01)
**          cv_dbcap() Added new iidbcapabilities rows.
**      08-apr-2005 (stial01)
**          cv_dbcap() Another new iidbcapabilities row.
**	23-Jan-2006 (kschendel)
**	    Announce the server version if mismatch.  (This usually
**	    indicates a foul-up on our part.)
**	31-Jan-2006 (kschendel)
**	    Always redo iidbdb stdcat views for 9.04 upgrades.
**	22-May-2006 (kschendel)
**	    Grant the stdcat views here after we recreate all of 'em.
**	2-Dec-2009 (kschendel) SIR 122882
**	    Fix conversion failure reading iidatabase row.  Older iidatabase
**	    rows have char dbcmptlvl's, not ints, and we have to read
**	    the old style.  We also need to fix up the dbcmptlvl type.
**	    Also, fix potential uppercase-installation problem with
**	    reading the iidatabase row.
**	4-May-2010 (kschendel) SIR 123639
**	    DMF core catalog conversion fixes the cmptlvl's now, so
**	    the above Dec-2009 change can be partly reverted.
*/

/* Catalogs to be updated in iidbdb after the "early" catalogs, but before
** the standard database conversion.  It's not clear that these have to
** be done in that specific order, but this is how upgradedb's always done it.
*/
static char *initial_iidbdb_list[] =
{
    "iidatabase",
    "iidbpriv",
    NULL
};

/* iidbdb-specific catalogs updated after standard database conversion. */
static char *main_iidbdb_list[] =
{
    "iistar_cdbs",
    "iiddb_netcost",
    "iiddb_nodecosts",
    "iigw07_relation",
    "iigw07_attribute",
    "iigw07_index",
    "iiextend",
    "iilocations",
    "iiprofile",
    "iirole",
    "iirolegrant",
    "iiuser",
    "iiusergroup",
    NULL
};


static VOID
cv_iidbdb(dbdb_specified,usernamep,userstatp)
bool	dbdb_specified;
char	*usernamep;
i4	*userstatp;
{
    EXEC SQL begin declare section;
	i4	minorlvl;
	i4	access_flags;
	i4	userstat;
	i4	proc_instruction;
	i4	service_flags;
	i4	cmptlevel;	/* dbcmptlvl now i4 */
	char	*username;
	char	locname[DU_LOC_SIZE + 1];
	char	areaname[DB_AREA_MAX + 1];
	char	dbdb_name[DB_MAXNAME+1];
	char	dbdb_dba[DB_MAXNAME+1];
	char    iidbdbname[DB_MAXNAME+1];
	char    iidatabase_name[DB_MAXNAME+1];
	char    dbcmptlvl_name[DB_MAXNAME+1];
	i4	cmpt_type;
	i4	imadb_cnt;
	i4	icedb_cnt;
	i4	icesvr_cnt;
	i4	icetutor_cnt;
	char	dbmsinfo_string[10];
	char	reltid_string[20];
	varchar struct
	{
		short	buff_size;
		char	buff[64+1];	/* DBMSINFO result size */
	}	infobuff;
    EXEC SQL end declare section;

    char	cdbname_temp[DB_MAXNAME+1];
    char	ddbname_temp[DB_MAXNAME+1];
    bool	really_upgrade;		/* Really upgrading iidbdb */
    bool	not_prived;		/* iidbdb opened unprivileged */
    bool	star_flag=FALSE;
    i4		level;
    DU_ERROR	duv_errcb;
    DU_ENV	dbenv;
    bool 	upcase = FALSE;
    DU_STATUS	du_status;

    /* Init SQL variable pointer */
    if (upgr_cb.du_user[0]=='\0')
	username = upgr_cb.duowner;
    else
	username = upgr_cb.du_user;
    userstat = 0;			/* Init SQL variable */
    STcopy(username, usernamep);	/* return username to caller --
					** this is just a convenient pointer
					** into the upgr_cb indicating which of
					** the two possible variable names to
					** use. */

    setauth(NULL);		/* Forget any current auth setting */
    really_upgrade = FALSE;

    /* connect to the iidbdb as $ingres.  If we're J Random User, this will
    ** fail, which means that we shouldn't be trying to upgrade the iidbdb.
    ** (The first upgradedb run always has to be against iidbdb run by the
    ** installation owner, which will succeed here.)
    */

    exec sql whenever sqlerror continue;
    upgr_cb.Ignore_errors = TRUE;
    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0085_IIDBDB_CONNECT, 0);
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> [1] connect to iidbdb session %d id %s options = %s\n",
		DBDB_SESSIONID, DU_DBA_DBDB, upg_concurrent ? "+w" : "-A6 +w");
    }

    if (vnode[0] != '\0')
       STprintf(iidbdbname, "%s::iidbdb", vnode);
    else
       STcopy("iidbdb", iidbdbname);

    if (upg_concurrent)
    {
	EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
         identified by :DU_DBA_DBDB options = '+w' ;
	not_prived = TRUE;
    }
    else
    {
	EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
	 identified by :DU_DBA_DBDB options = '-A6', '-l', '+U', '+w';
	not_prived = FALSE;
    }

    /* *Note* The above -A6 connect will cause the server to upgrade
    ** the database config file (if needed) and the core catalogs.
    ** iirelation and iiattribute are fixed to reflect the core catalog
    ** changes.  No other tables or table descriptors are changed.
    ** Journaling is forcibly turned off (a la alterdb -disable_journaling)
    ** if core catalog changes occurred.
    */

    if (sqlca.sqlcode < 0)
    {
	/* If this failed because of "no privilege", the iidbdb is OK but
	** we're not a privileged user.  Open iidbdb again without the
	** fancy options (so that we can collect db names).  After
	** double checking that iidbdb is up to date, we'll return
	** below, for other db conversions.
	**
	** *Note* we're still going to want to update iidatabase.  It
	** turns out that all that's needed is IIlq_Protect.  If or when
	** that hole gets fixed, this connect will probably need to
	** invoke a system standard role of some sort, or perhaps a
	** new built-in DBproc.
	*/
	if (sqlca.sqlcode != -GE_NO_PRIVILEGE || dbdb_specified)
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6002_BAD_IIDBDB_CONNECT);
	EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
	     options = '+w' ;
	if (sqlca.sqlcode < 0)
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6002_BAD_IIDBDB_CONNECT);
	upgr_cb.dbdb_cvt = FALSE;
	not_prived = TRUE;
    }

    exec sql whenever sqlerror call handle_esqlerr;
    upgr_cb.Ignore_errors = FALSE;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> connected to iidbdb%s\n",
		not_prived ? " (unprivileged)" : "");
    }

    /* Note that just because we were able to connect -u$ingres to the
    ** iidbdb doesn't make us the installation owner.  As noted above,
    ** though, the first time we get here we ARE the installation owner,
    ** unless the user is doing something very wrong (like bypassing the
    ** setup scripts).
    */

    /* Make sure there's a work directory in case the iidatabase/iilocations
    ** query decides to use it!
    */

    if (vnode[0] == '\0' && ! not_prived)
        chk_create_workdir("iidbdb");

    upgr_cb.dbdb_open = TRUE;
    IIlq_Protect(TRUE);		/* allow system catalog update priv */

    /* Make sure we are connected to a server at the proper level.
    ** e.g. 6.5 upgradedb will only let itself be run against a 6.5 server.
    */
    EXEC SQL SELECT dbmsinfo('_version') INTO :infobuff;

    if (upgr_cb.Iidbdbok == FALSE)
	return;
    if (sqlca.sqlerrd[2] == 0 || infobuff.buff_size == 0 )
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6003_UNKNOWN_VERSION);

    /* Beware that the _version string is longer than SERVER_VERSION,
    ** only compare the beginning.
    */
    infobuff.buff[infobuff.buff_size] = '\0';
    if (MEcmp(infobuff.buff, SERVER_VERSION, STlength(SERVER_VERSION)) != 0)
    {
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6004_WRONG_VERSION, 4,
		0, SERVER_VERSION,
		0, infobuff.buff);
	upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
    }

    STcopy(DU_DBDBNAME, dbenv.du_dbname);

    /* Find out if dbms is lp64 */
    EXEC SQL select dbmsinfo('lp64') into :dbmsinfo_string;
    if (dbmsinfo_string[0] == 'Y')
	upgr_cb.dbmsinfo_lp64 = 'Y';
    else
	upgr_cb.dbmsinfo_lp64 = 'N';
    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "dbmsinfo('lp64') returns '%c'\n", upgr_cb.dbmsinfo_lp64);

    /* Find out if database uses uppercase names */
    EXEC SQL select dbmsinfo('db_name_case') into :dbmsinfo_string;
    STcopy(ERx("iidbdb"),dbdb_name);
    STcopy(ERx("$ingres"), dbdb_dba);
    STcopy("iidatabase", iidatabase_name);
    STcopy("dbcmptlvl", dbcmptlvl_name);
    if (STcompare(dbmsinfo_string, "LOWER") != 0)
    {
	CVupper(username);
	CVupper(dbdb_dba);
	CVupper(dbdb_name);
	CVupper(iidatabase_name);
	CVupper(dbcmptlvl_name);
	upcase = TRUE;
    }

    /* Before selecting from iidbdb, see if dbcmptlvl has been updated.
    ** Core catalog conversion of pre-DSC_V9 catalogs will flip
    ** dbcmptlvl from a char(4) into an i4 (without changing the contents).
    ** If this is a non-privileged connect, and if iidbdb was never
    ** properly upgraded, the select from iidatabase (below) will fail.
    ** So, check the dbcmptlvl type if we're not prived, and issue
    ** a "you must upgrade iidbdb first" message if it's still char.
    */

    if (not_prived)
    {
	EXEC SQL SELECT a.attfrmt
	    INTO :cmpt_type
	    FROM iiattribute a, iirelation r
	    WHERE a.attrelid = r.reltid and a.attrelidx = r.reltidx
		and r.relid = :iidatabase_name
		and r.relowner = :dbdb_dba
		and a.attname = :dbcmptlvl_name;
	if (sqlca.sqlerrd[SQL_NUM_ROWS] == 0)
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6005_NONEXISTENT_IIDBDB);
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> non-upgrade iidbdb connect, dbcmptlvl type is %d\n",
		    cmpt_type);
	}

	if (cmpt_type != DB_INT_TYPE)
	{
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6009_IIDBDB_UPGR_DISALLOW);
	}
    }

    /* Get information about the iidbdb database.
    **
    ** Core catalog conversion of pre-DSC_V9 core catalogs will flip
    ** dbcmptlevel into an i4; it used to be char(4).
    */
    EXEC SQL SELECT
	iidatabase.dbcmptlvl, 
	iidatabase.dbcmptminor,
	iidatabase.access, 
	iidatabase.dbdev,
	iidatabase.dbservice,
	iilocations.area
    INTO
	:cmptlevel,
	:minorlvl,
	:access_flags,
	:locname,
	:service_flags,
	:areaname
    FROM
	iidatabase,
	iilocations
    WHERE
	iidatabase.name = :dbdb_name and
	iidatabase.dbdev = iilocations.lname;
    
    if (upgr_cb.Iidbdbok == FALSE)
	return;
    if (sqlca.sqlerrd[SQL_NUM_ROWS] == 0)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6005_NONEXISTENT_IIDBDB);

    /* if db is already inoperative we halt with an error */

    if (((access_flags & DU_OPERATIVE) == 0) &&
	((access_flags & DU_UPGRADING) == 0)
       )
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6006_INOPERATIVE_IIDBDB);


    /* Get information about the user -
    ** This used to be done by checking with dbmsinfo(), but because
    ** upgradedb ran as setuid ingres on UNIX this was always returning
    ** ingres as the user.  (We no longer do the suid stuff but this
    ** code works ok as is.)
    */
    EXEC SQL SELECT iiuser.status INTO :userstat FROM iiuser
    WHERE iiuser.name = :username;

    if (upgr_cb.Iidbdbok == FALSE)
	return;
    if (sqlca.sqlerrd[SQL_NUM_ROWS] == 0)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6007_NONEXISTENT_USER);

    /* Get the level to see if we need to convert */
    level = set_cmptlvl(cmptlevel, minorlvl);

    if (not_prived)
    {
	/* If we did a non-privileged connect, and iidbdb isn't up to snuff,
	** give up.  iidbdb has to be upgraded before any other databases.
	** If iidbdb IS at the proper level, return now to move on to
	** user databases.
	*/
	if (level != CURRENT_LEVEL)
	{
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6009_IIDBDB_UPGR_DISALLOW);
	}
	return;
    }

    *userstatp = (userstat & DU_USECURITY);
    if (userstat & DU_USECURITY)
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0086_SUPERUSER, 2, 0, username);
    else
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0087_NOTSUPERUSER, 2, 0, username);

    /* build an entry that subordinate routines will require */
    add_dbname(dbdb_name, dbdb_dba, level, access_flags,
		locname, areaname, cdbname_temp, ddbname_temp, star_flag, 
		upcase, service_flags);

    upgr_cb.Dbname_ptr = upgr_cb.Dbname_head;

    /* Check the level to see if we need to convert */
    if (level == 0)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6008_IIDBDB_WRONG_LEVEL);
    else if ( level == CURRENT_LEVEL )
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> do NOT need to convert the iidbdb\n");
	}
	upgr_cb.dbdb_cvt=1;
	goto  exit_cv_iidbdb1;      /*  lawst01  01-27-95  */
    }

    EXEC SQL commit;

    really_upgrade = TRUE;

    /* Do the initial updates needed to get things working.
    ** This includes core catalog rehash, key catalogs like iiprotect,
    ** and a few version specific updates such as adding fhdr/fmap
    ** pages to 6.4 ingres catalogs.  It also upgrades the DB procedure
    ** catalogs so that dbp's can be used.
    */
    do_early_updates(upgr_cb.Dbname_ptr);

    /* Set the access flags to indicate inoperative/converting */

    access_flags &= ~DU_OPERATIVE;
    access_flags |= DU_UPGRADING;

    dbenv.du_access = access_flags;

    if (upgr_cb.upgtrace[UPG04_SKIP_BECVT])
    {
	/* we hit a trace point to skip upgrading the back end catalogs */
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1856_TRACE_4, 0);
    }
    else
    {
	/* Update the access field in the config file as inoperative */
	proc_instruction = QEA_UPD_ACCESS;
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [1] executing ii_update_config(%s, %s, %d, %d)\n",
		dbdb_name, areaname, proc_instruction, access_flags);
	}
	exec sql execute procedure ii_update_config(
		database_name = :dbdb_name,
		location_area = :areaname,
		update_map = :proc_instruction,
		access = :access_flags);
	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU600B_ACCESS_UPDATE_ERR, 2,
		     0, dbenv.du_dbname);
	    upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
	}

	/* Mark the database inoperative */

	EXEC SQL UPDATE iidatabase SET access = :access_flags
	WHERE name = :dbdb_name;

	if (upgr_cb.Iidbdbok == FALSE)
	    return;

	/* Commit inoperability */

	EXEC SQL commit;

	if (upgr_cb.Iidbdbok == FALSE)
	    return;

	/* Convert the iidbdb */
	upgr_cb.dbdb_cvt = TRUE;
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0088_UPGRADE_ID, 4,
		0, dbenv.du_dbname, 0, SERVER_VERSION);

	/*
	** Do some special funky stuff only needed when converting
	** from pre-6.4 (do we even support that??)
	*/
	if (level < V64_LEVEL )
	{
	    cv_online();		
	    if (upgr_cb.Iidbdbok == FALSE)
	         return;
	}
	/* Convert iidbdb specific catalogs that need (?) conversion
	** before the generic database converter.  (Actually I don't
	** think these have to be converted early, but that's the way
	** we've always dunnit.)
	*/
	if (upgrade_catalog_list("iidbdb", initial_iidbdb_list) != E_DU_OK)
	{
	    upgr_cb.Iidbdbok = FALSE;
	    return;
	}
	if (level < V65ES_LEVEL)
	{
	    /* Do some additional version specific conversion if the
	    ** original DB was 6.4
	    */
	    cv_dbaccess();		/* 65 needed, but not for 65ES */
	    if (upgr_cb.Iidbdbok == FALSE)
	        return;
	    /*
	    ** This is a hang-over from the 64->65 conversion, 
	    ** since 65 database may have other sort devices we
	    ** don't do this automatically 
	    */
	    exec sql update iidatabase set sortdev = 'ii_work';
	    exec sql commit;
	}
	if (level < V26_LEVEL)
	{
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "\n]==> Drop iiqef_create_db for recreate \n");
	    }
	    /* need to drop internal procedures that have changed.
	    ** It will get recreated along with other changed internal
	    ** dbprocs, inside cv_database.
	    */
	    upgr_cb.Ignore_errors = TRUE;
	    exec sql drop procedure iiqef_create_db;
	    upgr_cb.Ignore_errors = FALSE;
	}

          /* This does the main conversion for every database */
        cv_database("iidbdb");
        if (upgr_cb.Iidbdbok == FALSE)
            return;

	/* Now do the iidbdb specific catalogs: locations and extents,
	** users, roles, etc.
	*/
	if (upgrade_catalog_list("iidbdb", main_iidbdb_list) != E_DU_OK)
	{
	    upgr_cb.Iidbdbok = FALSE;
	    return;
	}

	/* Always refresh IMA tables for XA use.  They probably
	** haven't changed, but just redoing them is easier than
	** checking for existence or changes.
	*/
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> redoing lgmo registrations\n");
	}
	duc_iilgmo(&duv_errcb);
	if (upgr_cb.Iidbdbok == FALSE)
	    return;

	if (level < V65ES_LEVEL)
	{
	    /* Special stuff for iisecuritystate */
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E7_CONVERTING_TBL, 2,
		0, "iisecuritystate");
	    cv_65es_iisecuritystate("iidbdb");
	    if (! upgr_cb.Iidbdbok)
		return;
	}
	/* Always re-register iiaudit */
	cv_iiaudit("iidbdb");
	if (! upgr_cb.Iidbdbok)
	    return;

	if (level < V30_LEVEL)
	{
	    /* Drop no-longer-existing B1 catalogs */
	    ensure_not_exists("iilevelaudit");
	    ensure_not_exists("iilabelaudit");
	    ensure_not_exists("iilabelmap");
	}

	/* Do any new-column or table population specific to iidbdb. */
	populate_iidbdb_catalogs(level);
	if (! upgr_cb.Iidbdbok)
	    return;

        /* Any stdcat views dropped should be re-created, unless it's
	** going to be done by fix-qry-trees.
	** NOTE: cv_database likely did all the standard ones already
	** if we aren't fixing qry trees, we still need to do the iidbdb
	** ones and regrant them all.
	*/

	if (! (upgr_cb.Dbname_ptr->tree_convert || upg_trees) )
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0103_RECREATING_STDCAT_VIEWS, 0);
	    duc_upgrade_stdcat_views("iidbdb", upgr_cb.Dbname_ptr->upcase,
                    upgr_cb.Dbname_ptr->star_flag);
	    /* Regrant select to public on all system catalog views. */
	    duc_grant_stdcat_views("iidbdb", upgr_cb.Dbname_ptr->star_flag);
	}

	/* conversion done; now upgrade cmptlvl and mark operative */

	access_flags |= DU_OPERATIVE;
	access_flags &= ~DU_UPGRADING;
	dbenv.du_access = access_flags;
	cmptlevel = DU_CUR_DBCMPTLVL;
	minorlvl = DU_1CUR_DBCMPTMINOR;
	EXEC SQL UPDATE iidatabase
	SET
	    access	= :access_flags,
	    dbcmptlvl = :cmptlevel,
	    dbcmptminor = :minorlvl
	WHERE
	    name = :dbdb_name;

	if (upgr_cb.Iidbdbok == FALSE)
	    return;

	/* Now update the access and compat fields of the config file. */
	proc_instruction = QEA_UPD_ACCESS | QEA_UPD_CMPTLVL | QEA_UPD_CMPTMINOR;
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file,
	    "]==> [2] executing ii_update_config(%s, %s, %d, %d, %d, %d)\n",
	    dbdb_name, areaname, proc_instruction, access_flags,
	    cmptlevel, minorlvl);
	}
	exec sql execute procedure ii_update_config(
		database_name = :dbdb_name,
		location_area = :areaname,
		update_map = :proc_instruction,
		access = :access_flags,
		cmptlvl = :cmptlevel,
		cmptminor = :minorlvl);
	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU600B_ACCESS_UPDATE_ERR, 2,
		    0, dbenv.du_dbname);
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU600C_CMPT_UPDATE_ERR, 2,
		    0, dbenv.du_dbname);
	    upgr_exit(__LINE__,  DU_FAIL_EXIT, 0);
	}

	/*
	** We must commit now, disconnect and reconnect
	** or we will not be able to access "dmpdev" in iidatabase.
	*/
	EXEC SQL commit;
	EXEC SQL disconnect;
	upgr_cb.dbdb_open = FALSE;
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (a) disconnect and sleep\n");
	}

	SIprintf("Sleeping for %d seconds before reconnecting to iidbdb...\n",
		DISCONNECT_WAIT_TIME / 1000);
	SIflush(stdout);
	PCsleep( DISCONNECT_WAIT_TIME ); 
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file,
		"]==> [3] connect to iidbdb session %d id %s -A6 -l +w\n",
		DBDB_SESSIONID, DU_DBA_DBDB);
	}
	EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
	     identified by :DU_DBA_DBDB
	     options = '-A6', '-l', '+w';
	if (sqlca.sqlcode < 0)
	    upgr_exit(__LINE__,  DU_FAIL_EXIT, E_DU600D_BAD_IIDBDB_RECONNECT);

	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> connected\n");
	}

	upgr_cb.dbdb_open = TRUE;
	IIlq_Protect(TRUE);			/* system catalog update priv */

    } /* endif db_convert is true */

    /* Jump here if iidbdb was already current version.  We might still have
    ** to upgrade trees if switching 64-bit-ness, or if -tree.  Note: do
    ** not attempt to upgrade FE cats unless we upgraded iidbdb itself, or
    ** if user explicitly said "upgradedb iidbdb".  Reason is that there's
    ** no simple FE catalog version to look at to skip the work, and
    ** we don't want to do redundant stuff to iidbdb every time thru.
    */

exit_cv_iidbdb1:

    /* See if we need to convert imadb, icedb, icesvr, icetutor */
    EXEC SQL select count(*) into :imadb_cnt from iidatabase 
	where lowercase(name)='imadb';
    if (imadb_cnt == 1)
	upgr_cb.imadb_cvt = TRUE;

    EXEC SQL select count(*) into :icedb_cnt from iidatabase 
	where lowercase(name)='icedb';
    if (icedb_cnt == 1)
	upgr_cb.icedb_cvt = TRUE;

    EXEC SQL select count(*) into :icesvr_cnt from iidatabase 
	where lowercase(name)='icesvr';
    if (icesvr_cnt == 1)
	upgr_cb.icesvr_cvt = TRUE;

    EXEC SQL select count(*) into :icetutor_cnt from iidatabase 
	where lowercase(name)='icetutor';
    if (icetutor_cnt == 1)
	upgr_cb.icetutor_cvt = TRUE;

    EXEC SQL whenever sqlerror continue;

    EXEC SQL commit;
    EXEC SQL disconnect;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> [3a] connect to iidbdb session %d id %s options = %s\n",
		DBDB_SESSIONID, DU_DBA_DBDB, 
		upg_concurrent ? "+w" : "-A6, +w -l");
    }
    
    if (upg_concurrent)
	EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
		identified by :DU_DBA_DBDB options = '+w';
    else
	EXEC SQL connect :iidbdbname session :DBDB_SESSIONID 
		 identified by :DU_DBA_DBDB options = '-A6', '+w', '-l';

    /* Fix trees (and standard catalog views) */
    if (upgr_cb.Dbname_ptr->tree_convert || upg_trees)
	fix_qry_trees("iidbdb", iidbdbname, FALSE, level);

    IIlq_Protect (TRUE);         /* system catalog update privilege */

    if (dbdb_specified || really_upgrade)
    {
	if (upgr_cb.upgtrace[UPG03_SKIP_FECVT])
	{
	    /* we hit a trace point to skip front end catalog conversion */
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1855_TRACE_3, 0);
	}
	else
	    fe_dictinst(dbenv.du_dbname,DU_DBA_DBDB, level);
    }

    /* Issue message to let user know if the database was [not] converted */
    if (really_upgrade && upgr_cb.Iidbdbok)
	du_talk(__LINE__,  DU_MODESENS, &upgr_cb, I_DU0089_DB_UPGRADED, 4,
	     0, dbenv.du_dbname, 0, SERVER_VERSION);

    /* indicate that we are done converting the iidbdb */
    upgr_cb.dbdb_cvt = FALSE;

    /* commit any fe work.  disconnect and reconnect without a lock so that
    ** other users may access the installation (to create new dbs, etc)...
    */
    if (really_upgrade)
    {
	rm_iitmp_tables();          /* remove all iitmp_ tables */
	rm_iiqef_procedures();      /* Bug 89164: remove all iiQEF procedures */
    }
    EXEC SQL commit;
    if (upgr_cb.Dbname_ptr->tree_convert)
	fix_dbservice(iidbdbname);
    EXEC SQL disconnect;
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> (c) disconnect\n");
    }
    upgr_cb.dbdb_open = FALSE;
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> [4] connect to iidbdb session %d id %s options +w\n",
	    DBDB_SESSIONID,DU_DBA_DBDB);
    }
    
    /* iidbdb is done, shouldn't need upgradedb flag any more */
    EXEC SQL connect :iidbdbname session :DBDB_SESSIONID 
		 identified by :DU_DBA_DBDB options = '+w';

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> connected\n");
    }
    if (sqlca.sqlcode < 0)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU600D_BAD_IIDBDB_RECONNECT);

    upgr_cb.dbdb_open = TRUE;
    /* Remove old execute protect if old database */
    if (level < V26_LEVEL)
	chmod_data_600();

    IIlq_Protect(TRUE);			/* system catalog update priv */
}

/*{
** Name: collect_dbs	- Collect all dbs which are in need of conversion
**			  and convert them
**
** Description:
**	This routine queries iidatabase for all dbs in need of conversion
**	and marks them inoperative (which will fail if any db is already
**	inoperative).  After each db is processed, it is added--along with
**	its cmptlvl--to a linked list of dbs.
**
**	This routine assumes that we are conenected to the iidbdb on the
**	DB_SESSION_ID with system catalog update priv.  It will stay connected
**	to the iidbdb even when individual dbs are being upgradedb.  It
**	does not disconnect unless it encounters a fatal error.
**
**	It does commits as it marks each database operative or inoperative
**	because it will operate on several DBs and if 1 fails, we do not want
**	to lose the status of the others.
**
**	This will build a list of all DBs in the installation that meet the
**	qualification and cache it in memory. The alternative is to open a
**	cursor on iidatabase and walk it.  However, the cursor is not
**	desirable because it will keep a lock on the iidatabase table for a
**	long period of time, which will keep other users from using any other
**	databases in the installation.  This routine will periodically take
**	and release table-level share-mode locking on the iidatabase catalog
**	to assure the consistency of the catalog while it is querying it.
**
**	It is possible that a database could be destroyed (destroydb) after it 
**	has been selected for upgrade and cached on the upgradedb cache, but
**	before upgradedb actually performed on the database.  If this HIGHLY
**	UNLIKELY, but there is a window and sometimes  users do strange things.
**	Therefore logic is built into upgradedb to handle this.  That logic
**	is:  if the connect to the target db fails, then scan iidatabase to
**	see if the db entry is still listed in iidatabase.  If the listing has
**	gone away print a warning that the database was destroyed after 
**	selection for upgrade.  If the listing is still there, then attempt a
**	reconnect and handle as an error if the reconnect fails.
**	
** Inputs:
**	dbname		The name of the database to "collect"
**			if "-all", all non-iidbdb databases are "collected"
**	username	The name of the current user.
**	superuser	zero if non-superuser; non-zero if superuser;
**
** Outputs:
**	none
**	
** Returns:
**	none
**
** Side Effects:
**	none
**
** History:
**	05-nov-88 (jrb)
**	    Extracted from main.
**	28-nov-88 (jrb)
**	    Added message to tell user there were no databases of the proper
**	    level to be converted.
**	07-jun-89 (ralph)
**	    Adapted from jrb's cv60to61 utility.
**	19-oct-89 (ralph)
**	    Collect info to delete config files in the dump directory.
**	14-dec-89 (ralph)
**	    Allow conversion of 6.3 database if one was specified on the
**	    command line.  If -all specified, continue to bypass conversion.
**	07-jun-90 (ralph)
**	    Add logic to qualify fe/be conversion separately.
**	06-jul-90 (ralph)
**	    Ensure user has permission to perform conversion, as follows:
**		If "-all" was specified, user must be a super user.
**		If dbname was specified, user must be a super user or the DBA.
**	03-may-91 (teresa)
**	    Add support for STAR databases here.
**      10-may-91 (markm)
**          Fix for Beta - disallow any journaled 6.3 databases to be upgraded
**          and if database is at 6.3 level do not delete the config file
**          in the dmp directory.
**	24-jul-91 (teresa)
**	    Extracted messages to erduf.msg and made several modifications to
**	    meet coding standards.  Also changed logic to be a master executive
**	    that causes the other DBs to be upgraded and marked operative again.
**	02-dec-91 (teresa)
**	    fix bug 40507.
**	16-apr-92 (teresa)
**	    change "for" control loop to "do" to appease sun4 compiler warnings.
**	19-Oct-1993 (jpk)
**	    go back to area name II_DATABASE instead of "default";
**	    Rachael's fix to internal database procedure makes
**	    this the correct parameter to pass it.
**	14-jul-94 (robf)
**          Only run order_critical_65() if not already on 65, and add
**          order_critical_65es() if already at 65.
**      28-jan-95 (lawst001)  Bug 66464
**          If a single database was specified for conversion and this 
**          database was already at the current level (1.1) upgradedb would
**          upgrade it anyway.  However, if the -all flag was specified
**          only databases below the 1.1 level would be upgraded.
**	5-dec-95 (stephenb)
**	    open_target() may fail in such a way as to leave us switched
**	    into a bad connection (notably when the target database is 
**	    inconsistent), this causes problems upgrading subsequent databases.
**	    Makse sure we switch back to the iidbdb connection before
**	    continuing
**	21-feb-96 (prida01)
**	    remove vnode from database name when checking if directory exists
**	    74749
**      06-mar-1996 (nanpr01)
**          Added upgrade code for 2.0 upgrade - Variable Page Size Project. 
**	31-may-96 (prida01)
**	    modify vnode change to work for local databases.
**      13-mar-98 (nicph02)
**          Added call to rm_iiqef_procedures to drop iiqef_ procedures.
**	12-may-99 (stephenb)
**	    Add call to changed_cats_25() for 2.5 catalog changes
**      31-Oct-03 (wanfr01)
**          Bug 111216, INGSRV 2583
**          Moved one of the error code checks so it runs
**          if debug mode isn't set (upgradedb -d)
**	12-mar-2004 (somsa01)
**	    Split out convert part into convert_dbs(), so that this routine
**	    can be invoked multiple times to add multiple system databases
**	    to the master list.
**	22-Sep-2004 (schka24)
**	    Split "all" loop so that we always do Star databases last.
**	    Otherwise we might upgrade a Star database before some DB
**	    that it references, which won't fly.
**	    (If a Star DB references another Star DB, then .. oh well...)
*/
static VOID
collect_dbs(dbname, username, superuser)
char	*dbname;
char	*username;
i4	superuser;
{
    EXEC SQL begin declare section;
	char	    *dbname_curr;
	char	    dbname_tmp[DB_MAXNAME+1];
	char	    cdbname_tmp[DB_MAXNAME+1];
	char	    ddbname_tmp[DB_MAXNAME+1];
	char	    dba[DB_MAXNAME+1];
	i4	    access_flags;
	i4	    dbservice;
	i4	    cmptlvl;
	i4	    minorlvl;
	i4	    level;
	char	    locname[DU_LOC_SIZE + 1];
	char	    areaname[DB_AREA_MAX + 1];
    EXEC SQL end declare section;

    bool	    star_flag = FALSE;
    bool	    convert_multiple;
    char            *colon_ptr;
    bool 	    upcase = FALSE;
    bool	    any_star = FALSE;

    dbname_curr = dbname;

    /*
    ** We have two ways of extracting databases to be converted:
    **     o If -all specified, use a select loop
    **	   o If dbname specified, select on that specific database
    */

    convert_multiple = (upgr_cb.du_scope == DU_INSTLTN);
    
    /* start a new tranaction and set up a lock on the iidatabase table */
    exec sql commit;
    exec sql set lockmode on iidatabase where level=table;    

    if (convert_multiple)
    {

	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> converting multiple\n");
	}
	/* bypass the conversion if the user is NOT a super user */
	if (superuser == 0)
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU6010_NOT_SUPERUSER);

	/* Skip iidbdb, imadb on -all;  imadb should have been done when
	** iidbdb was done, and doing it after the initial upgrade can
	** hang (if the remote command server is running).
	** If for some reason imadb upgrade was skipped, it needs to be
	** upgraded by itself explicitly.
	*/
	EXEC SQL declare x cursor for 
	SELECT  iidatabase.name,
		iidatabase.own,
		iidatabase.access,
		iidatabase.dbcmptlvl,
		iidatabase.dbservice,
		iidatabase.dbcmptminor,
		iidatabase.dbdev,
		iilocations.area
	    FROM
		iidatabase,
		iilocations
	    WHERE
		(lowercase(iidatabase.own) != '$ingres'
		 or lowercase(iidatabase.name) not in ('iidbdb','imadb'))
		and iidatabase.dbdev = iilocations.lname
	    ORDER BY own, name;

	EXEC SQL OPEN x FOR READONLY;
	
	/* loop for each database in the installation */
	for (;;)
	{
	    EXEC SQL FETCH x INTO
		:dbname_tmp,
		:dba,
		:access_flags,
		:cmptlvl,
		:dbservice,
		:minorlvl,
		:locname,
		:areaname;

	    if (sqlca.sqlcode == DU_SQL_NONE)
	    {       
		EXEC SQL CLOSE x;
		break;
	    }

	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file,
		"]==> considering database %s owned by %s dbservice %d\n\n",
		dbname_tmp, dba, dbservice);
	    }

	    if (dbservice & (DU_1SER_DDB | DU_2SER_CDB) )
	    {
		/* Skip star DB's first pass; need second pass */
		any_star = TRUE;
		continue;
	    }
	
	    /* is it FIPS database */
	    if (dbservice & DU_NAME_UPPER)
	      upcase = TRUE;
	    else
	      upcase = FALSE;

	    _VOID_ STtrmwhite(dbname_tmp);
	    _VOID_ STtrmwhite(locname);
	    _VOID_ STtrmwhite(areaname);
	    _VOID_ STtrmwhite(dba);

	    /* Calculate database's level */

	    level = set_cmptlvl(cmptlvl, minorlvl);

	    /* Add the database to the list */

	    add_dbname(dbname_tmp, dba, level, access_flags, locname, areaname,
	       cdbname_tmp, ddbname_tmp, FALSE, upcase, dbservice);

	}  /* end cursor loop to get db info from iidatabase */

	if (any_star)
	{
	    /* Do it again to get star databases.  Unfortunately it's not real
	    ** convenient to sort the cursor loop so that Star stuff comes at
	    ** the end, although it wouldn't be impossible (just clumsy).
	    */
	    EXEC SQL OPEN x FOR READONLY;
	    
	    /* loop for each database in the installation */
	    for (;;)
	    {
		EXEC SQL FETCH x INTO
		    :dbname_tmp,
		    :dba,
		    :access_flags,
		    :cmptlvl,
		    :dbservice,
		    :minorlvl,
		    :locname,
		    :areaname;

		if (sqlca.sqlcode == DU_SQL_NONE)
		{       
		    EXEC SQL CLOSE x;
		    break;
		}

		if (upg_dbg_out)
		{
		    SIfprintf(upgr_cb.du_dbg.du_file,
		    "]==> considering database %s owned by %s dbservice %d\n\n",
		    dbname_tmp, dba, dbservice);
		}

		/* Only star databases this time */
		if ((dbservice & (DU_1SER_DDB | DU_2SER_CDB))  == 0)
		    continue;

		/* illegal state of STAR DB, so SKIP this one but do not
		** generate an error */
		if ((dbservice & DU_1SER_DDB) && (dbservice & DU_2SER_CDB) )
		{
		    /* print error message that a db cannot be marked as 
		    ** both a CDB and a DDB.  Skip this DB */
		    du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1852_CDB_AND_DDB, 2,
			      0, ddbname_tmp);
		    continue;
		}
		else if (dbservice & DU_1SER_DDB)
		{
		    /* get cdb info from iistar_cdbs */
		    exec sql select cdb_name into :cdbname_tmp from iistar_cdbs
			where ddb_name = :dbname_tmp and ddb_owner = :dba;

		    /* set up DBNAME_NODE structure correctly for DDB */
		    STzapblank(dbname_tmp, ddbname_tmp);
		    STzapblank(cdbname_tmp,dbname_tmp);
		    _VOID_ STtrmwhite (cdbname_tmp);
		    /* Ensure that current system user is db owner */
		    _VOID_ STtrmwhite (dba);
		    if (STcmp(upgr_cb.duowner, dba) != 0)
		    {
		    	du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1874_UPGR_NOT_STAR_OWNER, 4,
				0, ddbname_tmp, 0, dba );
		    	continue;
		    }
		}
		else
		{
		    /* this must be a CDB.  Currently, we dont operate on
		    ** CDBS directly.  Rather, we ask the user to operate
		    ** on the DDB.  Since this is an all statement, we simply
		    ** note that this db is a CDB that upgradedb is skipping,
		    ** and DO NOT consider this an error
		    */

		    /* get ddb name from iistar_cdbs */
		    exec sql select ddb_name into :ddbname_tmp from iistar_cdbs
			where cdb_name = :dbname_tmp and cdb_owner = :dba;
		    _VOID_ STtrmwhite (ddbname_tmp);
		    _VOID_ STtrmwhite (dbname_tmp);

		    /* now print warning that dbname_tmp is a CDB for STAR DB
		    ** ddbname_tmp and that we are skipping this one...
		    */
		    du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1853_CDB_SKIPPED, 6,
				0, dbname_tmp, 0, ddbname_tmp, 0, dbname_tmp);
		    continue;
		}
	    
		/* is it FIPS database */
		if (dbservice & DU_NAME_UPPER)
		  upcase = TRUE;
		else
		  upcase = FALSE;

		_VOID_ STtrmwhite(dbname_tmp);
		_VOID_ STtrmwhite(locname);
		_VOID_ STtrmwhite(areaname);
		_VOID_ STtrmwhite(dba);

		/* Calculate database's level */

		level = set_cmptlvl(cmptlvl, minorlvl);

		/* Add the database to the list */

		add_dbname(dbname_tmp, dba, level, access_flags, locname, areaname,
		   cdbname_tmp, ddbname_tmp, TRUE, upcase, dbservice);

	    }  /* end cursor loop to get db info from iidatabase */
	} /* any_star */
    }
    else					/* Collect specific database */
    do		    /* control loop */
    {

	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> NOT converting multiple\n");
	}
	if ((colon_ptr = STchr(dbname, ':')) != NULL)
	  STcopy(colon_ptr+2, dbname_curr);

	EXEC SQL SELECT
		iidatabase.name,
		iidatabase.own,
		iidatabase.access,
		iidatabase.dbservice,
		iidatabase.dbcmptlvl,
		iidatabase.dbcmptminor,
		iidatabase.dbdev,
		iilocations.area
	    INTO
		:dbname_tmp,
		:dba,
		:access_flags,
		:dbservice,
		:cmptlvl,
		:minorlvl,
		:locname,
		:areaname
	    FROM
		iidatabase,
		iilocations
	    WHERE
		iidatabase.name = :dbname_curr and
		iidatabase.dbdev = iilocations.lname;

	/* Ensure the database actually exists */

	if (sqlca.sqlerrd[SQL_NUM_ROWS] == 0)
	{
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6012_NONEXISTENT_TARGET, 2,
		      0, dbname_curr);
	    upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
	}
         	
	if (colon_ptr != NULL)
	   STprintf(dbname_tmp, "%s::%s", vnode, dbname_curr);

	/* see if database is a star database */
	if (dbservice & (DU_1SER_DDB | DU_2SER_CDB) )
	{

	    if ((dbservice & DU_1SER_DDB) && (dbservice & DU_2SER_CDB) )
	    {
		/* illegal state of STAR DB, so SKIP this one but do not
		** generate an error */
		du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1852_CDB_AND_DDB, 2,
			  0, ddbname_tmp);
		upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
	    }
	    else if (dbservice & DU_1SER_DDB)
	    {
		/* get cdb info from iistar_cdbs */

		exec sql select cdb_name into :cdbname_tmp from iistar_cdbs
		    where ddb_name = :dbname_tmp and ddb_owner = :dba;

		/* set up DBNAME_NODE structure correctly for DDB */
		STzapblank(dbname_tmp, ddbname_tmp);
		STzapblank(cdbname_tmp,dbname_tmp);
		_VOID_ STtrmwhite (cdbname_tmp);
		star_flag = TRUE;		    
		/* Ensure that current system user is db owner */
		_VOID_ STtrmwhite (dba);
		if (STcmp(upgr_cb.duowner, dba) != 0)
		{
		    du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1874_UPGR_NOT_STAR_OWNER, 4,
				0, ddbname_tmp, 0, dba );
		    upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
		}
	    }
	    else
	    {
		/* this must be a CDB.  Currently, we dont operate on
		** CDBS directly.  Rather, we ask the user to operate
		** on the DDB.  Since this is an all statement, we simply
		** note that this db is a CDB that upgradedb is skipping,
		** and DO NOT consider this an error
		*/

		/* get ddb name from iistar_cdbs */
		exec sql select ddb_name into :ddbname_tmp from iistar_cdbs
		    where cdb_name = :dbname_tmp and cdb_owner = :dba;
		_VOID_ STtrmwhite (ddbname_tmp);
		_VOID_ STtrmwhite (dbname_tmp);

		/* now print warning that dbname_tmp is a CDB for STAR DB
		** ddbname_tmp and that we are skipping this one...
		*/
		du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1853_CDB_SKIPPED, 6,
			    0, dbname_tmp, 0, ddbname_tmp, 0, dbname_tmp);
		upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
	    }
	}  /* endif DB is marked as CDB or DDB */

	/* is it FIPS database */
	if (dbservice & DU_NAME_UPPER)
	   upcase = TRUE;
	else
	   upcase = FALSE;

	_VOID_ STtrmwhite(dbname_tmp);
	_VOID_ STtrmwhite(locname);
	_VOID_ STtrmwhite(areaname);
	_VOID_ STtrmwhite(dba);

	if ((superuser == 0) &&
	    (STcompare(dba, username) != 0))
	{
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6011_NOT_DBA, 4,
		      0, dbname_curr, 0, dba);
	    upgr_exit(__LINE__,  DU_FAIL_EXIT, 0);
	}

	/* Calculate database's level */

	level = set_cmptlvl(cmptlvl, minorlvl);
		
	/* Add the database to the list */
	add_dbname(dbname_tmp, dba, level, access_flags, locname, areaname, 
		   cdbname_tmp, ddbname_tmp, star_flag, upcase, dbservice);
    } while (0);

    /* commit to free lock on iidatabase */
    exec sql commit;
}

/*{
** Name: convert_dbs	- Perform conversion on list of databases collected
**
** Description:
**	This routine converts each database in the global list collected
**	by the collect_dbs() routine.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** Returns:
**	OK		If all databases are upgraded.
**	FAIL		If any upgrade fails.
**
** Side Effects:
**	none
**
** History:
**	12-mar-2004 (somsa01)
**	    Split from collect_dbs() to allow multiple calls to collect_dbs().
**	27-Aug-2004 (schka24)
**	    Add r3 upgrade calls.  Remove journal check, server turns off
**	    journaling when it gets a conversion-connect.  Fix bug that
**	    could check for upgrade temps in the iidbdb session instead
**	    of the database session, leaving junk in the db..
*/
static STATUS
convert_dbs()
{
    EXEC SQL begin declare section;
	char	    *dbname_curr;
	i4	    access_flags;
	char	    *areaname;
	char        iidbdbname[DB_MAXNAME+1];
	char	    dbname_star[DB_MAXNAME+DU_TAIL_LEN+1];
	i4	    proc_instruction;
    EXEC SQL end declare section;

    i4		    convert_count = 0;
    DU_ENV	    dbenv;
    char	    target_name[DB_MAXNAME+1];
    STATUS 	    status = OK;
    STATUS	    tree_status = OK;
    DU_STATUS	    du_status;

    /* Pre-qualify each database for conversion */

    for  (upgr_cb.Dbname_ptr = upgr_cb.Dbname_head;
	  upgr_cb.Dbname_ptr != NULL;
	  upgr_cb.Dbname_ptr = upgr_cb.Dbname_ptr->nextdb)
    {
	
	/* do not process the iidbdb in this loop, as it will have already
	** been processed by routine cv_iidbdb */
	if ( STcompare(upgr_cb.Dbname_ptr->dbname, ERx("iidbdb")) == 0)
	    continue;

	if (upgr_cb.Dbname_ptr->star_flag)
	    STcopy(upgr_cb.Dbname_ptr->ddbname, target_name);
	else
	    STcopy(upgr_cb.Dbname_ptr->dbname, target_name);

	if (upgr_cb.Dbname_ptr->errors)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1854_ERROR_SKIP, 2,
		    0, target_name);
            status = FAIL;
	    continue;
	}
	else
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00B6_DB_IDENTIFIER, 2,
		     0, target_name);

	/* Have iistats updated for Ingres 10 distributed databases. */
	upgrade_iidd_stats = TRUE;

	/* Prequalify for FE conversion here.... */
	upgr_cb.Dbname_ptr->fe_convert = TRUE;		/* Always convert */
	if (upgr_cb.upgtrace[UPG03_SKIP_FECVT])
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1855_TRACE_3, 0);
	    upgr_cb.Dbname_ptr->fe_convert = FALSE;	/* skip upgradefe */
	}

	/* Prequalify for BE conversion here.... */

	upgr_cb.Dbname_ptr->be_convert = TRUE;		/* Assume conversion */
	if (upgr_cb.upgtrace[UPG04_SKIP_BECVT])
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1856_TRACE_4, 0);
	    upgr_cb.Dbname_ptr->be_convert = FALSE;	/* skip for star dbs */
	}

	if (((upgr_cb.Dbname_ptr->access & DU_OPERATIVE) == 0) &&
		 ((upgr_cb.Dbname_ptr->access & DU_UPGRADING) == 0)
	   )
	{
	    if (upgr_cb.Dbname_ptr->access & DU_CONVERTING)
	    {
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1857_UNCONVERTED_V5DB,
			 2, 0, target_name);
		upgr_cb.Dbname_ptr->errors = TRUE;
		status = FAIL;
	    }
	    else
	    {
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1858_INOPERATIVE_DB,
			 2, 0, target_name);
		upgr_cb.Dbname_ptr->errors = TRUE;
		status = FAIL;
	    }
	}

        if ( upgr_cb.Dbname_ptr->level == CURRENT_LEVEL ) /* lawst01   */
	{
	    /*
	    ** Don't do BE conversion on this database if at current level.
	    ** Still does FE conversion because BE version is recorded before
	    ** FE is upgraded.  There's no good way to tell whether FE was
	    ** upgraded beforehand, just do it twicet.
	    */
	    upgr_cb.Dbname_ptr->be_convert = FALSE;
	    upgr_cb.Dbname_ptr->fe_convert = TRUE;
	}
	else if (upgr_cb.Dbname_ptr->level == 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1859_WRONG_LEVEL,
			 2, 0, target_name);
	    upgr_cb.Dbname_ptr->errors = TRUE;
	    status = FAIL;
	}

	/* At this point, we have completed prequalification.  Check result */

	if (upgr_cb.Dbname_ptr->errors)		/* Skip this db if errors */
	    continue;

	if (upgr_cb.Dbname_ptr->be_convert ||	/* See if anything to be done */
	    upgr_cb.Dbname_ptr->fe_convert ||
	    upgr_cb.Dbname_ptr->tree_convert)
	    ++convert_count;			/* Count the database */
	else					/* Nothing to be done */
	{
	    /*
	    ** Database was not selected for either BE or FE conversion.
	    ** Issue remainder of informational message and bypass this one.
	    */
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU185A_ALREADY_CURRENT,
			 4, 0, target_name, 0, SERVER_VERSION);
	    upgr_cb.Dbname_ptr->errors = TRUE;
	    continue;
	}

	/* Remainder of loop for be and/or fe conversion of a database */
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU008D_UPGRADE_TARGET, 2,
			0, target_name);
	if (upgr_cb.Dbname_ptr->be_convert)
	{
            if (vnode[0] == '\0')
	    {
		/* This is probably not needed but can't hurt.  The attempt
		** to create a work dir will fail (silently) if we're not
		** the installation owner.
		*/
		if (upgr_cb.Dbname_ptr->star_flag)
		   chk_create_workdir(upgr_cb.Dbname_ptr->dbname);
		else
		   chk_create_workdir(target_name);
            }
	}

	/* Open the DB if be or tree convert, but not if FE only convert */
	if (upgr_cb.Dbname_ptr->be_convert
	  || upgr_cb.Dbname_ptr->tree_convert)
	{
	    /*
	    ** Open the target database.  
	    **
	    ** If there is an error opening this database, then skip to the
	    ** next database in the list
	    */
	    if (! open_target(CONNECT_EXCL))
	    {
		/*
		** switch back to the iidbdb connection before skiping
		** to next db
		*/
		exec sql set_sql (session = :DBDB_SESSIONID);
		status = FAIL;
		continue;
	    }
	    /* set session id to the open database */

	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (a) setting session to user database\n");
	    }
	    exec sql set_sql (session = :DB_SESSIONID);
	}
	if (upgr_cb.Dbname_ptr->be_convert)
	{
	    /* Do the initial updates needed to get things working.
	    ** This includes core catalog rehash, key catalogs like iiprotect,
	    ** and a few version specific updates such as adding fhdr/fmap
	    ** pages to 6.4 ingres catalogs.
	    */
	    do_early_updates(upgr_cb.Dbname_ptr);

	    /* Get the status fields from iidatabase */

	    dbname_curr  = upgr_cb.Dbname_ptr->dbname;
	    access_flags = upgr_cb.Dbname_ptr->access;
	    areaname = upgr_cb.Dbname_ptr->areaname;
	    access_flags &= ~DU_OPERATIVE;
	    access_flags |= DU_UPGRADING;
	    upgr_cb.Dbname_ptr->access = access_flags;

	    _VOID_ STcopy(upgr_cb.Dbname_ptr->dbname, dbenv.du_dbname);
	    _VOID_ STcopy(upgr_cb.Dbname_ptr->locname,
			  dbenv.du_dbloc.du_locname);
	    _VOID_ STcopy(upgr_cb.Dbname_ptr->areaname, dbenv.du_dbloc.du_area);


	    /* Remove vnode from database name 'ii_read_config_value'
	    ** checks the database directory exists, so we don't need 
	    ** the vnode (bug 74749)
	    */	
       	
	    {
		char *tmp_dbname = NULL;
	    	if (((tmp_dbname = (STchr(dbname_curr, ':'))) != NULL) &&
	     	STchr(tmp_dbname+ 1, ':') == (tmp_dbname + 1))	
		    tmp_dbname += 2;
		if (tmp_dbname != NULL)
			dbname_curr = tmp_dbname;
	    }


	    dbenv.du_access = upgr_cb.Dbname_ptr->access;


	    /* Update the access field in the config file as inoperative */
	    proc_instruction = QEA_UPD_ACCESS;
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> [3] executing ii_update_config(%s, %s, %d, %d)\n",
		dbname_curr, areaname, proc_instruction, access_flags);
	    }
	    exec sql execute procedure ii_update_config(
		    database_name = :dbname_curr,
		    location_area = :areaname,
		    update_map = :proc_instruction,
		    access = :access_flags);
	    if (sqlca.sqlcode < 0)
	    {
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU185E_BAD_CONFIG_UPDATE, 0);
		upgr_cb.Dbname_ptr->errors = TRUE;
		status = FAIL;
		--convert_count;

		/* if db is open, close it */
		if (upgr_cb.Connected)
		{
			exec sql rollback;
			EXEC SQL disconnect;
			if (upg_dbg_out)
			{
			    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (f) disconnect\n");
			}
			upgr_cb.Connected = FALSE;
		}

		/* set session id back to iidbdb */
		if (upg_dbg_out)
		{
		    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (d) setting session to database database\n");
		}
		exec sql set_sql (session = :DBDB_SESSIONID);
		exec sql commit;	/* release lock on iidatabase */
		continue;
	    }

	    /* Mark the database inoperative in the iidatabase catalog */

	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (e) setting session to database database\n");
	    }
	    exec sql set_sql (session = :DBDB_SESSIONID);

            EXEC SQL COMMIT;
            EXEC SQL set lockmode on iidatabase where level = table;

	    EXEC SQL UPDATE iidatabase SET access = :access_flags
	    WHERE name = :dbname_curr;

	    EXEC SQL COMMIT;
	}

	/* go upgrade the database */
	cv_upgrade();

	if (upgr_cb.Dbname_ptr->tree_error)
	    tree_status = FAIL;

        rm_iitmp_tables();        /* remove all iitmp_ tables */
        rm_iiqef_procedures();    /* Bug 89164: remove all iiQEF procedures */

	/* when returning from the routine that operates on a given db, it
	** is important to assure that SQL knows its back to the iidbdb
	** session 
	*/
	if (upgr_cb.Dbname_ptr->be_convert || upgr_cb.Dbname_ptr->tree_convert)
	    update_iidatabase();    /* go mark db as operative in the iidbdb */
 
	exec sql set_sql (session = :DBDB_SESSIONID);
        if (upgr_cb.Dbname_ptr->star_flag)
	{
	    exec sql commit;
	    exec sql disconnect;
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (g) disconnect\n");
	    }
	    upgr_cb.dbdb_open = FALSE;

	    _VOID_ STpolycat (2, upgr_cb.Dbname_ptr->ddbname, DU_STARTAIL,
			dbname_star);

	    upgr_cb.Ignore_errors = TRUE;
	    EXEC SQL connect :dbname_star session :STAR_SESSIONID
		      identified by :DU_DBA_DBDB options = '-A6', '+w';
	    upgr_cb.Ignore_errors = FALSE;
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> connected to %s\n", dbname_star);
	    }
	    check_sql (sqlca.sqlcode);
	 
	    if (sqlca.sqlcode < 0)   /* no star server */
		return FAIL;
	    IIlq_Protect (TRUE);         /* system catalog update privilege */

	    /*
	    ** If we updated iidd_stats in the local db, 
	    ** we have to re-register iistats in the distributed db
	    */
	    cv_65_star_iistats(dbname_star);

	    /* Drop what looks like an obsolete catalog (no error check) */
	    upgr_cb.Ignore_errors = TRUE;
	    exec sql remove iiddb_finddbs;
	    upgr_cb.Ignore_errors = FALSE;
	    exec sql commit;

	    /* We are connected to the distributed database now */
	    if (upgr_cb.Dbname_ptr->tree_convert || upg_trees)
		fix_qry_trees(upgr_cb.Dbname_ptr->ddbname, dbname_star, 
			TRUE, upgr_cb.Dbname_ptr->level); 

	    if (upgr_cb.Dbname_ptr->tree_error)
		tree_status = FAIL;

	    exec sql commit;
	    exec sql disconnect;

	    if (upg_dbg_out)
	    {
	       SIfprintf(upgr_cb.du_dbg.du_file, "]==> [4] about to connect to db iidbdb session %d -A6\n",
		  DBDB_SESSIONID);
	    }
	    if (vnode[0] != '\0')
	       STprintf(iidbdbname, "%s::iidbdb", vnode);
	    else
	       STcopy("iidbdb", iidbdbname);

	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> [5] connect to iidbdb session %d options = %s\n",
			DBDB_SESSIONID, 
			upg_concurrent ? "+w" : "-A6 +w");
	    }

	    /* Reconnect the iidbdb session -- iidbdb is converted now,
	    ** no need for -A6 or other weird stuff.
	    ** Also, just connect as the running user, we'll say the magic
	    ** word to make iidatabase updates work.
	    */
	    EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
		options =  '+w';

	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> connected\n");
	    }
	    if (sqlca.sqlcode < 0)
	       upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU600D_BAD_IIDBDB_RECONNECT);

	    upgr_cb.dbdb_open = TRUE;
	    IIlq_Protect(TRUE);		/* system catalog update priv */
	}
    }  /* end loop for each database in potential target list */

    if (tree_status)
    {
	upgr_exit(__LINE__, DU_FAIL_EXIT, W_DU1873_UPGRADEDB_TREE);
    }

    return (status);
}


/*{
** Name: open_target	    - Open the target database
**
** Description:
**	    
**  This routine connects to the target database.  If there is an error 
**  connecting to the database, it verifies the db is still listed
**  in iidatabase and (if so) retries.  If the database is NOT listed, it 
**  prints a warning that the db has been destroyed during upgradedb execution.
**
**  Note: this routine connects as $ingres.  Upgradedb will do a
**		set session authorization xxxxx
**	  command to become the DBA later in the processing.  But the first
**	  few things upgradedb does requires that upgradedb connect as $ingres.
**
** Inputs:
**	none
**	
** Outputs:
**	none
** Returns:
**	TRUE	    -> database opened successfully
**	FALSE	    -> unable to open database
**	
** Side Effects:
**	none
**	
** History:
**	20-oct-92 (teresa)
**	    initial creation
**	20-jan-93 (jpk)
**	    changed "set user authorization" to "set session authorization"
**	    to comply with new standards.
**	11-Feb-1993 (daveb)
**	    make static to match declaration above.
**	11-Sep-2004 (schka24)
**	    Arrange for nicer message when reconnecting.
[@history_template@]...
*/
static bool
open_target(i4 open_mode)
{
    EXEC SQL begin declare section;
	char	dbname_curr[DB_MAXNAME+DU_TAIL_LEN+1];
	char	dba_curr[DB_MAXNAME+1];
    EXEC SQL end declare section;

    i4 msgid;

    do		/* control loop */
    {
	/* Disconnect from the previous database if we are somehow conencted */
	if (upgr_cb.Connected)
	{
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (f) setting session to user database\n");
	    }
	    exec sql set_sql (session = :DB_SESSIONID);
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> disconnecting from session %d\n", DB_SESSIONID);
	    }
	    exec sql commit;		/* commit, just to be safe */
	    EXEC SQL disconnect;
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (g) disconnect\n");
	    }
	    upgr_cb.Connected = FALSE;
	}
	if (upgr_cb.du_dbmstype == DU_DBRMS)
	    _VOID_ STpolycat(2, upgr_cb.Dbname_ptr->dbname, DU_RMSTAIL, 
			     dbname_curr);
	else
	    _VOID_ STcopy(upgr_cb.Dbname_ptr->dbname, dbname_curr);
	_VOID_ STcopy(upgr_cb.Dbname_ptr->dba, dba_curr);

	/* Connect to the target database */

	if (upgr_cb.Dbname_ptr->star_flag)
	    STcopy (upgr_cb.Dbname_ptr->ddbname, upgr_cb.du_opendb);
	else
	    STcopy (dbname_curr, upgr_cb.du_opendb);

	/* Be spiffy with the messages, different one first time */
	if (upgr_cb.Dbname_ptr->first_open)
	{
	    upgr_cb.Dbname_ptr->first_open = FALSE;
	    msgid = I_DU008E_USER_DB_CONNECT;
	}
	else
	{
	    msgid = I_DU0109_USER_DB_RECONNECT;
	}
	du_talk(__LINE__,  DU_MODESENS, &upgr_cb, msgid, 4,
		  0, upgr_cb.du_opendb, 0, dba_curr);

	if (upgr_cb.upgtrace[UPG06_DESTROYED])
	{
	    upgr_cb.this_trace = UPG06_DESTROYED;
	    /* simulate the db having gone away */
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00B5_TRACE_POINT, 2, 
		     sizeof(upgr_cb.this_trace), &upgr_cb.this_trace);
	    STcopy("nonexistent_db",dbname_curr);
	}
	/* note: we connect as $ingres even though we tell the user we
	**	 are connecting as the DBA.  That is because we need to execute
	**	 some internal procedures that can only be run as $ingres.
	*/
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [6] connect to %s session %d id %s %s +w\n",
		dbname_curr, DB_SESSIONID, DU_DBA_DBDB, 
		open_mode == CONNECT_EXCL ? "-A6 -l +U" : "");
	}
	if (open_mode == CONNECT_EXCL)
	{
	    EXEC SQL connect :dbname_curr session :DB_SESSIONID
		     identified by :DU_DBA_DBDB
		     options = '-A6', '-l', '+U', '+w';
	}
	else
	{
	    EXEC SQL connect :dbname_curr session :DB_SESSIONID
		     identified by :DU_DBA_DBDB
		     options = '-A6', '+w';
	}

	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> connected to %s\n", dbname_curr);
	}
	check_sql(sqlca.sqlcode);

 
	if (sqlca.sqlcode < 0)
	{
	    /* see if db is still known to installation -- perhaps it
	    ** was destroyed after info about this db was cached */
            if (upg_dbg_out)
            {
                SIfprintf(upgr_cb.du_dbg.du_file, "]==> Verifying db.....\n");
            }
	    if (validate_db(dbname_curr))
	    {
                if (upg_dbg_out)
                {
                    SIfprintf(upgr_cb.du_dbg.du_file, "]==> db validated\n");
                }
		/* retry the connect */
		if (open_mode == CONNECT_EXCL)
		{
		    EXEC SQL connect :dbname_curr session :DB_SESSIONID
			identified by :DU_DBA_DBDB
			options = '-A6', '-l', '+U', '+w';
		}
		else
		{
		    EXEC SQL connect :dbname_curr session :DB_SESSIONID
			identified by :DU_DBA_DBDB
			options = '-A6', '+w';
		}
		if (sqlca.sqlcode < 0)
		{   
		    if (upgr_cb.upgtrace[UPG06_DESTROYED])
		    {
			/* get the correct name back */
			STcopy(upgr_cb.Dbname_ptr->dbname, dbname_curr);
		    }		    
		    /* still failed, so print error */
		    du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1860_SKIP_DB, 2,
			  0, upgr_cb.du_opendb);
		    break;
		}
		else
		{
		    upgr_cb.Connected = TRUE;
		}
	    }
	    else
	    {
		/* the database no longer exists, so print message and
		** break */
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1868_DESTROYED_DB, 2,
			  0, upgr_cb.du_opendb);
		break;
	    }
	}
	else
	{
	    upgr_cb.Connected = TRUE;
	}
	IIlq_Protect(TRUE);		/* system catalog update priv */
	setauth(NULL);			/* Forget last auth setting */
	
    } while (0);     /* end of control loop */
    return upgr_cb.Connected;
}

/*{
** Name: cv_upgrade	    - Upgrade the database
**
** Description:
**	    
**  This is the controller for converting a database.  It expects that the
**  database has already been opened. It performs backend and frontend 
**  conversion.  
**
** Inputs:
**	none
**	
** Outputs:
**	none
**	
** Side Effects:
**	none
**	
** History:
**	24-jul-91 (teresa)
**	    initial creation
**	16-apr-92 (teresa)
**	    change "for" control loop to "do" to appease sun4 compiler warnings.
**	19-Oct-1993 (jpk)
**	    go back to area name II_DATABASE instead of "default";
**	    Rachael's fix to internal database procedure makes
**	    this the correct parameter to pass it.
**	14-jul-94 (robf)
**          Moved Converting message here.
**	21-Feb-96 (prida01)
**	    Remove vnode part of database name  (74749)
**	31-may-96 (prida01)
**	    Modify vnode change to work for local databases.
**	11-Sep-2004 (schka24)
**	    Fix catalogs to large page size after upgrade if they were before.
**	11-Jan-2005 (schka24)
**	    cmptlvl was too small by 1, smashed areaname -- how did that work?
**	18-Sep-2006 (gupsh01)
**	    Added update_date_alias() to support aliasing Date keyword to 
**	    ingresdate data type for earlier installations.
**	25-Sep-2006 (gupsh01)
**	    Removed update_date_alias() as it is done by iisudbms.
[@history_template@]...
*/
static VOID
cv_upgrade()
{
    EXEC SQL begin declare section;
	i4	proc_instruction;
	char	dbname_curr[DB_MAXNAME+DU_TAIL_LEN+1],*dbname_ptr;
	char	dba_curr[DB_MAXNAME+1];
	char	areaname[DB_AREA_MAX + 1];
	i4	cmptlvl;
	i4	minorlvl;
	i4	page_size;
    EXEC SQL end declare section;

    i4		access_flags;
    DU_ENV	dbenv;
    DU_STATUS	du_status;

    do		/* control loop */
    {

	if (upgr_cb.du_dbmstype == DU_DBRMS)
	    _VOID_ STpolycat(2, upgr_cb.Dbname_ptr->dbname, DU_RMSTAIL, 
			     dbname_curr);
	else
	    _VOID_ STcopy(upgr_cb.Dbname_ptr->dbname, dbname_curr);
	_VOID_ STcopy(upgr_cb.Dbname_ptr->dba, dba_curr);

	/* Create a pointer to database name that doesn't include vnode */
	{
	    char *tmp_dbname;
	    	if (((tmp_dbname = (STchr(dbname_curr, ':'))) != NULL) &&
	   	STchr(tmp_dbname + 1, ':') == (tmp_dbname + 1))
	           tmp_dbname += 2;
	    if (tmp_dbname != NULL)
		dbname_ptr = tmp_dbname;
	    else
		dbname_ptr = dbname_curr;
	}

	/* Perform be conversion */

	if (upgr_cb.Dbname_ptr->be_convert)
	{
	    _VOID_ STcopy(upgr_cb.Dbname_ptr->dbname, dbenv.du_dbname);
	    _VOID_ STcopy(upgr_cb.Dbname_ptr->locdump,
			  dbenv.du_dbloc.du_locname);
	    _VOID_ STcopy(upgr_cb.Dbname_ptr->areadump,
			  dbenv.du_dbloc.du_area);
	    do	    /* inner control loop */
	    {
		/* set the user to $ingres for the BE conversion */
		exec sql commit;
		if (setauth("$ingres") != OK)
		{
		    /* report error setting name and abort */
		    du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1860_SKIP_DB, 2,
			  0, upgr_cb.du_opendb);
		    break;
		}

	        if (upgr_cb.Dbname_ptr != NULL)
	        {
		    if (upgr_cb.Dbname_ptr->star_flag)

		        du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0088_UPGRADE_ID, 4,
			     0, upgr_cb.Dbname_ptr->ddbname, 0, SERVER_VERSION);
		    else
		        du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0088_UPGRADE_ID, 4,
			     0, dbname_curr, 0, SERVER_VERSION);
	        }
		/* now convert the currently connected database */
		cv_database(dbname_curr);

		/* Check for errors during conversion */
		if (upgr_cb.Dbname_ptr->errors == TRUE)
		{
		    EXEC SQL rollback;
		    break;
		}
		else
		{
		    EXEC SQL commit;
		}


		/* Update the compat fields in the config file */

		_VOID_ STcopy(upgr_cb.Dbname_ptr->dbname, dbenv.du_dbname);
		_VOID_ STcopy(upgr_cb.Dbname_ptr->locname,  
			      dbenv.du_dbloc.du_locname);
		_VOID_ STcopy(upgr_cb.Dbname_ptr->areaname, 
			      areaname);
		cmptlvl = DU_CUR_DBCMPTLVL;
		minorlvl = DU_1CUR_DBCMPTMINOR ;

		access_flags = upgr_cb.Dbname_ptr->access;
		access_flags |= DU_OPERATIVE;
		access_flags &= ~DU_UPGRADING;
		dbenv.du_access = access_flags;
		upgr_cb.Dbname_ptr->access = access_flags;

		/* go mark db as operative in the iidbdb */
	        if (upgr_cb.Dbname_ptr->be_convert || 
		    upgr_cb.Dbname_ptr->tree_convert)
		    update_iidatabase();

		if (! open_target(CONNECT_EXCL))
		{
		    SIprintf("Error re-opening database %s \n", 
		    dbname_ptr);
		    continue;
		}
		exec sql set_sql (session = :DB_SESSIONID);

		/* the the use back to $ingres to execute internal procedures */

		(void) setauth("$ingres");
		
		/* Now update the access and compat fields of the config file */
		proc_instruction = QEA_UPD_ACCESS | QEA_UPD_CMPTLVL | 
				   QEA_UPD_CMPTMINOR;
		/* No longer need to update core-catalog version by hand,
		** DMF will do it as part of the DSC_V9 conversion.
		*/
		if (upg_dbg_out)
		{
		    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [2] ii_update_config(%s, %s, %d, %d, %d, %d)\n",
		    dbname_curr, areaname, proc_instruction, access_flags,
		    cmptlvl, minorlvl);
		}
                /*
                ** for RMS, we need to use the name without "/rms". 
                ** Strip it and add back later.
                */
                if( upgr_cb.du_dbmstype == DU_DBRMS )
                {
                    char *tmp = STindex(dbname_ptr, "/", STlength(dbname_ptr));
                    *tmp = '\0';
                }
		exec sql execute procedure ii_update_config(
						database_name = :dbname_ptr,
						location_area = :areaname,
						update_map = :proc_instruction,
						access = :access_flags,
						cmptlvl = :cmptlvl,
						cmptminor = :minorlvl);
                if( upgr_cb.du_dbmstype == DU_DBRMS )
                    STcat( dbname_ptr, DU_RMSTAIL ); 

		if (sqlca.sqlcode < 0)
		{
		    du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1862_CNF_UPDATE_FAIL,
			      2, 0, upgr_cb.du_opendb);
		    upgr_cb.Dbname_ptr->errors = TRUE;
		}

		/*
		** We must commit now, disconnect and reconnect
		** or we will not be able to access "dmpdev" in iidatabase.
		*/
		/* Disconnect from target database */
		if (upgr_cb.Connected)
		{
		    if (upg_dbg_out)
		    {
			SIfprintf(upgr_cb.du_dbg.du_file, "]==> (h) setting session to user database\n");
		    }
		    exec sql set_sql (session = :DB_SESSIONID);
		    exec sql commit;		/* commit, just to be safe */
		    EXEC SQL disconnect;
		    upgr_cb.Connected = FALSE;
		    if (upg_dbg_out)
		    {
		        SIfprintf(upgr_cb.du_dbg.du_file, "]==> (b) disconnect user database\n");
		    }
		}

		if (! open_target(CONNECT_EXCL))
		{
		    SIprintf("Error re-opening database %s \n", 
		    dbname_ptr);
		    continue;
		}
		exec sql set_sql (session = :DB_SESSIONID);

		/* If the database was created with large-page
		** catalogs, remodify the catalogs.  The modifier
		** utility will only redo the ones that are the wrong
		** page size.
		** We'll assume that the core catalog(s) are always the
		** proper page size, as they are handled in the server.
		*/
		if (! upgr_cb.Dbname_ptr->star_flag)
		{
		    exec sql select relpgsize
			into :page_size
			from iirelation
			where lowercase(relid) = 'iirelation'
			    and lowercase(relowner) = '$ingres';
		    check_sql(sqlca.sqlcode);
		    if (sqlca.sqlcode >= 0 && page_size > 2048)
		    {
			/* Make utility babble away */
			upgr_cb.du_msg->du_flags &= ~DU_SAVEMSG;
			(void) duc_modify_pagesize(page_size, FALSE,
				upgr_cb.du_msg);
			/* Ignore errors, this is a nice-to-do step. */
			/* Routine turns off upd-cat, turn back on */
			IIlq_Protect(TRUE);
			upgr_cb.du_msg->du_flags |= DU_SAVEMSG;
		    }
		}

	    } while (0); /* end of control loop */

	} /* be conversion */

	/* Fix up query trees if needed */
	if (upgr_cb.Dbname_ptr->tree_convert || upg_trees)
	{
	    char    dbname_curr[DB_MAXNAME+DU_TAIL_LEN+1];

	    exec sql commit;

	    /* If this is star db, we're connecting to local database now */
	    if (upgr_cb.du_dbmstype == DU_DBRMS)
		_VOID_ STpolycat(2, upgr_cb.Dbname_ptr->dbname, DU_RMSTAIL, 
				 dbname_curr);
	    else
		_VOID_ STcopy(upgr_cb.Dbname_ptr->dbname, dbname_curr);

	    fix_qry_trees(upgr_cb.Dbname_ptr->dbname, dbname_curr, 
		    FALSE, upgr_cb.Dbname_ptr->level); 

	    exec sql set_sql (session = :DB_SESSIONID);
	    IIlq_Protect (TRUE);         /* system catalog update privilege */
	}

	/* Now perform fe conversion */

	if ((upgr_cb.Dbname_ptr->fe_convert) &&
	    !(upgr_cb.Dbname_ptr->errors))
	{
	    /* May not be connected if no BE or tree convert.
	    ** Open the db now, don't be looking at iidbdb here!
	    */
	    if (! upgr_cb.Connected)
	    {
		if (! open_target(CONNECT_EXCL))
		{
		    SIprintf("Error re-opening database %s \n", dbname_ptr);
		    break;
		}
	    }
	    /* set user to DBA for FE convert */
	    exec sql set_sql (session = :DB_SESSIONID);
	    IIlq_Protect (TRUE);         /* system catalog update privilege */
	    exec sql commit;
	    (void) setauth(upgr_cb.Dbname_ptr->dba);

	    fe_dictinst(dbname_curr, dba_curr, upgr_cb.Dbname_ptr->level);

	    /* set user back to $ingres */
	    exec sql commit;
	    (void) setauth("$ingres");
	}
    } while (0);     /* end of control loop */

    /* check if we need to force re-generation of the IL encodings in the
       system catalogs and force re-compilation of all
       application components */

    if (upgr_cb.Dbname_ptr->reset_apps)
    {

        /* remove entries from ii_encodings, ii_encoded_forms */
    
        /* check if catalog exists (could be a nofeclients db) */
        if (rel_exists("ii_encoded_forms"))
        {
    	    if (upg_dbg_out)
    	        SIfprintf(upgr_cb.du_dbg.du_file, 
                   "]==> Upgrade requires reset of ABF catalog information\n");

            exec sql delete from ii_encoded_forms;
            check_sql(sqlca.sqlcode);
            if (sqlca.sqlcode < 0)
            {
    	        du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1875_UPGRADEDB_ENC,
                         4, 0, "ii_encoded_forms", 0, sqlca.sqlerrm.sqlerrmc);
    	        if (upg_dbg_out)
    	            SIfprintf(upgr_cb.du_dbg.du_file, 
                      "]==> Failed deleting rows from ii_encoded_forms\nSQL Error:%s\n",
                       sqlca.sqlerrm.sqlerrmc);
            }
    	    else 
            {
                if (upg_dbg_out)
    	            SIfprintf(upgr_cb.du_dbg.du_file, 
                        "]==> deleted %d rows from ii_encoded_forms\n",
                         sqlca.sqlerrd[2]);
            }
    
            exec sql commit;
        }
        if (rel_exists("ii_encodings"))
        {
            exec sql delete from ii_encodings;
            check_sql(sqlca.sqlcode);
            if (sqlca.sqlcode < 0)
            {
    	        du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1875_UPGRADEDB_ENC,
                         4, 0, "ii_encodings", 0, sqlca.sqlerrm.sqlerrmc);
    	        if (upg_dbg_out)
    	            SIfprintf(upgr_cb.du_dbg.du_file, 
                      "]==> Failed deleting rows from ii_encodings\nSQL Error:%s\n",
                       sqlca.sqlerrm.sqlerrmc);
            }
    	    else 
            {
                if (upg_dbg_out)
    	            SIfprintf(upgr_cb.du_dbg.du_file, 
                        "]==> deleted %d rows from ii_encodings\n",
                         sqlca.sqlerrd[2]);
            }
    
            exec sql commit;
        }
    
        /* update alter date for application objects - causes next imageapp to
         * be a -f one i.e. forces everything to re-compile */
        if (rel_exists("ii_abfobjects"))
        {
    
            exec sql update ii_objects
                     set alter_date=date_gmt(date('now'));
            check_sql(sqlca.sqlcode);
            if (sqlca.sqlcode < 0)
            {
    	        du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1876_UPGRADEDB_ABF,
                         2, 0,  sqlca.sqlerrm.sqlerrmc);
    	        if (upg_dbg_out)
    	            SIfprintf(upgr_cb.du_dbg.du_file, 
                      "]==> Failed updating ii_objects\nSQL Error:%s\n",
                       sqlca.sqlerrm.sqlerrmc);
            }
    	    else 
            {
                if (upg_dbg_out)
    	            SIfprintf(upgr_cb.du_dbg.du_file, 
                        "]==> updated %d rows in ii_objects\n",
                         sqlca.sqlerrd[2]);
            }
    
            exec sql commit;
        }
    }

    /* Issue message to indicate whether or not the database was converted */
    if (upgr_cb.Dbname_ptr->be_convert)
    {    
	if (upgr_cb.Dbname_ptr->errors == TRUE)
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU008F_NOT_UPGRADED, 4, 
		      0, upgr_cb.du_opendb, 0, SERVER_VERSION);
	else
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0090_IS_UPGRADED, 4, 
		      0, upgr_cb.du_opendb, 0, SERVER_VERSION);
    }
}

/*{
** Name: update_iidatabase()	-  Changes compat level and access codes in 
**				   iidatabase
**
** Description:
**	    This routine marks the database as operative and at the current
**	    level.  It switches from the user session to the iidbdb session.
**	    It does a commit after the update so that the shared lock taken
**	    on iidatabase is released as soon as we are done with it.
**	    
** Inputs:
**	none
**
** Outputs:
**	none
**
** Side Effects:
**	none
**
** History:
**	24-jul-91 (teresa)
**	    initial creation to update db's access in iidatabase.
**	17-dec-91 (teresa)
**	    Moved the set_sql staetment out of the control loop so that it is
**          always executed and this routine always returns with session set
**	    to the iidbdb session.
**	16-apr-92 (teresa)
**	    change "for" control loop to "do" to appease sun4 compiler warnings.
**	21-Feb-96 (prida01)
**	    Remove vnode part of database name (747490 
[@history_template@]...
*/
static VOID
update_iidatabase()
{
    EXEC SQL begin declare section;
	char	*dbname_curr;
	char	*dbname_star;
	i4	access_flags;
	i4	cmptlvl, minorlvl;
    EXEC SQL end declare section;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> (g) setting session to database database\n");
    }
    exec sql set_sql (session = :DBDB_SESSIONID);
    do		/* control loop */
    {
	if (upgr_cb.Dbname_ptr->errors)
	    break;

	dbname_curr = upgr_cb.Dbname_ptr->dbname;
	if (upgr_cb.Dbname_ptr->star_flag)
	    dbname_star = upgr_cb.Dbname_ptr->ddbname;

	/* Remove vnode from database name 74749*/
	{
	    char *tmp_dbname;
	    if (((tmp_dbname = (STchr(dbname_curr, ':'))) != NULL) &&
	    	STchr(tmp_dbname+ 1, ':') == (tmp_dbname + 1))
	    	    tmp_dbname += 2;
	    if (tmp_dbname != NULL)
		dbname_curr = tmp_dbname;
	}

	access_flags = upgr_cb.Dbname_ptr->access;

	if (upgr_cb.Dbname_ptr->tree_convert)
	{
	    fix_dbservice(dbname_curr);
	    if (upgr_cb.Dbname_ptr->star_flag)
		fix_dbservice(dbname_star);
	}

	/* Update the iidatabase entry for the converted database */
	if (upgr_cb.Dbname_ptr->be_convert)
	{
	    EXEC SQL COMMIT;
	    EXEC SQL set lockmode on iidatabase where level = table;

	    cmptlvl = DU_CUR_DBCMPTLVL;
	    minorlvl = DU_1CUR_DBCMPTMINOR;
	    EXEC SQL UPDATE iidatabase
	    SET dbcmptlvl = :cmptlvl,
		dbcmptminor = :minorlvl ,
		access = :access_flags
	    WHERE name = :dbname_curr;

	    /* If this is a STAR DB, update the DDB entry as well */
	    if (upgr_cb.Dbname_ptr->star_flag)
	    {
		EXEC SQL COMMIT;
		EXEC SQL set lockmode on iidatabase where level = table;

		EXEC SQL UPDATE iidatabase
		SET dbcmptlvl = :cmptlvl,
		    dbcmptminor = :minorlvl,
		    access = :access_flags
		WHERE name = :dbname_star;
	    }
	    EXEC SQL commit;
	}
	
    } while (0); /* end of control loop */

    /* Disconnect from target database */
    if (upgr_cb.Connected)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (h) setting session to user database\n");
	}
	exec sql set_sql (session = :DB_SESSIONID);
	exec sql commit;		/* commit, just to be safe */
	EXEC SQL disconnect;
	upgr_cb.Connected = FALSE;
    }
}

/*{
** Name: cv_database	- Convert non-iidbdb-only catalogs to latest format
**
** Description:
**	This routine just calls all the conversion functions necessary
**	to convert the currently connected database's non-dbdb-only
**	catalogs to latest format.
**
** Inputs:
**	dbname_curr		Name of the currently open database.
**	
** Outputs:
**	none
**	
** History:
**      07-jun-89 (ralph)
**          Initial creation.
**	09-aug-89 (ralph)
**	    Added call to cv_sequence()
**	2-oct-90 (pete)
**	    Removed call to cv_sequence()
**	10-dec-90 (neil)
**	    Alerters: introduce call to cv_event() *before* cv_protect() so
**	    that iipermits may reference the [new] iievent table.
**	1-feb-1991 (bryanp)
**	    Btree index compression: call cv_tables(), cv_indexes(), and
**	    cv_physical_tables() to update standard catalogs for new index
**	    compression information.
**	    Call cv_dbconstants to convert the iidbconstants view.
**	    Call cv_index_columns to convert the iiindex_columns view.
**	03-may-91 (teresa)
**	    add support for STAR.
**	07-25-91 (teresa)
**	    bring up to coding standards
**	16-apr-92 (teresa)
**	    change "for" control loop to "do" to appease sun4 compiler warnings.
**	05-oct-92 (jpk)
**	    Remove references to MSB of relstat, cv_relstat() routine.
**	1-feb-93 (jpk)
**	    Skip routines that convert to 6.4 if database already 6.4.
**	    Otherwise some needless conversion will not be harmless.
**	    E.g. if you drop and recreate iipermits, it will try to
**	    define a view on iiprotect, which may not yet have
**	    the 6.5 columns that the view is being defined on.
**	28-March-1994 (jpk)
**	    Add call to create database procedures that are new for 6.5.
**	8-jul-94 (robf)
**          Update to 65ES levels
**	14-jul-94 (robf)
**          Took out Converting... message and moved into
**          cv_upgrade() so people upgrading iidbdb didn't  get two messages
**      06-mar-1996 (nanpr01)
**          Added upgrade code for 2.0 upgrade - Variable Page Size Project. 
**      12-apr-1999 (nanpr01)
**          Fixed core catalogs that are created by 2.0 createdb to fix the
**	    attintl_id field.
**	17-nov-2000 (somsa01)
**	    Added running of cv_25_iirule().
**      31-Oct-2003 (wanfr01)
**          Bug 110858, INGSRV 2493
**          Recreate select permits to public on system catalog views
**          after they are dropped and recreated.
**	25-Aug-2004 (schka24)
**	    Update dbcapabilities for any non-current level;
**	    remove attintl update, done by core catalog stuff in server now.
**	    Add r3 update calls.
**	23-Jan-2006 (kschendel)
**	    Addition of B1 security dummy columns to SCI views requires
**	    that we drop/recreate stdcat views for pre-9.0.4 db's.
**	22-May-2006 (kschendel)
**	    Drop security-alarms catalog for iidbdb, since it has to be
**	    created in a special iidbdb-ish way.  Let it get recreated
**	    by the iidbdb code, or by fix qry trees if we go that way.
**	    Also, don't do stdcat grants for iidbdb yet, we haven't recreated
**	    all of the iidbdb stdcat views.
**	6-aug-2008 (dougi)
**	    Upgrade iiproc_params view if this is a V904 database to add 
**	    parameter modes. This happens automagically for pre-904 dbs.
**	8-aug-2008 (dougi)
**	    Upgrade iisequence catalog for pre-V904 databases to support 
**	    64-bit integer sequences.
**	10-feb-2009 (dougi) Bug 121661
**	    Fix above to use properly assigned level definitions.
**	27-Apr-2010 (kschendel) SIR 123639
**	    Always drop and recreate SCI views if we get this far,
**	    it's a lot simpler than trying to decide if it's necessary,
**	    and in some cases (e.g. upgrade of iiprotect) it's essential.
*/

/* Main list of catalogs to upgrade, not including iidbdb catalogs or
** catalogs done in the "early" upgrade.  There's no particular order
** sensitivity here.
**
** You might perhaps wonder why iischema is done so late, since table
** creates look at iischema to see if a "schema" needs to be created.
** It turns out that table create doesn't do that for $ingres.
*/
static char *main_db_list[] =
{
    /* "iicolcompare", **** not yet */
    "iidbms_comment",
    "iidistcol",
    "iidistscheme",
    "iidistval",
    "iievent",
    "iiextended_relation",
    "iigw06_relation",
    "iigw06_attribute",
    "iikey",
    "iipartname",
    "iiprivlist",
    "iirange",
    "iirule",
    "iischema",
    "iisecalarm",
    "iisectype",
    "iisequence",
    NULL
};

static VOID
cv_database(dbname_curr)
char	*dbname_curr;
{
    bool is_iidbdb;
    DU_ERROR    errcb;
    STATUS status;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> in cv_database (%s)\n", dbname_curr);
    }

    is_iidbdb = TRUE;
    if (STcompare(dbname_curr, DU_DBDBNAME) != 0)	/* if user db */
    {
	is_iidbdb = FALSE;
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (i) setting session to user database\n");
	}
	exec sql set_sql (session = :DB_SESSIONID);	/* connect to it */
    }

    /* Make sure all privileges are active */
    exec sql set session with privileges=all;

    /* Make sure we're $ingres */
    if (setauth("$ingres") != OK)
    {
	SIprintf("Error changing effective user ID\n");
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }

    /* Call routines to convert specific areas */
    do		    /* control loop */
    {
	/* drop all standard catalog views */
	/* Do this all the time if we get this far.  It's easier, and it
	** simplifies life for developers during a development cycle.
	*/
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0102_DROPPING_STDCAT_VIEWS, 0);
	duc_drop_stdcat_views(dbname_curr, upgr_cb.Dbname_ptr->star_flag);

	/* Giant list of catalogs to check and update */
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> Main catalog update list\n");
	}
	if (upgrade_catalog_list(dbname_curr, main_db_list) != E_DU_OK)
	{
	    upgr_cb.Dbname_ptr->errors = TRUE;
	    break;
	}

	/*
	** dbcapabilities need to be updated in most every release
	*/
	if (upgr_cb.Dbname_ptr->level < CURRENT_LEVEL)
	{
	    cv_dbcap();		
	    if ( upgr_cb.Dbname_ptr->errors )
		break;
	}

	if (upgr_cb.Dbname_ptr->level < V65_LEVEL)
	{
	    /* Create schemas */
	    duc_iischema(upgr_cb.Dbname_ptr->upcase); /* Insert $ingres by hand */
	    populate_iischema();
	    file_extend_convert_user();
	}

	if (upgr_cb.Dbname_ptr->level < V20_LEVEL)
	{
	    /* Normalize hashed date columns (as per bug 74033) */
	    cv_20_hashdate_tables(dbname_curr);
	}

	/*
	** pre-2.5 table conversions (mostly etab stuff)
	** Not necessary if coming from 6.4, as the conversions have
	** already been run (for the file-extend conversion);  the
	** same iiqef_convert_table builtin dbproc is used in either case,
	** but the 6.4 file extender hits all tables, while the pre-2.5
	** extender only needs to touch blobs and btrees.
	*/
	if (upgr_cb.Dbname_ptr->level >= V65_LEVEL
	  && upgr_cb.Dbname_ptr->level < V25_LEVEL)
	{
	    convert_tables_25(upgr_cb.Dbname_ptr->dbname);
	}


	/* Fill in any newly created columns, populate new catalogs, etc */
	populate_catalogs(upgr_cb.Dbname_ptr);

	/* Any stdcat views dropped should be re-created */
	/* If this is iidbdb, don't do the iidbdb views yet.
	** (maybe they depend on iidbdb stuff not upgraded yet.)
	** Don't bother to do this if we're going to upgrade trees, the
	** fix-qry-tree routine drops and recreates all std cats
	** just to make sure that unloaddb has a good set to work with
	** However we DO need standard catalog views for Star.
	*/
	if (! (upgr_cb.Dbname_ptr->tree_convert || upg_trees)
	      || upgr_cb.Dbname_ptr->star_flag )
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0103_RECREATING_STDCAT_VIEWS, 0);
	    duc_upgrade_stdcat_views("", upgr_cb.Dbname_ptr->upcase,
		    upgr_cb.Dbname_ptr->star_flag);

	    if (is_iidbdb)
	    {
		/* FIXME:  iisecurity_alarms is currently the only SCI view
		** that is a) in all databases and b) DIFFERENT in iidbdb
		** vs user db's.  Ideally this would be handled with
		** separate db context vs what-cats-to-do flags to the
		** view utilities, but I can't summon the energy to do
		** that right now.  Instead, drop that one view and let
		** the iidbdb code recreate it.
		*/
		exec sql drop view iisecurity_alarms;
		if (sqlca.sqlcode < 0)
		{
		    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2417_NODROP_SYSCAT, 4,
			    0, "iisecurity_alarms",
			    0, dbname_curr);
		    /* but keep going */
		}
		exec sql commit;
		/* Don't do grants yet, wait till all catalogs are done */
	    }
	    else
	    {
		/* Regrant select to public on system catalog views. */
		duc_grant_stdcat_views(dbname_curr, upgr_cb.Dbname_ptr->star_flag);
	    }

	    /* Make sure we re-create any internal procedures dropped */
	    duc_upgrade_internal_procs(dbname_curr, upgr_cb.Dbname_ptr->upcase,
		    upgr_cb.Dbname_ptr->star_flag);
	    IIlq_Protect(TRUE);		/* Restore priv, gets turned off */
	}

	exec sql commit;

	if (setauth("$ingres") != OK)
	    SIprintf("Warning: SET SESSION AUTHORIZATION $ingres failed\n");
	exec sql set session with privileges=all;

	if ( (upgr_cb.Dbname_ptr) && (upgr_cb.Dbname_ptr->star_flag))
	{
	    cv_star_cats();
	}

    } while (0);    /* end of control loop */

}

/*{
** Name: add_dbname - Add database name to linked list
**
** Description:
**	Adds a DBNAME_NODE to the end of a linked list of DBNAME_NODEs
**	
** Inputs:
**	dbname			    Name of database to be added to list.
**	level			    internal Vnnn_LEVEL for the db
**	cdbname			    Name of CDB if star_flag is true
**	ddbname			    Name of DDB if star_flag is true
**	star_flag		    set to true if we are upgrading a
**				      distributed database
**	upcase			    set to tru for FIPS database
**      dbservice		    dbservice flags
**
** Outputs:
**	upgr_cb.Dbname_head	    Points to new struct containing dbname.
**
**      Returns:
**	    FAIL		    If out of memory
**
** Side Effects:
**	    
** History:
**	05-aug-88 (jrb)
**	    Initial coding.
**	10-sep-88 (jrb)
**	    Now sets the new "errors" field to FALSE.
**	04-nov-88 (jrb)
**	    Added new input parameter for setting minorid on each db.
**	05-nov-88 (jrb)
**	    Added dba to struct so that we can enter each db as the dba
**	    rather than as $ingres (had problems trying to do the grants
**	    as $ingres).
**	07-jun-89 (ralph)
**	    Adapted for CV60TO70
**	07-jun-90 (ralph)
**	    Add logic to qualify fe/be conversion separately.
**	03-may-91 (teresa)
**	    Add support for STAR (ie, cdbs and ddbs)
**	25-jul-91 (teresa)
**	    move error message text to erduf.msg
**	22-Sep-2004 (schka24)
**	    Add to the end, not to the front, so that we can arrange
**	    for Star databases to follow non-Star databases.
[@history_template@]...
*/
static VOID
add_dbname(dbname, dba, level, access, locname, areaname,
	   cdbname, ddbname, star_flag, upcase, dbservice)
char		*dbname;
char		*dba;
i4		level;
i4		access;
char		*locname;
char		*areaname;
char		*cdbname;
char		*ddbname;
i4		star_flag;
bool		upcase;
i4		dbservice;
{
    DBNAME_NODE	    *temp;
    DBNAME_NODE	    *p;
    STATUS	    status;

    temp = (DBNAME_NODE *) MEreqmem((u_i4)0, 
				    (u_i4)sizeof(DBNAME_NODE), 
				    (bool)FALSE, 
				    &status);
    if (status != OK)
	upgr_exit(__LINE__,  DU_FAIL_EXIT, E_DU6013_NO_MORE_MEMORY);
 
    _VOID_ STcopy(dbname, temp->dbname);	/* insert into list */
    _VOID_ STcopy(dba, temp->dba);
    _VOID_ STcopy(locname, temp->locname);
    _VOID_ STcopy(areaname, temp->areaname);
    if (star_flag)
    {
	_VOID_ STcopy(ddbname, temp->ddbname);
	_VOID_ STcopy(cdbname, temp->cdbname);
	temp->star_flag=TRUE;	
    }
    else
    {
	temp->star_flag=FALSE;
	temp->ddbname[0]='\0';
	temp->cdbname[0]='\0';
    }
    if (upcase)
      temp->upcase = TRUE;
    else
      temp->upcase = FALSE;
    temp->level	  = level;
    temp->access  = access;
    temp->errors  = FALSE;
    temp->tree_error = FALSE;
    temp->nextdb  = NULL;
    temp->be_convert = FALSE;
    temp->fe_convert = FALSE;
    temp->first_open = TRUE;

    /* Determine if we need to do tree upgrade */
    if (upg_trees 
	|| (upgr_cb.dbmsinfo_lp64 == 'Y' && (dbservice & DU_LP64) == 0)
	|| (upgr_cb.dbmsinfo_lp64 != 'Y' && (dbservice & DU_LP64)) )
    {
	temp->tree_convert = TRUE;
    }
    else
    {
	temp->tree_convert = FALSE;
    }

    temp->reset_apps = FALSE;

#ifdef LITTLE_ENDIAN_INT

    /* if this is a 64bit server but the DB was 32bit or vice-versa then
       set flag to say force re-generation of encoded forms
       and IL and force re-compile of applications */

    if ((upgr_cb.dbmsinfo_lp64 == 'Y' && (dbservice & DU_LP64) == 0)
	|| (upgr_cb.dbmsinfo_lp64 != 'Y' && (dbservice & DU_LP64)) )
    {
        temp->reset_apps = TRUE;
    }
#endif

    p = upgr_cb.Dbname_head;
    if (p == NULL)
    {
	upgr_cb.Dbname_head = temp;
    }
    else
    {
	while (p->nextdb != NULL)
	    p = p->nextdb;
	p->nextdb = temp;
    }
}

/*{
** Name: handle_esqlerr - Print esql error
**
** Description:
**	If an esql error occurs, this routine retrieves the error from
**	the SQLCA and prints it.  The error is marked either in the iidbdb
**	or the current database in the dbname list depending on what
**	upgr_cb.Dbname_ptr is set to.
**	
** Inputs:
**	none
**
** Outputs:
**	none
**
**     Side Effects:
**	    Will affect the upgr_cb.Dbname_ptr->errors field or the upgr_cb.Iidbdbok
**	    global.
**	    
** History:
**	04-aug-88 (jrb)
**	    Initial coding.
**	15-oct-91 (teresa)
**	    modified to expect possible Dbname_ptr during iidbdb conversion
[@history_template@]...
*/
VOID
handle_esqlerr()
{
    EXEC SQL begin declare section;
	char	error_buf[SQL_MSG_BUF_LEN];
    EXEC SQL end declare section;

    if (upgr_cb.Ignore_errors)
	return;
 
    if (upgr_cb.Dbname_ptr != NULL)
    {
	/* either we had an error while actually upgrading the iidbdb or
	** we had an error on the use database */

	if (STcompare (upgr_cb.Dbname_ptr->dbname, ERx("iidbdb"))==0)
	{   
	    /* its the iidbdb */
	    if (upgr_cb.Iidbdbok)
	    {
		SIprintf(
    "UPGRADEDB cannot complete any conversions due to the following error\n");
		du_log (upgr_cb.du_skiplog, &upgr_cb.du_log,
    "UPGRADEDB cannot complete any conversions due to the following error\n");
		upgr_cb.Iidbdbok = FALSE;
		upgr_cb.Dbname_ptr->errors = TRUE;
	    }
	}
	else if (!upgr_cb.Dbname_ptr->errors)
	{   
	    /* its a user database and the error has not previously been
	    ** reported */
	    SIprintf("Aborting upgrade of this database because of error");
	    du_log (upgr_cb.du_skiplog, &upgr_cb.du_log,
		   "Aborting upgrade of this database because of error");
	    upgr_cb.Dbname_ptr->errors = TRUE;  /* this db was not fully converted */
	}


    }
    else	/* iidbdb error during informational queries  before we
		** began converting the iidbdb */
    {
	if (upgr_cb.Iidbdbok)
	{
	    SIprintf(
"UPGRADEDB cannot complete any conversions due to the following error\n");
	    du_log (upgr_cb.du_skiplog, &upgr_cb.du_log,
"UPGRADEDB cannot complete any conversions due to the following error\n");
	    upgr_cb.Iidbdbok = FALSE;
	}
    }

    EXEC SQL inquire_ingres (:error_buf = ERRORTEXT);
    SIprintf("\n%s",error_buf);
    du_log (upgr_cb.du_skiplog, &upgr_cb.du_log, error_buf);
    du_log (upgr_cb.du_skiplog, &upgr_cb.du_dbg, error_buf);
}

/*{
** Name: handle_equelerr - Print equel error
**
** Description:
**	If an equel error occurs, this routine retrieves the error from
**	ingres and prints it.  The error is marked either in the iidbdb
**	or the current database in the dbname list depending on what
**	upgr_cb.Dbname_ptr is set to.
**
**	*Note* this handler is only in effect for part of upgradedb,
**	namely those routines textually between main() and upgr_exit(__LINE__, ).
**	I suspect someone didn't understand how "whenever sqlerror" works.
**	This needs to be fixed, but there's lots of code later in upgradedb
**	that ignores errors without setting the Ignore_error flag...
**	(schka24 Sep 2004)
**
** Inputs:
**	ernum					ingres error number
**
** Outputs:
**	none
**
**	Returns:
**	    0		To supress printing of error message by ingres.
**
** Side Effects:
**	Will affect the upgr_cb.Dbname_ptr->errors field or the Iidbdbok global.
**	    
** History:
**	28-nov-88 (jrb)
**	    Initial coding.
**	15-oct-91 (teresa)
**	    modified to expect possible Dbname_ptr during iidbdb conversion
[@history_template@]...
*/
i4
handle_equelerr(ernum)
i4 *ernum;
{
##  char    error_buf[SQL_MSG_BUF_LEN];

    if (upgr_cb.Ignore_errors)
	return(0);

    if (upgr_cb.Dbname_ptr != NULL)
    {
	/* either we had an error while actually upgrading the iidbdb or
	** we had an error on the use database */

	if (STcompare (upgr_cb.Dbname_ptr->dbname, ERx("iidbdb"))==0)
	{   
	    /* its the iidbdb */
	    if (upgr_cb.Iidbdbok)
	    {
		SIprintf(
    "UPGRADEDB cannot complete any conversions due to the following error\n");
		du_log (upgr_cb.du_skiplog, &upgr_cb.du_log,
    "UPGRADEDB cannot complete any conversions due to the following error\n");
		upgr_cb.Iidbdbok = FALSE;
	    }
	}
	else if (!upgr_cb.Dbname_ptr->errors)
	{   
	    /* its a user database and the error has not previously been
	    ** reported */
	    SIprintf("Aborting upgrade of this database because of error");
	    du_log (upgr_cb.du_skiplog, &upgr_cb.du_log,
		   "Aborting upgrade of this database because of error");
	    upgr_cb.Dbname_ptr->errors = TRUE;  /* this db was not fully converted */
	}


    }
    else	/* iidbdb error during informational queries  before we
		** began converting the iidbdb */
    {
	if (upgr_cb.Iidbdbok)
	{
	    SIprintf(
"UPGRADEDB cannot complete any conversions due to the following error\n");
	    du_log (upgr_cb.du_skiplog, &upgr_cb.du_log,
"UPGRADEDB cannot complete any conversions due to the following error\n");
	    upgr_cb.Iidbdbok = FALSE;
	}
    }

##  inquire_ingres(error_buf = ERRORTEXT);
 
    SIprintf("\n%s",error_buf);
    du_log( upgr_cb.du_skiplog, &upgr_cb.du_log, error_buf);
    du_log (upgr_cb.du_skiplog, &upgr_cb.du_dbg, error_buf);

    /* returning 0 tells ingres not to print error message */
    return(0);
}


/*{
** Name: handle_ex	- Exception handler for user aborts or AVs
**
** Description:
**      If the user aborts the program or an unexpected exception occurs,
**	this function will clean up and abort smoothly. 
**
** Inputs:
**      ex_parms                        This is an EX_ARGS struct.
**
** Outputs:
**      none
**
** History:
**	04-aug-88 (jrb)
**	    Initial coding.
**	23-jul-91 (teresa)
**	    rewrote to meet coding standards and also to use exit handler.
**	13-sep-96 (nick)
**	    Must use EXmatch() to comapre against EX types.
[@history_template@]...
*/
STATUS
handle_ex(ex_parms)
EX_ARGS            *ex_parms;
{
    switch (EXmatch(ex_parms->exarg_num, 2, EXBUSERR, EXINTR))
    {
      case 1:
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU3601_ACCESS_VIOLATION, 0);
	break;
 
      case 2:
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU3600_INTERRUPT, 0);
	break;

      default:
      {
	char	name[DB_MAXNAME+1];

	if (upgr_cb.du_opendb[0]=='\0')
	    STcopy (DU_DBDBNAME, name);
	else
	    STcopy (upgr_cb.du_opendb, name);

	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, W_DU1010_UTIL_ABORT, 4,
		 0, "Upgrade", 0, name);
	break;
      }
    }
 
    upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);

    /* Put the return value here so lint won't complain. */
    return(EXRESIGNAL);
}

/*{
** Name: cv_online	- Conversion for online backup
**
** Description:
**	Performs necessary conversion for online backup.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** History:
**	17-jun-89 (ralph)
**	    Initial creation for CV60TO70
**	20-Sep-2004 (schka24)
**	    Don't get faked out by ansi uppercase databases
[@history_template@]...
*/
static VOID
cv_online()
{
##	int	rows_database;
##	i4	tid_database;

##	RETRIEVE (
##		tid_database = iiattribute.tid)
##	WHERE
##		lowercase(iiattribute.attname)="dmpdev"
##	  AND	iiattribute.attrelid=DU_B_DATABASE_TAB_ID
##	  AND	iiattribute.attrelidx=DU_I_DATABASE_TAB_ID

##	INQUIRE_INGRES (
##		rows_database = ROWCOUNT)

	/* Exit if this field is present */
	if (rows_database != 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU009D_IIDATABASE_CURRENT, 2,
		      0, SERVER_VERSION);
	    return;
	}

	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU009E_UPG_IIDATABASE, 0);

##	REPLACE iidatabase (xtra="ii_dump")

	if (!upgr_cb.Iidbdbok)
		return;

##	REPLACE iiattribute (attname="dmpdev")
##	WHERE iiattribute.attname="xtra"
##	AND iiattribute.attrelid=DU_B_DATABASE_TAB_ID

	if (!upgr_cb.Iidbdbok)
		return;

	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU009F_APPEND_DUMP_LOC, 0);

##	APPEND TO iilocations (status=2, lname="ii_dump", area="II_DUMP")
}

/*{
** Name: cv_dbcap	- Add iidbcapabilities for 6.5
**
** Description:
**	Add iidbcapabilities entries for 6.5
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** History:
**	17-jun-89 (ralph)
**	    Initial creation for CV60TO70
**	02-jul-90 (ralph)
**	    Added 6.3/02 iidbcapabilities entries
**	12-mar-1991 (bryanp)
**	    Picked up some standard catalog changes from the FE group:
**		ING6.3 ==> ING6.4, 00603 ==> 00604 (iidbcapabilities)
**	06-may-91 (teresa)
**	    and STANDARD_CATALOG_LEVEL to iidbcapabilities.
**      09-Mar-95 (lawst01) bug 67381
**          added DB_DELIMITED_CASE and DB_REAL_USER_CASE both with 
**          values of 'LOWER' to iidbcapabilities table.
**      06-mar-1996 (nanpr01)
**	    Instead of using OPEN/SQL_LEVEL and 00605, use the standard
**	    defines DU_DB7_OPENSQL_LEVEL and DU_DB7_CUR_OPENSQL_LEVEL.
**	07-jan-2002 (toumi01)
**	    changed MAX_COLUMNS from 300 to 1024
**	30-Aug-2004 (schka24)
**	    update existing max-columns to 1024 as well.
**	17-sept-2008 (dougi)
**	    Add SQL_MAX_DECIMAL_PRECISION.
**	 1-Oct-09 (gordy)
**	    Added SQL_MAX_PROCEDURE_NAME_LEN.
**	28-Apr-2010 (kschendel) SIR 123639
**	    Table drive.
*/
static VOID
cv_dbcap()
{
	DUC_DBCAPS *table;
	i4	i;
exec sql begin declare section;
	char	*cap, *value;
exec sql end declare section;

exec sql whenever sqlerror call handle_esqlerr;

	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00A0_UPDATING_CAPS, 0);

	i = Duc_num_dbcaps;
	table = &Duc_dbcaps[0];
	while (--i >= 0)
	{
	    cap = &table->duc_capability[0];
	    value = &table->duc_value[0];
	    exec sql repeated update iidbcapabilities
		set cap_value = :value
		where cap_capability = :cap;
	    if (sqlca.sqlerrd[2] == 0)
		duc_ins_capabilities(cap, value);
	    ++table;
	}
	exec sql commit;
	exec sql modify iidbcapabilities to reconstruct;
	exec sql commit;

exec sql whenever sqlerror continue;

}

/*{
** Name: cv_protect	- Convert iiprotect
**
** Description:
**
**	Convert iiprotect.  This needs a special converter because
**	one of the changes is to byte-ize the column bitmap, so
**	we need cv_bitmap_cols instead of the usual copy_existing_columns.
**
**	Some older versions had an index, iixprotect, but those older
**	versions will all get here (because of the byte-izing in 10.0
**	if for no other reason).  So the index will be dropped, no need
**	to check for it specifically.
**
**	iiprotect is one of the system catalogs checked / affected by
**	drop statement.  Fortunately, all the columns that DROP needs
**	are in the same position since at least 6.4.  The iiprotect row
**	is wider, but DROP doesn't care.  One side effect is that
**	row(s) will be deleted from iiprotect after the temp copy is
**	made, and that has to be allowed for (see inline).
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** History:
**	17-jun-89 (ralph)
**	    Initial creation for CV60TO70
**	10-dec-90 (neil)
**	    Alerters: iipermits also includes references to iievent, so
**	    this is called *after* cv_event.
**	14-oct-91 (teresa)
**	    updated to convert to 6.5, also rewrote in SQL
**	11-sep-92 (andre)
**	    MSB in relstat is no longer being set - change
**	    mod((relstat+1073741824+1073741824),x) back to mod(relstat,x)
**	05-oct-92 (jpk)
**		Remove references to MSB of relstat, cv_relstat() routine.
**	14-jul-94 (robf)
**          Initialize the procrtime values (since they are available)
**          and proflags (since otherwise verifydb may complain about
**          QUEL/SQL permit mismatch) (reported as bug 64589)
**	30-Aug-2004 (schka24)
**	    Additions for r3.  Fix objtype for dbevents from 6.x.
**	    Delete the old iiprotect entry for itself, rest of that
**	    old priv is deleted by the drop.
**	27-Apr-2010 (kschendel) SIR 123639
**	    Add BYTE-izing conversion of prodomset columns.
**	    Unconditional update, caller decides whether it's needed.
*/
static VOID
cv_iiprotect(char *dbname)
{
    bool prior_63;
    bool prior_65;
    bool prior_r3;
    bool event_exists;
    i4 n;


    /* we need to upgrade the iiprotect catalog */
    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00A2_UPG_IIPROTECT, 0);

    prior_r3 = tbl_lacks_col("iiprotect","prodomset33");
    prior_65 = tbl_lacks_col("iiprotect","procrtime1");
    prior_63 = tbl_lacks_col("iiprotect","proseq");
    make_copy_of(upgr_cb.Dbname_ptr->dbname, "iiprotect");
	
    exec sql drop table iiprotect;
    if (upgr_cb.Dbname_ptr->errors == TRUE)
	return;

    /* This is something of a kludge mostly to make verifydb happy.
    ** When we drop iiprotect, the server will clean out the protections
    ** for it;  which is clearly sort of circular, but rows get deleted
    ** from iiqrytext (at least).  Unfortunately we've already picked
    ** up a copy of the iiprotect row for iiprotect, and it will get
    ** stuffed back into the new iiprotect;  thus leaving a discrepancy
    ** between iiprotect and iiqrytext.
    ** The cure is to remove iiprotect's row(s) from the temp copy
    ** and properly re-grant iiprotect later on.
    */

    exec sql delete from iitmp_iiprotect p
	where exists (select * from iirelation r
	where lowercase(r.relid) = 'iiprotect'
	    and lowercase(r.relowner) = '$ingres'
	    and p.protabbase = r.reltid and p.protabidx = r.reltidx);
    check_sql(sqlca.sqlcode);

    /* Copy back the temp table into iiprotect, dealing with the bitmap
    ** int-to-byte conversion.  Don't need to check whether table
    ** exists, it's always there.
    */
    n = 33;
    if (prior_r3)
	n = 10;
    if (prior_63)
	n = 4;
    cv_bitmap_cols(dbname, "iiprotect", n);

    /* if we were at r3 or better, done now. */
    if (! prior_r3)
	return;

    /* when we populate iiprotect from iitmp_iiprotect, all non-specified
    ** fields will take on default values */

    event_exists = rel_exists("iievent");
    if (!prior_65 && !prior_63 && event_exists)
    {
	/* Coming from at least 6.5 (OI 1.x) */
	/* Fix junk leftover from pre-R3 conversions from 6.4:  it put
	** P instead of E into the object type for converted dbevent
	** permits.  (Permits created post-64 are OK.)
	*/
	exec sql update iiprotect p from iievent ev
	    set probjtype = 'E',
		probjname = ev.event_name,
		probjowner = ev.event_owner
	    where ev.event_idbase = p.protabbase
		and ev.event_idx = p.protabidx
		and p.probjtype != 'E';
	check_sql(sqlca.sqlcode);
	return;
    }

    /* Here if converting from 6.4 or earlier, lotsa stuff to do */
    if (prior_63)
    {
	/* pre-6.3, so fill in 6.3 and 6.5 fields */
	exec sql update iiprotect
	    set prograntor = dbmsinfo('dba'),
		proopctl = proopset,
		probjtype = 'P';
	UpgrExitOnError(sqlca.sqlcode);

	exec sql update iiprotect set progtype = 3 where prouser = ' %';
	UpgrExitOnError(sqlca.sqlcode);
    }
    else
    {
	/* Must be prior_65, i.e. coming from 6.3 or 6.4. */
	exec sql update iiprotect
	    set prograntor = dbmsinfo('dba'),
		proopctl = proopset,
		probjtype = 'P',
		procrtime1 = proqryid1,
		procrtime2 = proqryid2;
	check_sql(sqlca.sqlcode);
	/* 
	** Mark SQL permits (from iiqrytext) as SQL in iiprotect as well
	** this is done since  verifydb does a consistency check between
	** the two flags
	*/
	exec sql update iiprotect p
		 set proflags=1
		 where exists (select * 
			       from iiqrytext q
			       where q.txtid1=p.proqryid1
			       and   q.txtid2=p.proqryid2
			       and   q.status=2)
		 and proflags=0;
	check_sql(sqlca.sqlcode);
    }
    if (upgr_cb.Dbname_ptr->errors == TRUE)
	return;

    /* now fill in 6.5 specific fields */

    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> Updating specific permit fields...\n");

    /* set probjtype for everything except for procedures -- this field
    ** was initialized to procedures */
    exec sql update iiprotect from iirelation set probjtype =
	 charextract('TVI', 
	    (mod((relstat/32), (2))+
	    (2*(mod((relstat/128), (2)))))+1)
    where protabbase = reltid and protabidx = reltidx;
    check_sql(sqlca.sqlcode);

    /* Don't forget dbevents.  Fortunately, events use the same
    ** tabid space as tables and procs.
    */
    if (event_exists)
    {
	exec sql update iiprotect p from iievent ev
	    set probjtype = 'E',
		probjname = ev.event_name,
		probjowner = ev.event_owner
	    where ev.event_idbase = p.protabbase
		and ev.event_idx = p.protabidx;
	check_sql(sqlca.sqlcode);
    }

    /* get object name/owner for tables, views, indexes */
    exec sql update iiprotect from iirelation 
	set probjname=relid, probjowner=relowner 
	where protabbase = reltid and protabidx = reltidx;
    check_sql(sqlca.sqlcode);

    /* get object name/owner for procedures */
    exec sql update iiprotect from iiprocedure 
	set probjname=dbp_name, probjowner=dbp_owner
	where protabbase = dbp_id and protabidx = dbp_idx;
    check_sql(sqlca.sqlcode);
} /* cv_iiprotect */

/*{
** Name: cv_star_cats - Master to convert star CDB catalogs
**
** Description:
**	This routine makes star CDB catalogs compatabile with what
**	the current star server expects.
**
**	If CDB was at level 6.2, then it needs the star 2pc catalogs added
**	to bring up to 6.3 compatibility, plus any other changes required to
**	bring up to current level compatability.
**
**	If CDB was at level 6.3, then it needs a little touch up to the
**	iidbcapabilities catalog to bring up to 6.4, plus any other changes
**	required to bring it up to the current level compatability.
**
**	If CDB was at level 6.4, then we need to create the STAR STANDARD
**	CATALOGS.  The current 6.4 star standard catalogs include:
**		iiregisted_objects
**
** FIXME FIXME PROBABLY NEEDS A LOT MORE DONE FOR 10.0 long names.
** update-catalog-list could handle it, but the question is, do we
** need to re-register all that stuff in the distributed database?
** which would in turn require a much smarter re-registerer than
** what exists now (which is either everything or iidd_stats only).
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** Side Effects:
**	none.
**
** History:
**	03-may-91 (teresa)
**	    Created for STAR.
**	16-oct-91 (teresa)
**	    added support for 6.5 star standard catalog iiregistered_objects.
**	10-Jan-93 (jpk)
**	    added support for 6.5 star standard catalog iiprocedures
**      06-mar-1996 (nanpr01)
**	    added support for 2.0 star standard catalog. Force update of
**	    star standard catalog.
**	21-Sep-2004 (schka24)
**	    Drop obsolete (6.4?) catalog views.
*/
static VOID
cv_star_cats()
{

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0114_CONVERTING_STAR, 0);
    switch (upgr_cb.Dbname_ptr->level)
    {
    case V61_LEVEL:
	/* there was no STAR in 6.1, so there is nothing to do */
	break;	
    case V62_LEVEL:
	/* some earlier releases of 6.2 did NOT have star 2PC catalogs.  So,
	** call a routine to assure they are created, then do the same
	** conversion we did for 6.3 by falling through to the 6.3 case */
	star_2pc();
    case V63_LEVEL:
	/* 6.2 and 6.3 star cdbs are identical, so upgrade them to 6.4 */
	starto64();
    case V64_LEVEL:
	/* 6.4 level, so build star starndard catalogs */
	star_std_cats();
    case V65_LEVEL:
    case V65ES_LEVEL:
    case V12_LEVEL:
    case V20_LEVEL:
    case V25_LEVEL:
    case V26_LEVEL:
	/* Refresh Star version of iitables, etc */
	star_20_std_cats(upgr_cb.Dbname_ptr->upcase);

	/* Drop a couple of obsolete Star catalog views.  I don't know
	** how far back these go, so just pitch them, no errors.
	*/
	exec sql commit;
	upgr_cb.Ignore_errors = TRUE;
	exec sql drop iidd_ddb_finddbs;
	exec sql drop iidd_views_cat;
	upgr_cb.Ignore_errors = FALSE;
	exec sql commit;
	break;

    default:
	/* already at current level, so break */
	if ((upgr_cb.upgtrace[UPG02_STAR_STDCATS]) &&
	    (upgr_cb.Dbname_ptr->level > V12_LEVEL))
	{
	    /* force star standard catalogs to be built if they dont exist */
	    star_std_cats();
	    star_20_std_cats(upgr_cb.Dbname_ptr->upcase);
	}
	break;
    }
}

/*{
** Name: starto64 - make 6.2 or 6.3 CDB 6.4 compatabile
**
** Description:
**	This routine makes star 6.2 or 6.3 CDB catalogs compatabile with
**	6.4.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** Side Effects:
**	none.
**
** History:
**	03-may-91 (teresa)
**	    Created for STAR.
*/
static VOID
starto64()
{
    EXEC SQL begin declare section;
	i4	cnt;
    EXEC SQL end declare section;

    /* change INGRES/QUEL_LEVEL from 00100 to 00000 in iidd_dbcapabilities */
    exec sql update iidd_dbcapabilities set cap_value= :DU_DB5_STAR_INGQUEL_LEVEL
	where cap_capability = :DU_DB5_INGQUEL_LEVEL;

    /* add STANDARD_CATALOG_LEVEL to iidd_dbcapabilities */
    exec sql select count(cap_capability) into :cnt from iidd_dbcapabilities
	where cap_capability = :DU_DB6_STDCAT_LEVEL;
    if (cnt==0)
    /* 6.2 STANDARD_CATALOG_LEVEL -- 6.2, 6.3 and 6.4 star all ship with a
    ** 6.2 standard catalog interface */
	exec sql insert into iidd_dbcapabilities (cap_capability, cap_value)
		values (:DU_DB6_STDCAT_LEVEL,:DU_DB6_STAR_STDCAT_LEVEL);

}

/*{
** Name: star_std_cats() - build the star standard catalog interface
**
** Description:
**
**	This routine builds the star standard catalog interface.  This is
**	currently comprised of:
**
**	Star Standard Catalog ii_registered_objects:
**	    COL NAME		DATA TYPE   DESCRIPTION
**	    -----------------  ---------    ------------------------------------
**	    ddb_object_name    char(32)	    name of star registered object (the 
**					    registered object will be a table, 
**					    view or index)
**	    ddb_object_owner   char(32)	    owner of star registered object
**	    register_date      char(25)	    date object was registered
**	    ldb_database       char(32)	    name of LDB database that registered
**					    object resides in
**	    ldb_node	       char(32)	    node that ldb_database resides on
**	    ldb_dbmstype       char(32)	    type of database ldb_database is 
**					    ('INGRES', 'RMS', 'DB2','RDB' etc).
**					    This is the same types used by 
**					    iinamu.
**	    ldb_object_name    char(32)	    name the LDB uses for the 
**					    registered object
**	    ldb_object_owner   char(32)	    owner of the registered object in 
**					    the LDB
**	    ldb_object_type    char(8)	    Type of local object:  
**						"T" for table,
**						"V" for view, 
**						"I" for index.
**
**
**	The stardard catalog is created in the CDB with the "ii" prefix being
**	replaced with the "iidd_" prefix. Example:  iiregistered_objects is
**	created in the LDB as iidd_registered_objects.
**
**	Then a routine is called to populate the STAR catalogs from the CDB
**	catalogs to make the star standard catalogs known to the installation.
**	This routine is shared between createdb and upgradedb, so it resides
**	in ducommon.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** Side Effects:
**	none.
**
** History:
**	16-oct-91 (teresa)
**	    Created for STAR.
*/
static VOID
star_std_cats()
{
    EXEC SQL begin declare section;
	i4	obj_base;
    EXEC SQL end declare section;
    DU_STATUS	stat;


    exec sql select object_base+1 into :obj_base from iidd_ddb_object_base;

    stat=   duc_register_starcats(obj_base, &DU_upg_object_map[0], 
				  &DU_upg_idx_map[0], 
				  upgr_cb.Dbname_ptr->cdbname,
				  &upgr_cb.du_msg);
    if (stat != E_DU_OK)
    {
	upgr_cb.Dbname_ptr->errors = TRUE;
	du_talk(__LINE__, DU_ERR_FMTD, &upgr_cb, 0, upgr_cb.du_msg->du_utilerr, 0);
	return;
    }
}

/*{
** Name: star_2pc - make star 2pc catalogs
**
** Description:
**	This routine makes star 2pc catalogs for 6.1 CDBs that are being
**	converted to 6.4 or above.  If the catalog already exists, this routine
**	does NOT touch them.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** Side Effects:
**	none.
**
** History:
**	03-may-91 (teresa)
**	    Created for STAR.
*/
static VOID
star_2pc()
{
    if (!rel_exists("iidd_ddb_dxlog"))
    {
	duc_create_catalog("iidd_ddb_dxlog");
	duc_modify_catalog("iidd_ddb_dxlog");
	exec sql commit;
    }

    if (!rel_exists("iidd_ddb_dxldbs"))
    {
	duc_create_catalog("iidd_ddb_dxldbs");
	duc_modify_catalog("iidd_ddb_dxldbs");
    }
}

/*{
** Name: upgr_exit	- upgradedb exit handler
**
** Description:
**
**  Exit neatly by:
**  1) Print any user specified messages, specified via parameter msg_id. That
**	parameter must specify a message that does not require any parameters.
**	If DU_OK_EXIT was specified, the message will be printed according
**	to the message mode (ie, DU_MODESENS).  If DU_FAIL_EXIT was specified,
**	the message will always be printed.
**  2) Close the upgradedb log file.
**  3) disconnect from any dbs that upgradedb may be connected to.  If
**     any DBs are left open when the exit handler is called, it will
**     abort the transaction if DU_FAIL_EXIT is specified and commit the 
**     transaction if DU_OK_EXIT is specified.  
**
** Inputs:
**	    exit_stat		    Exit status to return to invoker:
**					DU_OK_EXIT -- returns PCexit(OK)
**					DU_FAIL_EXIT -- returns PCexit(FAIL)
**				        NOTE: if value is neither DU_OK_EXIT
**					      nor DU_FAIL_EXIT, then it is 
**					      forced to DU_FAIL_EXIT.
**	    msg_id			message to print on exit
**
** Outputs:
**	none
**	Returns:
**	    OK via PC_EXIT
**	    FAIL via PC_EXIT
**	Exceptions:
**	    none
**
** Side Effects:
**	    log file is closed
**	    if any ESQL transaction exists, it is aborted
**
** History:
**      23-jul-91 (teresa)
**          Initial creation.
**      13-mar-98 (nicph02)
**          Added call to rm_iiqef_procedures to drop iiqef_ procedures.
[@history_template@]...
*/
static VOID
upgr_exit(line, exit_stat, msg_id)
i4		    line;
DU_STATUS	    exit_stat;
i4		    msg_id;
{
    i4		msg_mode;
    
    EXEC SQL WHENEVER SQLERROR continue;
    
    if (exit_stat == DU_OK_EXIT)
	msg_mode = DU_MODESENS;
    else if (exit_stat == DU_FAIL_EXIT)
	msg_mode = DU_ALWAYS;
    else
    {
	/* invalid exit_stat was specified, so force to FAIL */
	exit_stat = DU_FAIL_EXIT;
	msg_mode = DU_ALWAYS;
    }

    /* caller may specify a message to print.  If a message is specified,
    ** print it with the correct message mode */
    if (msg_id)
        du_talk(line, msg_mode, &upgr_cb, msg_id, 0);

    /* see if there is a database to close. */
    if (upgr_cb.Connected)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (j) setting session to user database\n");
	}
	exec sql set_sql (session = :DB_SESSIONID);
	if (exit_stat == DU_OK_EXIT)
	    exec sql commit;
	else 
	    exec sql rollback;
	IIlq_Protect(FALSE);		/* Remove catalog update permission */

        rm_iiqef_procedures();    /* Bug 89164: remove all iiQEF procedures */

	EXEC SQL DISCONNECT;
    }
    if (upgr_cb.dbdb_open)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (k) setting session to database database\n");
	}
	exec sql set_sql (session = :DBDB_SESSIONID);
	if (exit_stat == DU_OK_EXIT)
	    exec sql commit;
	else 
	    exec sql rollback;
	IIlq_Protect(FALSE);
	EXEC SQL DISCONNECT;
    }

    du_fclose(&upgr_cb.du_log, upgr_cb.du_msg);

    if (exit_stat == DU_OK_EXIT)
	    PCexit(OK);
    else
	    PCexit(FAIL);
}

/*{
** Name: validate_db - verify db is known to the installation
**
** Description:
**
**  Search the iidatabase catalog to see if the input dbname is in that
**  catalog.  If not, return FALSE.  If so, return TRUE.  In either case,
**  there is a special set lock on iidatabase, so be sure to do a commit
**  after accessing iidatabase.
**
**  This routine is necessary because there is a short window where a database
**  name may have been cached and then some other session did a destroydb on 
**  this database.  So, if upgradedb cannot connect to the target database, 
**  then we need to assure that the database still exists.  The usual case
**  will be that the database does indeed still exist.
**
** Inputs:
**	dbname			name of database (null terminated)
**
** Outputs:
**	none
**	Returns:
**	    TRUE		=> database is still known to installation
**	    FALSE		=> database is no longer known to installation
**	Exceptions:
**	    none
**
** Side Effects:
**	    Session is switched to iidbdb session and then switched back.
**	    A brief lock is taken (then released) on the iidatabase
**
** History:
**	07-aug-91  (teresa)
**	    initial creation.
*/
static DU_STATUS
validate_db(dbname)
char	*dbname;
{
    char	*tail;
    exec sql begin declare section;
	char	dname[DB_MAXNAME+1];
	i4	cnt;
    exec sql end declare section;

    if (upgr_cb.du_dbmstype == DU_DBRMS)
    {
	/* strip off the RMS tail */
	tail = STindex(dbname, "/", DB_MAXNAME+1);
	*tail = '\0';
    }

    STcopy(dbname,dname);
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> (l) setting session to database database\n");
    }
    exec sql set_sql (session = :DBDB_SESSIONID);

    exec sql select count(name) into :cnt from iidatabase where
	name = :dname;

    exec sql commit;	/* free lock in iidbdb by doing a commit */

    return (cnt == 1);
}

/*{
** Name: du_fopen - Open/create a log directory
**
** Description:
**      This routine creates a log directory path and ensures that the
**	directory exists.  This directory is also used as a work directory
**	when doing fix-query-tree operations.  The directory is:
**		II_SYSTEM~ingres~files~logdirname~subdirname
**	Where ~ is an abstraction for path specifications that are actually 
**	specific to various operating systems.
**
**	A pictorial representation of the directory structure is:
**
**			II_SYSTEM
**			   |
**			INGRES
**			   |
**			FILES
**			   |
**			Logdirname
**			   |
**	    +--------------+-------------------------+
**	    |		   |			     |
**	subdirname1	subdirname2	...	subdirnameN
**	    |		   |			     |
**	filename	filename		filename
**
**
**	If the subdirname parameter is specified and that subdirectory does not
**	already exist, then this routine creates it.  If the logdirname 
**	parameter is specified and the directory does not already exist, then
**	this routine creates it.
**
** Inputs:
**	fp				Status or Log file descriptor.
**	logdirname			Name of log directory
**	subdirname			Name of subdirectory that log file is
**					to reside in.  
**
** Outputs:
**	None
**
** Side Effects:
**	 If the 'subdirname' or 'logdirname' directory doesn't exist, then
**	 the directory is created.
**
** History:
**	8-aug-91 (teresa)
**	    initial creation.
**	3-Jan-2005 (schka24)
**	    Split up original du_fopen, trees need work dir even if -nolog.
[@history_template@]...
*/

static VOID
du_create_logdir(fp, logdirname, subdirname)
DU_FILE		    *fp;
char		    *logdirname;
char		    *subdirname;
{
    STATUS	    cl_stat;
    char	    *cp;
    char	    logname[LO_NM_LEN+1];   /* buffer to hold largest legal
					    ** directory name length */
    char	    dirname[LO_NM_LEN+1];   /* buffer to hold largest legal
					    ** subdirectory name length */
    LOCATION	    temploc;
    LOINFORMATION   locinfo;
    i4		    flags = LO_I_TYPE;

    /* initialization */
    fp->du_flocbuf[0] = '\0';
    MEfill (sizeof(locinfo), '\0', (PTR) &locinfo);

    /* use as many characters in subdir name as are legal for this host. */
    STncpy (dirname, subdirname, LO_NM_LEN);    
    dirname[LO_NM_LEN]='\0';
    STncpy (logname, logdirname, LO_NM_LEN);
    logname[LO_NM_LEN]='\0';

    /* build the pathname to the parent directory.
    ** Typically this is $II_SYSTEM/ingres/upgradedb
    */
    cl_stat = NMloc(FILES, PATH, logname, &temploc);
    if (cl_stat != OK)
    {
	/* print error message that we could not build the pathname to the log 
	** file directory */
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6016_CANT_CRE_DIR, 2, 0, logname);
	upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
    }
    LOcopy (&temploc, fp->du_flocbuf, &fp->du_floc);

    /* now see if the directory exists. */
    cl_stat = LOinfo ( &fp->du_floc, &flags, &locinfo);
    if (cl_stat != OK)
    {
	/* location does not exist, so create it */
	cl_stat = LOcreate(&fp->du_floc);
	if (cl_stat != OK)
	{
	    /* print error message that we could not create the directory */
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6016_CANT_CRE_DIR, 2, 
		    0, logname);
	    upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
	}
    }
    /* Always give read/write permission to parent subdirectory.
    ** This is a precaution because we're going to create <username>
    ** subdirs here as potentially non-ingres users, and we need this
    ** directory to be world writable even if it existed.
    ** This call will fail (silently) if we're not the installation owner.
    */
    PEworld("+r+w+x", &fp->du_floc);

    /* Append logfile subdir, typically now $II_SYSTEM/upgradedb/username */
    cl_stat = LOfaddpath(&fp->du_floc, dirname, &fp->du_floc);
    if (cl_stat != OK)
    {
	/* print error message that we could not build the pathname to 
	** the log file directory */
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6016_CANT_CRE_DIR, 2, 
		 0, dirname);
	upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
    }
    /* now see if the directory exists. */
    cl_stat = LOinfo ( &fp->du_floc, &flags, &locinfo);
    if (cl_stat != OK)
    {
	/* location does not exist, so create it */
	cl_stat = LOcreate(&fp->du_floc);
	if (cl_stat != OK)
	{
	    /* print error message that we could not create the 
	    ** directory */
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6016_CANT_CRE_DIR, 2, 
		     0, dirname);
	    upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
	}
	/* give read/write permission to subdirectory */
	PEworld("+r+w+x", &fp->du_floc);
    }

    /* Save the directory location for use by others */
    LOcopy(&fp->du_floc, upgr_cb.log_dir_buf, &upgr_cb.log_dir_loc);
}

/*{
** Name: du_fopen - Open/create a log file
**
** Description:
**	This routine appends a filename to the already-built log directory
**	path, and opens that log file in append mode.
**	The default filename is "upgrade.log".
**	We expect that the log/upgradedb work directory has already been
**	set up and created.
**
**	If the log file (filename) does not exist, it will be created.  In
**	either case, it is opened for append.
**
** Inputs:
**	fp				Status or Log file descriptor.
**	filename			Name of the log file.  Examples
**					are "upgrade.log" or "iivdb.log"
**
** Outputs:
**	None
**
** Side Effects:
**	The file is created if needed, and opened for append.
**
** History:
**	3-Jan-2005 (schka24)
**	    Split up original du_fopen.
*/

static VOID
du_fopen(fp, filename)
DU_FILE		    *fp;
char		    *filename;
{
    STATUS	    cl_stat;
    char	    *cp;
    char	    file[LO_NM_LEN+1];	    /* buffer to hold largest legal
					    ** filename length */

    /* use as many characters in file name as are legal for this host. */
    STncpy (file, filename, LO_NM_LEN);
    file[LO_NM_LEN]='\0';

    if (file[0] == '\0')
    {
	/* It is illegal to not specify the filename, so use the default of
	** "upgrade.log"
	*/
	(VOID)STcopy (file, "upgrade.log");
    }

    /* now append the filename to the location */
    cl_stat = LOfstfile ( file, &fp->du_floc);

    /* translate the filename to a string */
    LOtos(&fp->du_floc, &cp);
    STcopy(cp,fp->du_flocbuf);

    /* give read/write permission to the world, just incase ... */
    PEworld("+r+w", &fp->du_floc);

    /* now open the file.  This open will create the file if it does not
    ** exist and append to it if it does exist */
    if ( (cl_stat = SIopen(&fp->du_floc, "a", &fp->du_file)) != OK )
    {
	/* print error message that we could not open the log file */
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU6017_CANT_OPEN_LOG, 2, 
		 0, fp->du_flocbuf);
	upgr_exit(__LINE__, DU_FAIL_EXIT, I_DU0080_UPGRADEDB_TERM);
    }
}

/*{
** Name: du_fclose	- close the given file.
**
** Description:
**        This routine is called to close the log file.  Note, if 
**	  the file is not open, this routine is a no-op.
**
** Inputs:
**	errcb			Message control block.
**	fp			log file descriptor.
**	    .du_file		    Pointer for generic file descriptor.
**				    If NULL, then the given file is not open.
**
** Outputs:
**	    errcb			If an error occurs, this struct is
**					set by calling du_error().
**	    fp
**		.du_file		Upon successfully closing the given file
**					this field is set to NULL.
**	Returns:
**	    E_DU_OK			Completed successfully.
**	    E_DU2410_GEN_CL_FAIL	A CL routine failed.
**	Exceptions:
**	    none
**
** Side Effects:
**	      Close the given file.
**
** History:
**      08-aug-91 (teresa)
**          Initial Creation.
*/
DU_STATUS
du_fclose(fp, errcb)
DU_FILE	    *fp;
DU_ERROR    *errcb;
{

    if (fp->du_file != NULL)
    {
	/* The file should be open. */
	if ((errcb->du_clerr=SIclose(fp->du_file))!=OK)
	    return(du_error(errcb, E_DU2410_GEN_CL_FAIL,
			    4, 0, ERx("SIclose"), 0, ERx("du_fclose")));
	else
	    /* Record that the file has been closed. */
	    fp->du_file  = NULL;
    }

    return( (DU_STATUS) E_DU_OK);
}

/*{
** Name: du_log	- Log string to log file
**
** Description
**	This routine outputs a null terminated string to the log
**	file.  The file must be open before this routine is called.  The
**	character string must be null terminated.
**
**	WARNING:  this routine assumes message length is not too long for
**		  a message.  It also assumes (does not take the time to
**		  verify) that the msg buffer is null terminated.  However,
**		  it does verify that the log file is open.
**
**
** Inputs:
**	skip				flag to skip logging
**	fp				log file descriptor
**	msg_buffer			contains null terminated msg to output
**
** Outputs:
**	none
**	Returns:
**	    E_DU_IERROR			(log file was not open)
**	    E_DU_OK	    
**	Exceptions:
**	    none
**
** Side Effects:
**	      msg is output to buffer
**
** History:
**      8-aug-91 (teresa)
**          initial creation
*/
DU_STATUS
du_log(skip, fp, msg_buffer)
bool	    skip;
DU_FILE	    *fp;
char	    *msg_buffer;
{
    /* this is a no-op if the skip logging feature is selected via -n flag */
    if (skip)
	return( (DU_STATUS) E_DU_OK);

    if (fp->du_file == NULL)  /* no open log file */
	return ( (DU_STATUS) E_DU_IERROR);

    SIfprintf(fp->du_file, "    %s\n", msg_buffer);
    SIflush(fp->du_file);
    return ( (DU_STATUS) E_DU_OK);
}

/*{
** Name: du_talk	- handle I/O
**
** Description
**
**	This routine handles output to stdout and to the log file.  It examines
**	message type and mode to determine what I/O actions to take.
**
**  NOTES:  This routine assumes that the log file is open before it is called.
**
**
** Inputs:
**	du_mtype			message type:
**					    DU_ALWAYS
**					    DU_MODESENS
**					    DU_ERR_FMTD
**	cb				control block.  Contains
**					 mode and error control block
**					 and flag indicating if logging is
**					 bypassed
**      du_errno                        error code number indicating which
**					 error message to format
**	p_cnt				#parameters (5 max)
**	(note: parameters optional, but must match p_cnt)
**	p1_len				#bytes length of 1st parameter --
**					 null terminated strings should have
**					 a length of zero
**	p1_ptr				address of 1st parameter
**	p2_len				#bytes length of parameter #2 --
**					 null terminated strings should have
**					 a length of zero
**	p2_ptr				address of 2nd parameter
**	p3_len				#bytes length of parameter #3 --
**					 null terminated strings should have
**					 a length of zero
**	p3_ptr				address of 3rd parameter
**	p4_len				#bytes length of parameter #4 --
**					 null terminated strings should have
**					 a length of zero
**	p4_ptr				address of 4th parameter
**	p5_len				#bytes length of parameter #5 --
**					 null terminated strings should have
**					 a length of zero
**	p5_ptr				address of 5th parameter
**
**
** Outputs:
**      cb				control block.  Contains:
**	    du_msg.du_errmsg		    error message that was output
**	    du_msg.du_utilerr		    error message id that was output
**
**	Returns:
**	    NONE
**	Exceptions:
**	    none
**
** Side Effects:
**	    msg may be redefined to error message
**	    disables du_error from automatically outputting warning/error
**	      msgs and resetting control block.
**
** History:
**  08-aug-91 (teresa)
**	Initial creation.  Simplified from duve_talk
**  13-oct-93 (swm)
**	Bug #56448
**	Changed length parameters type from i4 * to i4 to be
**	consistent with actual usage and description of Inputs, above.
**  05-feb-2001 (horda03) Bug 103873
**      Remove the Ingres error code from the message being displayed.
**      For Warnings and Information messages, the Ingres error code is
**      preceded by a '\t', otherwise the Ingres error code is preceded by a
**      '\n'. See du_error().
*/

/* VARARGS4 */
VOID
du_talk(du_line, du_mtype, cb, du_errno, pcnt, p1_len, p1_ptr, 
	p2_len, p2_ptr, p3_len, p3_ptr, p4_len, p4_ptr, p5_len, p5_ptr)
i4		    du_line;
i4		    du_mtype;	    
DU_UPGRADE_CB	    *cb;
i4		    du_errno;
i4		    pcnt;
i4		    p1_len;
i4		    *p1_ptr;
i4		    p2_len;
i4		    *p2_ptr;
i4		    p3_len;
i4		    *p3_ptr;
i4		    p4_len;
i4		    *p4_ptr;
i4		    p5_len;
i4		    *p5_ptr;

{
    char	    *msg_ptr;
    char            *strip;
    i4              err_reported = (i4) du_errno;

    /* Reset the system error control block */
    MEfill( (u_i2) sizeof(DU_ERROR), 0, (PTR) cb->du_msg);
    cb->du_msg->du_ingerr     = DU_NONEXIST_ERROR;
    cb->du_msg->du_utilerr    = DU_NONEXIST_ERROR;

    if (du_mtype == DU_ERR_FMTD)
    {
	/* the message is an already formatted error message, so translate
	** the message type to DU_ALWAYS and skip formatting it 
	*/
	du_mtype = DU_ALWAYS;
    }
    else
    {
	/*
	** tell du_error to format msg only.  Else it will output info/warning 
	** and clear the message buffer.
	*/
	cb->du_msg->du_flags |= DU_SAVEMSG;
	switch(pcnt/2)
	{
	    case 0:
		du_error(cb->du_msg, du_errno, 0);
		break;

	    case 1:
		du_error(cb->du_msg, du_errno, 2,
			  p1_len, p1_ptr);
		break;

	    case 2:
		du_error(cb->du_msg, du_errno, 4,
			  p1_len, p1_ptr, p2_len, p2_ptr);
		break;

	    case 3:
		du_error(cb->du_msg, du_errno, 6,
			  p1_len, p1_ptr, p2_len, p2_ptr, p3_len, p3_ptr);
		break;

	    case 4:
		du_error(cb->du_msg, du_errno, 8,
			  p1_len, p1_ptr, p2_len, p2_ptr, p3_len, p3_ptr,
			  p4_len, p4_ptr);
		break;

	    case 5:
		du_error(cb->du_msg, du_errno, 10,
			  p1_len, p1_ptr, p2_len, p2_ptr, p3_len, p3_ptr,
			  p4_len, p4_ptr, p5_len, p5_ptr);
		break;

	    default:
                err_reported = E_DU2414_BAD_CASE_LABEL;
		du_error(cb->du_msg, E_DU2414_BAD_CASE_LABEL, 4,
				 sizeof (pcnt), &pcnt,
				 0, ERx("DU_TALK"));
	}
    }

    /*
    ** Determine whether or not to output msg to log file.
    ** DON'T strip the message number, it makes it harder to debug
    */
    if (cb->du_dbg.du_file != NULL) /* see if log file exists */
    {
	SIfprintf(cb->du_dbg.du_file, "(line %d): %s\n", du_line, 
		cb->du_msg->du_errmsg);
	SIflush(cb->du_dbg.du_file);
    }

    /* Determine which character will follow the message number.
    ** Refer to du_error().
    */
    strip = ( (err_reported < DU_INFO_BOUNDARY) ||
              (err_reported < DU_WARN_BOUNDARY))  ? "\t" : "\n";
    
    /* strip of message number */
    msg_ptr = STindex(cb->du_msg->du_errmsg, strip, 0);
    if (msg_ptr != NULL)
	msg_ptr++;
    else
	/* could not stip off message number, so use whole message */
	msg_ptr = &cb->du_msg->du_errmsg[0];

    /*
    **  output msg text to stdout:
    **	 if msg type is DU_ALWAYS (reports errors) always output msg to stdout.
    **	 Otherwise, output msg to stdout if mode is not RUNSILENT
    */
    if ( (cb->du_mode != DU_SILENT) || (du_mtype == DU_ALWAYS) )
    {
	SIprintf("%s\n",msg_ptr);
	SIflush(stdout);
    }

    /*
    ** Determine whether or not to output msg to log file.
    */
    if (cb->du_log.du_file != NULL) /* see if log file exists */
    {
	SIfprintf(cb->du_log.du_file, "%s\n", msg_ptr);
	SIflush(cb->du_log.du_file);
    }

}

/*{
** Name: fe_dictinst	- install FE dictionary
**
** Description:
**	Add 6.4 FE dictionary catalogs.  If the user has not specified a
**	client list, then build the client list from ii_authorization, reading
**	file 
**
** Inputs:
**	dbname	- database name
**	dba	- DBA.
**      level   - current db level
**
** Outputs:
**	none
**
** History:
**	5/90 (bobm)
**	     written
**	10/2/90 (pete)
**	     Fix how basecats argument is passed; Pass client "INGRES"; 
**	     pass "silent" flag.
**	05/03/91 (teresa)
**	     fix bug when error status returned from UTexe was used as an
**	     error message code.
**	05/03/91 (teresa)
**	    add star support.
**	09-may-91 (markm)
**	    fix bugs 37007 and 370379 by doing a IIlq_Protect(TRUE) call after
**	    coming back from UTexe call to upgradefe.
**	02-dec-91 (teresa)
**	    change if (upgr_cb.du_clients[0]==EOS) -> if (upgr_cb.du_fecnt == 0)
**	10-Sep-2004 (schka24)
**	    Don't run this if database doesn't at least have one of the
**	    CORE module catalogs.  Otherwise what ends up happening is
**	    that upgrade installs all the latest front-end poop,
**	    willy-nilly.
*/

static	char	ut_args[] =
    ERx("database = %S, equel = %S, user = %S, basecats = %S");
static  char	Fecatins[] = ERx("upgradefe");	/* FE dictionary creat*/
static  char	Empty_str[]    = ERx("");


static VOID
fe_dictinst(dbname,dba, level)
char *dbname;
char *dba;
i4   level;
{
	char		buf[ER_MAX_LEN];
	STATUS  	stat;
	CL_ERR_DESC	err_code;

	i4		cnt_silent = 0;	/* set to 1 if -s flag for UTexe */
	i4		cnt_client = 0; /* set to 1 if client list for UTexe */
	PTR		p_vararg1 = NULL;	/* passed in UTexe call */
	PTR		p_vararg2 = NULL;	/* passed in UTexe call */
	bool		dofe_flag = TRUE;
	char		*duu_xflag();
	i4		i;

	EXEC SQL begin declare section;
	    char    cdb_name[DB_MAXNAME+1];
	    char    ddb_name[DB_MAXNAME+DU_TAIL_LEN+1];
	    char    dba_name[DB_MAXNAME+1];
	    char    iidbdbname[DB_MAXNAME+1];
	EXEC SQL end declare section;


	/* If we don't at least have a CORE module catalog, return.
	** ii_dict_modules sounds like a good candidate.
	*/
	if (!rel_exists("ii_dict_modules"))
	    return;

	if (upgr_cb.du_fecnt == 0)
	{
	    /* no client names on cmd line; create client
	    ** catalogs based on user's authorization string. We 
	    ** will create front-end catalogs for everything they
	    ** are authorized to run.
	    ** Also, pass the "-s" flag to "upgradefe".
	    */
	    char clist[DU_MAX_CLIENT_NAME];

	    if (dui_bldDefClientList(clist, upgr_cb.du_msg) == OK)
	    {
		STcopy (clist, upgr_cb.du_feclients);

                if (level == CURRENT_LEVEL)
		{
		 cnt_client = 1;
		 p_vararg1 = (PTR) &upgr_cb.du_feclients[0];
		 STpolycat (2, ut_args, ERx(",client = %S"), buf);
                }
		else
		{
		STpolycat (2, ut_args, ERx(", silent = %S, client = %S"),
				     buf);
                cnt_silent=  1;
		cnt_client = 1;
		p_vararg1 = (PTR) Empty_str;
		p_vararg2 = (PTR) &upgr_cb.du_feclients[0];
		}
	    }
	    else
	    {
		/* Problems locating or reading file "prods.lst". Issue
		** warning message & continue.
		*/
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1081_CANT_READ_PRODS_LST, 0);

		/* create basecats only. */
		STcopy (ut_args, buf);
		STpolycat (2, ut_args, ERx(", silent = %S"), buf);

		cnt_silent = 1;
		p_vararg1 = (PTR) Empty_str;
	    }
	}
	else if (STcasecmp(upgr_cb.du_feclients, ERx("nofeclients") ) == 0)
	{
		/* "nofeclients" passed to CREATEDB. Don't create Front-end
		** catalogs; skip call to upgradefe.
		*/
		dofe_flag = FALSE;
	}
	else
	{
	    /* List of client names was an input parameter.
	    ** Pass this same list of client names on to upgradefe.
	    ** Do NOT pass the "-s" flag.
	    */
	    STpolycat (2, ut_args, ERx(", client = %S"), buf);

	    cnt_client = 1;
	    p_vararg1 = (PTR) &upgr_cb.du_feclients[0];
	}

	if (dofe_flag)
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00B4_FE_UPGRADE, 0);

        if (level != CURRENT_LEVEL &&
	    upgr_cb.Dbname_ptr && upgr_cb.Dbname_ptr->star_flag && dofe_flag)
	{

	    STcopy(upgr_cb.Dbname_ptr->cdbname,cdb_name);
	    STcopy(upgr_cb.Dbname_ptr->ddbname,ddb_name);
	    i = STtrmwhite(ddb_name);
	    STcopy("/star",&ddb_name[i]);
	    STcopy(upgr_cb.Dbname_ptr->dba,dba_name);
	    STcopy(upgr_cb.Dbname_ptr->ddbname,dbname);

	    /* disconnect from local server and connect to star server.
	    ** if we cannot connect to star server, then print a warning that
	    ** user will need to run upgradefe manually.  Otherwise, run
	    ** upgradefe from distriburted server.  In either case, be sure
	    ** to reconnect to local server before leaving...
	    */
	    if (!upgr_cb.Connected)
	    {	    
		du_talk(__LINE__, DU_ALWAYS, &upgr_cb, E_DU2106_UNOPENED_DB, 2,
			0, upgr_cb.Dbname_ptr->dbname);
		return;
	    }
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (m) setting session to user database\n");
	    }

	    exec sql set_sql (session = :DB_SESSIONID);
	    EXEC SQL commit;
	    exec sql disconnect;
	    exec sql set_sql (session = :DBDB_SESSIONID);
	    EXEC SQL commit;
	    exec sql disconnect;
	    upgr_cb.Connected = FALSE;

	    /* try and connect to the star server. If we cannot connect to it,
	    ** supress SERVER error messages.  Instead print a warning that
	    ** the user will need to run upgradefe manually.
	    */
	    upgr_cb.Ignore_errors = TRUE;
	    EXEC SQL connect :ddb_name session :DB_SESSIONID
		     identified by :dba_name options = '-A6', '+U', '+w';
	    upgr_cb.Ignore_errors = FALSE;
	    if (sqlca.sqlcode < 0)
	    {
	    
		dofe_flag = FALSE;
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1864_FE_CAT_FAIL, 2,
			0, ddb_name);

		/* reconnect to the cdb .. */
		EXEC SQL connect :cdb_name session :DB_SESSIONID
		     identified by :dba_name options = '-A6', '+U', '+w';
		if (sqlca.sqlcode == 0)
		    upgr_cb.Connected = TRUE;

                /* reconnect to the iidbdb */
		if (vnode[0] != '\0')
		   STprintf(iidbdbname, "%s::iidbdb", vnode);
		else
		   STcopy("iidbdb", iidbdbname);

		if (upg_dbg_out)
		{
		    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [7] connect to iidbdb session %d id %s options = %s\n",
			    DBDB_SESSIONID, DU_DBA_DBDB,
			    upg_concurrent ? "+w" : "-A6 +w");
		}

		/* Reconnect the iidbdb session.  iidbdb is converted, do
		** a normal reconnect.
		*/
		EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
                     options = '+w' ;
		IIlq_Protect(TRUE);
	    }
	    else
		upgr_cb.Connected = TRUE;
	}

	if  (( dofe_flag && (upgr_cb.Connected || upgr_cb.dbdb_cvt) ) ||
	      level == CURRENT_LEVEL)
	{
	    upgr_cb.Ignore_errors = TRUE;	/* Bypass local error recovery*/
	    if (upgr_cb.upgtrace[UPG01_SKIP_UPGRADEFE])
	    {
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00B3_TRACE_01, 0);
		stat = 0;
	    }
	    else
	        stat = UTexe(UT_WAIT|UT_STRICT, NULL, NULL,
		    NULL, ERx("upgradefe"), &err_code, buf,
		    (4 + cnt_silent + cnt_client),
		    dbname, duu_xflag(dbname), dba,
		    Empty_str,          /* basecats (fixed arg) */
		    p_vararg1,          /* silent or client */
		    p_vararg2,          /* client */
		    NULL);

	    upgr_cb.Ignore_errors = FALSE;	/*Resume local error recovery */

	    switch(stat)
	    {
	    case OK:
		    break;
	    case UTENOPROG:
		    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1865_MISSING_UTEXE_DEF,
			    0);
		    break;
	    case UTENOARG:
		    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1866_BAD_UTEXE_DEF, 0);
		    break;
	    default:
		    du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1867_UGRADEFE_FAIL,
			    2, sizeof(stat), &stat);
		    break;
	    }
	}  /* endif we are upgr_cb.Connected to LDB or DDB */

        if (level != CURRENT_LEVEL &&
	    upgr_cb.Dbname_ptr && upgr_cb.Dbname_ptr->star_flag && dofe_flag)
	{
	    /* disconnect from DDB and reconnect to LDB */
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (n) setting session to user database\n");
	    }
	    exec sql set_sql (session = :DB_SESSIONID);
	    exec sql commit;
	    exec sql disconnect;
	    upgr_cb.Connected = FALSE;

	    EXEC SQL connect :cdb_name session :DB_SESSIONID
		     identified by :dba_name options = '-A6', '+U', '+w';
     
	    if (sqlca.sqlcode == 0)
		upgr_cb.Connected = TRUE;

            /* reconnect to the iidbdb */
            if (vnode[0] != '\0')
	       STprintf(iidbdbname, "%s::iidbdb", vnode);
	    else
	       STcopy("iidbdb", iidbdbname);

	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> [8] connect to iidbdb session %d id %s options = %s\n",
			DBDB_SESSIONID, DU_DBA_DBDB,
			upg_concurrent ? "+w" : "-A6 +w");
	    }

            EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
                  options =  '+w';
	    IIlq_Protect(TRUE);		/* for iidbdb */

	}  /* endif we are doing a distributed DB */

	/* if we did the UTexe call for UPGRADEFE, then system catalog update
	** will be turned off on return from UPGRADEFE, so turn it back on */
	if (upgr_cb.Connected || upgr_cb.dbdb_cvt)
	    IIlq_Protect(TRUE);
}

/*{
** Name: cv_65_star_iistats - alter iistats for 6.5
**
** Description:
**
**
** Inputs:
**      database name
**
** Outputs:
**      none
**
** History:
**      November 1995 (prida01)
**          wrote
*/
static VOID
cv_65_star_iistats(dbname)
char *dbname;
{
    /* If we upgrade iidd_stats in the cdb then we have to do the same  */
    /* for this one. This is registered from iidd_stats   */

    if (upgrade_iidd_stats)
    {

    	exec sql remove table iistats;

	exec sql register table iistats as link from iidd_stats;
    	if (sqlca.sqlcode < 0)
    	{
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2418_NOCREATE_SYSCAT, 4,
		0, "iistats", 0, dbname);
        	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    	}
	exec sql commit;
    }	
}


/*{
** Name: cv_iiintegrity - alter iiintegrity
**
** Description:
**
**	Add columns consname, consid1, consid2, consschema_id1,
**	consschema_id2, consflags to iiintegrity for 6.5
**
**	Add more columns intdomset11 thru 33 for r3
**
** Inputs:
**	database name
**
** Outputs:
**	none
**
** History:
**	January 1993 (jpk)
**	    wrote
**	February 1993 (jpk)
**	    ensure new iiintegrity is created with QUEL; else DBMS will try to
**	    insert check constraints corresponding to NOT NULLS specified
**	    in iiintegrity columns into iintegrity itself.  Classic bootstrap
**	    problem.
**	30-Aug-2004 (schka24)
**	    r3 changes.
**	27-Apr-2010 (kschendel) SIR 123639
**	    Changes for byte-ized bitmap columns.
**	    Delete "pre-6.4" conversion, do as part of byte-izing.
**	    Upgrade is unconditional now, caller decides.
*/
static VOID
cv_iiintegrity(dbname)
char	*dbname;
{
    i4 n;

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E7_CONVERTING_TBL, 2, 0, "iiintegrity");

    /* Convert either 10 (pre-r3) or 33 (r3+) int bitmap cols to byte.
    ** Don't need to check for existing table, it's always there.
    */
    n = 33;
    if (tbl_lacks_col("iiintegrity", "intdomset33"))
	n = 10;
    if (tbl_lacks_col("iiintegrity", "intdomset5"))
	n = 4;
    cv_bitmap_cols(dbname, "iiintegrity", n);
}


/*{
** Name: cv_dbaccess - move data from iidbaccess into 6.5 catalogs
**
** Description:
**
**	The iidbaccess catalog has been obsoleted. Now information from
**	that catalog is placed into tuples in iidbpriv, converted as
**	follows:
**
**	      IIDBPRIV:			Value:
**		dbname			iidbaccess.dbname
**		grantee			iidbaccess.usrname
**		gtype			<default>
**		dbflags			<default>
**		control			DBPR_ACCESS (0x00000800)
**		flags			DBPR_ACCESS (0x00000800)
**		qrow_limit		<default>
**		qdio_limit		<default>
**		qcpu_limit		<default>
**		qpage_limit		<default>
**		qcost_limit		<default>
**		reserve			<default>
**
**	NOTE:  in iidbaccess the DBA is listed, but in iidbpriv, only non-dbas
**		are listed.  So, we need to eleminate the tuples from iidbaccess
**		that give the DBA access to the private db before we append
**		tuples to iidbpriv.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** History:
**	16-oct-91 (teresa)
**	    created for 6.5.
*/
static VOID
cv_dbaccess()
{
    exec sql begin declare section;
	i4	flag;	    
	i4	cnt;
    exec sql end declare section;

    if (!rel_exists("iidbaccess"))
    {
	/* there is not an iidbaccess catalog, so just return */
	return;	    
    }

    /*
    ** if we get here then there is an iidbaccess catalog, so assure that
    ** all non-dba users who have access to private databases end up
    ** in the iidbpriv catalog.  Be careful not to make duplicate tuples
    ** if upgradedb is run multiple times on the iidbdb 
    */

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> Converting iidbaccess to iidbpriv\n");
    }

    flag = DBPR_ACCESS;

    /* first get rid of any tuples that describe a dba's access to a
    ** private database */

    exec sql create table iidbaccess_temp as select * from iidbaccess;
    exec sql delete from iidbaccess_temp  where dbname in
	    (select name from iidatabase,iidbaccess_temp 
		    where name=dbname and own=usrname)
	and usrname in
	    (select own from iidatabase,iidbaccess_temp 
		    where name=dbname and own=usrname);

    /* delete any tuples from the work table that are already in
    ** iidbpriv */
    exec sql delete from iidbaccess_temp where dbname in
	(select x.dbname from iidbaccess_temp x, iidbpriv y where
	    x.dbname=y.dbname and x.usrname=y.grantee and y.control=:flag)
    and usrname in
	(select grantee from iidbaccess_temp x, iidbpriv y where
	    x.dbname=y.dbname and x.usrname=y.grantee and y.control=:flag);

    /* see if there are any tuples to append to iidbpriv */
    /*exec sql select count(*) into :cnt from iidbpriv_temp; */
    exec sql select count(*) into :cnt from iidbaccess_temp;

    if (cnt)
    {
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00C7_UPDT_IIDBPRIV, 0);
	
	/* Now put the remaining tuples into iidbpriv */

	exec sql insert into iidbpriv(dbname,grantee,control,flags)
	    select dbname, usrname, :flag, :flag from iidbaccess_temp;
    }
    else
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00C8_PRIV_DB_CURRENT, 0);

    /* finally get rid of the work table */
    exec sql drop iidbaccess_temp;
}

/*{
** Name: make_udt_defaults -- set UDT default ids for iiattribute.
**
** Description:
**	Server must and will perform almost all iiattribute id
**	conversion at connect time.  Upgradedb here converts
**	iiattribute ids for UDTs only.
**
** Inputs:
**	None
**
** Outputs:
**	None
**
** History:
**	July 1993 (jpk)
**	     written
*/
make_udt_defaults()
{
    exec sql begin declare section;
	i4		return_status;
    exec sql end declare section;

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E4_MAKE_UDT_DEFAULTS, 0);

    if (proc_exists("iiqef_make_udt_defaults"))
    {
	exec sql drop procedure iiQEF_make_udt_defaults;
	exec sql commit;
    }
    exec sql create procedure iiQEF_make_udt_defaults as
    begin
	execute internal;
    end;
    exec sql commit;

    exec sql execute procedure iiQEF_make_udt_defaults
	 into :return_status;
    if (return_status != 0)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> error executing iiQEF_make_udt_defaults\n\n");
	}
	upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
    }
}

/*{
 ** Name: make_copy_of - save copy of named tables
 **
 ** Description:
 **	used by make_copies_of_65_tables to modularize making
 **	a copy of a table into a temporary table.  Since our
 **	embedded SQL doesn't permit variable substitution for
 **	table names, this routine is coded in QUEL.  Note that
 **	it hardwires in the temp tablename convention:
 **	table iifoo is copied into temporary table iitmp_iifoo.
 **
 ** Inputs:
 **	database name
 **     table name
 **
 ** Outputs:
 **	none
 **
 ** History:
 **	January 1993 (jpk)
 **	     written
 **	2-May-2010 (kschendel)
**	    Check for missing catalog first.
 */
static VOID
make_copy_of(dbname, tblname)
char	*dbname;
##char	*tblname;
{
##  char	tmpname[DB_MAXNAME + 1];
##  int		err_no;
##  char	errtext[SQL_MSG_BUF_LEN];

    STcopy("iitmp_", tmpname);
    STcat(tmpname, tblname);

    /* If catalog isn't there, we can't make a copy... */
    if (!rel_exists(tblname))
    {
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU186A_MISSING_SYSCAT, 4,
	    0, tblname, 0, dbname);
	return;
    }

    /* If old copy of temporary table is hanging around, drop it.
    ** Better to be sure that the temporary table we are about to
    ** repopulate from is known to be a correct and current copy.
    */
    if (rel_exists(tmpname))
    {
##	destroy tmpname
##	inquire_equel (err_no = errorno)
	if (err_no != 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU241B_NODROP_TEMP, 4,
		0, tblname, 0, dbname);
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}
    }

    /* sys cat is there and tmp table is not, so now safe to make copy */
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> copying %s into %s\n", tblname, tmpname);
    }
##  retrieve into tmpname (tblname.all)
##  inquire_equel (err_no = errorno, errtext = errortext)
    if (err_no != 0)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> make_copy_of failed!  copying %s to %s\nerrortext: %s\n",
		tblname, tmpname, errtext);
	}

	du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2416_NOCOPY_SYSCAT, 4,
	    0, tblname, 0, dbname);
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }
    if (!rel_exists(tmpname))
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> make_copy_of failed!  copying %s to %s\n",
		tblname, tmpname);
	}
    }
}



/*{
** Name: copy_existing_columns - Copy columns from temp copy to new catalog
**
** Description:
**	When a catalog changes, very often all we need to do is copy the
**	existing catalog to a temp table, drop/recreate the catalog, and
**	copy the previously existing columns back into the catalog.
**	This routine will take care of the copy step, copying only those
**	columns that are found in both old and new versions of the
**	catalog.  Any other (new) columns are defaulted.
**
**	Note: if defaulting causes a problem, extend this routine to pass
**	two strings for insert-column-list and select-result-values, to be
**	appended to the insert.
**
** Inputs:
**	dbname				Name of the database (for errors)
**	tblname				Name of the catalog
**					(copy is assumed to be iitmp_tblname)
**
** Outputs:
**	Returns E_DU_xxx OK/ierror status
**	(error status sets upgr_cb.Dbname_ptr->errors)
**
** History:
**	30-Aug-2004 (schka24)
**	    Written.
**
*/

static DU_STATUS
copy_existing_columns(char *dbname, char *tblname)
{
    bool first_time;			/* First-time flag for comma */

    exec sql begin declare section;
    char colname[DB_MAXNAME+1];		/* A column name */
    char errtext[SQL_MSG_BUF_LEN];
    char insstring[850];		/* Enough for iiprotect + 200 extra */
    char selstring[850];
    char sqlstring[1800];		/* Above two plus extra */
    char tmpname[DB_MAXNAME+1];		/* Temp catalog name */
    char tname[DB_MAXNAME+1];		/* Table name */
    i4 err;
    exec sql end declare section;

    STcopy(tblname, tname);
    STcopy("iitmp_", tmpname);
    STcat(tmpname, tname);		/* Build table names */

    insstring[0] = '\0';
    selstring[0] = '\0';
    first_time = TRUE;
    /* All this lowercasing BS is to deal with ANSI-compliant databases */
    /* The varchar is for blank stripping */
    exec sql select varchar(a.attname)
	into :colname
	from iiattribute a, iirelation r
	where lowercase(r.relid) = :tmpname and lowercase(r.relowner) = '$ingres'
	and a.attrelid = r.reltid and a.attrelidx = r.reltidx
	and exists (select 1 from iiattribute a1, iirelation r1
	    where lowercase(a1.attname) = lowercase(a.attname)
	    and lowercase(r1.relid) = :tname and lowercase(r1.relowner)  = '$ingres'
	    and a1.attrelid = r1.reltid and a1.attrelidx = r1.reltidx);
    exec sql begin;
	if (first_time)
	{
	    first_time = FALSE;
	}
	else
	{
	    STcat(insstring, ",");
	    STcat(selstring, ",");
	}
	/* no delimited ID worries with catalogs */
	STcat(insstring, colname);
	STcat(selstring, colname);
    exec sql end;
    if (sqlca.sqlcode < 0)
    {
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
	    0, tname, 0, dbname);
	upgr_cb.Dbname_ptr->errors = TRUE;
	return (E_DU_IERROR);
    }
    exec sql commit;
    STprintf(sqlstring, "insert into %s (%s) select %s from %s",
		tname, insstring, selstring, tmpname);
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> copy_existing_columns: %s\n", sqlstring);
    }
    exec sql execute immediate :sqlstring;
    if (sqlca.sqlcode < 0)
    {
	exec sql inquire_sql(:errtext = errortext, :err = dbmserror);
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> copy_existing_columns failed, dbmserror %d errortext: %s\n",
		err, errtext);
	}
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
	    0, tname, 0, dbname);
	upgr_cb.Dbname_ptr->errors = TRUE;
	return (E_DU_IERROR);
    }
    exec sql commit;

    return (E_DU_OK);
}

/*{
** Name: needs_widening	- returns whether a table needs DB_MAXNAME conversion
**
** Description:
**	
**	Verify that either
**	    the table exists and the column is of width DB_MAXNAME:
**	    return FALSE;
**	or
**	    another condition obtains (including no table): return TRUE.
**
** Inputs:
**	table name
**	column name
**
** Outputs:
**	none
**
** Returns:
**	TRUE if table needs widening
**	FALSE otherwise
**
** History:
**	January 1993 (jpk)
**	     written
*/
static bool
needs_widening(tname, cname)
exec sql begin declare section;
char	*tname;
char	*cname;
exec sql end declare section;
{
    exec sql begin declare section;
	int		width;
    exec sql end declare section;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> does col %s in tbl %s need widening?\n", cname, tname);
    }

    if (!rel_exists(tname))
    {
	return TRUE;
    }

    exec sql select iiuserlen(ii_ext_type(a.attfrmt, a.attfrml),
	(ii_ext_length(a.attfrmt, a.attfrml)*65536) +a.attfrmp) into :width
	from iiattribute a, iirelation r where
	lowercase(r.relid) = :tname and lowercase(r.relowner) = '$ingres'
	and lowercase(a.attname) = :cname and a.attrelid = r.reltid
	and a.attrelidx = r.reltidx;

    if (width == DB_MAXNAME)
    {
	return FALSE;
    }
    else	/* all other conditions, including 0 if something went wrong */
    {
	return TRUE;
    }
    /* NOTREACHED */
}

/*{
** Name: file_extend_convert_ingres	- convert INGRES tables for file extend
**
** Description:
**	Use internal database procedure iiQEF_convert_table.
**	Iterate over the set of INGRES tables, calling
**	internal database procedure iiQEF_convert_table on each.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** History:
**	January 1993 (jpk)
**	    written
**	March 1993 (jpk)
**	    Separated out conversion of user tables (can and should
**	    be performed later in the upgrade sequence).
*/
file_extend_convert_ingres()
{
    exec sql begin declare section;
	u_i4		reltid;
	u_i4		reltidx;
	i4		return_status;
	char		relname[DB_MAXNAME + 1];
    exec sql end declare section;

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E2_FILE_EXTEND_INGRES, 0);
    exec sql commit;
    (void) setauth("$ingres");

    /* add internal db procedure: iiQEF_convert_table */
    add_iiqef_convert_table();

    /* call iiQEF_convert_table to convert unconverted system cats */
    /* XXX this query includes views, which is a no-op */
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> call iiQEF_convert_table for INGRES tables\n");
    }
    /* Note: no ANSI uppercase worries here, 6.4 databases are lowercase */
    exec sql declare c1 cursor for
	select trim(relid), reltid, reltidx from iirelation
	where relowner = '$ingres' and relfhdr = 0;
    exec sql open c1;
    exec sql whenever not found goto closec1;
    for (;;)
    {
	exec sql fetch c1 into :relname, :reltid, :reltidx;
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> file extend converting ingres table %s\n", relname);
	}
/*
** perhaps unwise to parade long list of INGRES tables past user?
** du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E3_FILE_EXTEND_TBL, 2, 0, relname);
*/
	exec sql execute procedure iiQEF_convert_table (
	    table_id = :reltid,
	    index_id = :reltidx ) into :return_status;
	if (return_status != 0)
	{
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> error executing iiQEF_convert_table on %s (%d,%d)\n",
		    relname, reltid, reltidx);
	    }
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E6_FILE_EXTEND_TBL_ERR, 2,
		0, return_status, 0, relname);
	    upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
	}
    }
    closec1:
    exec sql close c1;
    exec sql commit;
    exec sql whenever not found continue;
}


/*{
** Name: file_extend_convert_user	- convert user tables for file extend
**
** Description:
**	Use internal database procedure iiQEF_convert_table.
**	Iterate over the set of user tables, calling
**	iiQEF_convert_table on each.  Actually over set of ALL
**	unconverted tables, for robustness; handles possibility
**	that somehow an INGRES table didn't get converted earlier.
**	Thus at end of this procedure ALL tables are known to
**	be converted for file extend.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** History:
**	March 1993 (jpk)
**	    Separated out from file_extend_convert.
**      08-jul-1999 (chash01) (orignally, 1997)
**          for rms gateway, converting views and imported table causes
**          error, they must be excluded. Declare another cursor c3 to 
**          handle rms gateway stuff.  This is because embedded sql can
**          not handle C if---else language structure.
**      21-Jul-1999 (wanya01)
**      Retrieve BE errors during table file_extend_convert. Abort
**      upgradedb if errors is found.  (Bug 98017)
**      09-feb-04 (chash01)  then change for RMS gateway is no longer needed.
**	7-Sep-2004 (schka24)
**	    Skip views, don't need to convert them.  DMF would skip them
**	    anyway but no point in cluttering up the log.
*/
file_extend_convert_user()
{
    exec sql begin declare section;
	u_i4		reltid;
	u_i4		reltidx;
	i4		return_status;
	char		relname[DB_MAXNAME + 1];
        char            error_buf[SQL_MSG_BUF_LEN];
    exec sql end declare section;
        i4             err;        


    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E5_FILE_EXTEND_USER, 0);
    exec sql commit;
    (void) setauth("$ingres");

    /* call iiQEF_convert_table to convert user tables */
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> call iiQEF_convert_table for user tables\n");
    }
        exec sql declare c2 cursor for
	    select trim(relid), reltid, reltidx from iirelation
	    where relfhdr = 0
		and mod(relstat/32,2) != 1;	/* Not a view */
        exec sql open c2;
        exec sql whenever not found goto closec2;
        for (;;)
        {
	    exec sql fetch c2 into :relname, :reltid, :reltidx;
	    if (upg_dbg_out)
	    {
	        SIfprintf(upgr_cb.du_dbg.du_file, "]==> file extend converting user table %s\n", relname);
	    }
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E3_FILE_EXTEND_TBL,
                    2, 0, relname);
	    exec sql execute procedure iiQEF_convert_table (
	        table_id = :reltid,
	        index_id = :reltidx ) into :return_status;
	    if (return_status != 0)
	    {
	        if (upg_dbg_out)
	        {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> error executing iiQEF_convert_table on %s (%d,%d)\n",
		    relname, reltid, reltidx);
	        }
                SIprintf("Aborting upgrade of this database because of error");
                du_log (upgr_cb.du_skiplog, &upgr_cb.du_log,
                   "Aborting upgrade of this database because of error");
                exec sql inquire_ingres (:error_buf = ERRORTEXT, :err = dbmserror);
                du_log (upgr_cb.du_skiplog, &upgr_cb.du_log, error_buf);
                SIprintf("\n%s", error_buf);
	        du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E6_FILE_EXTEND_TBL_ERR, 2,
		        0, err, 0, relname);
	        upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
	    }
        }
closec2:
        exec sql close c2;
        exec sql commit;
        exec sql whenever not found continue;

}
/*{
** Name: add_iiqef_convert_table - add internal db proc iiQEF_convert_table
**
** Description:
**	Adds internal database procedure iiQEF_convert_table.
**
** Inputs:
**	none
**
** Outputs:
**	none
**
** History:
**	January 1993 (jpk)
**	     written
*/
add_iiqef_convert_table()
{
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> adding iiQEF_convert_table\n");
    }

    if (proc_exists("iiqef_convert_table"))
    {
	exec sql drop procedure iiQEF_convert_table;
	exec sql commit;
    }

    exec sql create procedure iiQEF_convert_table (
	table_id	i4 not null not default,
	index_id	i4 not null not default ) as
    begin
	execute internal;
    end;
    exec sql commit;
}


/*{
** Name: cv_65es_iisecuritystate - alter iisecuritytype for 6.5 ES
**
** Description:
**
**	Allow for new types in audit system, without losing current
**      audit state information
**
** Inputs:
**	database name
**
** Outputs:
**	none
**
** History:
**	11-jul-94 (robf)
**	    created
*/
static VOID
cv_65es_iisecuritystate(char *dbname)
{
    exec sql begin declare section;
	i4  cnt;
    exec sql end declare section;

    /* 16==Resource */
    exec sql select count(*)
	     into :cnt
	     from iisecuritystate
	     where state = 16;

    if (upgr_cb.Dbname_ptr->errors == TRUE)
	return;
    if(cnt!=1)
    {
	/* Add new values */
	exec sql insert into iisecuritystate (type,id,state)
		values (1, 16, 0);
        if (upgr_cb.Dbname_ptr->errors == TRUE)
	{
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU3200_BAD_APPEND, 4,
		    0, "iisecuritystate", 0, dbname);
		upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}
	exec sql commit;
    }

    /* 17==QueryText */
    exec sql select count(*)
	     into :cnt
	     from iisecuritystate
	     where state = 17;

    if (upgr_cb.Dbname_ptr->errors == TRUE)
	return;
    if(cnt!=1)
    {
	exec sql insert into iisecuritystate (type,id,state)
		values (1, 17, 0);
        if (upgr_cb.Dbname_ptr->errors == TRUE)
	{
		du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU3200_BAD_APPEND, 4,
		    0, "iisecuritystate", 0, dbname);
		upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}
    }
    exec sql commit;
}

/*{
** Name: cv_iipriv - alter iipriv to current
**
** Description:
**
**	Create additional iipriv columns for 1024 column limit.
**	(Creates the table if it doesn't exist.)
**
** Inputs:
**	database name
**
** Outputs:
**	none
**
** History:
**	8-Sep-2004 (schka24)
**	    created for extra iipriv columns
**	27-Apr-2010 (kschendel) SIR 123639
**	    Byte-ize the bitmap columns.
**	    Caller now decides that conversion is needed.
*/
static VOID
cv_iipriv(char *dbname)
{
    bool exists;
    i4 n;

    exists = rel_exists("iipriv");

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> %sing iipriv\n",exists ? "Convert" : "Creat");
    }

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E7_CONVERTING_TBL, 2, 0, "iipriv");

    /* Need to convert iipriv to byte bitmap columns */

    if (exists)
    {
	/* Server does special stuff to let iipriv drop get through:
	** it doesn't check dependencies.  Drop the index by hand.
	*/
	upgr_cb.Ignore_errors = TRUE;
	exec sql drop index iixpriv;
	check_sql(sqlca.sqlcode);
	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2417_NODROP_SYSCAT, 4,
		    0, "iipriv", 0, "iidbdb");
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}
	upgr_cb.Ignore_errors = FALSE;
	upgr_cb.Dbname_ptr->errors = FALSE;
	n = 33;
	if (tbl_lacks_col("iipriv", "i_priv_map33"))
	    n = 10;
	cv_bitmap_cols(dbname, "iipriv", n);
	return;
    }

    /* Old database without catalog, create it */
    duc_create_catalog("iipriv");
    if (sqlca.sqlcode < 0)
    {
	check_sql(sqlca.sqlcode);
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2418_NOCREATE_SYSCAT, 4,
		    0, "iipriv", 0, dbname);
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }

    /* Modify iipriv to current structure */
    (void) duv_modify_catalog(dbname, "iipriv");
} 

/*{
** Name: cv_iirule - alter iirule to current for release 3
**
** Description:
**
**	Delete rule_secid, add more rule_colxx to iirule.
**	This also works for conversion from 6.4 since we drop/recreate.
**	No special init of new columns needed.
**
** Inputs:
**	database name
**
** Outputs:
**	none
**
** History:
**	12-jul-94 (robf)
**	    created
**	27-Aug-2004 (schka24)
**	    transmogrify into r3 update, change name
**	27-Apr-2010 (kschendel) SIR 123639
**	    Byte-ize the bitmap columns.
**	    Caller decides whether upgrade is needed.
**	    Fix iirule upgrade from 6.4 (no column bitmap).
*/
static VOID
cv_iirule(dbname)
char	*dbname;
{
    bool existed = rel_exists("iirule");
    i4 n;

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E7_CONVERTING_TBL, 2, 0, "iirule");
    if (existed)
    {
	/* Byte-ify bitmap columns, possibly expanding them if pre-r3 */
	n = 33;
	if (tbl_lacks_col("iirule", "rule_col33"))
	    n = 10;
	if (tbl_lacks_col("iirule", "rule_col1"))
	    n = 0;		/* Special flag for cv_bitmap_cols */
	cv_bitmap_cols(dbname, "iirule", n);
	if (n > 0)
	    return;

	/* The 6.4 iirule had a single column number instead of a bitmap.
	** It's tricky to do a BTset in SQL, so update the relevant rows
	** by hand using the temp table -- which cv_bitmap_cols did not
	** drop if n == 0.
	*/
	exec sql whenever sqlerror call handle_esqlerr;
	exec sql declare fix_iirule cursor for
	    select rule_name, rule_owner, rule_column from iitmp_iirule
		where rule_column <> 0;
	exec sql open fix_iirule for readonly;
	while (sqlca.sqlcode == 0)
	{
	    DB_COLUMN_BITMAP map;
	    exec sql begin declare section;
	    char rule_name[DB_MAXNAME+1], rule_owner[DB_MAXNAME+1];
	    i4 rule_column;
	    u_char *mapp;		/* Don't confuse esql with i4's */
	    exec sql end declare section;

	    exec sql fetch fix_iirule into :rule_name, :rule_owner, :rule_column;
	    if (sqlca.sqlcode == DU_SQL_NONE)
		break;
	    MEfill(sizeof(map), 0, (PTR) &map);
	    BTset(rule_column, (PTR) &map);
	    mapp = (u_char *) &map.db_domset[0];
	    exec sql update iirule
		set rule_col = :mapp
		where rule_name = :rule_name and rule_owner = :rule_owner;
	}
	exec sql close fix_iirule;
	exec sql commit;
	exec sql whenever sqlerror continue;
	/* Leave iitmp_iirule around, drop at end */
	return;
    }
    /* No catalog, shouldn't really happen, but create it */
    duc_create_catalog("iirule");		/* create new iirule */
    if (sqlca.sqlcode < 0)
    {
	check_sql(sqlca.sqlcode);
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2418_NOCREATE_SYSCAT, 4,
		0, "iirule", 0, dbname);
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }
    exec sql commit;
    (void) duv_modify_catalog(dbname, "iirule");
}

/*{
** Name: cv_iiaudit - alter iiaudit for release 3
**
** Description:
**
**	Remove objectlabel column added in 6.5ES.  This is a registration,
**	not a regular table.
**
** Inputs:
**	database name
**
** Outputs:
**	none
**
** History:
**	30-Aug-2004 (schka24)
**	    r3 changes.
*/
static VOID
cv_iiaudit(char *dbname)
{

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00E7_CONVERTING_TBL, 2, 0, "iiaudit");

    exec sql remove iiaudit;

    duc_r_iiaudit();			/* Re-register */

    if (sqlca.sqlcode < 0)
    {
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2418_NOCREATE_SYSCAT, 4,
	    0, "iiaudit", 0, dbname);
	/* Allow upgrade to continue */
    }
    exec sql commit;
}


/* Create a work directory for a database.  This can fail silently if
** we aren't the installation owner, which is OK.
** This ought to be needed only for iidbdb and only when upgrading from
** a 6.4 installation without work dirs;  the initial iidbdb query might
** need a work location and can fail without this step.
*/

static void
chk_create_workdir(dbname)
 char *dbname;
{
   char     *pworkdir;
   LOCATION workloc;

   NMgtAt("II_WORK", &pworkdir);
   LOingpath(pworkdir, dbname, LO_WORK, &workloc);
   if (LOexist(&workloc) != OK)
       (void) LOcreate(&workloc);
   return;
}
  

/* rm_iitmp_tables
** description: remove all iitmp_ii* tables created from make_copy_of()
** input : none
** output: none
*/
rm_iitmp_tables()
{
    char tmpname[DB_TAB_MAXNAME+1];	/* Already declared to sql */

    exec sql declare global temporary table session.rmtmp as
	select varchar(lowercase(relid)) as relid
	from iirelation
	where lowercase(relid) like 'iitmp$_ii%' escape '$'
	    and lowercase(relowner) = '$ingres'
	on commit preserve rows with norecovery;
    check_sql(sqlca.sqlcode);

    exec sql declare rmtmp_curs cursor for select relid from session.rmtmp;
    exec sql open rmtmp_curs for readonly;
    check_sql(sqlca.sqlcode);

    for (;;)
    {
	exec sql fetch rmtmp_curs into :tmpname;
	if (sqlca.sqlcode < 0 || sqlca.sqlcode == DU_SQL_NONE)
	    break;
	ensure_not_exists(tmpname);	/* Doesn't commit */
    }
    exec sql close rmtmp_curs;
    exec sql commit;

    exec sql drop session.rmtmp;
    exec sql commit;
}

/*{
** Name: rm_iiqef_procedures - Clean-up routine
**
** Makes sure upgradedb doesn't leave any temporary
** procedures (iiQEF_ ...) behind.
** Inputs
**      none
** Outputs:
**      none
**
** Exceptions:
**      none
**
** Side effects:
**      none
**
** History:
**      12-march-1998 (nicph02)
**      Created: Fix to bug 89164
[@history_template@]...
**/
STATIC void rm_iiqef_procedures()
{
 
  if (proc_exists("iiqef_make_udt_defaults"))
  {
        exec sql drop procedure iiQEF_make_udt_defaults;
        exec sql commit;
  }
 
  if (proc_exists("iiqef_convert_table"))
  {
        exec sql drop procedure iiqef_convert_table;
        exec sql commit;
  }
 
}

/*
** Name: cv_bitmap_cols
**
** Description:
**	In order to support varying numbers of columns as a build
**	parameter, the various column-bitmap columns in some catalogs
**	have changed from some unwieldy number of i4 columns, to a
**	single BYTE(n) column.  This routine implements that change.
**
**	For maximum generality, the caller will tell us how many
**	pre-conversion i4 columns the table had.  Prior to r3, there
**	were 10 (300 columns), after r3 there were 33 (1024 columns).
**	(One extra bit needed since sometimes column and hence bit
**	numbers start at 1.)
**
**	There are 4 tables that have bitmap columns, so with some
**	table-driven code for column names and such, it's not hard
**	to do them all here.
**	0 = iiprotect (prodomsetNN -> prodomset)
**	1 = iiintegrity (intdomsetNN -> intdomset)
**	2 = iirule (rule_colNN -> rule_col)
**	3 = iipriv (i_priv_mapNN -> i_priv_map)
**
**	*Note* iiprotect is special, because we have to do a bunch of
**	special poop to it before copying the old rows back into the
**	new iiprotect.  Therefore, the caller will take care of making
**	the temp table, unlike the usual where it's done here.
**
** Inputs:
**	db		The database name
**	tbl		The catalog to convert (one of the above 4)
**	n		The original number of bitmap int columns
**			n == 0 is special for iirule, doesn't drop temp table
**
** Outputs:
**	None
**
** History:
**	27-Apr-2010 (kschendel) SIR 123639
**	    Integrate Datallegro byte-bitmap column change.
*/

static void
cv_bitmap_cols(char *db, char *tbl, i4 n)
{
    bool first_time;			/* First-time flag for comma */
    exec sql begin declare section;
    char colname[DB_ATT_MAXNAME+1];	/* A column name */
    char insstring[1000];		/* Enough for iiprotect + 200 extra */
    char selstring[1600];
    char tmpname[DB_TAB_MAXNAME+1];	/* Temp catalog name */
    char tname[DB_TAB_MAXNAME+1];	/* Table name */

    char qry[3000];
    exec sql end declare section;

    char s[128];
    char tblnames[][16]={"iiprotect", "iiintegrity", "iirule", "iipriv"};
    char colnames[][16]={"prodomset", "intdomset", "rule_col", "i_priv_map"};
    i4 tblidx, i;

    STcopy(tbl, tname);
    STcopy("iitmp_", tmpname);
    STcat(tmpname, tname);		/* Build table names */

    for(tblidx=0;tblidx<4;tblidx++)
	if(strcmp(tblnames[tblidx], tbl) == 0)
	    break;
    if(tblidx>=4)
	return;

    /* make a copy of sys table then drop sys table.
    ** * special * don't do this for iiprotect, already done by caller,
    ** because caller has to do special fixups in the temp table before
    ** copying into the new iiprotect.
    */
    if (strcmp(tbl,"iiprotect") != 0)
    {
	make_copy_of(db, tbl);
	STcopy("drop table ", qry);
	STcat(qry, tname);
	exec sql execute immediate :qry;
	UpgrExitOnError(sqlca.sqlcode);
    }

    /* create sys table (new structure) */
    duc_create_catalog(tbl);
    if (sqlca.sqlcode < 0)
    {
	check_sql(sqlca.sqlcode);
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2418_NOCREATE_SYSCAT, 4,
		0, tbl, 0, db);
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }

    /* copy common stuff from old copy to new sys table.
    ** This is almost copy_existing_columns, except that we have
    ** to copy the bitmap stuff too at the same time.  It's not a good
    ** idea to update it from the temp table later, because there's not
    ** always a good table key to use (e.g. iiintegrity doesn't seem to
    ** have a really reliable unique key).
    ** This way is more tedious but safer.
    */

    insstring[0] = '\0';
    selstring[0] = '\0';
    first_time = TRUE;
    /* All this lowercasing BS is to deal with ANSI-compliant databases */
    /* The varchar is for blank stripping */
    exec sql select varchar(a.attname)
	into :colname
	from iiattribute a, iirelation r
	where lowercase(r.relid) = :tmpname and lowercase(r.relowner) = '$ingres'
	and a.attrelid = r.reltid and a.attrelidx = r.reltidx
	and exists (select 1 from iiattribute a1, iirelation r1
	    where lowercase(a1.attname) = lowercase(a.attname)
	    and lowercase(r1.relid) = :tname and lowercase(r1.relowner)  = '$ingres'
	    and a1.attrelid = r1.reltid and a1.attrelidx = r1.reltidx);
    exec sql begin;
	if (first_time)
	{
	    first_time = FALSE;
	}
	else
	{
	    STcat(insstring, ",");
	    STcat(selstring, ",");
	}
	/* no delimited ID worries with catalogs */
	STcat(insstring, colname);
	STcat(selstring, colname);
    exec sql end;
    UpgrExitOnError(sqlca.sqlcode);
    exec sql commit;

    /* If converting 6.4 iirule (n=0), just default the bitmap in the
    ** new iirule, and set it to all-one's below.  The caller will fix
    ** up rule-col maps for rules listing a column.  6.4 iirule had a
    ** single column number instead of a bit-map.
    */
    if (n > 0)
    {
	/* Here is where we diverge from copy_existing_columns, add the
	** bitmap column to the end of the insert and select strings.
	** Append ",colname" to the insert string, and
	** ",byte(oldname1)+byte(oldname2)+..." to the select string.
	*/
	STcat(insstring, ",");
	STcat(insstring, colnames[tblidx]);
	first_time = TRUE;
	for (i=1; i<=n; i++)
	{
	    if (first_time)
	    {
		STcat(selstring,",");
		first_time = FALSE;
	    }
	    else
	    {
		STcat(selstring, "+");
	    }
	    STprintf(s, "byte(%s%d)", colnames[tblidx], i);
	    if(10==i)
		STprintf(s, "byte(%sa)", colnames[tblidx]);
	    STcat(selstring, s);
	}
    }

    STprintf(qry, "insert into %s (%s) select %s from %s",
		tname, insstring, selstring, tmpname);
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> bitmap copyback: %s\n", qry);
    }
    exec sql execute immediate :qry;
    UpgrExitOnError(sqlca.sqlcode);

    /* update bitmap to all ones if original N words are all -1.
    ** This is only needed if we're changing the length of the
    ** bitmap in addition to BYTE-izing it.
    */
    if (n != DB_COL_WORDS)
    {
	STprintf(qry, "update %s set %s=X'", tbl, colnames[tblidx]);
	for(i=0;i<DB_COL_BYTES;i++)
	    STcat(qry, "FF");
	if (n > 0)
	{
	    STprintf(s, "' where %s=X'", colnames[tblidx]);
	    STcat(qry, s);
	    for(i=0;i<n;i++)
		STcat(qry, "FFFFFFFF");
	}
	STcat(qry, "'");
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, " ==> bitmap extend: %s\n", qry);
	exec sql execute immediate :qry;
	UpgrExitOnError(sqlca.sqlcode);
    }

    if (duv_modify_catalog(db, tbl) != E_DU_OK)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);

    if (n > 0)
    {
	STcopy("drop table ", qry);
	STcat(qry, tmpname);
	exec sql execute immediate :qry;
	exec sql commit;
    }

} /* cv_bitmap_cols */

/*{
** Name: star_20_std_cats() - rebuild the star standard catalog interface
**
** Description: Refresh the iidd_columns for iitables, iiphysical_tables and
**		iiindexes for new column information. 
**
**
** Inputs:
**      database name
**
** Outputs:
**      none
**
** History:
**      06-mar-1996 (nanpr01)
**         Written. 
*/
static VOID
star_20_std_cats(bool upcase)
{
##  int DU_object_index;
##  char *DU_ii_name, *DU_iidd_name, *DU_obj_type, *DU_loc_type;
##  i4          duc_4row_cnt;

    for (DU_object_index = 0;
     STcompare((char *)(DU_upg20_link_object_map[DU_object_index].ii_name), "");
     DU_object_index++)
    {
	if (upcase)
	{
	    DU_ii_name = DU_upg20_link_object_map[DU_object_index].ii_name;
	    CVupper(DU_ii_name);
	    DU_iidd_name = DU_upg20_link_object_map[DU_object_index].iidd_name;
	    CVupper(DU_iidd_name);
	}
	else
	{
	    DU_ii_name = DU_upg20_link_object_map[DU_object_index].ii_name;
	    DU_iidd_name = DU_upg20_link_object_map[DU_object_index].iidd_name;
	}
        DU_obj_type = DU_upg20_link_object_map[DU_object_index].obj_type;
        DU_loc_type = DU_upg20_link_object_map[DU_object_index].loc_type;

        /* Initialize iidd_tables and substitute iidd_name into ii_name */
 
##      repeat delete iidd_columns
##          where iidd_columns.table_name = @DU_ii_name

##      repeat append to iidd_columns
##              (
##              table_name      = @DU_ii_name,
##              table_owner     = iicolumns.table_owner,
##              column_name     = iicolumns.column_name,
##              column_datatype = iicolumns.column_datatype,
##              column_length   = iicolumns.column_length,
##              column_scale    = iicolumns.column_scale,
##              column_nulls    = iicolumns.column_nulls,
##              column_defaults = iicolumns.column_defaults,
##              column_sequence = iicolumns.column_sequence,
##              key_sequence    = iicolumns.key_sequence,
##              sort_direction  = iicolumns.sort_direction,
##              column_ingdatatype = iicolumns.column_ingdatatype
##              )
##          where iicolumns.table_name = @DU_iidd_name
 
##      inquire_equel(duc_4row_cnt   = rowcount)
        if (duc_4row_cnt == 0)
        {
            /* Bad append to table, %0c, in database, %1c. */
            du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2417_NODROP_SYSCAT, 4,
                    0, "iidd_columns", 0, upgr_cb.Dbname_ptr->dbname);
            upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
        }
 
	/* Commit Transaction */
##      end transaction;

	/* Start another transaction */
##      begin transaction;

    }
}

/*{
** Name: cv_20_hashdate_tables - reformat hased date columns.
**
** Description:
**	Looks for tables containing date columns with hash indexes defined
**	on them. Such columns are the target of a subsequent update
**	which "normalizes" the date representation, then repositions
**	the row in the index. This is required by the fix to bugs 66329 and
**	74033. 
**
** Inputs:
**	database name (though call from cv_database assures we're already
**	connected).
**
** Outputs:
**	none
**
** History:
**	28-jan-1997 (inkdo01)
**	    Written.
**	30-oct-1998 (kitch01)
**		Bug 92451. Add 0 days instead of 0 hours. This will still allow
**		the date to be normalized but without appending 00:00:00 to
**		date only date values.
**	5-May-2010 (kschendel)
**	    Just do 'em one at a time, it's unlikely that there would be
**	    multiple date hash key columns on a single table anyway.
*/
static VOID
cv_20_hashdate_tables(dbname)
char	*dbname;
{
    exec sql begin declare section; 
	char    tablename[DB_MAXNAME+1];
	char	attname[DB_MAXNAME+1];
	char    dynstmt[5*DB_MAXNAME+300];	/* make it nice and big (it'll hold 5 cols) */

    exec sql end declare section;
 
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "\n]==> Fixing pre-2.0 hashed-on-date tables\n");
    }

    /* get table, column pairs for all date columns with hash indexes
    ** defined on them. */
    exec sql declare dupdcurs cursor for
    select varchar(attname) as attname, varchar(relid) as relid
	from "$ingres".iiattribute a, "$ingres".iirelation b 
	where a.attrelid = b.reltid and a.attrelidx = b.reltidx 
	    and a.attrelidx = 0 and exists 
	( select * from "$ingres".iiattribute a1, "$ingres".iirelation b1 
	    where a1.attkdom > 0 and a1.attrelid = b1.reltid 
		and a1.attfrmt in (-3, 3) and a1.attrelidx = b1.reltidx 
		and b1.relspec = 7 and a.attname = a1.attname 
		and a.attrelid = a1.attrelid)
	order by relid;
 
    exec sql open dupdcurs
             for readonly;
 
    /* fetch loop retrieves all qualifying table, column pairs and
    ** whacks 'em into the corresponding update syntax. */

    while(sqlca.sqlcode == 0)
    {
	exec sql fetch dupdcurs into :attname, :tablename;
	if (sqlca.sqlcode == 100)
	    break;
	STprintf(dynstmt, "update \"%s\" set \"%s\" = \"%s\" + '0 days'",
		tablename, attname, attname);
 
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> Hashed date column update:\n %s \n",
			dynstmt);
	}
	/* update <table> set <col1> = <col1> +'0 days' */
	exec sql execute immediate :dynstmt;
	/* Would be nice to commit here, but it will screw up the
	** cursor.  Since this is an old transformation I'm not
	** worrying about it.
	*/
    }
 
    exec sql close dupdcurs;

    exec sql commit;
                                     
}   

/*
** Name:  convert-tables_25 - table conversions for 2.5
**
** Description:
**	This function is designed to make any updates to catalogs that 
**	changed in 2.5, it is executed after the 6.5 (OpenIngres) and 2.0 
**	upgrade operations, and includes changes that happened between
**	2.0 and 2.5. Changes are:
**
**	iiqef_convert_table is called for tables with blobs, or btree
**	or rtree tables.
**
**	The updates herein depend on a functioning "create procedure"
**	mechanism, so they're done after the initial order critical catalog
**	updates.
**
** Inputs:
**	dbname		name of database
**
** Outputs:
**	None
**
** Returns:
**	None
**
** History:
**	12-may-99 (stephenb)
**	    Created
**	20-may-1999 (nanpr01)
**	    SIR 89267 - Need additional index to check the existence
**	    of rule by its owner and name.
**      03-aug-1999 (stial01)
**          create/modify iiextended_relation if it doesn't exist
**          Call iiQEF_convert_table for all tables having (blob) extensions
**	16-aug-99 (inkdo01)
**	    Added call to cv_25_iiintegrity() to add referential action
**	    columns.
**	29-aug-2000 (somsa01)
**	    Changed c3 cursor to 'c4', as c3 is already in use in this file.
**	3-nov-00 (inkdo01)
**	    Drop/recreate iistats, iihistograms views to support composite
**	    histograms.
**     28-jan-04 (chash01) interestingly, some RMS
**         gateway registered table/index has relspec=11
**         (btree) thus we has to eliminate them for update. 
**         test relstat for TCB_GATEWAY bit set, select those
**         that do not have this bit set.
**     09-feb-04 (chash01)
**         Further testing found that the problem with RMS Gateway imported
**         table update is the result of not being able to tell that TIDP 
**         is also part of index key (by Ingres definition).  Correction
**         is made in gwrms.c and the last change is back out.
**	30-Aug-2004 (schka24)
**	    iiintegrity done in bootstrap for r3.
*/
static VOID	
convert_tables_25(char		*dbname)
{
    EXEC SQL BEGIN DECLARE SECTION;
	u_i4            reltid;
	u_i4            reltidx;
	i4              return_status;
	char            relname[DB_MAXNAME + 1];
    EXEC SQL END DECLARE SECTION;

    /*
    ** Make sure etabs exist for all peripheral attributes
    ** First add internal db procedure: iiQEF_convert_table
    */
    add_iiqef_convert_table();

    /*
    ** 
    ** Select all tables having extension table
    ** Select all tables that are BTREE or RTREE
    ** 28-jan-04 (chash01) interestingly, almost all RMS
    ** gateway registered table/index has relspec=11
    ** (btree) thus we has to eliminate them for update.
    ** 09-feb-04 (chash01) above change is backed out.
    ** fix now is in gwrms.c  
    */
    exec sql declare c4 cursor for
	select relid, reltid, reltidx from iirelation where
        mod(relstat2/2, 2) = 1 or relspec = 11 or relspec = 13; 
    exec sql open c4;
    exec sql whenever not found goto closec4;
    for (;;)
    {
	exec sql fetch c4 into :relname, :reltid, :reltidx;
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00FE_VERIFYING_TBL, 2, 0, relname);

	exec sql execute procedure iiQEF_convert_table (
	    table_id = :reltid,
	    index_id = :reltidx ) into :return_status;

	if (sqlca.sqlcode < 0 || return_status != 0)
	{
	    SIprintf("]==> error executing iiQEF_convert_table on %s (%d,%d)(%d,%d)\n",
		    relname, reltid, reltidx, sqlca.sqlcode, return_status);
	    upgr_exit(__LINE__, DU_FAIL_EXIT, 0);
	}
    }
    closec4:
    exec sql close c4;
    exec sql commit;
    exec sql whenever not found continue;

}

/*
** Name:  chmod_data_600 - Chmod data files to 600
**
** Description:
**		For UNIX file systems, change file to permission to 
**		read/write for owner.  This removes the executable bit
**		that has been set in previous releases.
**
** Inputs:
**	None
**
** Outputs:
**	None
**
** Returns:
**	None
**
** History:
**	27-may-99 (hanch04)
**	    Created
**	23-May-2001 (jenjo02)
**	    Ignore RAW locations.
**	10-Jul-2003 (schka70)
**	    "chmod 0600 *" is no good for db's with lots of tables.
**	    Use xargs instead.  Also, translate locations names properly.
**	    Use symbolic length constants!
*/
static VOID	
chmod_data_600()
{
#ifdef UNIX
    EXEC SQL BEGIN DECLARE SECTION;
        char locarea[ DB_AREA_MAX + 1 ];
	i4		stat;
	char chmoddbname[ DB_MAXNAME + 1];
    EXEC SQL END DECLARE SECTION;

    /* Below needs enough for "ls -1 loc-path | xargs chmod 600" */
    char dataloc_buf[ MAX_LOC + 80 + 1 ];
    CL_ERR_DESC		err_code;
    LOCATION		redirectloc;
    char		redirectbuf[MAX_LOC];
    LOCATION locpath;			/* Actual path struct for locname */
    STATUS		lo_status;

    STcopy("/dev/null", redirectbuf);
    LOfroms( FILENAME & PATH, redirectbuf, &redirectloc );

    /*Load table */
    EXEC SQL SELECT l.location_area, database_name, e.status
        INTO :locarea, :chmoddbname, :stat
        FROM iiextend_info e, iilocation_info l
        WHERE e.status > 0
            AND e.location_name = l.location_name
        ORDER BY e.location_name;
    EXEC SQL BEGIN;
##  {
        if ( (stat & (DU_EXT_DATA | DU_EXT_RAW)) == DU_EXT_DATA )
	{
	    STcopy(ERx("cd "), dataloc_buf);
	    /* Translate the data location that's in locarea */
	    lo_status = LOingpath(locarea, chmoddbname, LO_DB, &locpath);
	    if (lo_status == OK) {
		STcat(dataloc_buf, locpath.string);
	 	STcat(dataloc_buf, ERx("; ls -1 | xargs chmod 0600 "));
		PCcmdline((LOCATION *) NULL, dataloc_buf, PC_WAIT, 
		      &redirectloc, &err_code);
	    }
	}
##  }
    EXEC SQL END;
#endif /* UNIX */
    EXEC SQL COMMIT;
}


/*{
** Name: fix_qry_trees() - Rebuild views, quel permits, rules, integrities
**			   Optionally rebuild ALL permits
**                         Optionally add copy_into, copy_from permission
**
** Description:
**	This routine rebuilds all query trees.
**
**	Unloaddb is used to do most of the work.  Flags are passed to unloaddb
**	so that it generates drop and recreate of views, rules, quel
**	integrities, and optionally permits.  (Permits are rebuilt only if
**	the database is 6.4 or earlier, or if QUEL permits with trees
**	exist.  6.4 permits are redone not because of query trees, but
**	because ALL permits are stored differently post-6.4.)
**
**	Unloaddb can't conveniently handle system generated rules (for
**	constraints), so they are dealt with separately (fix_sysgen_rules
**	and fix_constraints).  It also depends on valid standard
**	catalog views, so those are reconstructed before calling unloaddb.
**
**	Note: if star_db is TRUE, we're connected to the Star database
**	(ddb) only, and must use conn_dbname instead of open_target() for
**	reconnects.  If star_db is FALSE, we should have connections to
**	both iidbdb and the target database open.  (The target might be a
**	star CDB in this case, i.e. star_db <> Dbname_ptr->star_flag.)
**
** Inputs:
**	dbname		name of current database
**      conn_dbname	name to use for connect
**	star_db		TRUE if connected to dbname/star
**      level		level of current database
**
** if level < V65ES:
** 1) Redefine 'GRANT ALL' permits:
**    Change procedure 'GRANT ALL' permits to 'GRANT EXECUTE'
**    Change event 'GRANT ALL' permits to 'GRANT REGISTER, RAISE'
**
** 2) Add copy_into, copy_from GRANTS
**    Change grant insert -> grant insert, copy_into
**    Change grant select -> grant select, copy_from
**
** Outputs:
**      upgr_cb.Dbname_ptr->tree_error
**
** History:
**    ??/??/?? - initial version
**    11-apr-2003 devjo01 (b110050)
**	Capture and surpress "unloaddb" output so user does not see
**	instructions for unloading and reloading his database, which
**	are misleading in this context.
**    31-Oct-2003 (wanfr01)
**          Bug 110858, INGSRV 2493
**          Recreate select permits to public on system catalog views
**          after they are dropped and recreated.
**	10-Sep-2004 (schka24)
**	    More work on getting grants right.  Always redo catalog
**	    grants (old db's have them screwed up from old conversions).
**	    Reissue 6.4 all-to-public and select-to-public so that they're
**	    in new form.  Fix object counter check for uppercase DB's.
**	    Also, rework cross-owner referential constraint fixup, see
**	    fix_ref_constraints.
**	24-Sep-2004 (schka24)
**	    Get Star upgrades working; fix 1.2 upgrades with constraints.
**	27-oct-2004 (somsa01)
**	    Updated runs of unloaddb to be executed via PCcmdline(), so
**	    that we have better control of "-u" passing.
**	13-jul-2005 (abbjo03)
**	    Back out change of 27-oct-2004 as it causes errors when unloaddb
**	    is run on VMS.    
**	14-May-2009 (kschendel) 122041
**	    Compiler warning fixes.
**	15-Mar-2010 (troal01)
**	    A geo indicator needs to be passed to duc_create_stdcat_views
**	    set to FALSE on upgrades.
*/

/*
** Since unloadddb may generate sql statements that will fail, e.g.
** a procedure might reference a table was dropped. Instead use:
**    \continue; set autocommit on;
** to recreate as many objects as possible. 
**
** Alternatively (in a future release) add \\include iiupgr.scr,
** where iiupgradedb.scr is some file with continue/nocontinue
** and set autocommit on/off options specified by the dba.
** 
** Invoke unloaddb -uninterrupted, so the sql script does not contain
** \nocontinue
** 
*/
static  char    unloaddb_args[] = ERx(
  "database = %S, user = %S, directory = %S, viewonly = %S, procedureonly = %S, rulesonly = %S, dropincluded = %S, integonly = %S, uninterrupted = %S");

/* If ANY QUEL permits in db.... drop and recreate ALL permits */
static  char    unloaddb_args_permits[] = ERx(
  "database = %S, user = %S, directory = %S, viewonly = %S, procedureonly = %S, rulesonly = %S, dropincluded = %S, integonly = %S, permitsonly = %S, uninterrupted = %S");

static  char    unloaddb_star_args[] = ERx(
  "database = %S, user = %S, directory = %S, viewonly = %S, dropincluded = %S, uninterrupted = %S");

static  char    Fe_unloaddb[] = ERx("unloaddb");  
static  char    Fe_sql[] = ERx("sql");  


/*
** All of this was copied from front!misc!hdr xf.h 
** The -A6 flag was added so the server knows it is called from upgradedb
*/

# ifdef	VMS /* quote the flags to prevent lowercasing */
#define CMD_SQLSYMDEF  ERx("sql :== $II_SYSTEM:[ingres.bin]tm.exe -qSQL")
#define CMDLINE	ERx("sql +w -s -f4F79.38 -f8F79.38 -u%s \"+U\" \"-A6\" %s <%s >%s\n")
#endif

# ifdef	UNIX
#define CMDLINE	ERx("sql +w -s -f4F79.38 -f8F79.38 -u'%s' +U -A6 %s < %s > %s\n")
# endif

# ifdef	hp9_mpe
#define CMDLINE	ERx("sql +w -s -f4F79.38 -f8F79.38 -u%s +U -A6 %s < %s > %s\n")
# endif

# if defined (MSDOS) || defined (NT_GENERIC)
#define CMDLINE	ERx("sql +w -s -f4F79.38 -f8F79.38 -u%s +U -A6 %s < %s > %s") 
# endif                        

static VOID 
fix_qry_trees(
char *dbname, char *conn_dbname, bool star_db, i4 level)
{
    DU_ERROR		errcb;
    STATUS		cl_stat;
    char		ut_args[LO_NM_LEN+1 + 500];
    CL_ERR_DESC		err_code;
    LOCATION		copyin_loc;
    char		copyin_loc_buf[MAX_LOC];
    LOCATION		grant_fix_loc;
    char		grant_fix_loc_buf[MAX_LOC];
    char		grant_fix_file[DI_FILENAME_MAX + 1];
    LOCATION		grant_out_loc;
    char		grant_out_loc_buf[MAX_LOC];
    char		grant_out_file[DI_FILENAME_MAX + 1];
    LOCATION		ref_fix_loc;
    char		ref_fix_loc_buf[MAX_LOC];
    char		ref_fix_file[DI_FILENAME_MAX + 1];
    LOCATION		ref_out_loc;
    char		ref_out_loc_buf[MAX_LOC];
    char		ref_out_file[DI_FILENAME_MAX + 1];
    LOCATION		sql_input_loc;
    char		sql_input_loc_buf[MAX_LOC];
    char		sql_input_file[DI_FILENAME_MAX + 1];
    LOCATION		sql_output_loc;
    char		sql_output_loc_buf[MAX_LOC];
    char		sql_output_file[DI_FILENAME_MAX + 1];
    char		sql_cmd[(LO_NM_LEN * 3) + 500];
    char		*dirname;
    i4			n;
    FILE		*fp;
    bool		db_open;
    bool		grant_65es = FALSE;
    bool		fix_iiud = TRUE; /* remove iiud.scr from copy.in */
    EXEC SQL BEGIN DECLARE SECTION;
    char		*sql_conn_dbname;
    char		start_dt[26];
    i4			quel_perm_cnt;
    char		tbuf[512];
    i4			pre_view_cnt, pre_intg_cnt, pre_proc_cnt;
    i4			post_view_cnt, post_intg_cnt, post_proc_cnt;
    i4			old_view_cnt, old_intg_cnt, old_proc_cnt;
    i4			pre_cons_cnt, post_cons_cnt;
    char		*iidbdbname;
    EXEC SQL END DECLARE SECTION;
    bool		did_unload = FALSE;
    bool		grant_fixes = FALSE;
    bool		cons_fixes = FALSE;
    i4			new_cnt;

    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "Fixing query trees for database %s connect dbname %s\n", 
	dbname, conn_dbname);
     sql_conn_dbname = conn_dbname;

    if (setauth("$ingres") != OK)
	SIprintf("Warning: SET SESSION AUTHORIZATION $ingres failed\n");


    if (level < V65ES_LEVEL)
	grant_65es = TRUE;


    exec sql select date('now') into :start_dt;

    if (star_db)
    {
	/* Re-register distributed views on standard catalog views */
	const DU_link_object_entry *map = &DU_link_object_map[0];
	i4			object_index;

	for (object_index = 0;
	    STcompare((char *)(map[object_index].ii_name), "");
		object_index++)
	{
	    if (map[object_index].loc_type[0] != 'V')
		continue;
	    STprintf(tbuf, "remove %s", map[object_index].ii_name);
	    EXEC SQL EXECUTE IMMEDIATE :tbuf;
	    check_sql(sqlca.sqlcode);
	    /* Ignore remove errors */
	    STprintf(tbuf, "register view %s as link from %s",
		map[object_index].ii_name, map[object_index].iidd_name);
	    EXEC SQL EXECUTE IMMEDIATE :tbuf;
	    check_sql(sqlca.sqlcode);
	    if (sqlca.sqlcode < 0)
		SIprintf("SQL error %d statement: %s\n", sqlca.sqlcode, tbuf);
	    exec sql commit;
	}
	pre_cons_cnt = 0;		/* Meaningless in a star DB */
    }
    else
    {
	/* Local database, drop all standard catalog views */
	/* Probably dropped already if normal upgrade path, but make sure;
	** not dropped if Star CDB, drop now (again!).
	*/

	/* Count constraints now before we drop any, other things counted
	** later.  Note: no std cat views can be used here.
	*/
	pre_cons_cnt = -1;
	exec sql select count(*) into :pre_cons_cnt
	    from iiintegrity
	    where consflags <> 0;
	exec sql commit;

	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0102_DROPPING_STDCAT_VIEWS, 0);
	duc_drop_stdcat_views(dbname, upgr_cb.Dbname_ptr->star_flag); 

	/* For conversions from 6.4 or earlier, fix ALL/SELECT to PUBLIC
	** grants to look like the later style.  Do this now while
	** the std cats are out of the way.
	*/
	if (level < V65_LEVEL)
	{
	    /*
	    ** Build unique grant-fix sql filename
	    ** Just in case this isn't the first time running upgradedb...
	    ** We don't want to step on previous scripts (no real
	    ** reason why not, but seems like a good idea!)
	    */
	    for ( n = 1;  ; n++)
	    {
		/* Build location for grant fixing: dbname.gNN */
		STprintf(grant_fix_file, "%s.g%02d", dbname, n);
		LOcopy(&upgr_cb.log_dir_loc, grant_fix_loc_buf, &grant_fix_loc);
		cl_stat = LOfstfile ( grant_fix_file, &grant_fix_loc);
		if (n == 99 || (cl_stat = SIopen(&grant_fix_loc, "r", &fp)) != OK )
		    break;
		SIclose(fp);
	    }
	    /* Build grant-sql output filename too */
	    STprintf(grant_out_file, "%s.go%02d", dbname, n);
	    LOcopy(&upgr_cb.log_dir_loc, grant_out_loc_buf, &grant_out_loc);
	    cl_stat = LOfstfile ( grant_out_file, &grant_out_loc);

	    /* Write script for -to-public grant fixup */
	    grant_fixes = fix_64_grants(dbname,&grant_fix_loc,grant_fix_loc_buf);
	}
	/* Drop all internal procedures */
	duc_drop_internal_procs(dbname, upgr_cb.Dbname_ptr->star_flag);

	/* Re-create all stdcat views.
	** Re-create Star views if this is a Star CDB.
	*/
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0103_RECREATING_STDCAT_VIEWS, 0);
	duc_create_stdcat_views(dbname, upgr_cb.Dbname_ptr->upcase, FALSE);

	if (upgr_cb.Dbname_ptr->star_flag)
	    duc_create_star_views(dbname, upgr_cb.Dbname_ptr->upcase);

	if (level >= V65_LEVEL)
	{
	    /*
	    ** Post-64 database might have constraints.
	    ** Build unique constraint-fix sql filename.  (rNN because
	    ** originally this was just for cross-user referential
	    ** constraints, before I discovered the 1.2 situation.)
	    */
	    for ( n = 1;  ; n++)
	    {
		/* Build location for ref constraint fixing: dbname.rNN */
		STprintf(ref_fix_file, "%s.r%02d", dbname, n);
		LOcopy(&upgr_cb.log_dir_loc, ref_fix_loc_buf, &ref_fix_loc);
		cl_stat = LOfstfile ( ref_fix_file, &ref_fix_loc);
		if (n == 99 || (cl_stat = SIopen(&ref_fix_loc, "r", &fp)) != OK )
		    break;
		SIclose(fp);
	    }
	    /* Build ref-sql output filename too */
	    STprintf(ref_out_file, "%s.ro%02d", dbname, n);
	    LOcopy(&upgr_cb.log_dir_loc, ref_out_loc_buf, &ref_out_loc);
	    cl_stat = LOfstfile ( ref_out_file, &ref_out_loc);

	    /* Drop cross-user ref constraints, or all 1.2 ref and check
	    ** constraints, write script to recreate
	    */
	    cons_fixes = fix_constraints(dbname,level,&ref_fix_loc,ref_fix_loc_buf);
	}

	/*
	** See if this db has any QUEL permits (which have trees)
	** No need to do this if we're dumping pre-6.5es permits anyway.
	**
	** If so, drop and recreate all permissions/grants for ALL tables
	** I could've tried to call copydb for the tables having quel permits..
	** but I am not sure if I can do this correctly for tables with 
	** delimited ids...
	*/
	if (!grant_65es)
	{
	    EXEC SQL DECLARE GLOBAL TEMPORARY TABLE session.quelperms as
	    SELECT DISTINCT object_name,object_owner,permit_number
	    FROM iipermits
	    WHERE text_sequence = '1' AND
	    text_segment not like 'grant%' AND text_segment not like 'create%'
	    ON COMMIT PRESERVE ROWS WITH NORECOVERY;

	    quel_perm_cnt = 0;
	    EXEC SQL SELECT count(*) INTO :quel_perm_cnt FROM session.quelperms;

	    exec sql commit;

	    if (quel_perm_cnt > 0)
		grant_65es = TRUE;
	}

	/* System catalog views should have select to public WGO */
	duc_grant_stdcat_views(dbname, upgr_cb.Dbname_ptr->upcase);

    }

    /* Get more pre-counts now that we have std catalog views */

    pre_view_cnt = pre_intg_cnt = pre_proc_cnt = -1;
    exec sql select count(*) into :pre_view_cnt from iitables 
	    where table_type = 'V' and lowercase(table_name) not like 'ii%';
    if (! star_db)
    {
	exec sql select count(*) into :pre_intg_cnt from iiintegrities;
	exec sql select count(*) into :pre_proc_cnt from iiprocedures
	    where text_sequence = 1
	    and lowercase(procedure_name) not like 'ii%'
	    and system_use <> 'G';
    }

    exec sql commit;
    exec sql disconnect;
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> (h) disconnect\n");
    }
    upgr_cb.Connected = FALSE;

    /*
    ** Need to make sure the (exclusive) connection is ended 
    ** unloaddb below will fail if the exclusive connection hasn't ended
    ** Try to connect wait - without requesting db lock - then disconnect again
    */
    if (STcompare(dbname, DU_DBDBNAME) == 0)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [9] connect to iidbdb session %d id %s options = +w\n",
		    DBDB_SESSIONID, DU_DBA_DBDB);
	}

	iidbdbname = conn_dbname;
	/* If we're doing iidbdb, we must be ingres, this will work */
	EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
		     identified by :DU_DBA_DBDB options = '+w';
	exec sql disconnect;
	upgr_cb.Connected = FALSE;
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (i) disconnect\n");
	}
    }
    else if (star_db)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [9] connect to %s session %d id %s options = +w\n",
		    conn_dbname, STAR_SESSIONID, DU_DBA_DBDB);
	}
	EXEC SQL connect :sql_conn_dbname session :STAR_SESSIONID
		      identified by :DU_DBA_DBDB options = '+w';
	exec sql disconnect;
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> (j) disconnect\n");
    }
    else
    {
	if (open_target(CONNECT_SHARE))
	{
	    exec sql set_sql (session = :DB_SESSIONID);
	    exec sql disconnect;
	    upgr_cb.Connected = FALSE;
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> (j) disconnect\n");
	    }
	}
    }

    /*
    ** call unloaddb to generate script to create views, procedures, rules 
    ** and maybe permissions
    ** If upgr_cb.Dbname_ptr->star_flag, connect to the local db
    */

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0104_UNLOADING_TREES, 0);

    LOtos(&upgr_cb.log_dir_loc, &dirname);
    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "upgradedb calling UNLOADDB db %s directory = %s\n",
		dbname, dirname);

    /* Build location for copy.in file that unloaddb will create */
    LOcopy(&upgr_cb.log_dir_loc, copyin_loc_buf, &copyin_loc);
    cl_stat = LOfstfile ( "copy.in", &copyin_loc);

    /*
    ** Build unique sql input and output file names 
    ** Just in case this isn't the first time running upgradedb...
    ** We don't want to step on previous unloaddb scripts
    */
    for ( n = 1;  ; n++)
    {
	/* Build location for backup of copy.in -> dbname.iNN */
	/* Filename may be DB_MAXNAME.iNN, must be < DI_FILENAME_NAME */
	STprintf(sql_input_file, "%s.i%c%c", dbname, 
	    ((n / 10) % 10) + '0', (n % 10) + '0');
	LOcopy(&upgr_cb.log_dir_loc, sql_input_loc_buf, &sql_input_loc);
	cl_stat = LOfstfile ( sql_input_file, &sql_input_loc);
	if ( (cl_stat = SIopen(&sql_input_loc, "r", &fp)) == OK )
	{
	    SIclose(fp);
	    continue;
	}

	/* Build location for sql output -> dbname.oNN */
	/* Filename may be DB_MAXNAME.oNN, must be < DI_FILENAME_NAME */
	STprintf(sql_output_file, "%s.o%c%c", dbname, 
	    ((n / 10) % 10) + '0', (n % 10) + '0');
	LOcopy(&upgr_cb.log_dir_loc, sql_output_loc_buf, &sql_output_loc);
	cl_stat = LOfstfile ( sql_output_file, &sql_output_loc);
	if ( (cl_stat = SIopen(&sql_output_loc, "r", &fp)) == OK )
	{
	    SIclose(fp);
	    continue;
	}

	/* Found an unused input/output file name */
	break;
    }

    /* Use "dbname.oNN" to capture unwanted "unloaddb" output. */
    if (star_db)
    {
	STcopy (unloaddb_star_args, ut_args);
	cl_stat = UTexe(UT_WAIT|UT_STRICT, &sql_output_loc, NULL,
	    NULL, Fe_unloaddb, &err_code, ut_args, 6,
	    conn_dbname, upgr_cb.Dbname_ptr->dba, dirname, 
	    Empty_str, Empty_str, Empty_str);
    }
    else if (grant_65es)
    {
	STcopy (unloaddb_args_permits, ut_args);
	cl_stat = UTexe(UT_WAIT|UT_STRICT, &sql_output_loc, NULL,
	    NULL, Fe_unloaddb, &err_code, ut_args, 10,
	    conn_dbname, upgr_cb.Dbname_ptr->dba, dirname, 
	    Empty_str, Empty_str, Empty_str, Empty_str, 
	    Empty_str, Empty_str, Empty_str);
    }
    else
    {
	STcopy (unloaddb_args, ut_args);
	cl_stat = UTexe(UT_WAIT|UT_STRICT, &sql_output_loc, NULL,
	    NULL, Fe_unloaddb, &err_code, ut_args, 9,
	    conn_dbname, upgr_cb.Dbname_ptr->dba, dirname, 
	    Empty_str, Empty_str, Empty_str, Empty_str, 
	    Empty_str, Empty_str);
    }

    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "UTARGS: %s (%s %s %s) status = %d\n",
	    ut_args, conn_dbname, upgr_cb.Dbname_ptr->dba, dirname, cl_stat);

    if (cl_stat != OK)
    {
	/*
	** Save CL err info from UTexe so "du_error" can see it,
	** and don't truncate "dbname.oNN".
	*/
	STRUCT_ASSIGN_MACRO (err_code, errcb.du_clsyserr);
	du_talk(__LINE__, DU_ALWAYS, &upgr_cb, W_DU186C_UPGRADEDB_UNLOADDB, 2, 
		 0, dirname);
	upgr_cb.Dbname_ptr->tree_error = TRUE;
    }
    else
    {
	/* Truncate "dbname.oNN", for reuse by PCcmdline. */
	if ( OK == SIopen(&sql_output_loc, "w", &fp) )
	{
	    SIclose(fp);
	}

	/*
	**
	** Changes to be made to copy.in:
	** (Read copy.in... make these changes ... write dbname.sql0000n)
	** 
	** 1) Unloaddb adds the following line:
	**  \include $II_SYSTEM/ingres/files/iiud.scr
	** This is a quel script that causes the execution of the script
	** to fail with the error E_UD000C if there are front end catalogs. 
	** We need to strip this line from the unloaddb copy.in script
	**
	** 2) GRANT change for 65ES
	** grant insert -> grant insert, copy_into
	** grant select -> grant select, copy_from
	** grant ALL changes
	*/

	if (fix_iiud)
	{
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "Copy: %s \nTo: %s\n(remove iiud.scr %d, fix grants %d)\n", 
			copyin_loc_buf, sql_input_loc_buf,
			fix_iiud, grant_65es);
	    }
	    fix_copy_in(&copyin_loc, &sql_input_loc, fix_iiud);
	}
	else
	{
	    /* Make back up of copy.in -> dbname.sql0000n */
	    if (upg_dbg_out)
		SIfprintf(upgr_cb.du_dbg.du_file, "copy %s to %s\n", copyin_loc_buf, sql_input_loc_buf);
	    SIcopy(&copyin_loc, &sql_input_loc);
	}

	/*
	** Build our own command line for sql
	** We need to specify -A6 to connect as upgradedb
	** This is necessary so drop views won't need to read old trees
	**     - see back!qef!qeu qeuqmod.c qeu_v_ubt_id()
	** Also re-define check constraints won't (re)validate constraint
	**     - see back!qef!qeq qeaddl.c qea_createIntegrity{}
	**/
	{
	    char    ingresname[10];

	    STcopy("$ingres", ingresname);
	    if (upgr_cb.Dbname_ptr->upcase)
		CVupper(ingresname);
	    STprintf(sql_cmd, CMDLINE, ingresname, 
		    conn_dbname, sql_input_loc_buf, sql_output_loc_buf);
	}

	/* unloaddb successful */
	did_unload = TRUE;
    }

    /* Even if we had errors... try to redefine internal procedures */
    if (STcompare(dbname, DU_DBDBNAME) == 0)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [9] connect to iidbdb session %d id %s options = %s\n",
		    DBDB_SESSIONID, DU_DBA_DBDB,
		    upg_concurrent ? "+w" : "-A6 +w -l");
	}

	iidbdbname = conn_dbname;
	if (upg_concurrent)
	    EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
                     identified by :DU_DBA_DBDB options = '+w';
	else
	    EXEC SQL connect :iidbdbname session :DBDB_SESSIONID 
		     identified by :DU_DBA_DBDB options = '-A6', '+w', '-l';
	db_open = TRUE;
    }
    else if (star_db)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> connect to %s session %d id %s options = -A6 +w -l\n",
		    conn_dbname, STAR_SESSIONID, DU_DBA_DBDB);
	}
	EXEC SQL connect :sql_conn_dbname session :STAR_SESSIONID
		      identified by :DU_DBA_DBDB options = '-A6', '+w', '-l';
	db_open = TRUE;
    }
    else
    {
	db_open = open_target(CONNECT_EXCL);
	exec sql set_sql (session = :DB_SESSIONID);
    }

    if (db_open)
    {
	if (!star_db)
	{
	    if (upg_dbg_out)
		SIfprintf(upgr_cb.du_dbg.du_file, "Recreating internal procedures\n");

	    /* Re-create all internal procedures AFTER unloaddb, reload.ing */
	    duc_upgrade_internal_procs(dbname, upgr_cb.Dbname_ptr->upcase,
			    upgr_cb.Dbname_ptr->star_flag);
	    IIlq_Protect(TRUE);		/* Restore privs */
	}

	/* Need to redefine rules for referential constraints */
	/* (schka24) I'd rather see this after reload, but no problems
	** have been observed.
	** This doesn't work for upgrades from 1.2.  OI 1.2 didn't create
	** the rule text for the constraint rules!  We'll recreate the
	** entire constraint, below.
	*/
	if (level > V12_LEVEL)
	{
	    if (upg_dbg_out)
		SIfprintf(upgr_cb.du_dbg.du_file, "Recreating system generated rules\n");
	    (void) fix_sysgen_rules();
	}

	exec sql disconnect;
	upgr_cb.Connected = FALSE;
    }

#ifdef VMS
    if (did_unload || grant_fixes || cons_fixes)
    {
	if (PCcmdline(NULL, CMD_SQLSYMDEF, PC_WAIT, NULL, &err_code) != OK)
	    SIprintf("Defining 'sql' global symbol failed\n");
    }
#endif

    if (did_unload)
    {
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "Executing the command line: \n%s\n", sql_cmd);

	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0105_RELOADING_TREES, 0);
	if (PCcmdline(NULL, sql_cmd, (bool)PC_WAIT, NULL, &err_code) != OK)
	{
	    /* save CL err info from UTexe so "du_error" can see it */
	    STRUCT_ASSIGN_MACRO (err_code, errcb.du_clsyserr);
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, W_DU186D_UPGRADEDB_SQL, 2, 
		 0, sql_cmd);
	    SIprintf("PCcmdline '%s' failed\n", sql_cmd);
	    upgr_cb.Dbname_ptr->tree_error = TRUE;
	}
    }

    if (grant_fixes)
    {
	char    ingresname[10];

	STcopy("$ingres", ingresname);
	if (upgr_cb.Dbname_ptr->upcase)
	    CVupper(ingresname);
	STprintf(sql_cmd, CMDLINE, ingresname, 
		    conn_dbname, grant_fix_loc_buf, grant_out_loc_buf);
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "Executing the command line: \n%s\n", sql_cmd);
	if (PCcmdline(NULL, sql_cmd, (bool)PC_WAIT, NULL, &err_code) != OK)
	{
	    /* save CL err info from UTexe so "du_error" can see it */
	    STRUCT_ASSIGN_MACRO (err_code, errcb.du_clsyserr);
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, W_DU186D_UPGRADEDB_SQL, 2, 
		 0, sql_cmd);
	    SIprintf("PCcmdline '%s' failed\n", sql_cmd);
	    upgr_cb.Dbname_ptr->tree_error = TRUE;
	}
    }

    if (cons_fixes)
    {
	char    ingresname[10];

	if (level > V12_LEVEL)
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0111_RECREATING_REF_CONS, 0);
	else
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0113_RECREATING_CONS, 0);
	STcopy("$ingres", ingresname);
	if (upgr_cb.Dbname_ptr->upcase)
	    CVupper(ingresname);
	STprintf(sql_cmd, CMDLINE, ingresname, 
		    conn_dbname, ref_fix_loc_buf, ref_out_loc_buf);
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "Executing the command line: \n%s\n", sql_cmd);
	if (PCcmdline(NULL, sql_cmd, (bool)PC_WAIT, NULL, &err_code) != OK)
	{
	    /* save CL err info from UTexe so "du_error" can see it */
	    STRUCT_ASSIGN_MACRO (err_code, errcb.du_clsyserr);
	    du_talk(__LINE__, DU_ALWAYS, &upgr_cb, W_DU186D_UPGRADEDB_SQL, 2, 
		 0, sql_cmd);
	    SIprintf("PCcmdline '%s' failed\n", sql_cmd);
	    upgr_cb.Dbname_ptr->tree_error = TRUE;
	}
    }

    /* Verify unload-reload was complete */
    if (!STcompare(dbname, DU_DBDBNAME))
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> [10] connect to iidbdb session %d id %s options = %s\n",
		    DBDB_SESSIONID, DU_DBA_DBDB,
		    upg_concurrent ? "+w" : "-A6 +w -l");
	}

	iidbdbname = conn_dbname;
	/* Reopen iidbdb for remainder of conversion, if any */
	if (upg_concurrent)
	    EXEC SQL connect :iidbdbname session :DBDB_SESSIONID
                     identified by :DU_DBA_DBDB options = '+w';
	else
	    EXEC SQL connect :iidbdbname session :DBDB_SESSIONID 
		     identified by :DU_DBA_DBDB options = '-A6', '+w', '-l';
	db_open = TRUE;
    }
    else if (star_db)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> connect to %s session %d id %s options = -A6 +w -l\n",
		    conn_dbname, STAR_SESSIONID, DU_DBA_DBDB);
	}
	EXEC SQL connect :sql_conn_dbname session :STAR_SESSIONID
		      identified by :DU_DBA_DBDB options = '-A6', '+w', '-l';
	db_open = TRUE;
    }
    else
    {
	db_open = open_target(CONNECT_EXCL);
	exec sql set_sql (session = :DB_SESSIONID);
    }

    if (!db_open)
    {
	SIprintf("Error re-opening database %s connect dbname %s\n", 
		dbname, conn_dbname);
	return;
    }
    /*
    ** Make sure all views, check constraints, quel permits, procedures
    ** were recreated
    */
    post_view_cnt = post_intg_cnt = post_proc_cnt = -1;
    post_cons_cnt = -1;
    exec sql select count(*) into :post_view_cnt from iitables 
	    where table_type = 'V'
	    and lowercase(table_name) not like 'ii%';
    if (star_db)
    {
	/* Zero out meaningless quantities */
	pre_intg_cnt = post_intg_cnt = 0;
	pre_proc_cnt = post_proc_cnt = 0;
	pre_cons_cnt = post_cons_cnt = 0;
    }
    else
    {
	exec sql select count(*) into :post_intg_cnt from iiintegrities;
	exec sql select count(*) into :post_proc_cnt from iiprocedures
	    where text_sequence = 1
	    and lowercase(procedure_name) not like 'ii%'
	    and system_use <> 'G';
	exec sql select count(*) into :post_cons_cnt
	    from iiintegrity
	    where consflags <> 0;
    }
    old_view_cnt = old_intg_cnt = old_proc_cnt = -1;
    exec sql select count(*) into :old_view_cnt from iitables 
	    where table_type = 'V'
	    and lowercase(table_name) not like 'ii%'
	    and date(create_date) < :start_dt;
    if (! star_db)
    {
	exec sql select count(*) into :old_intg_cnt from iiintegrities
	    where date(create_date) < :start_dt;
	exec sql select count(*) into :old_proc_cnt from iiprocedures
	    where text_sequence = 1
	    and lowercase(procedure_name) not like 'ii%'
	    and system_use <> 'G'
	    and date(create_date) < :start_dt;
    }
    /* No "old" for constraints since we only need to recreate cross
    ** user ref constraints.  The others will look "old".
    */

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "Upgraded trees for %d views %d integrities %d procs %d cons\n",
	    pre_view_cnt, pre_intg_cnt, pre_proc_cnt, pre_cons_cnt);
	SIfprintf(upgr_cb.du_dbg.du_file, "After upgrade: %d views %d integrities %d procs %d cons\n",
	    post_view_cnt, post_intg_cnt, post_proc_cnt, post_cons_cnt);
	SIfprintf(upgr_cb.du_dbg.du_file, "Create date < start date for %d views %d integrities %d procs\n",
	    old_view_cnt, old_intg_cnt, old_proc_cnt);
    }

    /* No "old" for constraints since we only need to recreate cross
    ** user ref constraints.  The others will look "old".
    */


    /* See if all views were upgraded successfully */
    if (post_view_cnt != pre_view_cnt || old_view_cnt > 0)
    {
	new_cnt = post_view_cnt - old_view_cnt;
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU186E_VIEW_UPGRADE, 4,
	    sizeof(pre_view_cnt), &pre_view_cnt, sizeof(new_cnt), &new_cnt);
	upgr_cb.Dbname_ptr->tree_error = TRUE;
    }

    /* See if all integrities were upgraded successfully */
    if (post_intg_cnt != pre_intg_cnt || old_intg_cnt > 0)
    {
	new_cnt = post_intg_cnt - old_intg_cnt;
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU186F_INTEG_UPGRADE, 4,
	    sizeof(pre_intg_cnt), &pre_intg_cnt, sizeof(new_cnt), &new_cnt);
	upgr_cb.Dbname_ptr->tree_error = TRUE;
    }

    /*
    ** See if all procedures were upgraded successfully 
    ** Constraints can create additional procs (although one would think
    ** that they would be tagged G), so check for < instead of !=
    */
    if (post_proc_cnt < pre_proc_cnt || old_proc_cnt > 0)
    {
	new_cnt = post_proc_cnt - old_proc_cnt;
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1870_PROC_UPGRADE, 4,
	    sizeof(pre_proc_cnt), &pre_proc_cnt, sizeof(new_cnt), &new_cnt);
	upgr_cb.Dbname_ptr->tree_error = TRUE;
    }

    /* See if all integrity constraints were upgraded successfully */
    if (post_cons_cnt != pre_cons_cnt)
    {
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1871_CONS_UPGRADE, 4,
	    sizeof(pre_cons_cnt), &pre_cons_cnt,
	    sizeof(post_cons_cnt), &post_cons_cnt);
	upgr_cb.Dbname_ptr->tree_error = TRUE;
    }

    if (upgr_cb.Dbname_ptr->tree_error)
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, W_DU1872_UPGRADEDB_TREE_DB, 2,
		    0, dbname);

    return;

}

/*
** Name: fix_sysgen_rules
**
** Description:
**	The unloaddb process won't touch system generated rules.
**	These are generated for constraints.  We could drop and re-add
**	the constraints, but that can take a long time as the constraint
**	condition has to be re-checked, indexes built, etc.
**
**	To regenerate the rule tree, we'll create a rule identical to
**	the rule under consideration, but with a fake name.  We then
**	exchange the iitree ID's between new and old rules, and drop
**	the new rule (which thus drops the old tree).
**
**	This little trick doesn't work for REF constraints that refer
**	to another user's table, as one can't normally create a rule on
**	someone else's table.  But that's what a REF constraint does.
**	Cross-user REF constraints cause permit issues as well, so
**	they are dropped before we get here, and recreated later on.
**
** Inputs:
**	none
**
** Output:
**	Returns OK/notok status.
**
** History:
**	?????
**
**	11-Sep-2004 (schka24)
**	    Take out the special ref-constraint stuff.  It doesn't always
**	    work as coded, and there are other reasons why they have to
**	    be dropped and recreated anyway.
*/

static STATUS
fix_sysgen_rules()
{
    EXEC SQL BEGIN DECLARE SECTION;
	char		tmp_rule_name[DB_MAXNAME + 1];
	char		cur_rule_name[DB_MAXNAME + 1];
	char		cur_rule_owner[DB_MAXNAME + 1];
	char		rule_name[DB_MAXNAME + 1];
	char		rule_owner[DB_MAXNAME + 1];
	char		table_name[DB_MAXNAME + 1];
	i4		text_sequence;
	char		text_segment[512]; /* really only need 240 */
	char		tbuf[100+DB_MAXNAME];
	char		*rule_buf;
	i4		cnt;
	i4		max_text_sequence;
	i2		max_null;
	i4		tmp_rule_treeid1;
	i4		tmp_rule_treeid2;
	i4		sys_rule_treeid1;
	i4		sys_rule_treeid2;
	char		err_msg[500];
    EXEC SQL END DECLARE SECTION;
	STATUS		status;
	i4		rows_found;

    /* Init temp rule name */
    STcopy("temp_upgradedb_rule_for_rconstr", &tmp_rule_name[0]);
    if (upgr_cb.Dbname_ptr->upcase)
	CVupper(tmp_rule_name);

    /* Init current rule name, rule owner to empty */
    cur_rule_name[0] = '\0';
    cur_rule_owner[0] = '\0';


    EXEC SQL SELECT count(*), max(text_sequence)
    INTO :cnt, :max_text_sequence:max_null
    FROM iirules WHERE system_use = 'G';
    if (sqlca.sqlcode != 0)
	return (FAIL);
    else if (!cnt)
    {
	return (OK);
    }

    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "iirules cnt = %d max_null = %d\n", cnt, max_null);

    /* Allocate buffer for rule text */
    rule_buf = (PTR)MEreqmem(0, (max_text_sequence + 1) * sizeof(text_segment),
		TRUE, &status);
    if (status != OK)
    {
	return (FAIL);
    }

    for ( ; ; )
    {
	EXEC SQL commit;
	(void) setauth("$ingres");

	/* get the next rule text and create a temp rule just like it */
	rows_found = 0;
	MEfill(sizeof(text_segment), '\0', &text_segment[0]);

	/* Hmm, can we do this any less efficiently... */
	EXEC SQL REPEATED SELECT 
	    varchar(rule_name) as rule_name,
	    varchar(rule_owner) as rule_owner,
	    varchar(table_name) as table_name,
	    text_sequence, text_segment
	INTO 
	    :rule_name, :rule_owner, :table_name, :text_sequence, :text_segment
	FROM iirules
	WHERE system_use = 'G'
	AND (rule_owner > :cur_rule_owner 
	    OR (rule_owner = :cur_rule_owner AND rule_name > :cur_rule_name))
	ORDER BY rule_owner, rule_name, text_sequence;

	EXEC SQL BEGIN;
	    if (sqlca.sqlcode != 0)
	    {
		EXEC SQL ENDSELECT;
	    }

	    if (text_sequence == 1)
	    {
		char *cp;

		if (rows_found)
		{
		    EXEC SQL ENDSELECT;
		}

		cp = STstrindex(text_segment, "AFTER", 0, TRUE);
		STprintf(rule_buf, "create rule %s %s", tmp_rule_name, cp); 
		STcopy(rule_name, &cur_rule_name[0]);
		STcopy(rule_owner,  &cur_rule_owner[0]);
	    }
	    else
	    {
		STcat(rule_buf, text_segment);
	    }

	    rows_found++;

	    /* clear text_segment buffer after each row */
	    MEfill(sizeof(text_segment), '\0', &text_segment[0]);
	  
	EXEC SQL END;

	if (!rows_found)
	    break;

	/* set session authorization not allowed if already in transaction */
	EXEC SQL commit;
	if (setauth(cur_rule_owner) != OK)
	{
	    SIprintf("sqlcode %d\n", sqlca.sqlcode);
	    EXEC SQL inquire_ingres (:err_msg = errortext);
	    SIprintf("]==> error text: %s\n\n", err_msg);
	    continue;
	}

	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "%s\n", rule_buf);

	EXEC SQL EXECUTE IMMEDIATE :rule_buf;
	if (sqlca.sqlcode != 0)
	{
	   SIprintf("Error for user %s: ", rule_owner);
	   SIprintf("%s returned ", rule_buf);
	   SIprintf("sqlcode %d\n", sqlca.sqlcode);
	   EXEC SQL inquire_ingres (:err_msg = errortext);
	   SIprintf("]==> error (%d) -  text : %s\n\n", sqlca.sqlcode, err_msg);
	    continue;
	}   

        /* update iirule and switch rule_treeid1, rule_treeid2 */
	EXEC SQL commit;
	if (sqlca.sqlcode == 0)
	{
	    (void) setauth("$ingres");
	}

	if (sqlca.sqlcode == 0)
	{
	    EXEC SQL set session with privileges=all;
	    IIlq_Protect(TRUE);
	}

	if (sqlca.sqlcode == 0)
	{
	    EXEC SQL SELECT rule_treeid1, rule_treeid2
	    INTO :sys_rule_treeid1, :sys_rule_treeid2
	    FROM iirule 
	    WHERE rule_name = :cur_rule_name
	    AND rule_owner = :cur_rule_owner;
	}

	if (sqlca.sqlcode == 0)
	{
	    EXEC SQL SELECT rule_treeid1, rule_treeid2
	    INTO :tmp_rule_treeid1, :tmp_rule_treeid2
	    FROM iirule
	    WHERE rule_name = :tmp_rule_name
	    AND rule_owner = :cur_rule_owner;
	}

	if (sqlca.sqlcode == 0)
	{
	    EXEC SQL UPDATE iirule 
	    SET rule_treeid1 = :tmp_rule_treeid1, 
		rule_treeid2 = :tmp_rule_treeid2
	    WHERE rule_name = :cur_rule_name
	    AND rule_owner = :cur_rule_owner;
	}

	if (sqlca.sqlcode == 0)
	{
	    EXEC SQL UPDATE iirule
	    SET rule_treeid1 = :sys_rule_treeid1, 
		rule_treeid2 = :sys_rule_treeid2
	    WHERE rule_name = :tmp_rule_name
	    AND rule_owner = :cur_rule_owner;
	}

	if (sqlca.sqlcode == 0)
	{
	    EXEC SQL commit;
	}
	else
	{
	    SIprintf("sqlcode %d\n", sqlca.sqlcode);
	    EXEC SQL inquire_ingres (:err_msg = errortext);
	    SIprintf("]==> error text: %s\n\n", err_msg);

	    EXEC SQL rollback;
	}

	(void) setauth(cur_rule_owner);
	/* drop temp rule */
	STprintf(tbuf, "drop rule %s\n", tmp_rule_name);
	EXEC SQL EXECUTE IMMEDIATE :tbuf;


	/* try to find the next rule */
    }

    MEfree(rule_buf);
    return (OK);
}


/*{
** Name:	fix_copy_in - Fix copy.in file for upgradedb
** 
** Description: The copy.in file generated by unloaddb may need some editing:
**
** 1) Remove the 'include iiud.scr' 
**    iiud.scr is a quel script that causes the execution of the script
**    to fail with the error E_UD000C if there are front end catalogs.
**
** (We used to mess with old 6.4-style grants, but it was pointless and
** I removed it - schka24.)
**
** Inputs:
**      in		input file
**      out		output file
**      fix_iiud	Strip out include iiud.scr ?
**
** Outputs:
**	none.
**
** History:
**      13-dec-01 (stial01)
**         Re-wrote original routine in doview.qsc, which selected query text
**         and issued sql statements. Here we just update the file created
**         by unloaddb, so we don't have to worry about delimited IDs
**	7-Sep-04 (schka24)
**	   Probably too late to be practical, but ... don't mess with
**	   6.4 style grants.  The server properly translates ALL grants
**	   to whatever ALL means these days (which is IMO the proper action),
**	   and there's no real need to attach COPY-IN and COPY-OUT to
**	   SELECT and INSERT grants.
*/

# define MAX_LINE 16384 /* 16 KB Buffer */

void
fix_copy_in(LOCATION *in, LOCATION *out, bool fix_iiud)
{
    FILE            *in_fp;
    FILE            *out_fp;
    PTR             buf;
    PTR		    buf2;	
    PTR		    cur_buf;
    PTR		    str;
    char	    *cp;
    STATUS          status;
    i4		    count;
	
    status = SIopen(in, "r", &in_fp);
    if (status == OK)
    {
	status = SIopen(out, "w", &out_fp);
	if (status == OK)
	{
	    /* Set for continue after errors, autocommit */
	    SIfprintf(out_fp, "\\continue\nset autocommit on\n\\p\\g\n");

	    buf = (PTR)MEreqmem(0, 2 * MAX_LINE, TRUE, &status);
	    if (status == OK)
	    {
		buf2 = buf + MAX_LINE;
		while (SIgetrec(buf, MAX_LINE, in_fp) == OK)
		{
		    cur_buf = buf;
		    str = NULL;

		    /* Skip leading blanks and tabs */
		    for (cp = buf; 
			(*cp == ' ' || *cp == '\t') && cp < buf + MAX_LINE; 
			cp++);

		    if (fix_iiud && MEcmp(ERx("\\include"), cp, 8) == 0
			&& STstrindex(cp, "iiud.scr", 0, TRUE))
		    {
			/* found the line to remove */
			fix_iiud = FALSE; 
			/* continue without copying this line */
			continue;
		    }

		    status = SIwrite((i4)STlength(cur_buf), cur_buf, &count, out_fp);
		    if (status != OK)
			break;
		}
		if (status == ENDFILE)
		    status = OK;
		MEfree(buf);
	    }
	    SIclose(out_fp);
	}
	SIclose(in_fp);
    }
    /* Pitch return status because nobody cares! */
} /* fix_copy_in */

static STATUS
fix_dbservice(dbname)
EXEC SQL begin declare section;
	char *dbname;
EXEC SQL end declare section;
{
    EXEC SQL begin declare section;
	i4	dbservice;
	i4	newdbservice;
	char	*dbname_ptr;
	i4	proc_instruction;
	char    areaname[DB_AREA_MAX + 1];
    EXEC SQL end declare section;

    if (!upgr_cb.dbdb_open)
	return (E_DB_ERROR);

    EXEC SQL set lockmode on iidatabase where level = table;
    exec sql select iidatabase.dbservice,iilocations.area
    into :dbservice, :areaname
    from iidatabase, iilocations 
    where iidatabase.name = :dbname and iidatabase.dbdev = iilocations.lname;

    _VOID_ STtrmwhite(areaname);
    newdbservice = dbservice;

    if (sqlca.sqlcode != 0)
    {
	SIprintf("Cannot update dbservice for database %s\n", dbname);
    }
    else
    {
	if (upgr_cb.dbmsinfo_lp64 == 'Y')
	    newdbservice = dbservice | DU_LP64;
	else
	    newdbservice = dbservice & ~DU_LP64;
	if (newdbservice != dbservice)
	{
	    dbname_ptr = dbname;
	    if (upg_dbg_out)
		SIfprintf(upgr_cb.du_dbg.du_file, "Updating iidatabase.dbservice for %s from %x to %x\n",
		    dbname, dbservice, newdbservice);

	    (void) setauth("$ingres");

	    if (! upgr_cb.Dbname_ptr->star_flag && !STcmp(dbname_ptr,upgr_cb.Dbname_ptr->ddbname) == 0)
	    {
	    /* Update the dbservice field in the config file - for non DDBs only */
	    proc_instruction = QEA_UPD_SERVICE;
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> [2] ii_update_config(%s, %s, %d, %d)\n",
		dbname_ptr, areaname, proc_instruction, newdbservice);
	    }
	    exec sql execute procedure ii_update_config(
					    database_name = :dbname_ptr,
					    location_area = :areaname,
					    update_map = :proc_instruction,
					    service = :newdbservice);
	    if (sqlca.sqlcode < 0)
	    {
		du_talk(__LINE__,  DU_MODESENS, &upgr_cb, W_DU1862_CNF_UPDATE_FAIL,
			  2, 0, upgr_cb.du_opendb);
		upgr_cb.Dbname_ptr->errors = TRUE;
	    }
	    }

	    /* Update iidatabase.dbservice */
	    exec sql update iidatabase set dbservice = :newdbservice
		    where name = :dbname;
	}
	else if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "Do not need to update iidatabase.dbservice for %s (%x)\n", 
		    dbname, dbservice);
    }

    exec sql commit;
    return (E_DU_OK);
}

/*}
** Name: fix_syscat_grants
**
** Description:
**	Various problems have arisen over the years with the way
**	that catalogs have been granted.  E.g. old conversions from
**	6.4 left the extended catalogs in a state where they were
**	granted all to the DBA, by the DBA, which had no grant option!
**	(The grant should have been issued by $ingres.)
**	Verifydb in particular has a hissy-fit over this, and wants
**	to drop the catalog. (!)
**
**	In order to clean up the situation, we'll simply drop all
**	base table catalog grants, and reissue them.
**	Ordinary catalogs are granted select to public with grant option.
**	Extended catalogs are additionally granted all to dba.
**	(The grant option lets people define and grant views on
**	catalogs.)  We don't need to deal with standard catalog views,
**	since this code runs while they're all dropped.
**
**	It should be noted that this fixup will take care of catalogs
**	that are dropped/recreated during upgrade, as well.  (The
**	duc_create_catalog routine doesn't grant anything.)
**
**	It should also be noted that DROP PERMIT is being used instead
**	of the harder-to-generate REVOKE.  DROP PERMIT operates in
**	RESTRICT mode, not CASCADE mode, and so some drops may (silently)
**	fail if users have defined views on system catalogs.  However if
**	a catalog has a view on it, it's probably granted properly
**	already.
**
** Inputs:
**	dbname			The database name
**
** Outputs:
**	none
**
** History
**	8-Sep-2004 (schka24)
**	    Written to clean up detritus from old upgrades.
*/

static void
fix_syscat_grants(char *dbname)
{
    exec sql begin declare section;
    char grant_stmt[DB_MAXNAME+50];	/* grant select on xxx to public wgo */
    char table_name[DB_MAXNAME+1];	/* A table name */
    i4 relstat;				/* Relation status flags */
    exec sql end declare section;

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0107_FIXING_CAT_GRANTS, 0);
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> Redoing all system catalog grants\n");
    }

    /* Cursors suck toxic wastes, but it's the easiest way.
    ** The varchar() is for blank stripping.
    */

    /* No views, no indexes, and [extended] catalogs only.
    ** that aren't ii_xxx catalogs (eg iidbcapabilities).
    ** (because they aren't treated the same by createdb either.)
    ** Basically, all the front-end stuff.
    */
    exec sql declare grant_c1 cursor for
	select varchar(relid) as relid, relstat
	from iirelation
	where lowercase(relowner) = '$ingres'
	    and (mod(relstat/16384,2) = 1	/* Extended catalog */
		 or mod(relstat, 2) = 1)	/* Regular catalog */
	    and mod(relstat/32,2) = 0		/* not a view */
	    and mod(relstat/128,2) = 0		/* not an index */
	    and lowercase(relid) NOT IN ('iirelation','iiprotect',
					'iiqrytext','iitree','iidbdepends');

    exec sql open grant_c1 for readonly;
    check_sql(sqlca.sqlcode);
    if (sqlca.sqlcode < 0)
    {
	exec sql rollback;
	SIprintf("Error fixing system catalog grants\n");
	return;
    }
    for (;;)
    {
	exec sql fetch grant_c1 into :table_name, :relstat;
	if (sqlca.sqlcode == DU_SQL_NONE)
	    break;
	CVlower(table_name);
	STprintf(grant_stmt, "drop permit on %s all", table_name);
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> %s\n", grant_stmt);
	exec sql execute immediate :grant_stmt;
	/* Ignore drop error... */

	/* Extended catalogs get "all to dba".  Note: only do
	** ii_xxx type catalogs.  iidbcapabilities and one other are
	** marked as ext-catalogs, but don't get the all-to-dba priv.
	** All catalog names are at least 3 chars long...!
	*/
	if ((relstat & TCB_EXTCATALOG) && table_name[2] == '_')
	{
	    STprintf(grant_stmt, "grant all on %s to %s", table_name,upgr_cb.Dbname_ptr->dba);
	    if (upg_dbg_out)
		SIfprintf(upgr_cb.du_dbg.du_file, "]==> %s\n", grant_stmt);
	    exec sql execute immediate :grant_stmt;
	    check_sql(sqlca.sqlcode);
	    if (sqlca.sqlcode < 0)
	    {
		exec sql commit;
		SIprintf("Error granting extended catalog %s\n",table_name);
		break;
	    }
	}
	/* Now for the regular select-to-public grant */
	STprintf(grant_stmt, "grant select on %s to public with grant option", table_name);
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> %s\n", grant_stmt);
	exec sql execute immediate :grant_stmt;
	check_sql(sqlca.sqlcode);
	if (sqlca.sqlcode < 0)
	{
	    exec sql commit;
	    SIprintf("Error granting catalog %s\n",table_name);
	    break;
	}
    }
    exec sql close grant_c1;
    exec sql commit;
    /* Do iirelation and permit catalogs separately.  "DROP" does a
    ** protect/qrytext/tree scan and you get "close that table" error.
    ** Don't mess with iiprotect or iiqrytext at all, other than
    ** making sure that a grant is there.
    */
    exec sql drop permit on iirelation all;
    exec sql grant select on iirelation to public with grant option;
    exec sql commit;
    exec sql grant select on iiqrytext to public with grant option;
    exec sql commit;
    exec sql grant select on iiprotect to public with grant option;
    exec sql commit;
    exec sql grant select on iitree to public with grant option;
    exec sql commit;
    exec sql grant select on iidbdepends to public with grant option;
    exec sql commit;

    /* As a courtesy, re-modify iiprotect, which has just undergone
    ** a serious beating.
    */
    (void) duv_modify_catalog(dbname, "iiprotect");

} /* fix_syscat_grants */

/*}
** Name: fix_64_grants
**
** Description:
**	When converting from 6.4 or earlier, grants of all-to-public
**	or select-to-public are ONLY recorded in iirelation.  (Unlike
**	later releases, which have the iirelation bit, but also record
**	the individual grants composing the ALL privilege.)
**	We need to detect these all-to-public and select-to-public
**	grants, and reissue them as proper grant statements so
**	that utilities such as unloaddb understand them.
**
**	Fixing these grant problems brings up a nice little chicken-
**	and-egg situation.  We can't regrant views until the query
**	trees are rebuilt with unload/reload.  If we wait to do this
**	until after the unloaddb script runs, we lose all memory of
**	the original public grants (since the script drops all permits).
**	The best answer seems to be to write a script file with the
**	proper grants, to be run after unloaddb and reload runs.
**
**	This routine is called from fix-query-trees after all standard
**	catalog views are dropped (so we don't need to deal with them).
**
** Inputs:
**	dbname			The database name
**	grant_fix_loc		LOCATION for grant-fix script file
**	grant_fix_loc_buf	String buffer for above (for msgs)
**
** Outputs:
**	TRUE if need to run grant-fix script, else FALSE
**
** History
**	8-Sep-2004 (schka24)
**	    Write, eight years too late.  Bah.  Replaces grant_select_64_11
**	    which was being called too late, and didn't fix ALL grants.
*/

static bool
fix_64_grants(char *dbname, LOCATION* grant_fix_loc,
	char *grant_fix_loc_buf)
{
    bool any_grants;			/* TRUE if anything scripted */
    char last_owner[DB_MAXNAME+1];	/* Previous owner */
    FILE *fp;				/* Script output stream */

    exec sql begin declare section;
    char all_to_all[1+1];		/* all-to-public flag */
    char grant_stmt[DB_MAXNAME+50];	/* grant select on xxx to public wgo */
    char select_to_all[1+1];		/* select-to-public flag */
    char table_name[DB_MAXNAME+1];	/* A table name */
    char table_owner[DB_MAXNAME+1];	/* A table owner */
    exec sql end declare section;

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0106_FIXING_64_GRANTS, 0);

    /* Generate grant all or grant select to public statements, for
    ** everything that has the all-to-all or ret-to-all bits clear.
    ** We'll skip standard or extended catalogs, as we dealt with them
    ** in fix-syscat-grants.
    **
    ** Note that the all-to-all and ret-to-all bits work in negative
    ** logic, ie set means OFF.
    */

    if (SIopen(grant_fix_loc, "w", &fp) != OK)
    {
	SIprintf("Error opening grant-fix output file %s\n", grant_fix_loc_buf);
	return (FALSE);
    }

    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> Writing public grants to %s\n",grant_fix_loc_buf);

    any_grants = FALSE;
    /* Set for continue after errors, autocommit */
    SIfprintf(fp, "\\continue\nset autocommit on\n\\p\\g\n");
    last_owner[0] = '\0';
    /* Fire up select loop */
    exec sql
	select varchar(relid) as relid, varchar(relowner) as relowner,
	    charextract('YN', mod((relstat/4096), (2)) +1) as all_to_all,
	    charextract('YN', mod((relstat/8192), (2)) +1) as ret_to_all
	into :table_name, :table_owner, :all_to_all, :select_to_all
	from iirelation
	where mod(relstat/4096, 4) != 3		/* ret- or all-to-all */
	    and mod(relstat/128,2) = 0		/* not an index */
	    and (relowner != '$ingres'		/* Not a catalog */
	      or mod(relstat/16384,2) + mod(relstat, 2) = 0)
	order by relowner, relid;
    exec sql begin;
	any_grants = TRUE;

	/* If different owner, emit authorization change */
	if (STcompare(table_owner, last_owner) != 0)
	{
	    SIfprintf(fp, "set session authorization %s\n\\p\\g\n", table_owner);
	    STcopy(table_owner, last_owner);
	}
	/* Issue the proper grant. */
	SIfprintf(fp, "grant %s on %s to public\n\\p\\g\n",
		    all_to_all[0] == 'Y' ? "all" : "select", table_name);
    exec sql end;
    check_sql(sqlca.sqlcode);
    if (sqlca.sqlcode < 0)
    {
	exec sql rollback;
	SIprintf("Error retrieving ALL and SELECT public grants\n");
	any_grants = FALSE;
    }
    exec sql commit;
    SIclose(fp);

    return (any_grants);
} /* fix_64_grants */

/*}
** Name: fix_constraints - Fix 1.2 or cross-user referential constraints
**
** Description:
**	This routine fixes up constraints for a couple of problem cases:
**	cross-user constraints, or 1.2 constraints.  The problems are
**	rather different, but the solution is the same, which is why
**	they are both dealt with here.
**
**	Cross-user referential integrity constraints pose an upgrade
**	problem, in a a couple different ways:
**
**	1. The constraint rule(s) generated for the referenced table
**	are created by the constraint user C, but belong to and apply
**	to the referenced table owner R.  Normally, one can't create
**	rules for someone else's table.  This will blow out the
**	rule tree fixups in fix_system_rules.
**
**	2. The constraint depends on the REFERENCES permission
**	on the referenced table.  If there are permits with query
**	trees, unloaddb is told to drop all permits and recreate them
**	all.  The permit drop on the referenced table will fail
**	because (for convenience) it's done with DROP ALL, not REVOKE,
**	and DROP operates in RESTRICT mode, not CASCADE mode.  (Using
**	REVOKE doesn't really help, because REVOKE CASCADE would
**	drop the constraint!)
**
**	Note that these problems only arise when the referencing and
**	referenced tables have different owners.
**
**	1.2 constraints that generate rules (namely referential and
**	check constraints), create rules with no text!  Amazing.  Since
**	there's no rule text, the trick used by fix_sysgen_rules to
**	rebuild a new version rule tree doesn't work.  The only solution
**	is to drop and recreate all ref and check constraints.
**
**	This routine fixes either situation by dropping the selected
**	constraints, and writing a script file to recreate them after
**	all other query trees (and permits) are dropped and recreated.
**
**	We're called after standard catalogs have been recreated, but
**	before unloaddb is run to generate permit and object drops
**	and recreates.
**
** Inputs:
**	dbname			The database name
**	level			The original database version
**	ref_fix_loc		LOCATION for ref-fix script file
**	ref_fix_loc_buf		String buffer for above (for msgs)
**
** Outputs:
**	TRUE if need to run ref-recreate script, else FALSE
**
** History
**	12-Sep-2004 (schka24)
**	    Replace original cross-user workaround, which failed in the
**	    presence of QUEL permits thanks to issue #2 above.
*/

static bool
fix_constraints(char *dbname, i4 level, LOCATION* ref_fix_loc,
	char *ref_fix_loc_buf)
{
    bool first_time;			/* First-time loop flag */
    char last_owner[DB_MAXNAME+1];	/* Previous owner */
    FILE *fp;				/* Script output stream */
    STATUS st;				/* General status holder */

    exec sql begin declare section;
    char cons_name[DB_MAXNAME+3];	/* A constraint name */
    char sel_cons_name[DB_MAXNAME+1];	/* Select result: constraint name */
    char sel_table_name[DB_MAXNAME+1];	/* Select result: table name */
    char sel_schema_name[DB_MAXNAME+1];	/* Select result: schema name */
    char sql_stmt[2*DB_MAXNAME+100];	/* alter table xx drop constraint yy restrict */
    char table_name[DB_MAXNAME+3];	/* A table name */
    char table_owner[DB_MAXNAME+1];	/* A table owner */
    char text_segment[250];		/* Hardcoded to 240 in eg dbdbms.h */
    char *text_buf;			/* Area for constraint text */
    i4 maxseq;				/* Max # of constraint texts */
    i4 n;				/* Constraint count or seq */
    exec sql end declare section;

    /* First, see if there are any of these buggers to worry about */

    if (level > V12_LEVEL)
    {
	exec sql select count(*), ifnull(max(c.text_sequence),0) as max_seq
	    into :n, :maxseq
	    from iiref_constraints r, iiconstraints c
	    where r.ref_schema_name <> r.unique_schema_name
		and c.constraint_name = r.ref_constraint_name
		and c.schema_name = r.ref_schema_name
		and c.table_name = r.ref_table_name;
    }
    else
    {
	exec sql select count(*), ifnull(max(text_sequence),0) as max_seq
	    into :n, :maxseq
	    from iiconstraints
	    where constraint_type in ('C', 'R');
    }
    check_sql(sqlca.sqlcode);
    if (sqlca.sqlcode < 0)
    {
	SIprintf("Error checking for cross-user ref constraints\n");
	return (FALSE);
    }
    if (n == 0)
	return (FALSE);

    /* Work to do, allocate some text working space */

    if (level > V12_LEVEL)
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0110_DROPPING_REF_CONS, 0);
    else
	du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0112_DROPPING_CONS, 0);

    text_buf = (char *) MEreqmem(0, (maxseq + 1) * sizeof(text_segment),
		TRUE, &st);
    if (st != OK)
    {
	SIprintf("MEreqmem for %d failed\n", (maxseq+1) * sizeof(text_segment));
	return (FALSE);
    }
    if (SIopen(ref_fix_loc, "w", &fp) != OK)
    {
	SIprintf("Error opening ref-constraint-fix output file %s\n", ref_fix_loc_buf);
	return (FALSE);
    }

    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> Writing ref constraint re-adds to %s\n",ref_fix_loc_buf);

    /* Set for continue after errors, autocommit */
    SIfprintf(fp, "\\continue\nset autocommit on\n\\p\\g\n");
    last_owner[0] = '\0';

    /* Select a cross-user ref constraint, drop it, and write a recreate
    ** request into the ref fixup file.
    ** Unfortunately, the drop may require a user switch, which requires
    ** a commit, so this can't be done with a cursor.  Laboriously
    ** re-select each time.
    ** Varchar for blank strip.
    */
    for (;;)
    {
	first_time = TRUE;
	text_buf[0] = EOS;
	/* Easiest to just duplicate the text gathering loop for
	** the two different conditions: ref constraints or 1.2 constraints
	*/
	if (level > V12_LEVEL)
	{
	    exec sql repeated select
		    varchar(r.ref_constraint_name) as ref_constraint_name,
		    varchar(r.ref_schema_name) as ref_schema_name,
		    varchar(r.ref_table_name) as ref_table_name,
		    c.text_sequence,
		    c.text_segment
		into :sel_cons_name, :sel_schema_name, :sel_table_name,
		    :n, :text_segment
		from iiref_constraints r, iiconstraints c
		where r.ref_schema_name <> r.unique_schema_name
		    and c.constraint_name = r.ref_constraint_name
		    and c.schema_name = r.ref_schema_name
		    and c.table_name = r.ref_table_name
		order by ref_schema_name,ref_table_name,ref_constraint_name,
		    text_sequence;
	    exec sql begin;
		if (n == 1)
		{
		    /* First segment, see if first or new constraint */
		    if (! first_time)
		    {
			/* Start of new constraint, skip out */
			exec sql endselect;
		    }
		    first_time = FALSE;
		    /* Move constraint info to safe place. */
		    STcopy(sel_cons_name, cons_name);
		    STcopy(sel_schema_name, table_owner);
		    STcopy(sel_table_name, table_name);
		}
		STcat(text_buf, text_segment);
	    exec sql end;
	}
	else
	{
	    exec sql repeated select
		    varchar(constraint_name) as constraint_name,
		    varchar(schema_name) as schema_name,
		    varchar(table_name) as table_name,
		    text_sequence,
		    text_segment
		into :sel_cons_name, :sel_schema_name, :sel_table_name,
		    :n, :text_segment
		from iiconstraints
		where constraint_type in ('C', 'R')
		order by schema_name,table_name,constraint_name,text_sequence;
	    exec sql begin;
		if (n == 1)
		{
		    /* First segment, see if first or new constraint */
		    if (! first_time)
		    {
			/* Start of new constraint, skip out */
			exec sql endselect;
		    }
		    first_time = FALSE;
		    /* Move constraint info to safe place. */
		    STcopy(sel_cons_name, cons_name);
		    STcopy(sel_schema_name, table_owner);
		    STcopy(sel_table_name, table_name);
		}
		STcat(text_buf, text_segment);
	    exec sql end;
	}
	check_sql(sqlca.sqlcode);
	if (sqlca.sqlcode < 0)
	{
	    SIprintf("Error gathering constraint info\n");
	    break;
	}
	exec sql commit;
	if (first_time)
	    break;			/* Finished, exit */

	/* Drop this constraint */
	if (setauth(table_owner) != OK)
	{
	    SIprintf("fix_constraints: error setting to user %s", table_owner);
	    break;
	}

	STprintf(sql_stmt, "alter table \"%s\" drop constraint \"%s\" restrict",
		table_name, cons_name);
	if (upg_dbg_out)
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> fix_constraint: %s\n",sql_stmt);
	exec sql execute immediate :sql_stmt;
	check_sql(sqlca.sqlcode);
	if (sqlca.sqlcode < 0)
	{
	    SIprintf("Error dropping constraint %s (table %s, user %s)\n",
		cons_name,table_name,table_owner);
	    break;
	}

	/* Write the recreate string */
	if (STcompare(table_owner, last_owner) != 0)
	{
	    SIfprintf(fp, "set session authorization %s\n\\p\\g\n", table_owner);
	    STcopy(table_owner, last_owner);
	}
	/* In the learn-something-new-every-day dept:
	** If the constraint name starts with "$", we could omit the
	** entire "constraint xxx" phrase, and let the server (re)name
	** it.  That would also allow removal of the hack in pslsgram.yi
	** that I added to let upgradedb define objects with $-names.
	** I didn't know that syntax was valid.
	** Todo someday.
	*/
	SIfprintf(fp, "alter table \"%s\" add constraint \"%s\" %s\n\\p\\g\n",
		table_name, cons_name, text_buf);
    } /* for */

    /* All cross-user ref constraints should be gone unless an error occurred */
    SIclose(fp);
    exec sql commit;
    setauth("$ingres");

    return (TRUE);
} /* fix_constraints */

/*
** Name: UpgrExitOnError - issue error and exit if SQL error
**
** Description:
**	This routine is basically a check_sql that exits with
**	error if an actual error occurred.
**
**	Basically, this is some duct-taping until we get the entire
**	SQL error handling in upgradedb fixed up, it's pretty
**	half-assed at the moment.  (sometimes trapped with WHENEVER,
**	and sometimes not...)
**
** Inputs:
**	sqlcode			integer sqlcode from sqlca
**
** Outputs:
**	none
**
** Returns:
**	nothing if OK, exits if error
**
** History:
**	27-Apr-2010 (kschendel) SIR 123639
**	    Integrated from Datallegro (written summer 2006 lluo).
*/

static void
UpgrExitOnError(i4 sqlcode)
{
    exec sql begin declare section;
    char errtxt[200];
    exec sql end declare section;
    if (sqlcode < 0)
    {
	EXEC SQL INQUIRE_INGRES (:errtxt = ERRORTEXT);
	SIprintf("\nSQL Error:\n %s\n", errtxt );
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }
} /* UpgrExitOnError */

/*{
** Name: tbl_lacks_col	- determines whether a table needs 6.5 conversion
**
** Description:
**	
**	Verify the named table doesn't have the named column.
**	Intended to be called to find out if a table is already
**	in 6.5 format, e.g. already has a column.  Thus it is
**	also intended to return TRUE if table itself does not
**	exist.  This still means table needs 6.5 conversion.
**	If it isn't even there it clearly isn't in 6.5 format.
**
** Inputs:
**	table name
**	column name
**
** Outputs:
**	none
**
** Returns:
**	TRUE if table lacks the col, FALSE otherwise
**
** History:
**	January 1993 (jpk)
**	     written
**	07-jan-1997 (nanpr01)
**	    FIPS upgrade bug 87948.
*/
static bool
tbl_lacks_col(tname, cname)
exec sql begin declare section;
char	*tname;
char	*cname;
exec sql end declare section;
{
    exec sql begin declare section;
	int		tup_cnt;
    exec sql end declare section;

    /* xxx debugging for upgradedb. should go away in next integration */
    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file,
	"]==> does tbl %s lack col %s?\n", tname, cname);
    }
    exec sql select count(*) into :tup_cnt
	from iiattribute a, iirelation r where
	lowercase(r.relid) = :tname and lowercase(r.relowner) = '$ingres'
	and lowercase(a.attname) = :cname and a.attrelid = r.reltid
	and a.attrelidx = r.reltidx;

    if (tup_cnt == 0)
    {
	return TRUE;
    }
    else
    {
	return FALSE;
    }
    /* NOTREACHED */
}


/*}
** Name: modify_physlock_tbls 
**
** Description:
**      modifies TCB2_PHYSLOCK_CONCUR tables back to their intended
**      structure - which should be HASH.
**      TCB2_PHYSLOCK_CONCUR implies physical locks which will only
**      guarantee consistency if the structure is HASH
**
**	Only catalogs should have the TCB2_PHYSLOCK_CONCUR flag, so
**	including a test for it in the WHERE clause should eliminate
**	all sorts of dross (physical partitions, views, etc).
**
** Inputs:
**      none
**
** Outputs:
**      none
**
** History
**	10-Feb-2010 (maspa05)
**          created.
**	27-Apr-2010 (kschendel) SIR 123639
**	    Add a where clause to reduce traffic in db's with many tables.
**	    Return DU_STATUS as advertised, not DB_STATUS.
*/
static DU_STATUS 
modify_physlock_tbls()
{
    i2	i,j=-1;
    DU_STATUS retval=E_DU_OK;

    /* array to collect catalogs we need to modify
       should be <= DU_1MAXDBMS_CATDEFS i.e. number of
       non-core DBMS catalogs */
    char cats_to_mod[DU_1MAXDBMS_CATDEFS][DB_TAB_MAXNAME+1];

    EXEC SQL BEGIN DECLARE SECTION;
        char relid[DB_TAB_MAXNAME + 1];
	i4 relstat2;
	i2 relspec;
	i4 plock_flag, tcb_hash;
    EXEC SQL END DECLARE SECTION;

    plock_flag = TCB2_PHYSLOCK_CONCUR;
    tcb_hash = TCB_HASH;
    EXEC SQL select relid,relstat2 ,relspec
                       into :relid, :relstat2 , :relspec
                from iirelation
		where lowercase(relowner) = '$ingres'
		    and relspec != :tcb_hash
		    and mod(relstat2/:plock_flag,2) = 1;
    EXEC SQL BEGIN;

    /* Should always pass this test if the where clause is right */
    if (( relstat2 & TCB2_PHYSLOCK_CONCUR ) && ( relspec != TCB_HASH ))
    {
        /* this should be made HASH but if we're in concurrent mode it
           will fail */

        if (upg_concurrent)
        {
            SIprintf("ERROR: %s needs to be modified back to its intended"
                     " structure, but it cannot be modified in concurrent mode"
                     "\n   Please re-run upgradedb without the -c flag.\n",
                       relid);
            retval=E_DU_IERROR;
            EXEC SQL ENDSELECT;
        }

        if (upg_dbg_out)
        {
            SIfprintf(upgr_cb.du_dbg.du_file,
	              "]==> Modifying catalog %s back to intended structure"
                      " since it is TCB2_PHYSLOCK_CONCUR\n",
                      relid);
        }

	if ( ++j <= DU_1MAXDBMS_CATDEFS )
        {
	    i=STtrmwhite(relid);
	    STcopy(relid,cats_to_mod[j]);
        }
        else
	{
            SIprintf("ERROR: found more than %d TCB2_PHYSLOCK_CONCUR catalogs"
              "\n   which is more than the total number of catalogs.\n"
              "\n   Check to see if any of the following are user tables:\n",
                    DU_1MAXDBMS_CATDEFS);
            for (;j >= 0; j--)
                SIprintf("     %s\n",cats_to_mod[j]);
            retval=E_DU_IERROR;
            EXEC SQL ENDSELECT;
	}
    }

    EXEC SQL END;

    if (retval != E_DU_OK)
        return (retval);

    check_sql(sqlca.sqlcode);
    if (sqlca.sqlcode < 0)
    {
        SIprintf("Error reading iirelation checking for TCB2_PHYSLOCK_CONCUR\n");
	SIprintf("(sql error: %s)\n",sqlca.sqlerrm.sqlerrmc);
        return(E_DU_IERROR);
    }

    for (;j >= 0; j--)
    {
        if (duv_modify_catalog(upgr_cb.Dbname_ptr->dbname, cats_to_mod[j]) != E_DU_OK)
        {
            SIprintf("Error modifying %s\n",cats_to_mod[j]);
            return(E_DU_IERROR);
        }
    }

    return(E_DU_OK);

}

/*
** Name: duv_modify_catalog - Modify a catalog for upgradedb
**
** Description:
**	This is a little front-end to duc_modify_catalog, which modifies
**	a catalog and applies any indexes.  This wrapper outputs a debug
**	line, checks the return error, and does a commit.
**
** Inputs:
**	dbname			The database name (for messages)
**	tablename		The table name to modify
**
** Outputs:
**	Returns E_DU_OK or error.
**
** History:
**	2-May-2010 (kschendel)
**	    Write.
*/

static DU_STATUS
duv_modify_catalog(char *dbname, char *tablename)
{
    DU_STATUS status = E_DU_OK;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "Modifying %s\n", tablename);
    }
    duc_modify_catalog(tablename);
    if (sqlca.sqlcode < 0)
    {
	/* warning: modify didn't work */
	check_sql(sqlca.sqlcode);
	du_talk(__LINE__, DU_MODESENS, &upgr_cb,
		W_DU1869_NOMODIFY, 4,
		0, tablename, 0, dbname);
	status = E_DU_IERROR;
    }
    exec sql commit;
    return (status);
} /* duv_modify_catalog

/* Special needs-updating tests.
**
**	A number of catalogs have special requirements that indicate that
**	the catalog needs to be updated.  For instance, quite a number of
**	catalogs (especially iidbdb catalogs) used to have a "security
**	label" column, which was typically re-typed and renamed.  Since
**	the table row width didn't change, a special test for the old
**	style of catalog is needed.
**
**	The upgrade-catalog routine has already determined that the
**	catalog exists and has the same number of columns and same row
**	width.
**
**	These special tests all have the same call style, to wit:
**
** Inputs:
**	dbname			The database name
**
** Outputs:
**	Returns TRUE if the catalog needs to be updated, else FALSE.
**
** History:
**	30-Apr-2010 (kschendel)
**	    Reorganize the zillions of cv_xxxx routines into fewer zillions
**	    of needs-updated tests.
*/

/* iievent: see if the event_secid column exists, must upgrade if it does. */
static bool
needs_update_iievent(char *dbname)
{
    return (!tbl_lacks_col("iievent", "event_secid"));
}


/* iiextended_relation: upgrade if DB is pre-2.5, to turn off duplicates
** checking on the catalog.
*/
static bool
needs_update_iiextended_relation(char *dbname)
{
    return (upgr_cb.Dbname_ptr->level < V25_LEVEL);
}


/* iiprivlist, iisectype: dropped and recreated if coming from before 65ES */
static bool
needs_update_pre65es(char *dbname)
{
    return (upgr_cb.Dbname_ptr->level < V65ES_LEVEL);
}


/* iiprocedure: see if dbp_secid exists */
static bool
needs_update_iiprocedure(char *dbname)
{
    return (!tbl_lacks_col("iiprocedure", "dbp_secid"));
}


/* iisequence: see if seq_secid exists */
static bool
needs_update_iisequence(char *dbname)
{
    return (!tbl_lacks_col("iisequence", "seq_secid"));
}


/* iidatabase: see if dbsecid exists */
static bool
needs_update_iidatabase(char *dbname)
{
    return (!tbl_lacks_col("iidatabase", "dbsecid"));
}


/* iidbpriv: used to have a column "fill1" which was changed to "dbflags" */
static bool
needs_update_iidbpriv(char *dbname)
{
    return (tbl_lacks_col("iidbpriv", "dbflags"));
}


/* iilocations: see if lsecid exists */
static bool
needs_update_iilocations(char *dbname)
{
    return (!tbl_lacks_col("iilocations", "lsecid"));
}


/* iiprofile: check for lim_secid */
static bool
needs_update_iiprofile(char *dbname)
{
    return (!tbl_lacks_col("iiprofile", "lim_secid"));
}


/* iirole: check for rolesecid */
static bool
needs_update_iirole(char *dbname)
{
    return (!tbl_lacks_col("iirole", "rolesecid"));
}


/* iiuser: check for lim_secid */
static bool
needs_update_iiuser(char *dbname)
{
    return (!tbl_lacks_col("iiuser", "lim_secid"));
}

/*}
** Name: upgrade_catalog_list 
**
** Description:
**
**	This routine checks a list of catalogs for upgrading, and
**	does so usually via unloading into a temp table, recreating
**	the catalog, and reloading back into the catalog.  The catalog
**	(if upgraded) is then re-modified to the current structure.
**
**	Conditions for actually requiring an upgrade are:
**	- The catalog doesn't exist;
**	- The catalog has a different number of attributes than what's
**	  specified in the current catalog list in Duc_catdef;
**	- The catalog has a different width than what's specified in the
**	  current catalog list in Duc_catdef;
**	- The catalog fails a test specifically coded for that catalog.
**
**	In some cases, such as bitmap catalog conversions, a straight
**	unload (make_copy_of) and reload (copy_existing_columns) might
**	not suffice.  This routine has a list of special cases for
**	actually doing the upgrade.
**
**	At some (future!) point, considerable improvements are possible.
**	The lookup into Duc_catdef could be made faster, and the tests
**	for "special-upgrade-test" and "special-upgrade-action" could become
**	more clever than a giant if-then-else.
**
**	The caller supplies an ordered list of table names to check.
**	Some catalogs (in particular, those involved in table drop and
**	re-create) have to be upgraded first, while others can wait until
**	later on.  It's up to the caller to pass in only valid catalog
**	names -- no views, no gateway registrations, no core catalogs.
**
**	One thing that can't be handled here is dropping obsolete
**	catalogs that no longer exist.  That will have to be done by
**	hand by the caller.
**
** Inputs:
**      dbname			- Database name being upgraded
**	table_list		- List of table names to check for upgrade;
**				the list is ended with a NULL entry.
**				Names should be in lowercase!
**
** Outputs:
**      DU_STATUS
**
** History
**	2-May-2010 (kschendel)
**	    stial01's duv_upgrade_be_catalog was a good idea, but a
**	    wee bit too general.  The caller will supply a list of tables
**	    to consider, and the knowledge of which ones need special
**	    handling is embedded here (for now).
*/

exec sql whenever sqlerror continue;

static DU_STATUS
upgrade_catalog_list(char *dbname, char **table_list)
{
    EXEC SQL BEGIN DECLARE SECTION;
    char dropstmt[DB_TAB_MAXNAME+50];
    char *tabname;
    i4 errorno;
    i4	relatts;
    i4  relwid;
    char errortext[256];
    EXEC SQL END DECLARE SECTION;
    bool relexists;
    bool update;
    DUC_CATDEF *catdef;

    while (*table_list != NULL)
    {
	/* Check table *table_list */
	relexists = TRUE;
	tabname = *table_list;
	exec sql repeated select relatts, relwid
	    into :relatts, :relwid
	    from iirelation
	    where lowercase(relid) = :tabname and lowercase(relowner) = '$ingres';
	check_sql(sqlca.sqlcode);
	if (sqlca.sqlerrd[2] == 0)
	{
	    relexists = FALSE;
	}
	else
	{
	    /* Get createdb information;  must exist, or caller's
	    ** list is garbage, which we don't allow for...
	    */
	    for (catdef = &Duc_catdef[0]; catdef->catname; catdef++)
	    {
		if (STcmp(catdef->catname, tabname) == 0)
		    break;
	    }

	    /* Skip this catalog if relwid and relatts unchanged */
	    update = TRUE;
	    if (relwid == catdef->rowsize && relatts == catdef->columns)
	    {
		/* List of special case catalogs that need special checking */
		/* FIXME do this better! */
		update = FALSE;
		if (STcmp(tabname, "iievent") == 0)
		    update = needs_update_iievent(dbname);
		else if (STcmp(tabname, "iiextended_relation") == 0)
		    update = needs_update_iiextended_relation(dbname);
		else if (STcmp(tabname, "iiprivlist") == 0)
		    update = needs_update_pre65es(dbname);
		else if (STcmp(tabname, "iiprocedure") == 0)
		    update = needs_update_iiprocedure(dbname);
		else if (STcmp(tabname, "iisectype") == 0)
		    update = needs_update_pre65es(dbname);
		else if (STcmp(tabname, "iisequence") == 0)
		    update = needs_update_iisequence(dbname);
		else if (STcmp(tabname, "iidatabase") == 0)
		    update = needs_update_iidatabase(dbname);
		else if (STcmp(tabname, "iidbpriv") == 0)
		    update = needs_update_iidbpriv(dbname);
		else if (STcmp(tabname, "iilocations") == 0)
		    update = needs_update_iilocations(dbname);
		else if (STcmp(tabname, "iiprofile") == 0)
		    update = needs_update_iiprofile(dbname);
		else if (STcmp(tabname, "iirole") == 0)
		    update = needs_update_iirole(dbname);
		else if (STcmp(tabname, "iiuser") == 0)
		    update = needs_update_iiuser(dbname);
	    }
	}
	exec sql commit;
	if (relexists && !update)
	{
	    if (upg_dbg_out)
		SIfprintf(upgr_cb.du_dbg.du_file, "Catalog %s doesn't need update\n", tabname);
	}
	else
	{
	    /* Catalog needs updating, check list of catalogs that
	    ** have special requirements.  FIXME do this better!
	    */
	    if (upg_dbg_out)
	    {
		SIfprintf(upgr_cb.du_dbg.du_file, "%s catalog %s\n",
			relexists ? "Updating" : "Creating", tabname);
	    }
	    if (STcmp(tabname, "iiintegrity") == 0)
		cv_iiintegrity(dbname);
	    else if (STcmp(tabname, "iipriv") == 0)
		cv_iipriv(dbname);
	    else if (STcmp(tabname, "iiprotect") == 0)
		cv_iiprotect(dbname);
	    else if (STcmp(tabname, "iirule") == 0)
		cv_iirule(dbname);
	    else if (STcmp(tabname, "iiprivlist") == 0)
	    {
		exec sql drop iiprivlist;	/* Ignore error */
		exec sql commit;
		duc_iisesspriv();
		(void) duv_modify_catalog(dbname, "iiprivlist");
	    }
	    else if (STcmp(tabname, "iisectype") == 0)
	    {
		/* FIXME if we get more of these always-drop tables,
		** do a little routine for them!
		*/
		exec sql drop iisectype;	/* Ignore error */
		exec sql commit;
		duc_create_catalog("iisectype");
		if (sqlca.sqlcode < 0)
		{
		    check_sql(sqlca.sqlcode);
		    du_talk(__LINE__, DU_MODESENS, &upgr_cb,
				E_DU2418_NOCREATE_SYSCAT, 4,
				0, "iisectype", 0, dbname);
		    return (E_DU_FATAL);
		}
		duc_init_iisectype();
		(void) duv_modify_catalog(dbname, "iisectype");
	    }
	    else
	    {
		/* Standard updating of catalog here.  Make a copy,
		** drop the old catalog, create a new one, and copy
		** all columns that existed in both old and new.
		** If any new columns need to be populated, it can be
		** done later with a (possibly version sensitive)
		** update.  (Or, in extreme cases, a table specific
		** updater routine can be created and called.)
		*/
		du_talk(__LINE__, DU_MODESENS, &upgr_cb,
			I_DU00E7_CONVERTING_TBL, 2, 0, tabname);
		if (relexists)
		{
		    make_copy_of(dbname, tabname);
		    STprintf(dropstmt, "drop table %s", tabname);
		    exec sql execute immediate :dropstmt;
		    if (sqlca.sqlcode < 0)
		    {
			check_sql(sqlca.sqlcode);
			du_talk(__LINE__, DU_MODESENS, &upgr_cb,
			    E_DU2417_NODROP_SYSCAT, 4,
			    0, tabname, 0, dbname);
			upgr_exit(__LINE__, DU_FAIL_EXIT,
			    E_DU241A_SYSCAT_UPGRADE_FAILED);
		    }
		    exec sql commit;
		}
		if (upg_dbg_out)
		{
		    SIfprintf(upgr_cb.du_dbg.du_file, "(Re)creating %s\n", tabname);
		}
		duc_create_catalog(tabname);
		if (sqlca.sqlcode < 0)
		{
		    check_sql(sqlca.sqlcode);
		    du_talk(__LINE__, DU_MODESENS, &upgr_cb,
				E_DU2418_NOCREATE_SYSCAT, 4,
				0, tabname, 0, dbname);
		    return (E_DU_FATAL);
		}
		if (relexists
		  && copy_existing_columns(dbname, tabname) != E_DU_OK)
		{
		    du_talk(__LINE__, DU_FAIL_EXIT, &upgr_cb,
			    E_DU2419_NOREPOP_SYSCAT, 4,
			    0, tabname, 0, dbname);
		    return (E_DU_FATAL);
		}
		/* Ignore error on modify (?) */
		(void) duv_modify_catalog(dbname, tabname);
	
		exec sql commit;
		/* The iitmp_xxxx table is dropped when we're all done */
	    }
	}

	/* Move to the next table in the list */
	++table_list;
    } /* while */

    return (E_DU_OK);
} /* upgrade_catalog_list */

/* Name: do_early_updates - Do core and order sensitive initial updates.
**
** Description:
**
**	This routine does catalog updates that have to be done early.
**	Typically these affect core catalogs, or catalogs that are
**	involved in drop/recreate.
**
** Inputs:
**	dbinfo			Pointer to DBNAME_NODE for DB being upgraded
**
** Outputs:
**	None.
**
** History:
**	2-May-2010 (kschendel)
**	    Put together from all the old bits and pieces that have
**	    been collecting.
*/

/* The catalogs to be upgraded first.  See inline for why these are
** important, and why they are in the order they are in.
*/
static char *initial_catalog_list[] =
{
    "iiintegrity",
    "iipriv",
    "iidbdepends",
    "iiqrytext",
    "iitree",
    "iiprotect",
    "iidevices",
    "iiprocedure",
    "iiprocedure_parameter",
    "iistatistics",
    "iihistogram",
    "iidefault",
    "iisynonym",
    NULL
};

/* iidd_stats only, for Star */
static char *iidd_stats_list[] =
{
    "iidd_stats",
    NULL
};

/* Star tables for a pre-2.0 database.
** I suspect that these could be checked for upgrade in any Star database,
** but I'm afraid to mess with the Star upgrade too much at present.
*/
static char *star_20_list[] =
{
    "iidd_tables",
    "iidd_indexes",
    NULL
};

exec sql whenever sqlerror continue;	/* by-hand error checking */

static void
do_early_updates(DBNAME_NODE *dbinfo)
{
    char *dbname = &dbinfo->dbname[0];
    DU_ERROR errcb;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> doing initial conversions from level %d\n",
		dbinfo->level);
    }

    /* Make sure we're $ingres */
    if (setauth("$ingres") != OK)
    {
	SIprintf("Error changing effective user ID\n");
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }
    IIlq_Protect(TRUE);		/* Do we need this??? */

    /* DMF may have redone the core catalogs if any of them changed.
    ** Rehash them.  Note that this step could be version sensitive,
    ** but it's probably best to just always rehash.
    */

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00DA_MODIFY_CORE, 0);
    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0100_MODIFYING_SY, 2, 0, "iirelation");
    if (duv_modify_catalog(dbname, "iirelation") != E_DU_OK)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0100_MODIFYING_SY, 2, 0, "iiattribute");
    if (duv_modify_catalog(dbname, "iiattribute") != E_DU_OK)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU0100_MODIFYING_SY, 2, 0, "iiindex");
    if (duv_modify_catalog(dbname, "iiindex") != E_DU_OK)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);

    /* If database is 64 or older, truncate iistatistics and iihistogram.
    ** The stats format changed and it's simplest to just drop the old stats.
    ** The 6.4 upgrade is documented to require stats regeneration.
    ** The storage structure keys haven't changed, so the modifys are OK.
    */
    if (dbinfo->level < V65_LEVEL)
    {
	exec sql modify iistatistics to truncated;
	(void) duv_modify_catalog(dbname, "iistatistics");
	exec sql modify iihistogram to truncated;
	(void) duv_modify_catalog(dbname, "iihistogram");
    }

    /* Do some of the essential catalogs.
    ** This is very order sensitive!  We start with the 5 catalogs that
    ** are scanned by the DBMS server during a table drop (qeu_d_cascade).
    ** When running upgradedb, a drop on those 5 catalogs just drops
    ** the base table and any secondary indexes, without running
    ** qeu_d_cascade or any of the hideous qeu_dxxx stuff that cascade
    ** calls.  We need to upgrade (if needed) those 5 first.  They are:
    ** iiintegrity, iipriv, iidbdepends, iiqrytxt, and iitree.
    **
    ** (Note that any views, permits, etc defined on the above five
    ** catalogs will still exist after a drop/recreate.  Views in particular
    ** will probably be junk afterwards.  Upgradedb will toss and
    ** recreate all system catalog views, for this reason among many
    ** others;  but any user defined views will have to be manually
    ** recreated.  FIXME someday it would be nice to poke around
    ** in iidbdepends / iipriv ourselves to drop user catalog views.)
    **
    ** Drops also muck around inside iiprotect, so it is done next.
    ** (Fortunately, it appears that the server usage of iiprotect
    ** only looks at the part of the iiprotect row that hasn't changed
    ** in a long time, so the iiprotect drop/recreate manages to work.)
    **
    ** iidevices only matters for multi-location catalogs, which the
    ** above aren't, but it's a core DMF catalog so we'll get it now.
    ** 
    ** Some of the later steps in upgrading use built-in DB
    ** procedures, so we had better make sure that the DB proc
    ** catalogs are up-to-date.
    **
    ** The server depends on optimizer stats, and if we're coming from
    ** 6.4, the defaults catalog is important too.
    **
    ** And finally, drops of indexed tables look at iisynonym!  Amazing.
    ** Although the server is tricked out to allow it, we might as well
    ** get iisynonym created and up to date.
    */

    du_talk(__LINE__, DU_MODESENS, &upgr_cb, I_DU00A1_SERVER_CATS, 0);
    if (upgrade_catalog_list(dbname, initial_catalog_list) != E_DU_OK)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);

    if (upg_dbg_out)
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> Checking/initializing iidefault\n");
    if (duc_init_iidefault(TRUE, &errcb) != E_DB_OK)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);

    if (dbinfo->star_flag)
    {
	/* Not included in initial list, don't want to create if not star. */
	if (upgrade_catalog_list(dbname, iidd_stats_list) != E_DU_OK)
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
    }
    /* Now that DBprocs should work, if we're coming from 6.4, do the
    ** "file extend" (space management system) conversion on all of the
    ** $ingres-owned catalogs.
    */
    if (dbinfo->level < V65_LEVEL)
    {
	file_extend_convert_ingres();
	make_udt_defaults();
    }

    /* Do a bunch of Star stuff if pre-2.0 and a Star database. */
    if (dbinfo->star_flag && dbinfo->level < V20_LEVEL)
    {
	exec sql drop view iidd_physical_tables;

	if (upgrade_catalog_list(dbname, star_20_list) != E_DU_OK)
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	exec sql update iidd_tables
	    set table_pagesize = 2048, table_relversion = 0
	    where table_pagesize = 0;
	exec sql commit;
	exec sql update iidd_indexes
	    set index_pagesize = 2048 where index_pagesize = 0;
	exec sql commit;
    }

    /* Signal for tree conversion - neccessary for Ingres 10 */
    dbinfo->tree_convert = TRUE;

} /* do_early_updates */

/*
** Name: populate_catalogs - Update / populate new or changed catalogs
**
** Description
**	This is a relatively random collection of updates and inserts
**	into newly created or changed catalogs.  It's run for all databases,
**	iidbdb or not.
**
**	Although some updates may be unavoidably version sensitive, it
**	would be good to avoid "level" tests as much as possible.
**
** Inputs:
**	dbinfo			DBNAME_NODE info about db being upgraded
**
** Outputs:
**	None
**
** History:
**	2-May-2010 (kschendel)
**	    Put together from all the zillions of old cv_xxx routines.
*/

static void
populate_catalogs(DBNAME_NODE *dbinfo)

{
    char *dbname = &dbinfo->dbname[0];
    SYSTIME Current_date;
    exec sql begin declare section;
    i4 rowcount;
    i4 sql_current_date;
    exec sql end   declare section;

    /* iidefault is done in early-updates. */

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> doing iiprocedure updates\n");
    }
    /* Populate dbp_create_date when coming from old iiprocedure */
    TMnow (&Current_date);
    sql_current_date = Current_date.TM_secs;
    exec sql update iiprocedure
	set dbp_create_date = :sql_current_date
	where dbp_create_date = 0;
    check_sql(sqlca.sqlcode);
    exec sql commit;

    /* Populate iisecalarm if it's empty */
    rowcount = 0;
    exec sql select count(*) into :rowcount from iisecalarm;
    check_sql(sqlca.sqlcode);
    if (rowcount == 0)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> populating iisecalarm\n");
	}
	(void) populate_secalarm(dbname);
	(void) duv_modify_catalog(dbname, "iisecalarm");
    }

    /* iiprivlist, iisectype populated when (re)created */

    /* This seems as good a place as any to regrant select access on
    ** catalogs that we recreated.  Actually, this regrants all
    ** catalogs, which is a bit overwhelming, but works.
    ** Don't do it for iidbdb, iidbdb has more stuff to do, will take
    ** care of it in populate-iidbdb-catalogs.
    */
    if (STcasecmp(dbname, "iidbdb") != 0)
    {
	fix_syscat_grants(dbname);
    }

    /* Verify that core catalogs are hash */
    if (modify_physlock_tbls() != E_DU_OK)
	upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU601C_CANT_MAKE_CATS_HASH);

} /* populate_catalogs */
/*
** Name: populate_iidbdb_catalogs - Update / populate new or changed
**	iidbdb catalogs
**
** Description
**	This is a relatively random collection of updates and inserts
**	into newly created or changed iidbdb-only catalogs.
**
**	Although some updates may be unavoidably version sensitive, it
**	would be good to avoid "level" tests as much as possible.
**
** Inputs:
**	level			The previous iidbdb catalog level
**
** Outputs:
**	None
**
** History:
**	2-May-2010 (kschendel)
**	    Put together from all the zillions of old cv_xxx routines.
*/

static void
populate_iidbdb_catalogs(i4 level)

{
    exec sql begin declare section;
    i4 rowcount;
    exec sql end   declare section;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> doing iiextend updates\n");
    }

    /* iiextend:  pad names, fool with status flags */
    /*
    ** set DU_EXT_DATA bit (value is 2) in status column in iiextend.
    ** Exception: work locations get 4 set, not 2.  So for idempotency,
    ** qualification excludes them, and those with DU_EXT_DATA,
    ** DU_EXT_WORK, or DU_EXT_AWORK already set.
    */
    exec sql update iiextend set status = status + 2
	where mod((status/2), 2) = 0 and mod((status/4), 2) = 0
	    and mod((status/8), 2) = 0
	    and lname != 'ii_work';
    exec sql commit;

    /*
    ** this too is harmless to do every time, and easier to do here
    ** than for every database being converted, and harmless to do
    ** for every database even if some are for some unknown reason
    ** not being converted: add work locations to iiextend.
    ** How to do it: add a work location for every database that lacks one.
    ** This is idempotent even if you upgrade the iidbdb several times.
    ** The magic value 5 comes from the DU_OPERATIVE bit (value is 1)
    ** ORed with DU_EXT_WORK (value is 4).
    */
    exec sql insert into iiextend select 'ii_work', 
	dname, 5, 0, 0 from iiextend
	where dname not in
	(select dname from iiextend where trim(lname) = 'ii_work');
    exec sql update iiextend set lname=pad(lname), dname=pad(dname);
    exec sql commit;

    /* These are carried over from the 6.5 conversion */
    exec sql update iilocations
        set lname = 'ii_work' where lowercase(lname) = 'ii_sort';
    exec sql update iilocations
        set area = 'II_WORK' where lowercase(area) = 'ii_sort';
    exec sql commit;

    if (upg_dbg_out)
    {
	SIfprintf(upgr_cb.du_dbg.du_file, "]==> doing iiprofile updates\n");
    }

    /* Populate iiprofile if it's empty */
    rowcount = 0;
    exec sql select count(*) into :rowcount from iiprofile;
    check_sql(sqlca.sqlcode);
    if (rowcount == 0)
	duc_init_iiprofile();

    /* Populate iirolegrant with existing roles if converting from 6.4. */
    /* The version test is unavoidable here because an empty iirolegrant
    ** is perfectly legit.
    */
    if (level < V65ES_LEVEL)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> Grant roles to public\n");
	}
	exec sql insert into iirolegrant
	    (rgr_rolename, rgr_flags, rgr_gtype, rgr_grantee)
	    select distinct roleid, 0, 3, 'public'
	    from iirole
	    where roleid not in  (select rgr_rolename from iirolegrant);
	check_sql(sqlca.sqlcode);
	exec sql commit;
    }

    /* iisecuritystate done inline in cv_iidbdb, simplest */

    /* iiuser: if coming from pre-6.5ES, turn on DU_UHASPROFILE for all
    ** users with zero flags (which ought to be all of them);
    ** disassemble the old SECURITY privilege into new privileges;
    ** and turn on flags for default group.
    */
    if (level < V65ES_LEVEL)
    {
	if (upg_dbg_out)
	{
	    SIfprintf(upgr_cb.du_dbg.du_file, "]==> doing 6.4 iiuser updates\n");
	}
	exec sql update iiuser
	    set flags_mask = 16384,
		default_priv = status,
		user_priv = status;
	exec sql commit;

	/*
	** Now update user status so the SECURITY users now have appropriate
	** finer-grained privileges (MAINTAIN_USERS, AUDITOR, MAINTAIN_AUDIT)
	*/
	exec sql update iiuser 
	set status=status+65536,
	    default_priv=default_priv+65536,
	    user_priv=user_priv+65536
	where mod(status/32768,2)=1
	and   mod(status/65536,2)=0;

	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
		0, "iiuser", 0, "iidbdb");
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}
	exec sql update iiuser 
	set status=status+16384,
	    default_priv=default_priv+16384,
	    user_priv=user_priv+16384
	where mod(status/32768,2)=1
	and   mod(status/16384,2)=0;

	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
		0, "iiuser", 0, "iidbdb");
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}

	exec sql update iiuser 
	set status=status+8192,
	    default_priv=default_priv+8192,
	    user_priv=user_priv+8192
	where mod(status/32768,2)=1
	and   mod(status/8192,2)=0;

	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
		0, "iiuser", 0, "iidbdb");
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}

	/* if a super user, then add 'operator' and 'create location' 
	   privileges to the super user. (#67365) 
	*/
	exec sql update iiuser 
	    set status=status+2560,
	    default_priv=default_priv+2560,
	    user_priv=user_priv+2560
	  where mod(status/32768,2)=1; 

	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
		0, "iiuser", 0, "iidbdb");
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}

	/*
	** Mark privileges flags appropriately.
	** This ensures privileges are maintained when
	** later merging/unmerging profile information.
	*/
	exec sql update iiuser
	set flags_mask=24
	where status!=0;
	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
		0, "iiuser", 0, "iidbdb");
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}
	/*
	** same for default group
	*/
	exec sql update iiuser
	set flags_mask=flags_mask+4
	where default_group!='';

	if (sqlca.sqlcode < 0)
	{
	    du_talk(__LINE__, DU_MODESENS, &upgr_cb, E_DU2419_NOREPOP_SYSCAT, 4,
		0, "iiuser", 0, "iidbdb");
	    upgr_exit(__LINE__, DU_FAIL_EXIT, E_DU241A_SYSCAT_UPGRADE_FAILED);
	}
	exec sql commit;
    } /* 6.5ES and iiuser */

    /* Re-grant all system catalogs including iidbdb catalogs.
    ** This is a bit brute-force, but it works.
    */
    fix_syscat_grants("iidbdb");

} /* populate_iidbdb_catalogs */

