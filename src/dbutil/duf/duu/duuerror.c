/*
**Copyright (c) 2004 Ingres Corporation
*/

#include    <compat.h>
#include    <er.h>
#include    <duerr.h>
#include    <cm.h>
#include    <si.h>
#include    <st.h>
#include    <duustrings.h>
#include    <stdarg.h>

/**
**
**  Name: DUUERROR.C -	routines necessary for error, warning or informative
**		        messages.
**
**  Description:
**        This file contains all the routines necessary to do error-handling
**	messages or warning/informative messages.  It is DUF's interface to
**	ERslookup.
**
**          du_error() -	format a msg for a DUF, translate to the 
**				appropriate DU_STATUS for return and print
**				msg if appropriate.
**
**
**  History:
**      09-Sep-86 (ericj)
**          Initial creation.
**	26-Oct-88 (teg, as per request of russ)
**	    modifying parameter passing to ERlookup
**      23-jan-1989 (roger)
**          Revised to conform to latest ERlookup specification.
**	21-may-89 (jrb)
**	    Yet another change to ERlookup's interface (this one for generic
**	    error suppport).
**	26-Jun-1989 (teg)
**	    changed description so it no longer appears this routine is used
**	    only for Destroydb, as all of DUF uses it.
**	11-Oct-89 (teg)
**	    ERlookup used to initialize result_msglen, but no long does on
**	    unix, so initialize it before the call to fix bug 7993.
**	26-oct-92 (andre)
**	    replaced calls to ERlookup() with calls to ERslookup()
**      21-apr-1999 (hanch04)
**          replace STindex with STchr
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**      17-Apr-2001 (hweho01)
**          Changed du_error() to be a variable-arg list function.
**          The mismatch of parameter numbers between the calling routines     
**          and du_error() caused stack corruptions during runtime.
**          According to ANSI standard, variable argument list should 
**          be used when the numbers of parameter passed by the callers  
**          are not fixed.   
**/

/*
[@forward_type_references@]
[@forward_function_references@]
*/

/*
**  Defines of other constants.
*/

/*
**        Define the maximum number or parameters the error routine du_error()
**	can take.
*/

#define                 DU_MX_ERR_PARAMS 10

/*
[@group_of_defined_constants@]...
*/

/*
[@type_definitions@]
[@global_variable_definitions@]
[@static_variable_or_function_definitions@]
*/


/*{
** Name: du_error() -   format an error message and translate to proper
**			DU_STATUS for return.
**
** Description:
**        This routine formats an error message using ERslookup().  It
**	also translates it to the proper DU_STATUS for return.  If the
**	resulting DU_STATUS is E_DU_INFO or E_DU_WARN, an error message
**	is printed for the user and E_DU_OK is returned.
**
** Inputs:
**      du_errcb                        Ptr to an DU_ERROR struct.
**      du_errno                        An error number (defined in duerr.h)
**	pcnt				Argument count.  This should
**					always be an even number as
**					arguments come in pairs(length,
**					address).
**	p1 - p10			Variable number of error arguments.
**
** Outputs:
**      *du_errcb
**	    .du_errmsg			Buffer containing null-terminated
**					formatted error	message.
**	Returns:
**	    E_DU_OK			Completed successfully.
**	    E_DU_IERROR			The error number passed in was
**					generated by an internal error.
**	    E_DU_UERROR			The error number passed in was
**					generated by an user error.
**
** Side Effects:
**	      A informational or warning message may be printed out for
**	    the user.
**
** History:
**      09-Sep-86 (ericj)
**          Initial creation.
**      06-apr-86 (ericj)
**	19-aug-87 (mmm)
**	    Make it accept 10 argument pairs.
**	26-Oct-88 (teg, as per request of russ)
**	    modifying parameter passing to ERlookup
**      23-jan-1989 (roger)
**          Revised to conform to latest ERlookup specification: changed
**	    CL_SYS_ERR to CL_ERR_DESC.  Also got rid of code that assumed
**	    it could look inside the the CL_ERR_DESC (at `error', which no
**	    longer exists in the UNIX implementation).  This means that
**	    ERlookup is always called for du_errcb.du_clsyserr; if there
**	    is no information there, ERlookup should do nothing gracefully.
**	    It should be noted that the errors E_DU2000_BAD_ERLOOKUP and
**	    E_DU2002_BAD_SYS_ERLOOKUP are redundant; simply looking up the
**	    error returned by ERlookup is to be preferred.
**	09-feb-1989 (jrb)
**	    Removed line where rslt_msglen was being used after an ERlookup
**	    call, but the ERlookup call was returning an error status.
**      04-apr-1989 (teg)
**          Fixed typecasting loc_param to (ER_ARGUMENT *) since it is already
**          ER_ARGUMENT.  Also removed indirection on PARAM[] when used as
**          argument to ERlookup because UNIX does not like indirection for
**          arrays.
**	11-Oct-89 (teg)
**	    ERlookup used to initialize result_msglen, but no long does on
**	    unix, so initialize it before the call to fix bug 7993.
**	26-oct-92 (andre)
**	    replaced calls to ERlookup() with calls to ERslookup()
**	11-oct-93 (swm)
**	    Bug #56448
**	    Changed p1, p3, p5, p7, p9 from type i4 * to i4 to
**	    be consistent with actual usage.
**	19-jul-94 (robf)
**          Check du_errcb is not NULL, which causes a subsequent AV. In
**	    this case just issue a diagnostic (via SIprintf) and return.
*/
/*ARGSUSED*/
/*VARARGS1*/
DU_STATUS
du_error(DU_ERROR *du_errcb, int du_errno, int pcnt, ...)
{
    char		*msg_ptr;
    DU_STATUS           ret_status;
    CL_ERR_DESC		clerror;
    i4			rslt_msglen=0;
    i4			save_msglen;
    i4			buf_len	    = ER_MAX_LEN;
    ER_ARGUMENT		loc_param;
    i4			tmp_status;
    i4			lang_code;
    ER_ARGUMENT		param[DU_MX_ERR_PARAMS];
    va_list ap;
    int  i ;

    va_start( ap, pcnt );

    for( i = 0 ; i < ( pcnt / 2 ) ; i++ )
     {
      param[i].er_size  = (int) va_arg( ap, int );
      param[i].er_value = (PTR) va_arg( ap, PTR );
     }

    va_end( ap );

    /* First get the language code. */
    ERlangcode((char *) NULL, &lang_code);

    /* Check if the call was done correctly */

    if ((pcnt % 2) == 1 || pcnt > DU_MX_ERR_PARAMS)
    {
	du_errno    = E_DU2001_BAD_ERROR_PARAMS;
	pcnt	    = 0;
    }
    if (du_errcb==NULL)
    {
	SIprintf("du_error: du_errcb is NULL. Error number is %d (X%x)\n",
				du_errno, du_errno);
	SIflush(stdout);
	return E_DU_IERROR;
    }

    /* Classify the severity of the error */
    if (du_errno < DU_OK_BOUNDARY)
	ret_status    = E_DU_OK;
    else if (du_errno < DU_INFO_BOUNDARY)
	ret_status    = E_DU_INFO;
    else if (du_errno < DU_WARN_BOUNDARY)
	ret_status    = E_DU_WARN;
    else if (du_errno < DU_IERROR_BOUNDARY)
	ret_status    = E_DU_IERROR;
    else
	ret_status    = E_DU_UERROR;

    du_errcb->du_status	= ret_status;

    /* Format the database utility error message */
    du_errcb->du_utilerr    = du_errno;

    tmp_status  = ERslookup(du_errno, (CL_ERR_DESC *) 0, 0, (char *) NULL,
			    du_errcb->du_errmsg, buf_len, lang_code,
			    &rslt_msglen, &clerror, pcnt/2, param);


    if (tmp_status != OK)
    {
	loc_param.er_size   = sizeof(du_errno);
	loc_param.er_value  = (PTR)&du_errno;

	tmp_status = ERslookup((i4) E_DU2000_BAD_ERLOOKUP,
	    (CL_ERR_DESC *)0, 0, (char *) NULL, du_errcb->du_errmsg, buf_len,
	    lang_code, &rslt_msglen, &clerror, 1, &loc_param);
	if (tmp_status != OK)
	{
	    /* err_lookup is not working.  Put something in the buffer to
	    ** avoid a silent exit 
	    */
	    STcopy ( DUU_ERRLOOKUP_FAIL, du_errcb->du_errmsg);
	    SIprintf("%s\n", du_errcb->du_errmsg);
	    SIflush(stdout);

	}
	else
	{
	    du_errcb->du_errmsg[rslt_msglen]    = EOS;
	    ret_status		= E_DU_IERROR;
	    du_errcb->du_status	= ret_status;
	    du_errcb->du_utilerr	= E_DU2000_BAD_ERLOOKUP;
	}
    }
    else
    {
	/* Format CL error (internal CL failure and/or OS error) */
	du_errcb->du_errmsg[rslt_msglen++]    = '\n';
	save_msglen  = rslt_msglen;
	buf_len	    -= rslt_msglen;
	tmp_status = ERslookup((i4) 0, &du_errcb->du_clsyserr, 0,
			       (char *) NULL, &du_errcb->du_errmsg[rslt_msglen],
			       buf_len, lang_code,
			       &rslt_msglen, &clerror, 0,(ER_ARGUMENT *) NULL);

	if (!rslt_msglen)
	    du_errcb->du_errmsg[save_msglen - 1] = ' ';    /* delete newline */

	if (tmp_status != OK)
	{
	    /* Report that the operating system error couldn't be found */
	    ERslookup((i4) E_DU2002_BAD_SYS_ERLOOKUP, (CL_ERR_DESC *) 0, 0,
		     (char *) NULL, &du_errcb->du_errmsg[save_msglen], buf_len,
		     lang_code, &rslt_msglen, &clerror, 0,
		     (ER_ARGUMENT *) NULL);
	    ret_status	= E_DU_IERROR;
	    du_errcb->du_status	= ret_status;
	    du_errcb->du_utilerr    = E_DU2002_BAD_SYS_ERLOOKUP;
	}
	du_errcb->du_errmsg[save_msglen + rslt_msglen]    = EOS;
    }

    /* If the message being formatted is really informational or a warning,
    ** print it and reset the error-handling control block.
    */
    if (ret_status == E_DU_WARN || ret_status == E_DU_INFO)
    {
	if ((du_errcb->du_flags & DU_SAVEMSG) == 0)
	{
	    /* Print the warning or informative msg and reset the error
	    ** control block.
	    */
	    msg_ptr = STchr(du_errcb->du_errmsg, '\t');
	    if (msg_ptr != NULL)
	    {
		msg_ptr++;
		/*
		**  while (CMspace(msg_ptr))
		**	CMnext(msg_ptr);
		*/
		SIprintf("%s\n", msg_ptr);
		SIflush(stdout);
	    }
	    du_reset_err(du_errcb);
	}
	/* In either case, whether we reset the error control block or not
	** return an OK status.
	*/
	ret_status  = E_DU_OK;
    }
    else
    {
	/* Replace the TAB after the DUF facility code id with a NEWLINE. */
	msg_ptr = STchr(du_errcb->du_errmsg, '\t');
	if (msg_ptr)
	    *msg_ptr = '\n';
    }

    return(ret_status);
}
