/********************************************************************
**
**  Copyright (C) 2005-2006 Ingres Corporation. All Rights Reserved.
**
**    Project : Ingres Visual DBA
**
**    Source : dbaparse.c
**    Parse objects descriptions
**
**    Author : Lionel Storck
**
**   History:
**     26-Jul-99 (noifr01)
**     bug 98053: ignore case when searching for keywords when parsing
**     a view definition
**     22-May-2000 (schph01)
**     bug 99242 replace isspace() by _istspace()
**     12-Mar-2001 (schph01)
**     SIR 97068 add a function GetOneQuelViewTable() to parse the statement
**     write with QUEL language.
**     26-Mar-2001 (noifr01)
**     (sir 104270) removal of code for managing Ingres/Desktop
**     25-Mar-2003 (noifr01)
**     (sir 107523) management of sequences
**     16-May-2003 (schph01)
**     bug 110245 Change the rules parser to retrieve the Procedure Name
**        - Used ignore case function to get the word syntax
**        - Remove useless space characters before to copy the characters
**        - Remove the SQL quotes
**        - Add Function to search the 'execute procedure' keyword.
**            To manage the case where there are many blank characters between
**            'execute' and 'procedure' keywords
**    19-Aug-2004 (zhahu02)
**    Updated for INGDBA192/b110245 needed for Solaris.
********************************************************************/

#include <ctype.h>
#include "dba.h"
#include "dbaparse.h"
#include "dbaset.h"
#include "esltools.h"
#include "dbadlg1.h"
#include "tchar.h"

# include <compat.h>
# include <cm.h>

#ifdef DOUBLEBYTE
#ifdef WINDOWS
#define _WINDOWS
#endif /* WINDOWS */

#include <windows.h>
#endif /* DOUBLEBYTE */


static UCHAR STR_EXECPROC[]=" execute procedure ";
static UCHAR STR_AFTER[]=" after ";
static UCHAR STR_ON[]=" on ";
static UCHAR STR_OF[]=" of ";
static UCHAR STR_FROM[]=" from ";
static UCHAR STR_INTO[]=" into ";
static UCHAR STR_WHERE[]=" where ";
static UCHAR STR_REFERENCING[]=" referencing ";

static UCHAR *PTextSegm=NULL;       // segment text pointer used by the
                                    // xxText procedures.
UCHAR *SQLPosTBL(Ptable)
UCHAR *Ptable;
{
   static UCHAR *keyword_list[]={")from ", " from ", " join ", NULL};
   UCHAR **key_word=keyword_list, *ptr, *ptr_to_return=NULL;
   int keyw_len;
   while (*key_word) {
      ptr=x_stristr(Ptable, *key_word);
      if (ptr) {
         if (!ptr_to_return)  // first time
            ptr_to_return=ptr;
         if (ptr<=ptr_to_return) {   // take the first position only
            keyw_len=x_strlen(*key_word);
            ptr_to_return=ptr;
         }
      }
      key_word++;
   }
   if (ptr_to_return)
      ptr_to_return+=keyw_len; 
   return ptr_to_return; 
}
/**********************************************************
* FreeText frees the memory attached to the text_segment  *
* concatenation, if any has to be freed                   *
**********************************************************/ 

void FreeText()
{
   if (!PTextSegm)
      return; 

   ESL_FreeMem((void *) PTextSegm);
   PTextSegm=NULL;
   return;
}

/**********************************************************
* ConcatText concatenates all the TEXT_SEGMENTs found in  *
* the system tables when many exist in order to parse the *
* full statement                                          *
* It removes the "\\r" and "\\n" generated by Ingres in   *
* substitution of the carriage return that may have been  *
* keyed in by the object creator                          *
* It also allocates the memory required to do the job     *
**********************************************************/

BOOL ConcatText(Data)
UCHAR *Data;
{
   int slen=0;
   int slen1=0;
   LPUCHAR lptemp;

   slen1=x_strlen(Data);

   if (PTextSegm) {
      slen=x_strlen(PTextSegm);
      if (slen1<SEGMENT_TEXT_SIZE+1)
         PTextSegm=ESL_ReAllocMem(PTextSegm, slen+SEGMENT_TEXT_SIZE+1, slen); 
      else
         PTextSegm=ESL_ReAllocMem(PTextSegm, slen+slen1+1, slen); 
   }
   else {
      if (slen1<SEGMENT_TEXT_SIZE+1)
         PTextSegm=ESL_AllocMem(SEGMENT_TEXT_SIZE+1);
      else 
         PTextSegm=ESL_AllocMem(slen1+1);
   }

   if (!PTextSegm)
      return FALSE;
   lptemp=Data;
   while (lptemp=x_strpbrk(Data,"\n\r\t")) 
      *lptemp=' ';
   x_strcat(PTextSegm, Data);  // concatenates the strings.
   return TRUE;
}

TCHAR *SearchExecuteProcedureKeyWord()
{
   TCHAR STR_EXECUTE_KEYWORD []   = _T("execute ");
   TCHAR STR_PROCEDURE_KEYWORD [] = _T("procedure ");
   /* tab and return characters have already been replaced with a space at */
   /* this point (through the call of the ConcatText function)             */
   TCHAR *p1;
   int iNbQuotes = 0;

   if (!PTextSegm)
      return NULL;
   p1 = PTextSegm;

   while (*p1!=EOS)
   {
      if (*p1 == _T('\"'))
         iNbQuotes++;

      if ( (iNbQuotes % 2) == 0 &&
            _tcsnicmp(p1, STR_EXECUTE_KEYWORD,_tcslen(STR_EXECUTE_KEYWORD)) == 0)
      {
           p1+=x_strlen(STR_EXECUTE_KEYWORD);  // ignore the literal 'execute'
           while ( CMspace(p1) )               // Skip the useless space characters
               CMnext(p1);
           if ( _tcsnicmp(p1, STR_PROCEDURE_KEYWORD,_tcslen(STR_PROCEDURE_KEYWORD)) == 0)
           {
               p1+=x_strlen(STR_PROCEDURE_KEYWORD);  // ignore the literal 'procedure'
               return p1;
           }
      }
      CMnext(p1);
   }
   return NULL;
}


UCHAR *ParseRuleText(LPUCHAR PUout)
{
   UCHAR *Stype[]={STR_ON,STR_OF,STR_FROM,STR_INTO,NULL}; 
   UCHAR szBufOwner[MAXOBJECTNAME],szObjName[MAXOBJECTNAME],szTemp[MAXOBJECTNAME];
   UCHAR *p = NULL;
   UCHAR *pEnd = NULL; 
   UCHAR *pTemp = NULL; 
   UCHAR **StypeScan = NULL;
   UCHAR *pDest = NULL;
   int slen, maxlen,nbQuote;

   if (!PTextSegm)   // nothing: nothink! (may happen when no rows are ...
      return NULL;   // found by the caller).

   /***************************************
   * Part I : Isolate the procedure name  *
   ***************************************/

   if (!(p=SearchExecuteProcedureKeyWord())) {   // abnormal situation
      *(PUout+MAXOBJECTNAME)='\0';             // constarint rules
      *PUout='\0';
      return NULL;
   }

   while (CMspace(p))                   // do not take space 
      CMnext(p);

   nbQuote = 0;
   pTemp = p;
   pDest = PUout;
   while (*pTemp != EOS)
   {
       if (*pTemp == '\"')
           nbQuote++;
       if (*pTemp == ' ' && (nbQuote % 2) == 0)
       {
           while ( CMspace(pTemp) )             // Skip the useless space characters
               CMnext(pTemp);
       }
       if (*pTemp == '(' && (nbQuote % 2) == 0) // End of Procedure Name
           break;
       else
       {
           CMcpychar(pTemp,pDest);
           CMnext(pTemp);
           CMnext(pDest);
       }
   }
   *pDest ='\0';

   // Remove the SQL quotes
   if (nbQuote >0 && (nbQuote % 2) == 0)
   {
      x_strcpy(szBufOwner, RemoveSQLQuotes(OwnerFromString(PUout, szTemp)));
      x_strcpy(szObjName , RemoveSQLQuotes(StringWithoutOwner(PUout)));
      StringWithOwner(szObjName, szBufOwner, PUout);
   }
   /***************************************
   * Part II : Isolate significant text   *   
   ***************************************/

    slen=MAXOBJECTNAME;

   // look for the statment type 

   if (!(p=x_stristr(PTextSegm, STR_AFTER))) {      // abnormal situation
      *(PUout+MAXOBJECTNAME)='\0';
      return PUout;
   }
   p+=x_strlen(STR_AFTER);   

   while (_istspace(*p))               // ignore spaces
      CMnext(p);

   StypeScan=Stype;
   while (!(pEnd=x_stristr(p,*StypeScan))) {   //   search for keyword (on, of...)
      if (!StypeScan++) {
         *(PUout+MAXOBJECTNAME)='\0';   // abnormal situation
         return PUout;
      }
   }
   maxlen=MAXOBJECTNAME;   
   slen=(maxlen>pEnd-p) ? pEnd-p+1 : maxlen; // take lower length
   fstrncpy(PUout+MAXOBJECTNAME, p, slen);
   maxlen-=slen;
   slen = (maxlen>4) ? 4 : maxlen;  // 4 is size of "... "
   x_strncat(PUout+MAXOBJECTNAME, "... ", slen);
   maxlen-=slen;

   if (maxlen<=0)
      return PUout;

   if (!(p=x_stristr(pEnd, STR_REFERENCING)))   // if optional keywords are
      if (!(p=x_stristr(pEnd, STR_WHERE)))       // not there
         return PUout;                       // we are done

   slen=x_strlen(p);                        // copy remainding chars       
   x_strncat(PUout+MAXOBJECTNAME, p, (slen>maxlen) ? maxlen : slen);
   return PUout; 
}
UCHAR *ParseProcText(PUout)
UCHAR *PUout;
{
   int static n=MAXOBJECTNAME;      // length to be copied
   int Sln;
   UCHAR *PUstart, *PUend;            // begin and end of str ptrs

   if (!PTextSegm) {
      *PUout='\0';
      return NULL;
   }

   PUstart = x_stristr(PTextSegm, "begin"); // look for the begin keyword
   if (!PUstart) {                  // not found, sets null string   
      *PUout='\0';
      return NULL;
   }

   PUstart+=6;                        // do jot copy the keyword
   PUend=x_stristr(PUstart, "end");   // look for the end of proc

   if (!PUend)                        // q: end of proc not found 
      Sln=n-(PUstart-PTextSegm);  // a: yes, copy to end of string 
   else
      Sln=PUend-PUstart;            // a: no, copy to the 'end' keyword

   if (Sln>n)                        // limit the copy to the max
      Sln=n;

   StrToLower(PUstart);
   fstrncpy(PUout,PUstart, Sln);      // copy
   suppspace(PUout);                  // trim the string

   return PUout;
}

static BOOL GetOneQuelViewTable(LPUCHAR singlename)
{
   static UCHAR *PTblName=NULL, *pEnd;
   int slen;
   static BOOL OtherRangeInSegm=FALSE;

   TCHAR STR_RANGE_OF   [] = _T("range of");
   TCHAR STR_IS_KEYWORD [] = _T(" is ");
   TCHAR STR_DEFINE_VIEW[] = _T("define view");

   if (!PTextSegm)         // no buffer to analyse
      return FALSE;

   if (!PTblName)          // first time entered
      PTblName=PTextSegm;

   if (!OtherRangeInSegm) { // verify that the first key word is "range of"
      if ( _tcsnicmp(PTblName, STR_RANGE_OF,_tcslen(STR_RANGE_OF)) != 0 )
      {
         PTblName=NULL;
         return FALSE;
      }
   }

   PTblName = PTblName + _tcslen ( STR_RANGE_OF );
   while (*PTblName != EOS)
   {
      if ( _tcsnicmp(PTblName, STR_IS_KEYWORD,_tcslen(STR_IS_KEYWORD)) != 0)
         CMnext(PTblName);
      else
          break;
   }

   PTblName = PTblName + _tcslen ( STR_IS_KEYWORD );

   if (pEnd=x_strpbrk(PTblName," \n\t\f\r")) {  // positioning to end of token
      slen = pEnd - PTblName;
      fstrncpy(singlename, PTblName, slen+1);
      PTblName = PTblName + slen;
   }

   while (*PTblName != EOS)// find the next key word.
   {
      if ( _tcsnicmp(PTblName, STR_RANGE_OF,_tcslen(STR_RANGE_OF)) == 0 )
      {
          OtherRangeInSegm = TRUE;
          return TRUE;
      }
      else if ( _tcsnicmp(PTblName, STR_DEFINE_VIEW,_tcslen(STR_DEFINE_VIEW)) == 0 )
      {
          OtherRangeInSegm = FALSE;
          return TRUE;
      }
      CMnext(PTblName);
   }

   return TRUE;
}
static BOOL GetOneViewTable(LPUCHAR singlename, LPUCHAR lpOwnerName)

{

   static UCHAR *PTableName=NULL, *pEnd, *pTemp,*lptblName,*pTempOwner;
   static slen;
   static BOOL OtherInSegm=FALSE;
   static UCHAR *SelKeywords[]={
         "select ",
         "where ",
         "group ",
         "having ",
         "union ",
         "order ",
         "exec ",
         NULL};
   UCHAR **SelKeyword=SelKeywords;

   if (!PTextSegm)         // no buffer to analyse
      return FALSE;


/* WARNING : the register "view" is not yet implemented to be finished.*/

   if (!PTableName) {      // first time entered 
      if (PTableName=x_stristr(PTextSegm, "register ")) {
         PTableName=NULL;
         return FALSE;
      }
      PTableName=PTextSegm;
   }

   if (!OtherInSegm)        // if the table list was exhaust, look for "FROM"
      if (!(PTableName=SQLPosTBL(PTableName))) { // we are done 
         PTableName=NULL;
         return FALSE;
      }

   while (CMspace(PTableName)||*PTableName=='(') 
      CMnext(PTableName);

   if (*PTableName == '\"')
   {
       int nbQuote = 0;
       pTempOwner = PTableName;
       // find the schema name : for determinate where the schema name end,
       // search the first dot character with the pair number of quotes.
       while (*pTempOwner != EOS) 
       {
           if (*pTempOwner == '\"')
                nbQuote++;
           if ( *pTempOwner == '.' && (nbQuote % 2) == 0 ) 
           {
               slen=pTempOwner-PTableName;
               fstrncpy(lpOwnerName,PTableName, slen+1);
               x_strcpy(lpOwnerName, RemoveSQLQuotes(lpOwnerName));
               break;
           }
           else
               CMnext(pTempOwner);
       }
       nbQuote = 0;

       if( *pTempOwner == '.')     // ignore the dot character
           CMnext(pTempOwner);     
       while (CMspace(pTempOwner)) // remove the space
          CMnext(pTempOwner);
       // if *pTempOwner == EOS there are no schema in this object name
       // in this case do not change "PTableName" and copy directly the object name into "singlename".
       if (*pTempOwner != EOS)
            PTableName = pTempOwner;
       lptblName  = pTempOwner;
       while (*lptblName != EOS)  // find the object name
       {
           if (*lptblName == '\"')
               nbQuote++;
           if ((*lptblName == ',' || *lptblName == ' ') && (nbQuote % 2) == 0)
           {
                slen = lptblName-PTableName;
                fstrncpy(singlename, PTableName, slen+1);
                x_strcpy(singlename, RemoveSQLQuotes(singlename));
                break;
           }
           else
               CMnext(lptblName);
       }
       if (*lptblName == EOS)
            x_strcpy(singlename, RemoveSQLQuotes(PTableName));

       pEnd = lptblName;
   }
   else
   {
       if (pEnd=x_strpbrk(PTableName," ,).")) {  // positioning to end of token
          if (*pEnd=='.') {                     // it's an owner name
             pTemp=lpOwnerName;
             while (PTableName<pEnd) {               // copy owner
                if (*PTableName!='\"') {
                    CMcpychar(PTableName,pTemp);
                    CMnext(pTemp);
                }
                CMnext(PTableName);
             }
             *pTemp='\0';
             CMnext(pEnd);
             PTableName=pEnd; 
             while (CMspace(PTableName))      // if space between owner and table
                CMnext(PTableName);
             pEnd=x_strpbrk(PTableName," ,)");  // position end of table name
          }
       }
       x_strcpy(lpOwnerName, RemoveSQLQuotes(lpOwnerName));
       if (!pEnd) {            // no delim found (end of buffer reached)
          fstrncpy(singlename,PTableName, MAXOBJECTNAME);
          x_strcpy(singlename,RemoveSQLQuotes(singlename));
          OtherInSegm=FALSE;   // no other table name      
          return TRUE;
       }
       slen=pEnd-PTableName;
       fstrncpy(singlename,PTableName, slen+1);
       x_strcpy(singlename,RemoveSQLQuotes(singlename));
   }

/*************************************************************************
* if the delimitator was a space we can get
* 1) a correlation name ....................
*                                          I
*                                          V
*    select x.colname .... from table_name x ....
* 2) a separator .................
*                                I
*                                V
*    select.... from table_name1 , tablename..
* 3) if neither 1) nor 2) this is a SQL keyword (select, where...) 
*************************************************************************/

   PTableName=pEnd;
   while (CMspace(PTableName))  // ignore spaces after the table name 
         PTableName++;           

   switch (*PTableName) {
      case ')' :              // subquery end, no more tables for this 'from'
         OtherInSegm=FALSE;
         CMnext(PTableName);
         return TRUE;
      case ',' :              // at least one table name follows
         OtherInSegm=TRUE;
         CMnext(PTableName);
         return TRUE;
   }
// --- determine if the pointed token is a keyword or a correlation name 
   while (*SelKeyword) {
      if (x_stricmp(*SelKeyword,PTableName)==0) {
         OtherInSegm=FALSE;   // the token was a key word          
         return TRUE;
      }
      SelKeyword++;
   }
// --- ignore the correlation name
   pEnd=x_strpbrk(PTableName, ") ,");
   if (!pEnd) {         // buffer exhausted
      OtherInSegm=FALSE;   
      return TRUE;
   }
   PTableName=pEnd;
   while (CMspace(PTableName))  // ignore spaces after the correlation name 
         CMnext(PTableName);

   switch (*(PTableName)) {
      case ')' :              // subquery end, no more tables for this 'from'
         CMnext(PTableName);
         OtherInSegm=FALSE;
         break;
      case ',' :              // at least one table name follows
         CMnext(PTableName);
         OtherInSegm=TRUE;
         break;
      case '(' :              // at least one table name follows
         CMnext(PTableName);           
         //OtherInSegm=TRUE;  // PS 03/19/98
         OtherInSegm=FALSE;   // after "(" find the next "from" in the string
         break;
      default :               // we had a ' ' after the correlation name
         OtherInSegm=FALSE;         
         break;
   }
   return TRUE;
}

int GetViewTables(LPUCHAR tablename, LPUCHAR lpOwnerName,BOOL bSqlViewType)

{
   static LPOBJECTLIST ptablelist=NULL,Newptableobject,pScanTableList;
   BOOL OneToPass=FALSE;

   while (!OneToPass) {
      if (bSqlViewType)
      {
         if (!GetOneViewTable(tablename, lpOwnerName)) {  /* get 1 tbl from bfr*/
            FreeObjectList(ptablelist);
            ptablelist=NULL;
            return RES_ENDOFDATA;
         }
      }
      else
      {
         if (!GetOneQuelViewTable(tablename)) {  /* get 1 tbl from bfr*/
            FreeObjectList(ptablelist);
            ptablelist=NULL;
            return RES_ENDOFDATA;
         }
      }
      StrToLower(tablename);
      StrToLower(lpOwnerName);
      pScanTableList=ptablelist;
      OneToPass=TRUE;
      while (pScanTableList&&OneToPass) { /* see if not already there */
         if (x_strcmp(tablename, (char *) pScanTableList->lpObject)==0)
            if (x_strcmp(lpOwnerName,
                (char *) pScanTableList->lpObject+MAXOBJECTNAME)==0)
               OneToPass=FALSE;
         pScanTableList=pScanTableList->lpNext;
      }
   }
   Newptableobject=AddListObject(ptablelist, MAXOBJECTNAME*2+1);
   if (!Newptableobject) {
      FreeObjectList(ptablelist);
      ptablelist=NULL;
      return RES_ERR;
   }
   ptablelist=Newptableobject;
   fstrncpy((char *) ptablelist->lpObject, tablename, MAXOBJECTNAME);
   fstrncpy((char *) ptablelist->lpObject+MAXOBJECTNAME, lpOwnerName,
               MAXOBJECTNAME);
   return RES_SUCCESS;
}
/*************************************************
* WARNING : This proc assumes that if            *
*     1) Neither the SUCCESS keyword nor the     *
*        FAILURE keyword are found, SUCCESS AND  *
*        FAILURE are to be generated.            *
*     2) the WHEN clause is not specified, all   *
*        accesses are to be generated.           *
*************************************************/
void ParseSecurityText(extradata, SecuritySet, jmax)
UCHAR *extradata;
struct SecuritySets *SecuritySet;
int jmax;
{
   struct {
      UINT Success : 1;
      UINT Failure : 1;
      UINT OneTypeOn : 1;
   } Security;
   static struct {
      UINT Success;     
      UCHAR *Type;
   } SF[]={
              {TRUE, " success "},
             {TRUE, ",success "},
             {TRUE, " success,"},
             {TRUE, ",success,"},
              {FALSE, " failure "},
             {FALSE, ",failure "},
             {FALSE, " failure,"},
             {FALSE, ",failure,"},
             {0, NULL}};
   static struct {
      UINT Indice;     
      UCHAR *Type;
   } Alarm[]={
             {0, " select "},
             {0, " select,"},
             {0, ",select "},
             {0, ",select,"},
             {2, " delete "},
             {2, " delete,"},
             {2, ",delete "},
             {2, ",delete,"},
             {4, " insert "}, 
             {4, " insert,"}, 
             {4, ",insert "}, 
             {4, ",insert,"}, 
             {6, " update "},
             {6, " update,"},
             {6, ",update "},
             {6, ",update,"},
             {8, " connect "},
             {8, " connect,"},
             {8, ",connect "},
             {8, ",connect,"},
             {10, " disconnect "},
             {10, " disconnect,"},
             {10, ",disconnect "},
             {10, ",disconnect,"},
             {0, NULL}};
   int j=0, k; 

   for (j=0;j<jmax;j++)                    // Initialize the flags
      SecuritySet[j].TypeOn=FALSE;      

   Security.Success = Security.Failure = Security.OneTypeOn = FALSE;

   j=0;
   while (SF[j].Type) {            // search for success and failure key words
      if (x_strstr(extradata,SF[j].Type)) {
         if (SF[j].Success) 
            Security.Success=TRUE;
         else
            Security.Failure=TRUE;
      }
      j++;
   }

   if (!(Security.Success||Security.Failure))   // if neither fail nor success
      Security.Success=Security.Failure=TRUE;   // set both

   j=0;
   while (Alarm[j].Type) {                       // scan all access type
      k=Alarm[j].Indice;
      if (x_strstr(extradata,Alarm[j].Type))  {   // search an access type
         Security.OneTypeOn=TRUE;
          SecuritySet[k].TypeOn=Security.Success;
          SecuritySet[k+1].TypeOn=Security.Failure;      
      }
      j++;
   }      
   if (Security.OneTypeOn)
      return; 

// no acces types were specified : default is all -> generate all

   j=0;
   while (Alarm[j].Type) {
      if (Security.Success)
         SecuritySet[Alarm[j].Indice].TypeOn=TRUE;      
       if (Security.Failure)
         SecuritySet[Alarm[j].Indice+1].TypeOn=TRUE;      
      j++;
   }
   return;
}      

int ParsePermitText(rt1, extradata)
int rt1;
UCHAR *extradata;

{
   static struct Rets {
    int ObjType;
    struct{
         char *priv;
         int Value;
    } Obj[MAX_PRIVILEGES+1];
   } Ret[] = {OT_TABLE,   {{" select ",     OT_TABLEGRANT_SEL_USER},
                           {" insert ",     OT_TABLEGRANT_INS_USER},
                           {" update ",     OT_TABLEGRANT_UPD_USER},
                           {" delete ",     OT_TABLEGRANT_DEL_USER},
                           {" references ", OT_TABLEGRANT_REF_USER},
                           {" copy_into ",  OT_TABLEGRANT_CPI_USER},
                           {" copy_from ",  OT_TABLEGRANT_CPF_USER},
                           {NULL, OT_ERROR}},
              OT_VIEW,    {{" select ", OT_VIEWGRANT_SEL_USER},  
                           {" insert ", OT_VIEWGRANT_INS_USER},
                           {" update ", OT_VIEWGRANT_UPD_USER},
                           {" delete ", OT_VIEWGRANT_DEL_USER},
                           {NULL, OT_ERROR}},
              OT_DBEVENT, {{" raise ",    OT_DBEGRANT_RAISE_USER}, 
                           {" register ", OT_DBEGRANT_REGTR_USER},
                           {NULL, OT_ERROR}},
              OT_PROCEDURE, {{" execute ", OT_PROCGRANT_EXEC_USER}, 
                           {NULL, OT_ERROR}},
              OT_SEQUENCE, {{" next ",     OT_SEQUGRANT_NEXT_USER}, 
                           {NULL, OT_ERROR}}};

   int OType, j, OTmax=sizeof(Ret)/sizeof(Ret[0]);

   // look for the object type;

   for (OType=0; OType<OTmax; OType++)
      if (rt1==Ret[OType].ObjType)    
         break;                        

   if (OType>=OTmax)     // Object type not found, error
      return OT_ERROR;

  // look for privilege of type just found.

   j=0;
   while(Ret[OType].Obj[j].priv) {
      if (x_strstr(extradata,Ret[OType].Obj[j].priv)) 
         return Ret[OType].Obj[j].Value;     // privilege found, OK
      j++;
   }
   return OT_ERROR; // privilege not found; error;
}
