/*
**  Copyright (C) 2005-2006 Ingres Corporation. All Rights Reserved.
*/

/*
**    Source   : dmldbf.cpp: implementation file
**    Project  : IMPORT ASSISTANT 
**    Author   : Sotheavut UK (uk$so01)
**    Purpose  : Manipulation of data of dBASE file 
**
** History:
**
** 15-Feb-2001 (uk$so01)
**    Created
** 25-Oct-2001 (noifr01)
**    (bug 105484) fixed the way short integers were read from the file
** 17-Jan-2002 (uk$so01)
**    (bug 106844). Add BOOL m_bStopScanning to indicate if we really stop
**     scanning the file due to the limitation.
** 21-Jan-2002 (uk$so01)
**    (bug 106844). Additional fix: Replace ifstream and some of CFile.by FILE*.
** 23-Jan-2002 (uk$so01)
**    (bug 106844). Additional fix: use the WORD and DWORD to read 2-bytes and 4-bytes.
** 30-Jan-2002 (uk$so01)
**    SIR  #106952, Add new Ingres Export Assistant & Cleanup.
** 03-Apr-2002 (uk$so01)
**    SIR  #107487, iia fails to import .DBF files generated by Etrust Antivirus
**    The .dbf file generated by Etrust Antivirus has an unexpected '\0' after
**    the column description terminated by 0x0D.
** 04-Apr-2002 (uk$so01)
**    BUG #107505, import column that has length 0, record length != sum (column's length)
** 05 Apr-2002 (uk$so01)
**    BUG #107518, import column that has length > 200, buffer's size too small
** 30 Aug-2002 (uk$so01)
**    BUG #108408, check the valid length only if we are not getting row one by one.
**/


#include "stdafx.h"
#include "dmlcolum.h"
#include "formdata.h"
#include "dmldbf.h"
#include "tkwait.h"
#include "rcdepend.h"
#include <stdio.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
#define IO_BUFFER_DBF    256

static void CheckDBFVersion(int nVersion)
{
	BOOL bOk = FALSE;
	switch (nVersion)
	{
	case 0x03: // dBASE III with no memo file
	case 0x04: // dBASE IV  with no memo file
	case 0x05: // dBASE V   with no memo file
		bOk = TRUE;
		break;
	case 0x83: // dBASE III+ with memo file
	case 0xF5: // FoxPro with memo file
	case 0x8B: // dBASE IV with membo file
	case 0x8E: // dBASE IV with SQL Table
	case 0x30: // Visual FoxPro with DBC
	case 0x7B: // dBASE IV with Memo file
		throw (int)DBFxERROR_HASMEMO_FILE;
		break;
	default:
		break;
	}

	if (!bOk)
		throw (int)1; // Unsupport version of file
}

static TCHAR tchszMonth  [13][4] = 
{
	_T("???"),
	_T("jan"),
	_T("feb"),
	_T("mar"),
	_T("apr"),
	_T("may"),
	_T("jun"),
	_T("jul"),
	_T("aug"),
	_T("sep"),
	_T("oct"),
	_T("nov"),
	_T("dec")
};

//
// Converse the DBF data format yyyymmdd to US dd-mmm-yyyy
static void DBF_Date2USDefault(CString& strDate)
{
	CString strNewDate;
	CString strTemp = strDate;
	strTemp.TrimLeft();
	strTemp.TrimRight();
	int nLen = strTemp.GetLength();
	if (nLen != 8)
		return;

	CString strItem = strTemp.Right(2);
	strNewDate = strItem;
	strNewDate+= _T("-");

	strItem = strTemp.Mid (4, 2);
	int nMonth = _ttoi (strItem);
	strNewDate+= tchszMonth [nMonth];
	strNewDate+= _T("-");

	strNewDate+= strTemp.Left(4);
	strDate = strNewDate;
}


//
// DBF_QueryRecord
//
// Summary: Query the DBF records.
// Parameters:
//    hwndAnimate : Animate dialog, if this parameter is not NULL, the function can interact 
//                  with animation dialog for showing the progression ...
//    pData       : import assistant data (page1, ..., page3)
//    pFile       : dbf file to read.
//    strOutRecord: not affected if nQueryMode = 0.
//                  if nQueryMode = 2, the formated record to the varchar(0)
//                  i.e each field is prefixed by a 5-characters length.
//    nQueryMode  : 0, strOutRecord is not affected and scan the file to update pData.
//                  1, strOutRecord is not affected and scan the file to skip the header
//                     until the firt record.
//                  2, read the record one by one, you must call with nQueryMode = 1 first.
// Throw exception as integer (int)
// 1: unsupport version of DBF file
// 2: cannot read file.
// 3: The number of columns in dbf file is not equal to the number of columns in the table.
// ************************************************************************************************
void DBF_QueryRecord(HWND hwndAnimate, CaIIAInfo* pData, FILE* pFile, CString& strOutRecord, int nQueryMode)
{
	ASSERT (nQueryMode == 0 || nQueryMode == 1 || nQueryMode == 2);
	CaDataPage1& dataPage1 = pData->m_dataPage1;
	CaDataPage2& dataPage2 = pData->m_dataPage2;
	CString strFile = dataPage1.GetFile2BeImported();
	CStringArray& arrayColumns = dataPage2.GetArrayColumns();
	CStringArray& arrayColumnType = dataPage2.GetArrayColumnType();
	BYTE i1;
	unsigned short ishort;

	int nTotalByteRead = 0;
	CArray <int, int> arrayFieldLength;
	//
	// Reject the 4 first charaters. (useless version and date of last change)
	int  nItemRead = 0;
	int  nByte = 0;
	int  nRecords;
	int  nByte2Read = 1;
	int  nHeaderLength = 0;
	int  nRecordLength = 0;
	TCHAR buf[IO_BUFFER_DBF + 1];

	if (nQueryMode != 2)
	{
		//
		// Read number of version and check to see if the file is a dBASE III (03h)
		// Or = 83H (131) with the file .DBT
		nByte2Read = 1;      // Byte [0]
		nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
		if (nByte != nByte2Read)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
		nTotalByteRead+= nByte;

		int nVersion = (int)buf[0];
		CheckDBFVersion(nVersion);
		//
		// Skip the last update (3 bytes):
		nByte2Read = 3;  // Byte [1 3]
		nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
		if (nByte != nByte2Read)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
		nTotalByteRead+= nByte;

		//
		// Number of records Byte [4 7] (4 bytes):
		DWORD dwRecNumber = 0;
		nItemRead = fread ((void*)&dwRecNumber, sizeof(dwRecNumber), 1, pFile); 
		if (nItemRead != 1)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
		nTotalByteRead+= nItemRead*sizeof(DWORD);
		nRecords = dwRecNumber;
		//
		// Skip Length of header. Byte [8 9] (2 bytes):
		WORD wHeaderSize = 0;
		nItemRead = fread ((void*)&wHeaderSize, sizeof (WORD), 1, pFile); 
		if (nItemRead != 1)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
		nTotalByteRead+=  nItemRead*sizeof(WORD);
		nHeaderLength = (int)wHeaderSize;

		//
		// Length of Record Byte [10 11] (2 bytes):
		nItemRead = fread ((void*)&ishort, sizeof (ishort), 1, pFile); 
		if (nItemRead != 1)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
		nTotalByteRead+=  nItemRead*sizeof(ishort);
		nRecordLength = (int)ishort;

		//
		// Skip the reserve bytes  Byte [12 31] (20 bytes):
		nByte2Read = 20; 
		nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
		if (nByte != nByte2Read)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
		nTotalByteRead+= nByte;

		//
		// Field descriptors  (matrix of 32 bytes and terminates by a 0x0D):
		nByte2Read = 1; 
		nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
		if (nByte != nByte2Read)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
		nTotalByteRead+= nByte;
		while (buf[0] != 0x0D)
		{
			//
			// Field name (11 bytes):
			nByte2Read = 10; // Total 11 bytes (name of fields)
			//
			// We have already read the buf[0] to check the terminator (0x0D), so we read
			// the last 10 bytes start from buf[1] ...
			nByte = fread ((void*)&buf[1], sizeof(TCHAR), nByte2Read, pFile); 
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;
			buf[nByte2Read+1] = _T('\0');
			TRACE1 ("Field name = %s, ", buf);
			if (nQueryMode == 0)
				arrayColumns.Add(buf);
			//
			// Field data type (1 byte):
			nByte2Read = 1; 
			nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;
			buf[nByte2Read] = _T('\0');
			TRACE1 ("Type = %s, ", buf);
			TCHAR tchType = buf[0];
			//
			// Skip the address of data of the field (4 bytes):
			nByte2Read = 4; 
			nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;

			//
			// The length of the field (1 byte):
			nByte2Read = 1; 
			nByte = fread ((void*)&i1, sizeof(BYTE), nByte2Read, pFile); 
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;
			buf[nByte2Read] = _T('\0');
			int nFieldLength = (int)i1;
			TRACE1 ("Length = %d, ", nFieldLength);
			if (nQueryMode == 0)
				arrayFieldLength.Add(nFieldLength);

			//
			// The number of precision (1 byte):
			nByte2Read = 1; 
			nByte = fread ((void*)&i1, sizeof(BYTE), nByte2Read, pFile); 
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;
			int nDecimalLength = (int)i1;
			TRACE1 ("Decimal.prec = %d\n", nDecimalLength);

			switch (tchType)
			{
			case _T('C'):
			case _T('c'): // Characters (map to varchar)
				arrayColumnType.Add(_T("varchar"));
				break;
			case _T('D'):
			case _T('d'): // Date
				arrayColumnType.Add(_T("date"));
				break;
			case _T('F'):
			case _T('f'): // Float (map to float)
				arrayColumnType.Add(_T("float"));
				break;
			case _T('L'):
			case _T('l'): // Boolean (map to char)
				arrayColumnType.Add(_T("char"));
				break;
			case _T('N'):
			case _T('n'): // Numeric (map to integer or float)
				if (nDecimalLength > 0)
					arrayColumnType.Add(_T("float"));
				else
					arrayColumnType.Add(_T("integer"));
				break;
			default:
				throw (int)DBFxERROR_UNSUPORT_DATATYPE;
			}

			//
			// Skip the reserve bytes [18, 31] of field descriptor (14 bytes):
			nByte2Read = 14; 
			nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;

			//
			// Check the terminator (0x0D)
			nByte2Read = 1; 
			nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;
		}

		//
		// Check the match columns:
		if (nQueryMode == 0)
		{
			if (dataPage1.IsExistingTable() && 
			    dataPage1.GetTableColumns().GetCount() != arrayColumns.GetSize() && 
			    dataPage1.GetFileMatchTable() == 1)
			{
				throw (int)DBFxERROR_WRONGCOLUMN_COUNT; // The number of columns in dbf file is not equal to the number of columns in the table.
			}

			int i, nSize = arrayFieldLength.GetSize();
			ASSERT (nSize == arrayColumns.GetSize());
			dataPage2.SetFieldSizeInfo (nSize);
			for (i=0; i<nSize; i++)
			{
				int& nMax  = dataPage2.GetFieldSizeMax(i);
				int& nEMax = dataPage2.GetFieldSizeEffectiveMax(i);

				nMax  = arrayFieldLength.GetAt(i);
				nEMax = nMax;
			}

			dataPage2.SetDBFTheoricRecordSize(nRecords);
		}

		if (nQueryMode == 1)
			return;
	}
		
	ASSERT (nQueryMode == 0 || nQueryMode == 2);
	//
	// Read the records:

	int nFieldCount = 0;
	CaRecord* pNewRecord = NULL;
	int i, nCount = 0;
	double dRatio = 100.0 / nRecords; // For the progress bar:
	CPtrArray& arrayRecord = dataPage2.GetArrayRecord();
	if (nQueryMode == 0)
	{
		arrayRecord.SetSize(nRecords);
		nFieldCount = arrayFieldLength.GetSize();
		dataPage2.SetColumnCount(nFieldCount);
	}
	else
	{
		nFieldCount = dataPage2.GetColumnCount();
	}

	BOOL bSkipped = FALSE;
	nByte2Read = 1; // Marker of record (0x20 or 0x2A for delete mark)
	
	if (nTotalByteRead < nHeaderLength)
	{
		int nPos = fseek(pFile, nHeaderLength, SEEK_SET);
		if (nPos != 0)
			throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
	}
	nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
	if (nByte == 0)
		return; // END OF FILE;
	if (nByte != nByte2Read)
		throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
	nTotalByteRead+= nByte;

	ASSERT(nFieldCount == dataPage2.GetFieldSizeInfoCount());
	//
	// Check the record length:
	if (nQueryMode != 2)
	{
		int nSumFieldLength = 0;
		for (i = 0; i<nFieldCount; i++)
		{
			nSumFieldLength += dataPage2.GetFieldSizeMax(i);
		}
		ASSERT (nRecordLength >= (nSumFieldLength+1));
		if (nRecordLength < (nSumFieldLength+1))
		{
			throw (int)DBFxERROR_RECORDLEN; 
		}
	}

	while (buf[0] == 0x20 || buf[0] == 0x2A)
	{
		if (buf[0] == 0x20)
		{
			int nRecordSizeRead = 1; // 0x20
			pNewRecord = new CaRecord();
			CStringArray& arrayField = pNewRecord->GetArrayFields();
			arrayField.SetSize(nFieldCount);
			CString strVarField = _T(""); // For writing to temporary file
			CString strRecord = _T("");   // For writing to temporary file
			for (i = 0; i<nFieldCount; i++)
			{
				int nFLength = dataPage2.GetFieldSizeMax(i);
				buf[0] = _T('\0');
				if (nFLength > 0)
				{
					nByte2Read = nFLength;
					nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
					if (nByte != nByte2Read)
						throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
					nTotalByteRead+= nByte;
					nRecordSizeRead += nByte;
					buf[nByte2Read] = _T('\0');
				}

				CString strField = buf;
				strField.TrimRight();
				if (dataPage1.GetCodePage() == CaDataPage1::OEM)
				{
					strField.OemToAnsi();
				}
				//
				// Converse date:
				CString strDBFType = arrayColumnType.GetAt(i);
				if (strDBFType == _T("date"))
					DBF_Date2USDefault(strField);

				if (nQueryMode == 2)
				{
					strVarField.Format (_T("%05d%s"), strField.GetLength(), (LPCTSTR)strField);
					strRecord += strVarField;
				}
				else
				{
					arrayField.SetAt(i, strField);
				}
			}

			if (nRecordSizeRead < nRecordLength)
			{
				int nByteLeft = nRecordLength - nRecordSizeRead;
				while (nByteLeft > 0)
				{
					nByte = fread ((void*)buf, sizeof(TCHAR), min (nByteLeft, IO_BUFFER_DBF), pFile); 
					nTotalByteRead+= nByte;
					nByteLeft -= min (nByteLeft, IO_BUFFER_DBF);
				}
			}

			if (nQueryMode == 2)
			{
				strOutRecord = strRecord;
				strRecord = _T("");
				delete pNewRecord;
			}
			else
			{
				strRecord = _T("");
				arrayRecord.SetAt (nCount, pNewRecord);
			}
	
			nCount++;
			if (nQueryMode == 0)
			{
				if (hwndAnimate)
				{
					int nCur = (int)(dRatio * (nCount));
					::PostMessage (hwndAnimate, WM_EXECUTE_TASK, W_TASK_PROGRESS, (LPARAM)nCur);
				}

				BOOL bInterruped = FALSE;
				if (theApp.m_synchronizeInterrupt.IsRequestCancel())
				{
					theApp.m_synchronizeInterrupt.BlockUserInterface (FALSE); // Release user interface
					theApp.m_synchronizeInterrupt.WaitWorkerThread ();        // Wait itself until user interface releases it.
					bInterruped = pData->GetInterrupted();
				}

				if (bInterruped || (dataPage1.GetKBToScan() > 0 && (nTotalByteRead / 1024) >= dataPage1.GetKBToScan()))
				{
					TRACE0("Stop scanning dbf file due to limit reached\n");
					dataPage1.SetStopScanning(TRUE);
					fclose (pFile);
					//
					// The record size may be allocated to the exact size in the file. But somehow some records
					// might have been marked as deleted and we ignore those records:
					while (arrayRecord.GetSize() > nCount)
					{
						arrayRecord.RemoveAt(nCount);
					}
					return; // Reach the limit to read or Interrupted
				}
			}
		}
		else // Skip the record that hes been marked to delete:
		{
			int nByteLeft = nRecordLength;
			while (nByteLeft > 0)
			{
				nByte = fread ((void*)buf, sizeof(TCHAR), min (nByteLeft, IO_BUFFER_DBF), pFile); 
				nTotalByteRead+= nByte;
				nByteLeft -= min (nByteLeft, IO_BUFFER_DBF);
			}
		}


		if (nQueryMode == 2)
			break; // Read only one record
		else
		{
			nByte2Read = 1; // Marker of record (0x20 or 0x2A for delete mark)
			nByte = fread ((void*)buf, sizeof(TCHAR), nByte2Read, pFile); 
			if (nByte == 0)
				break; // END OF FILE
			if (nByte != nByte2Read)
				throw (int)DBFxERROR_CANNOT_READ; // Failed to read file 'strFile2BeImported'
			nTotalByteRead+= nByte;
		}
	}

	if (nQueryMode == 0)
	{
		//
		// The record size may be allocated to the exact size in the file. But somehow some records
		// might have been marked as deleted and we ignore those records:
		while (arrayRecord.GetSize() > nCount)
		{
			arrayRecord.RemoveAt(nCount);
		}
	}
}


