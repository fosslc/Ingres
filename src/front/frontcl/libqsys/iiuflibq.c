# include 	<compat.h>
# include	<er.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<eqlang.h>
# include	<eqrun.h>
# if defined(UNIX) || defined(hp9_mpe)
# include	<iiufsys.h>

/*
** Copyright (c) 2004 Ingres Corporation
*/

/*
+* Filename:	iiuflibq.c
** Purpose:	Runtime translation layer for Unix EQUEL/F77 programs only
**
** Defines:			Maps to:
**	iibrea_()		IIbreak
**	iierrt_()		IIerrtest
**	iiexit_()		IIexit
**	iiflus_()		IIflush
**	iiingo_()		IIngopen
**	iinext_()		IInextget
**	iinexe_()		IInexec
**	iieqiq_()		IIeqiqio
**	iieqst_()		IIeqstio
**	iiparr_()		IIparret
**	iipars_()		IIparset
**	iigetd_()		IIgetdomio
**	iireti_()		IIretinit
**	iiputd_()		IIputdomio
**	iinotr_()		IIputdomio
**	iisexe_()		IIsexec
**	iisync_()		IIsyncup
**	iitupg_()		IItupget
**	iiutsy_()		IIutsys 
**	iiwrit_()		IIwritio
**	iicscl_()		IIcsClose
**	iicsde_()		IIcsDelete
**	iicser_()		IIcsERplace
**	iicsrp_()		IIcsReplace
**	iicsop_()		IIcsOpen
**	iicsqu_()		IIcsQuery
**	iicsre_()		IIcsRetrieve
**	iicsge_()		IIcsGetio
**	iicsrt_()		IIcsERetrieve
**	iiexde_()		IIexDefine
**	iiexex_()		IIexExec
**	iiputc_()		IIputctrl
**	iixact_()		IIxact
**	iivars_()		IIvarstrio
**	iicsrd_()		IIcsRdO
**	iilqpr_()		IILQpriProcInit
**	iilprs_()		IILQprsProcStatus
**	iilprv_()		IILQprvProcValio
**	iiserr_()		IIseterr
**	iilqes_()		IILQesEvStat
**	iilqss_()		IILQssSetSqlio
**	iilqis_()		IILQisInqSqlio
**	iilqsh_()		IILQshSetHandler
**	iilqle_()		IILQled_LoEndData
**	iilqlg_()		IILQlgd_LoGetData
**	iilqlp_()		IILQlpg_LoPutData
**	iilqld_()		IILQldh_LoDataHandler
-*
** Notes:
** 0)	Files in F77 runtime layer:
**		iiuflibq.c	- libqsys directory
**		iiufutils.c	- libqsys directory
**		iiufrunt.c	- runsys directory
**		iiuftbacc.c	- runsys directory
**
** 1)   Purpose of F77 runtime layer:
**	The above files contain routines which map subroutine calls from a 
**	Unix F77 program (i.e., generated by eqf on UNIX) to our runtime system.
**	These files should be easily portable to Unix on the Alliant
**	box.  Read (5) and (6) below regarding Alliant porting considerations.
**
** 2)	F77 symbol conventions:
**	F77 subroutine names need translating because the F77 compiler lower
**	cases and appends an underscore to symbol names.  Also, some F77 
**	compilers, such as Pyramid's, complain about names > 6 chars.  
**	Therefore, for Unix F77 EQUEL, we generate calls to our runtime 
**	routines using abbreviated names.  The code generator's abbreviation 
**	is to emit no more than six chars altogether. 
**	e.g.  a call to IIwriteio becomes "call IIwrit(....)".  
**	Note that all our names are unique to seven, not six, characters
**	so in order to pass unique 6-letter names to this layer, we have had 
**	to make special F77 entries in the code generator's table of runtime 
**	routines in the module forgen.c
**
** 3)   Parameter passing by reference:
**	The F77 compiler passes everything by reference, so this translation
**	layer also serves to dereference numerics and strings where necessary.
**	Sometimes an argument may be a numeric zero (a null pointer) or a 
**	string pointer.  (See IIflush, IIretinit, IIsyncup, IIutsys, IIfsetio 
**	IIprnscr, IIfrskact, IIthidecol).  This layer tests for a non-zero 
**	(sent by reference) before deciding whether to send the pointer 
**	or a zero.
**
** 4)   Null-terminated input strings:
**	This layer assumes that string variables which are SENDING data
**	to INGRES/forms system are blank padded.  String literals are
**	assumed to have had a null concatenated to them.  For literals,
**	the EQUEL F77 code generator generates calls to IIsd() and IIsdno().
**	These routines return a pointer into a buffer where the string
**	has been copied and null terminated.  Since the compiler passes
**	everything by reference, this pointer is passed by reference
**	(char **) to these run time routines!!
**
** 5)   String Lengths as parameters:
**	In those instances where string variables are being passed
**	for RECEIVING character data from INGRES/forms system, this
**	layer assumes that a host-language blank padded variable is used.
**	For those routines which return strings to host language variables
**	the interface layer must specify the type as DB_CHA_TYPE.  The system
**	blank pads the output to the length specified.
**
**	In previous incarnations, the interface layer has received
**	an extra parameter, usually occuring at the end of the parameter
**	list, specifying the actual number of character bytes allocated
**	to a variable or string constant by the compiler.  This nasty
**	interface is now restricted to a few routines, found in 'iiufutil.c'.
**	The routines perform a variety of functions associated with hiding
**	compiler specific string quirks form the runtime system.
**
** 6)	External variable sent via IIaddform:
**	The "## addform formvar" statement uses an external integer (formvar).
**	An F77 external integer is actually a pointer to an integer.
**	After sending this extern as a parameter, it doubly dereferenced
**	and must be declared that way (see iadfor_ in the file iifrunt.c).
**	For Alliant FORTRAN, the external integer is not dereferenced
**	(I think).
**
** 7)   IIxname versus IIname:
**	The code generator for VMS calls the "IIx" version of a runtime
**	routine whenever a string variable is receiving and sending data.  
**	This was done so that VMS EQUEL programs could go through a string 
**	descriptor handling layer.  For Unix we don't need the "IIx" versions
**	of the routines.  However, in this runtime layer, which EVERY call
**	goes through, we must recognize that the return variable is of
**	character type and pass DB_CHA_TYPE, and possibly cast the pointer
**	received by the interface layer as (char **), and then dereference
**	it once as IIfunc(..., DB_CHA_TYPE, *(char **)var_ptr, ...);
**	See note 5 above.
**
** History:
**	06-jun-86	- Written for 4.0 UNIX EQUEL/FORTRAN (bjb)
**	01-sep-86 (cmr)	- Modified for 5.0 UNIX EQUEL/FORTRAN
**	2/19/87	(daveb)	-- Hide fortran details in iiufsys.h by using
**			  FLENTYPE and FSTRLEN for string lengths.
**			  Add wrappers for apollo's different way of
**			  creating C names from the fortran compiler.
**	15-jun-87 (cmr) - use NO_UNDSCR (defined in iiufsys.h) for
**			  for compilers that do NOT append an underscore
**			  to external symbol names.
**	1-jun-99 (markd) - Added LEN_BEFORE_VAR case for compilers which
**			   pass the string length pointer before the pointer
**			   to the string.
**	10-oct-88(russ)  - Added the STRUCT_VAR case for compilers which
**			   pass strings as a structure.
**	24-feb-89(bjb)	 - Updated I/O calls with correct char type.
**	10-aug-89 (bjb)	 - Fixed bug #7515 - missing param name on iilprv(). 
**	11-aug-89 (bjb)	 - Another missing param name on iilprv().
**	20-dec-89 (barbara) 
**	    Updated for Phoenix/Alerters.
**      06-jul-90 (fredb) - Added cases for HP3000 MPE/XL which needs these
**                          routines.
**	11-sep-90 (teresal)- Modified I/O calls to accept new decimal
**                          data type DB_DEC_CHR_TYPE (53) which is a decimal
**                          number encoded as a character string. For
**                          completeness, all current I/O routines have been
**                          updated.
**	12-sep-90 (barbara)
**	    Incorporated part of Russ's mixed case changes here using
**	    the same code as NO_UNDSCR.  The other redefines for external
**	    symbols are in separate files.
**	14-sep-90 (barbara)
**	    Undid previous fix.  It won't work.
**	09-nov-1990 (barbara)
**	    Fixed bug #33181.  Added IIseterr to interface for EQUEL users.
**	    IIserr was already defined in this interface as to call IIseterr --
**	    but why?  IIserr is not a documented alternative to IIseterr
**	    in the Unix EQUEL/FORTRAN manual.  However, I've left that
**	    interface intact incase someone's using it.
**	26-feb-1991 (kathryn) Added:
**      	iilqss_()  -   IILQssSetSqlio
**      	iilqis_()  -   IILQisInqSqlio
**      	iilqsh_()  -   IILQshSetHandler
**	25-apr-1991 (teresal)
**	    Removed obsolete EVENT function IILQegEvGetio.
**	28-aug-1991 (kathryn)
**	    Change iilqss_ to dereference variable attr before calling
**	    IILQssSetSqlio.
**	14-nov-1991 (gautam)
**	    Add entry for iiseterr
**	22-jul-1992 (rudyw)
**	    Add conditional around iiseterr code for the purpose of
**          allowing code to be excluded from mixedcase companion file
**          iiuflbqM.c which pulls in this whole file with name remapping.
**	30-Jul-1992 (fredv)
**	    For m88_us5, we don't want to redefine these symbols because
**	    m88_us5 FORTRAN compiler is NO_UNDSCR and MIXEDCASE_FORTRAN.
**	    If we do that, symbols in iiuflbqM.o will be all screwed up.
**	    This is a quick and dirty change for this box for 6.4. The
**	    NO_UNSCR and MIXEDCASE_FORTRAN issue should be revisited in
**	    6.5. Me and Rudy both have some idea what should be the change
**	    to make this FORTRAN stuff a lot cleaner.
**	14-oct-1992 (lan)
**		Added IILQled_LoEndData.
**	25-nov-1992 (kathryn)
**	    Added IILQlpd_LoPutData and IILQlge_LoGetData for Large objects.
**	01-dec-1992 (kathryn)
**	    Removed redundant code from iilqlg.
**	08-dec-1992 (lan)
**	    Added IILQldh_LoDataHandler.
**	26-jul-1993 (lan)
**	    Added IIG4... for EXEC 4GL.
**	18-aug-1993 (lan)
**	    Removed iig4... (moved them to iiufg4.c).
**	19-aug-1993 (kathryn) Bug 53984
**	    Changed iilqld_ to not dereference datahandler argument.
**	    Datahandler argument of zero could be valid.
**	01-oct-1993 (kathryn) Bug 55775
**	    Do not dereference the null indicator variable in iilqld.
**	01-oct-1993  (kathryn)Bug 55775
**	    Change interface for iilqld which needs to know whether or not
**	    a null indicator variable has been specified.
**	06-feb-1996 (morayf)
**	    Removed obsolete Event function IILQegEvGetio #define (iilqeg_).
**	    This stuff is whacky enough without unused names left lying around.
**	2-Feb-1996 (consi01 xinteg by hand nanpr01) 
**	    Bug 78585 : When data is being retrieved with a null indicator the
**	    indicator value is not being returned to the calling program
**	    Added code to copy null indicator value from local copy to
**	    original variable in functions iicsge_ (IIcsGetio) and
**	    iigetd_ (IIgetdomio).
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**      09-oct-2007 (huazh01)
**          Call IILQprsProcStatus() with correct number of parameter.
**          This fixes bug 119273.
*/


# if defined(NO_UNDSCR) && !defined(m88_us5)
/* compiler does NOT append an underscore to calls from fortran */
# define	iibrea_		iibrea
# define	iicscl_		iicscl
# define	iicsde_		iicsde
# define	iicser_		iicser
# define	iicsge_		iicsge
# define	iicsop_		iicsop
# define	iicsqu_		iicsqu
# define	iicsrd_		iicsrd
# define	iicsre_		iicsre
# define	iicsrp_		iicsrp
# define	iicsrt_		iicsrt
# define	iieqiq_		iieqiq
# define	iieqst_		iieqst
# define	iierrt_		iierrt
# define	iiexde_		iiexde
# define	iiexex_		iiexex
# define	iiexit_		iiexit
# define	iiflus_		iiflus
# define	iigetd_		iigetd
# define	iiingo_		iiingo
# define	iilprs_		iilprs
# define	iilprv_		iilprv
# define	iilqpr_		iilqpr
# define	iinexe_		iinexe
# define	iinext_		iinext
# define	iinotr_		iinotr
# define	iiparr_		iiparr
# define	iipars_		iipars
# define	iiputc_		iiputc
# define	iiputd_		iiputd
# define	iireti_		iireti
# define	iisexe_		iisexe
# define	iiseterr_	iiseterr
# define	iisync_		iisync
# define	iitupg_		iitupg
# define	iiutsy_		iiutsy
# define	iivars_		iivars
# define	iiwrit_		iiwrit
# define	iixact_		iixact
# define	iiserr_		iiserr
# define	iilqes_		iilqes
# define	iisete_		iisete
# define	iilqss_		iilqss
# define	iilqis_		iilqis
# define	iilqsh_		iilqsh
# define	iilqle_		iilqle
# define	iilqlg_		iilqlg
# define	iilqlp_		iilqlp
# define	iilqld_		iilqld
# endif

/*
** IIbreak
**	- ## endretrieve
**	- Generated to break retrieve loop
*/
void
iibrea_()
{
    IIbreak();
}

/*
** IIerrtest
**	- Generated as test in retrieve loop
*/
i4
iierrt_()
{
    return IIerrtest();
}

/*
** IIexit
** 	- ## exit
*/
void
iiexit_()
{
    IIexit();
}


/*
** IIflush
**	- Clean up at completion of retrieve
*/
void
iiflus_( file_name, line_num )
char	**file_name;
i4	*line_num;
{
    if (*file_name)
	IIflush( *file_name, *line_num );
    else
	IIflush( (char *)0, 0 );
}

/* 
** IIingopen 
##	- ## ingres <dbname> flags
** 	- Sends a variable number of arguments, up to a maximum of 14
**	  character string args plus language argument.
**	- For F77 only we assume an extra first argument, which is a
**	  count representing the number of string args.  This is present
**	  on all calls which have a varying number of arguments.
**	  (See which calls go through gen_var_args in code generator.)
*/
void
iiingo_( count, lan, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, 
	    arg9, arg10, arg11, arg12, arg13, arg14 )
i4	*count, *lan;
char	**arg1, **arg2, **arg3, **arg4, **arg5, **arg6, **arg7, **arg8,
        **arg9, **arg10,**arg11,**arg12,**arg13,**arg14;
{
# define 	ING_ARGS_MAX	14
    char	*v_args[ING_ARGS_MAX];
    i4  	i;

    for (i = 0; i < ING_ARGS_MAX; i++)
  	v_args[i] = (char *)0;		/* initialize arg array */

  /*
  ** Enter this switch statement according to argument count.
  ** Fill v_args, starting at last arg and dropping through
  ** all subsequent ones until first arg
  */

    switch( *count - 1 ) {	
      case 14:  v_args[13] = *arg14;
      case 13:  v_args[12] = *arg13;	
      case 12:  v_args[11] = *arg12;	
      case 11:  v_args[10] = *arg11;	
      case 10:  v_args[ 9] = *arg10;	
      case  9:  v_args[ 8] = *arg9;	
      case  8:  v_args[ 7] = *arg8;	
      case  7:  v_args[ 6] = *arg7;	
      case  6:  v_args[ 5] = *arg6;	
      case  5:  v_args[ 4] = *arg5;	
      case  4:  v_args[ 3] = *arg4;	
      case  3:  v_args[ 2] = *arg3;	
      case  2:  v_args[ 1] = *arg2;	
      case  1:  v_args[ 0] = *arg1;	
    }

    IIingopen( hostC, v_args[0], v_args[1], v_args[2], v_args[3], v_args[4],
	v_args[5], v_args[6], v_args[7], v_args[8], v_args[9], v_args[10],
	v_args[11], v_args[12], v_args[13] );
}

/*
** IInextget
**	- Checks to see if there's another tuple in retrieve loop
*/
i4
iinext_()
{
    return IInextget();
}

/*
** IInexec
**	- Checks if repeat query successfully executed.
*/
i4
iinexe_()
{
    return IInexec();
}

/*
** IIeqiqio
**	- ## inquire_equel statement
**	- Called once for each object being inquired about
**	- We must blank pad user var if result var is a string
*/

void
iieqiq_( indflag, indptr, isvar, type, len, var_ptr, inq_name )
i4	*indflag;		/* 0 = no null pointer		*/
i2	*indptr;		/* null pointer			*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of user variable	*/
i4	*len;			/* sizeof data, or strlen	*/
i4	*var_ptr;
char	**inq_name;
{

    i2  ind;
    i2  *indptr1;

    ind = *indptr;
    indptr1 = &ind;

    if ( !*indflag )
	indptr1 = (i2 *)0;

    if (*type == DB_CHR_TYPE)
    {
	IIeqiqio( indptr1, 1, DB_CHA_TYPE, *len, *(char **)var_ptr, *inq_name );
    }
    else if (*type == DB_DEC_CHR_TYPE)
    {
	IIeqiqio( indptr1, 1, *type, *len, *(char **)var_ptr, *inq_name );
    }
    else
    {
	IIeqiqio( indptr1, 1, *type, *len, var_ptr, *inq_name );
    }

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}

/*
** IIeqstio
**	- ## set_equel command
*/
void
iieqst_( setname, indflag, indptr, isvar, type, len, var_ptr )
char	**setname;		/* Object to set		*/
i4	*indflag;		/* 0 = no null indicator	*/
i2	*indptr;		/* null indicator pointer	*/
i4	*isvar;			/* Always 1 for F77		*/
i4	*type;			/* Type of user variable	*/
i4	*len;			/* Sizeof data, or strlen	*/
i4	*var_ptr;		/* Variable containing value	*/
{
    i2  ind;
    i2  *indptr1;

    ind = *indptr;
    indptr1 = &ind;

    if ( !*indflag )
	indptr1 = (i2 *)0;

    if (*type == DB_CHR_TYPE)
    	IIeqstio( *setname, indptr1, 1, *len == 0 ? DB_CHR_TYPE : DB_CHA_TYPE,
		  *len, *(char **)var_ptr );
    else if (*type == DB_DEC_CHR_TYPE)
    	IIeqstio( *setname, indptr1, 1, *type, *len, *(char **)var_ptr );
    else
    	IIeqstio( *setname, indptr1, 1, *type, *len, var_ptr );

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}
    
/*
** IIparret
** 	- Called when the target list for RET-type statements is parameterized.
**	- IIxouttrans (a special F77 version) will be called from IIparret to
**	  put data into host vars pointed at by argv vector.
*/
iiparr_( format, argv )
char	**format;		/* User's target list		*/
char	*argv[];		/* Pointers to user's variables	*/
{
    i4	IIxouttrans();

    IIparret( *format, argv, IIxouttrans );
}

/*
** IIparset
**	- Called when the target list for SET-type statements is parameterized.
**	- IIxintrans (a special F77 version) will be called from IIparset to
**	  get data from host vars pointed at by argv vector.
*/
void
iipars_( format, argv )
char	**format;
char	*argv[];
{
    char	*IIxintrans();

    IIparset( *format, argv, IIxintrans );
}


/*
** IIgetdomio
**	- Transfers data from retrieve statement into host-vars
** 	- When the receiving variable is a string, we must blank pad
*/

void
iigetd_( indflag, indptr, isvar, type, len, var_ptr )
i4	*indflag;		/* 0 = no null indicator	*/
i2	*indptr;		/* null indicator pointer	*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of object		*/
i4	*len;			/* sizeof data, or strlen	*/
i4	*var_ptr;		/* pointer to the object	*/
{

    i2  ind;
    i2  *indptr1;

    ind = *indptr;
    indptr1 = &ind;

    if ( !*indflag )
	indptr1 = (i2 *)0;

    if (*type == DB_CHR_TYPE)
    {
	IIgetdomio( indptr1, 1, DB_CHA_TYPE, *len, *(char **)var_ptr );
    }
    else if (*type == DB_DEC_CHR_TYPE)
    {
	IIgetdomio( indptr1, 1, *type, *len, *(char **)var_ptr );
    }
    else
    {
	IIgetdomio( indptr1, 1, *type, *len, var_ptr );
    }

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}
		
/*
** IIretinit
** 	- Set up for retrieve loop
*/
void
iireti_( file_name, line_num )
char	**file_name;
i4	*line_num;
{
    IIretinit( *file_name, *line_num );
}

/*
** IIputdomio
**	- Transfers data to backend in database write statements
**	- Generated on ## append and ## replace
**	- Trims if len > 0.
*/
void
iiputd_( indflag, indptr, isvar, type, len, var_ptr )
i4	*indflag;		/* 0 = no null indicator	*/
i2	*indptr;		/* null indicator pointer	*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of object		*/
i4	*len;			/* sizeof data, or strlen	*/
char	*var_ptr;		/* pointer to the object	*/
{

    i2  ind;
    i2  *indptr1;

    ind = *indptr;
    indptr1 = &ind;

    if ( !*indflag )
	indptr1 = (i2 *)0;

    if (*type == DB_CHR_TYPE)
	IIputdomio( indptr1, 1, *len == 0 ? DB_CHR_TYPE : DB_CHA_TYPE,
		    *len, *(char **)var_ptr );
    else if (*type == DB_DEC_CHR_TYPE)
	IIputdomio( indptr1, 1, *type, *len, *(char **)var_ptr );
    else
	IIputdomio( indptr1, 1, *type, *len, var_ptr);

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}
/*
** IInotrimio
**	- Transfers data to backend in database write statements
**	- Generated on ## append and ## replace
**	- No trimming takes place
*/
void
iinotr_( indflag, indptr, isvar, type, len, var_ptr )
i4	*indflag;		/* 0 = no null indicator	*/
i2	*indptr;		/* null indicator pointer	*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of object		*/
i4	*len;			/* sizeof data, or strlen	*/
i4	*var_ptr;		/* pointer to the object	*/
{
    i2  ind;
    i2  *indptr1;

    ind = *indptr;
    indptr1 = &ind;

    if ( !*indflag )
	indptr1 = (i2 *)0;

    IIputdomio( indptr1, 1, DB_CHR_TYPE, *len, *(char **)var_ptr );

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}

/*
** IIsexec
**	- Resets status flag during repeat query loop
*/
void
iisexe_()
{
    IIsexec();
}

/*
** IIsyncup
**	- Generated after IIwrite calls to synch up with backend
*/
void
iisync_( file_name, line_num )
char	**file_name;
i4	*line_num;
{
    IIsyncup( *file_name, *line_num );
}

/*
** IItupget
**	- Generated in parameterized retrieves to get data into host_var.
*/
i4
iitupg_()
{
    return IItupget();
}

/*
** IIutsys
**	- ## call <ingres subsystem>  (parameters)
*/
i4
iiutsy_( flag, arg, argstr )
i4	*flag;
char	**arg;			/* Program/argument name */
char	**argstr;		/* Value of argument name */
{

    IIutsys( *flag, *arg, *argstr ); 
}


/*
** IIwritio
**	- Writes a string to the backend
**	- Generated for most statements
*/
void
iiwrit_( trim, indflag, indptr, isvar, type, len, string )
i4	*trim;			/* trim flag, 0 = no trim	*/
i4	*indflag;		/* 0 = no null pointer		*/
i2	*indptr;		/* null pointer			*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of data			*/
i4	*len;			/* sizeof data, or strlen	*/
char	**string;		/* actual string		*/
{
    i2  ind;
    i2  *indptr1;

    ind = *indptr;
    indptr1 = &ind;

    if ( !*indflag )
	indptr1 = (i2 *)0;

    IIwritio( *trim, indptr1, *isvar, *len == 0 ? DB_CHR_TYPE : DB_CHA_TYPE,
	      *len, *string );

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}

/*
** IIcsClose
**	- Close cursor
*/
void
iicscl_( cursor_name, cid1, cid2 )
char	**cursor_name;
i4	 *cid1;			/* cursor id 1			*/
i4	 *cid2;			/* cursor id 2			*/
{
    IIcsClose( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsDelete
**	- Delete cursor
*/
void
iicsde_( table_name, cursor_name, cid1, cid2 )
char	**table_name;
char	**cursor_name;
i4	 *cid1;			/* cursor id 1			*/
i4	 *cid2;			/* cursor id 2			*/
{
    IIcsDelete( *table_name, *cursor_name, *cid1, *cid2 );
}

/*
** IIcsERplace
**	- Cursor UPDATE/REPLACE end
*/
void
iicser_( cursor_name, cid1, cid2 )
char	**cursor_name;
i4	 *cid1;			/* cursor id 1			*/
i4	 *cid2;			/* cursor id 2			*/
{
    IIcsERplace( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsRplace (IIcsReplace in VMS)
**	- Cursor UPDATE/REPLACE begin
*/
void
iicsrp_( cursor_name, cid1, cid2 )
char	**cursor_name;
i4	 *cid1;			/* cursor id 1			*/
i4	 *cid2;			/* cursor id 2			*/
{
    IIcsReplace( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsOpen
**	- Cursor OPEN begin
*/
void
iicsop_( cursor_name, cid1, cid2 )
char	**cursor_name;
i4	 *cid1;			/* cursor id 1			*/
i4	 *cid2;			/* cursor id 2			*/
{
    IIcsOpen( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsQuery
**	- Cursor OPEN end
*/
void
iicsqu_( cursor_name, cid1, cid2 )
char	**cursor_name;
i4	 *cid1;			/* cursor id 1			*/
i4	 *cid2;			/* cursor id 2			*/
{
    IIcsQuery( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsRetrieve
**	- Cursor FETCH begin
*/
i4
iicsre_( cursor_name, cid1, cid2 )
char	**cursor_name;
i4	 *cid1;			/* cursor id 1			*/
i4	 *cid2;			/* cursor id 2			*/
{
    return IIcsRetrieve( *cursor_name, *cid1, *cid2 );
}

/*
** IIcsGetio
**	- Cursor FETCH data into user variable
*/
void
iicsge_( indflag, indptr, isvar, type, len, var_ptr )
i4	*indflag;		/* 0 = no null pointer		*/
i2	*indptr;		/* null pointer			*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of data			*/
i4	*len;			/* sizeof data, or strlen	*/
i4	*var_ptr;		/* pointer to user space	*/
{
    i2  ind;
    i2  *indptr1;

    indptr1 = &ind;
    ind = *indptr;
		   
    if ( !*indflag )
	indptr1 = (i2 *)0;

    if ( *type == DB_CHR_TYPE )
	IIcsGetio( indptr1, 1, DB_CHA_TYPE, *len, *(char **) var_ptr );
    else if ( *type == DB_DEC_CHR_TYPE )
	IIcsGetio( indptr1, 1, *type, *len, *(char **) var_ptr );
    else
	IIcsGetio( indptr1, 1, *type, *len, var_ptr );

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}

/*
** IIcsRtrievE (IIcsERetrieve in VMS)
**	- Cursor FETCH end
*/
i4
iicsrt_()
{
    IIcsERetrieve();
}

/*
** IIexDefine
**	- Repeat Query Definition
*/
void
iiexde_( type, name, qid1, qid2 )
i4	 *type;			/* type of repeat definition	*/
char	**name;			/* name of query		*/
i4	 *qid1;			/* query id 1			*/
i4	 *qid2;			/* query id 2			*/
{
    IIexDefine( *type, *name, *qid1, *qid2 );
}

/*
** IIexExec
**	- Repeat Query Execution
*/
i4
iiexex_( type, name, qid1, qid2 )
i4	 *type;			/* type of repeat definition	*/
char	**name;			/* name of query		*/
i4	 *qid1;			/* query id 1			*/
i4	 *qid2;			/* query id 2			*/
{
    return IIexExec( *type, *name, *qid1, *qid2 );
}

/*
** IIputctrl
**	- Place control character in the DBMS query string
*/
void
iiputc_( ctrl )
i4	*ctrl;
{
    IIputctrl ( *ctrl );
}


/*
** IIxact
**	- Begin Transaction, Commit Transaction, End Transaction
*/
void
iixact_( flag )
i4	*flag;
{
    IIxact ( *flag );
}


/*
** IIvarstrio
**	- Send variable to the BE as string
*/
void
iivars_( indflag, indptr, isvar, type, len, var_ptr )
i4	*indflag;		/* 0 = no null pointer		*/
i2	*indptr;		/* null pointer			*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of data			*/
i4	*len;			/* sizeof data, or strlen	*/
i4	*var_ptr;		/* pointer to user space	*/
{
    i2  ind;
    i2  *indptr1;

    indptr1 = &ind;
    ind = *indptr;
		   
    if ( !*indflag )
	indptr1 = (i2 *)0;

    if ( *type == DB_CHR_TYPE )
	IIvarstrio( indptr1, 1, *len == 0 ? DB_CHR_TYPE : DB_CHA_TYPE,
		    *len, *(char **) var_ptr );
    else if ( *type == DB_DEC_CHR_TYPE )
	IIvarstrio( indptr1, 1, *type, *len, *(char **) var_ptr );
    else
	IIvarstrio( indptr1, 1, *type, *len, var_ptr );

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}


/*
** IIcsRdO
**	- Open cursor for Repeat Query readonly operations
*/
void
iicsrd_( flag, str )
i4	*flag;
char	**str;
{
    IIcsRdO( *flag, ERx("for readonly") );
}

/*
** IILQpriProcInit
**	- Create/Execute/Drop Procedure
*/
void
iilqpr_( type, name )
i4	*type;
char	**name;
{
    IILQpriProcInit( *type, *name );
}


/*
** IILQprsProcStatus
**	- EXECUTE PROCEDURE control flow
*/
i4
iilprs_()
{
    return IILQprsProcStatus(0);
}


/*
** IILQprvProcValio
**	- EXECUTE PROCEDURE requiring i/o
*/
void
iilprv_( name, dummy, indflag, indptr, isvar, type, len, var_ptr )
char	**name;			/* Name of parameter 		*/
i4	*dummy;			/* param_byref flag - not supported yet */
i4	*indflag;		/* 0 = no null pointer		*/
i2	*indptr;		/* null pointer			*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of data			*/
i4	*len;			/* sizeof data, or strlen	*/
i4	*var_ptr;		/* pointer to user space	*/
{
    i2  ind;
    i2  *indptr1;

    indptr1 = &ind;
    ind = *indptr;
		   
    if ( !*indflag )
	indptr1 = (i2 *)0;

    if ( *type == DB_CHR_TYPE )
	IILQprvProcValio( *name, *dummy, indptr1, 1,
		*len == 0 ? DB_CHR_TYPE : DB_CHA_TYPE, *len,
		*(char **) var_ptr );
    else if ( *type == DB_DEC_CHR_TYPE )
	IILQprvProcValio( *name, *dummy, indptr1, 1, *type, *len,
		*(char **) var_ptr );
    else
	IILQprvProcValio( *name, *dummy, indptr1, 1, *type, *len, var_ptr );

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}

/*
** IIseterr
**	- user defined error function
**	- Usage: external myfunc
**		 integer myfunc
**	  	  IIserr( myfunc )
**	- Note:  As far as I (barbara) know, IIserr is not documented
**	  	anywhere as a synonym for IIseterr.  Not sure why this
**		interface has been introduced.
*/
void
iiserr_( func )
i4	*func;
{
    IIseterr( func );
}

/*
** IIseterr
**	- Pass error handler to INGRES run-time.
**	- Usage: (This version works for compilers that truncate)
**		external myfunc
**		integer myfunc
**		IIseterr( myfunc )
*/
i4
iisete_( err_hdl )
i4	(*err_hdl)();
{
    IIseterr(err_hdl);
}

# ifndef EXCLUDE_IISETERR
/*
** IIseterr
**	- Pass error handler to INGRES run-time.
**	- Usage: Same as above
**	  (This version works for compilers that don't truncate)
*/
i4
iiseterr_( err_hdl )
i4	(*err_hdl)();
{
    IIseterr(err_hdl);
}
# endif

/*
** IILQesEvStat
**	- GET EVENT initializing/finalizing routine
*/
void
iilqes_( flag, waitsecs )
i4	*flag, *waitsecs;
{
    IILQesEvStat( *flag, *waitsecs );
}

/*
** IILQssSetSqlio
**	- EXEC SQL SET_SQL(attribute = value)
**	
*/
void
iilqss_(attr, indflag, indptr, isvar, type, len, var_ptr )
i4	*attr;			/* inquire_sql attribute code  	*/
i4	*indflag;		/* 0 = no null indicator	*/
i2	*indptr;		/* null indicator pointer	*/
i4	*isvar;			/* Always 1 for F77		*/
i4	*type;			/* type of user variable	*/
i4	*len;			/* Sizeof data, or strlen	*/
i4	*var_ptr;		/* Variable containing value	*/
{
    i2  ind;
    i2  *indptr1;

    indptr1 = &ind;
    ind = *indptr;
		   
    if ( !*indflag )
	indptr1 = (i2 *)0;

    if (*type == DB_CHR_TYPE)
    	IILQssSetSqlio(*attr, indptr1, 1, *len == 0 ? DB_CHR_TYPE : DB_CHA_TYPE,
		  *len, *(char **)var_ptr );
    else if (*type == DB_DEC_CHR_TYPE)
    	IILQssSetSqlio(*attr, indptr1, 1, *type, *len, *(char **)var_ptr );
    else
    	IILQssSetSqlio(*attr, indptr1, 1, *type, *len, var_ptr );

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}

/*
** IILQisInqSqlio
**	- EXEC SQL INQUIRE_SQL(value = attribute)
**	- Called once for each object being inquired about
**	- We must blank pad user var if result var is a string
*/

void
iilqis_( indflag, indptr, isvar, type, len, var_ptr, attr )
i4	*indflag;		/* 0 = no null pointer		*/
i2	*indptr;		/* null pointer			*/
i4	*isvar;			/* by value or reference	*/
i4	*type;			/* type of user variable	*/
i4	*len;			/* sizeof data, or strlen	*/
i4	*var_ptr;
i4	*attr;			/* inquire_sql attribute code 	*/
{
    i2  ind;
    i2  *indptr1;

    indptr1 = &ind;
    ind = *indptr;
		   
    if ( !*indflag )
	indptr1 = (i2 *)0;

    if (*type == DB_CHR_TYPE)
    {
	IILQisInqSqlio( indptr1, 1, DB_CHA_TYPE, *len, 
			*(char **)var_ptr, *attr);
    }
    else if (*type == DB_DEC_CHR_TYPE)
    {
	IILQisInqSqlio( indptr1, 1, *type, *len, *(char **)var_ptr, *attr );
    }
    else
    {
	IILQisInqSqlio( indptr1, 1, *type, *len, var_ptr, *attr );
    }

    /* consi01 Bug 78585 */
    /* copy back indicator */
    if ( *indflag )
	*indptr=ind;
}
/*
** IILQshSetHandler
**      - EXEC SQL SET_SQL(myhandler = funcptr)
*/
void
iilqsh_(hdlr,funcptr)
i4	*hdlr;
i4	*funcptr;
{

	if (*funcptr == 0)
		IILQshSetHandler(*hdlr, (i4 (*)())0);
	else
		IILQshSetHandler(*hdlr, funcptr);
}

/*
** IILQled_LoEndData
**	EXEC SQL ENDDATA();
*/
VOID
iilqle_()
{
	IILQled_LoEndData();
}

/*
** IILQlgd_LoGetData
**      EXEC SQL GET DATA(:var = segment, :var = segmentlength, :var = dataend)
**		WITH maxlength = :var | val;
**
*/
VOID
iilqlg_(flag, type, len, data, maxlen, seglen, dataend)
i4	*flag; 
i4  	*type;
i4	*len;
i4	*data;
i4	*maxlen;
i4	*seglen;
i4  	*dataend;
{
    i4	ctype;
    PTR	datptr;

    if (!*flag)
	datptr = (PTR)0;
    else if (*type == DB_CHR_TYPE || *type == DB_DEC_CHR_TYPE)
	datptr = *(char **)data;
    else
	datptr = (PTR)data;

    ctype = *type == DB_CHR_TYPE ? DB_CHA_TYPE : *type;
    IILQlgd_LoGetData(*flag, ctype, *len, datptr, *maxlen, seglen, dataend);
}

/*
** IILQlgd_LoPutData
**   EXEC SQL PUT DATA(:var|val = segment, :var|val = segmentlength, 
**	:var|val  = dataend)
**
*/
VOID
iilqlp_(flag, type, len, data, seglen, dataend)
i4   	*flag; 
i4	*type;
i4	*len;  
i4  	*data;
i4  	*seglen;
i4  	*dataend;
{
	i4     ctype;
	PTR     datptr;

    if (!*flag)
	datptr = (PTR)0;
    else if (*type == DB_CHR_TYPE || *type == DB_DEC_CHR_TYPE)
	datptr = *(char **)data;
    else
	datptr = (PTR)data;

    ctype = (*type == DB_CHR_TYPE && *len != 0) ? DB_CHA_TYPE : *type;
    IILQlpd_LoPutData(*flag, ctype, *len, datptr, *seglen, *dataend);
}

/*
** IILQldh_LoDataHandler
**	DATAHANDLER(func_name([arg_name]));
*/
void
iilqld_(type, indflag, indvar, datahdlr, hdlr_arg)
i4	*type;
i4      *indflag;
i2	*indvar;
i4	(*datahdlr)();
PTR	hdlr_arg;
{
	if (!*indflag)
	    indvar = (i2 *)0;
            IILQldh_LoDataHandler(*type, indvar, datahdlr, hdlr_arg);
}

# endif /* UNIX */
