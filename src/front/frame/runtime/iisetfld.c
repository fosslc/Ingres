/*
**	iisetfld.c
**
**	Copyright (c) 2004 Ingres Corporation
**	All rights reserved.
*/

# include	<compat.h>
# include	<me.h>		 
# include	<st.h>		 
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
# include	<ft.h>
# include	<fmt.h>
# include	<adf.h>
# include	<frame.h>
# include	<menu.h>
# include	<runtime.h> 
# include	<frserrno.h>
# include	<rtvars.h>
# include	<afe.h>
# include       <er.h>

/**
** Name:	iisetfld.c
**
** Description:
**
**	Public (extern) routines defined:
**		IIsetfield()
**		IIputfldio()
**	Private (static) routines defined:
**
** History:
**	07/25/87 (dkh) - Fixed jup bug 515.
**	08/26/87 (dkh) - Changes for 8000 series error numbers.
**	09/01/87 (dkh) - Added explicit include of <frserrno.h>.
**	09/01/87 (dkh) - Added more change bit support.
**	11/11/87 (dkh) - Code cleanup.
**	11/14/87 (dkh) - Changed to pass correct args to FDsetoper().
**	19-jun-89 (bruceb)
**		Don't allow sets for derived fields.  Validate the
**		field if a derivation source field.
**	30-aug-90 (bruceb)	Fix for bug 32798.
**		Added IIFRndNullDBV() to set dbv value to be NULL if
**		it's the functional equivalent.  Also added ADF_TRIMBLANKS_MACRO
**		and ADF_SETNULL_MACRO for use by IIFRndNullDbv.
**	04-sep-90 (bruceb)
**		Moved ADF_TRIMBLANKS_MACRO to afe.h (renamed AFE_).  Use
**		adc_getempty() instead of ADF_SETNULL_MACRO.
**	02/22/91 (dkh) - Fixed bug 35879 (by rolling back change for bug
**			 32798; bug 32798 will be fixed in a different manner).
**	19-feb-92 (leighb) DeskTop Porting Change:
**		adh_evcvtdb() has only 3 args, bogus 4th one deleted.
**	13-apr-92 (seg)
**		Unnecessary and illegal extern for MEcopy deleted.  If needed,
**		it must be had by including <me.h>.
**	21-mar-94 (smc) Bug #60829
**		Added #include header(s) required to define types passed
**		in prototyped external function calls.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	18-Aug-2009 (kschendel) 121804
**	    Update some of the function declarations to fix gcc 4.3 problems.
**/

FUNC_EXTERN	STATUS	FDsetoper();
FUNC_EXTERN	STATUS	adh_evcvtdb();
FUNC_EXTERN	FIELD	*FDfndfld();
FUNC_EXTERN	i4	(*IIseterr())();
FUNC_EXTERN	i4	IIFDdecDerErrCatcher();


/*{
** Name:	IIsetfield	-	Put value into a field
**
** Description:
**	This routine is the general interface to put a value into
**	a field.  It confirms that the field name exists, builds an
**	embedded-data-value from the caller's parameters, and calls
**	set_field to actually set the field value.  Note that either
**	a query operator or a data value may be set by this routine.
**
**	IIsetfield is part of RUNTIME's external interface as a 
**	compatability cover for pre-6.0 EQUEL programs.
**	
** Inputs:
**	s1		Name of the field to update
**	isvar		Flag indicating whether variable
**	type		Embedded data type
**	len		Embedded data length
**	data		Ptr to the actual embedded data value
**
** Outputs:
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Example and Code Generation:
**	## putform f1 (f2 = i4var)
**
**	if (IIfsetio("f1") != 0) {
**	    IIsetfield("f2", ISVAL, DB_INT_TYPE, 4, i4var);
**	}
**
** Side Effects:
**
** History:
**	16-feb-1983  -  Extracted from original runtime.c (jen)
**	24-sep-1984  -  Added the putoper() option. (ncg)
**	5/17/85	     -  Added support for forced lower/upper
**			case attribute.  Placed here for
**			efficiency reasons. (dkh)
**	7/2/86	     -	Removed call on FDcaseconv() as the
**			semantics of force upper/lower have
**			changed. Fix for bug 9390 (bab)
**	01/09/87 (dkh) - ADT stubbing changes.
**	24-feb-1987	Changed to a pre 6.0 compatability cover routine (drh)
*/

i4
IIsetfield(char *s1, i4 isvar, i4 type, i4 len, PTR data)
{

	return ( IIputfldio( s1, (i2 *) NULL, isvar, type, len,data ));
}

/*{
** Name:	IIputfldio	-	Put value into a field
**
** Description:
**	This routine is the general interface to put a value into
**	a field.  It confirms that the field name exists, builds an
**	embedded-data-value from the caller's parameters, and calls
**	set_field to actually set the field value.  Note that either
**	a query operator or a data value may be set by this routine.
**
**	If a query operator value is being put, a db_data_value for
**	the operator is constructed locally, otherwise, FDgetdbv
**	is called to get a pointer to the field's db_data_value.
**	Adh_cvcvtdb is called to convert the callers value in the
**	embedded-data-value into the internal data value for the
**	field.
**
**	A call to this routine will be generated by release 6.0 and
**	later EQUEL programs.  It is part of RUNTIME's external
**	interface.
**	
** Inputs:
**	s1		Name of the field to update
**	ind		Ptr to the NULL indicator
**	isvar		Flag indicating whether variable
**	type		Embedded data type
**	len		Embedded data length
**	data		Ptr to the actual embedded data value
**
** Outputs:
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Example and Code Generation:
**	## putform f1 (f2 = i4var)
**
**	if (IIfsetio("f1") != 0) {
**	    IIputfldio("f2", 0, ISVAL, DB_INT_TYPE, 4, i4var);
**	}
**
** Side Effects:
**
** History:
**	24-feb-1987	Created by extracting code from IIsetfld, and
**			making modifications for ADTs and NULLs (drh)
*/

i4
IIputfldio(char *s1, i2 *ind, i4 isvar, i4 type, i4 len, PTR data)
{
    char		*fnm;
    char		fbuf[MAXFRSNAME+1];
    DB_EMBEDDED_DATA	edv;
    i4			retstat;
    DB_DATA_VALUE	*fld_dbv;
    DB_DATA_VALUE	dbv;
    ADF_CB		*cb;	
    bool		putoper = FALSE;
    i4			oper;
    FIELD		*fld;
    FRAME		*frm = IIfrmio->fdrunfrm;
    bool		disponly;
    FLDHDR		*hdr;
    bool		dummy;
    i4			(*oldproc)();



    /*
    **	Check all variables make sure they are valid.
    **	Also check to see that the forms system has been
    **	initialized and that there is a current frame.
    */

    fnm = IIstrconv(II_CONV, s1, fbuf, (i4)MAXFRSNAME);
    if (fnm == NULL)
    {
	IIFDerror(RTRFFL, 2, IIfrmio->fdfrmnm, fnm);
	return (FALSE);
    }

    if ((fld = FDfndfld(frm, fnm, &disponly)) == NULL)
    {
	IIFDerror(PFFLNF, 1, fnm);
	return (FALSE);
    }
    hdr = &(fld->fld_var.flregfld->flhdr);
    if (hdr->fhd2flags & fdDERIVED)
    {
	IIFDerror(E_FI2267_8807_SetDerived, 1, fnm);
	return (FALSE);
    }
    
    /*
    **  Build an embedded data value out of the input parms
    */

    edv.ed_type = type;
    edv.ed_length = len;
    edv.ed_data = (isvar || type == DB_CHR_TYPE) ? data : (PTR) &data;
    edv.ed_null = ind;

    /*
    **  Update the field's value
    */

    cb = FEadfcb();

    if (putoper = IIputoper((i4)0))
    {
	if ( IIfrmio->fdrunmd != fdrtQRY )
	{
	    return (FALSE);
	}
	else
	{
	    dbv.db_datatype = DB_INT_TYPE;
	    dbv.db_length = sizeof(i4);
	    dbv.db_prec = 0;
	    dbv.db_data = (PTR) &oper;
	}
	fld_dbv = &dbv;
    }
    else
    {
	/*
	**  Get a pointer to the field's DBV
	*/
	 
	if ( FDdbvget(frm, fnm, (char *) NULL, NULL, &fld_dbv) != OK )
	{
	    return( FALSE );
	}
    }

    /*
    **  Convert the user's data value to the internal value for the field.
    */

    if ( adh_evcvtdb( cb, &edv, fld_dbv ) != OK )	 
    {
	if (cb->adf_errcb.ad_errcode == E_AD1012_NULL_TO_NONNULL)
	{
	    IIFDerror(RTSNLNNL, 2, IIfrmio->fdfrmnm, fnm);
	}
	else
	{
	    IIFDerror(RTPFERR, 2, IIfrmio->fdfrmnm, fnm);
	}
	return( FALSE );
    }

    /*
    **  Update the form with the new data value or operator
    */

    if ( putoper )
    {
	retstat = FDsetoper(frm, fnm, NULL, 0, oper);
    }
    else
    {
	/*
	**  Clear out change bit for simple field.
	*/
	IIFDfccb(frm, fnm);

	retstat = FDdispupd(frm, fnm, (char *) NULL, NULL);
	/*
	** If this is a derivation source field, and the form is not
	** in query mode, validate the field and evaluate the 'set'
	** derivation tree.
	*/
	if ((hdr->fhdrv) && (IIfrmio->fdrunmd != fdrtQRY))
	{
	    oldproc = IIseterr(IIFDdecDerErrCatcher);

	    _VOID_ FDvalidate(frm, hdr->fhseq, FT_REGFLD, (i4)0, (i4)0,
		&dummy);

	    _VOID_ IIseterr(oldproc);
	}
    }

    return(retstat);
}
