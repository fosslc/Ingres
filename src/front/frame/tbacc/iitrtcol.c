/*
**	iitretcol.c
**
**	Copyright (c) 2004 Ingres Corporation
**	All rights reserved.
*/

# include	<compat.h>
# include	<me.h>		/* 6-x_PC_80x86 */
# include	<st.h>		/* 6-x_PC_80x86 */
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
# include	<ft.h>
# include	<fmt.h>
# include	<adf.h>
# include	<frame.h>
# include	<menu.h>
# include	<runtime.h>
# include	<frserrno.h>
# include	<er.h>
# include	<rtvars.h>

/**
** Name:	iitretcol.c	-	Get column value
**
** Description:
**
**	Public (extern) routines defined:
**		IItcolret()	Pre 6.0 routine - get col value
**		IItcogetio()	6.0 and later - get col value
**	Private (static) routines defined:
**		tb_ret()
**		ds_ret()
**		ret_col()
**
** History:
**	19-jun-87 (bruceb)	Code cleanup.
**	06/24/87 (dkh) - Fixed the way FDcolop() is called.
**	07/25/87 (dkh) - Fixed jup bug 515.
**	08/14/87 (dkh) - ER changes.
**	08/26/87 (dkh) - Changes for 8000 series error numbers.
**	09/01/87 (dkh) - Added explicit include of <frserrno.h>.
**	17-apr-89 (bruceb)
**		Return row even if row state is stUNDEF.  Needed for
**		rows added by application with _STATE set.
**	16-aug-89 (bruceb)
**		Allow evaluation of aggregates when 'getting' values.
**	07-feb-90 (bruceb)
**		Added call on IIseterr to supress getmessages when the
**		global control block so indicates.
**	13-feb-90 (bruceb)
**		Changed default value for getmsg-supression for LRC/FRC.
**	13-apr-92 (seg)
**	    Can't dereference or do arithmetic on a PTR variable.  Must cast.
**	12/13/92 (dkh) - Fixed trigraph warnings from acc.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	18-Aug-2009 (kschendel) 121804
**	    Update some of the function declarations to fix gcc 4.3 problems.
**/

# define	STATE	1
# define	RECORD	2

static i4  tb_ret();				/* retrieve from frame table */
static i4  ds_ret();				/* retrieve from data set    */
static i4  ret_col();				/* ret from data set record  */
static i4  ret_dsinfo();			/* ret data set runtime info */
static i4  nd_dsinfo();				/* check data set info req */

GLOBALREF	TBSTRUCT	*IIcurtbl;

FUNC_EXTERN	COLDESC *IIcdget();
FUNC_EXTERN	STATUS	FDctylen();
FUNC_EXTERN	STATUS	adh_dbcvtev();
FUNC_EXTERN	i4	(*IIseterr())();
FUNC_EXTERN	i4	IIFRgmoGetmsgsOff();

/*{
** Name:	IItcolret	-	Return the value for a column
**
** Description:
**	Return the value of a column into a user variable.  This may
**	be a request for the data displayed in the tablefield, or for
**	data from the tablefield dataset.
**
**	This routine is part of TBACC's external interface, as a compatability
**	cover for pre 6.0 EQUEL programs.
**	
** Inputs:
**	isvariable;		Variable argument
**	vartype;		Type
**	varlen;			Length
**	vardata;		Actual variable ptr
**	columnname;		Name of column
**
** Outputs:
**	 Vardata will be updated with the data value for the column
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Example and Code Generation:
**	## getrow form1 tbl3 (buf = col1)
**
**	if (IItbsetio(3, "form1","tbl3",-2) != 0 )
**	{
**		IItcolret( 1,32,0,buf,"col1");
**	}
**
** Side Effects:
**
** History:
**	04-mar-1983	- Written (ncg)
**	30-apr-1984	- Improved interface to FD routines (ncg)
**	12-jan-1983	- Added Query operator request (ncg)
**	30-apr-1986	- Added FDerror for TBCONVERR (bruceb)
**	01/10/87 (dkh) - ADT stubbing changes.
**	10-feb-1987 	- Changes for ADTs and NULL (drh)
**	20-feb-1987	- Changed to be a cover to IItcogetio (drh)
**
*/

i4
IItcolret(i4 variable, i4 type, i4 len, PTR data, char *colname)
{
	return ( IItcogetio( (i2 *) 0, variable, type, len, data, colname ) );
}

/*{
** Name:	IItcogetio	-	Return the value for a column
**
** Description:
**	Return the value of a column into a user variable.  This may
**	be a request for the data displayed in the tablefield, or for
**	data from the tablefield dataset.
**
**	A call to this routine will be generated by 6.0 and later
**	versions of EQUEL.  The pre-6.0 version is IItretcol.
**
**	Basic method is locate the DBV for the row/column desired. 
**	Build an EDV from the callers parameters, and call adh_dbcvtev
**	to convert the internal data value into an embedded value.
**
**	Check that the data transfer operation can be executed.	 If the
**	data is requested from the DISPLAY then call the frame driver
**	FDgetcol().  Otherwise, if the call orients from an UNLOADing
**	of a data set, transfer the data directly after type and length
**	matching.  There are quite a few differences based on the state
**	of the table and whether or not the requested column is hidden
**	from display or not.  These differences are resolved case by
**	case.
** 
**	There are two possible table states in this routine:
**
**	tbDISPLAY  -  The source call was a SCROLL or DELETEROW
**		      with an OUT list, or a simple GETROW.
**	tbUNLOAD   -  The source call was a UNLOADTABLE.
**
**	Each state is handled differently, based on whether a data set
**	is linked to the table field or not.
**
**	This routine is part of TBACC's external interface.
**	
** Inputs:
**	ind			Ptr to a null indicator
**	variable;		Variable argument
**	type;			Type
**	len;			Length
**	data;			Actual variable ptr
**	columnname;		Name of column
**
** Outputs:
**	 Data and ind will be updated with the data value for the column
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Example and Code Generation:
**	## getrow form1 tbl3 (buf:ind = col1)
**
**	if (IItbsetio(3, "form1","tbl3",-2) != 0 )
**	{
**		IItcogetio(&ind,1,32,0,buf,"col1");
**	}
**
** Side Effects:
**
** History:
**	20-feb-1987	- Created from code extracted from IItcolret, and
**			  modified for ADTs and NULLs (drh)
**	02-apr-1987	- Added call to IIftrim to trim trailing blanks 
**			  from character-type fields (drh).
**
*/

/* VARARGS4 */
i4
IItcogetio(i2 *ind, i4 variable, i4 type, i4 len, void * data, char *colname)
{
	char			*colptr;	/* pointer to column buffer */
	char			c_buf[MAXFRSNAME+1];
	DB_EMBEDDED_DATA	edv;
	DB_DATA_VALUE		dbv;
	DB_DATA_VALUE		*dbvptr;
	DB_DATA_VALUE		dbvcop;
	ADF_CB			*cb;
	i4			dsitype;
	i4			dsop;
	i4			retval = TRUE;
	bool			assign = TRUE;
	i4			(*oldproc)();
	bool			disp_msgs = TRUE;


	if ((colptr =IIstrconv(II_CONV, colname, c_buf, 
		(i4)MAXFRSNAME)) == NULL)
	{

		/* no column name given for table I/O statement */
		IIFDerror(TBNOCOL, 1, (char *) IIcurtbl->tb_name);
		return (FALSE);
	}

	/*
	**  Build an EDV from the caller's parameters
	*/

	edv.ed_type = type;
	edv.ed_length = len;
	edv.ed_data = data;
	edv.ed_null = ind;

	cb = FEadfcb();

	if (IIfrscb->frs_globs->enabled & GETMSGS_OFF)
	{
	    disp_msgs = FALSE;
	    oldproc = IIseterr(IIFRgmoGetmsgsOff);
	}

	/*
	**  Fill in DBV as if pointing to a nat.  This will be used
	**  for a data set info request, or a 'getoper' type request.
	**  Otherwise, the DBV will be udpated to point to the column's
	**  'real' data.
	*/

	dbv.db_datatype = DB_INT_TYPE;
	dbv.db_length = sizeof(i4);
	dbv.db_prec = 0;
	dbv.db_data = (PTR) &dsop;
	dbvptr = &dbv;

	/*
	**  Get the data value to be returned
	*/

	if ( ( dsitype = ( nd_dsinfo( colptr ) ) ) != 0 )
	{
		/*
		**  This is a request for data set information
		**  ( _STATE, _RECORD )
		*/

		retval = ( ret_dsinfo( colptr, dsitype, dbvptr ) );
		if ( retval == FALSE )
		{
			/* don't assign, but don't return FALSE either */

			assign = FALSE;
			retval = TRUE;
		}
	}
	else if (IIcurtbl->dataset == NULL)
	{
		/* 
		**  If no data set is linked to the table field, use the
		**  data directly from the form
		*/

		retval = (tb_ret(colptr , &dbvptr ));
	}
	else
	{
		IIfrscb->frs_event->eval_aggs = TRUE;

		/*
		**  Tablefield is linked to a dataset. Use the dataset.
		*/

		retval = (ds_ret(colptr, &dbvptr ));

		IIfrscb->frs_event->eval_aggs = FALSE;
	}

	/*
	**  Convert the data value to the embedded value requested by
	**  the caller, handling the NULL indicator appropriately.
	*/

	if ( assign && retval )
	{
		/*  Trim trailing blanks if necessary */

		if ( (IIftrim( dbvptr, &dbvcop )) == OK )
		{
			if ( adh_dbcvtev( cb, &dbvcop, &edv ) != OK )
			{
				if (cb->adf_errcb.ad_errcode ==
					E_AD1012_NULL_TO_NONNULL)
				{
					IIFDerror(TBRNLNNL, 2,
						IIcurtbl->tb_name, colptr);
				}
				else
				{
					IIFDerror(TBDTRET, 2,
						(char *) IIcurtbl->tb_name,
						(char *) colptr);
				}
				retval = FALSE;
			}
		}
		else
		{
			retval = FALSE;
		}
	}

	if (!disp_msgs)
	    _VOID_ IIseterr(oldproc);

	return( retval );
}

/*{
** Name:	tb_ret	-	Return value from frame
**
** Description:
**	Get DBV for the column from the form and return it to the caller.
**	This is used on display mode tablefields, and on 'bare' ones.
**
**	Called by IItcolret, this routine is INTERNAL to tbacc.
**
** Inputs:
**	colptr		Name of the column to get value for
**	adbvptr		Ptr to a dbvptr to update with the address of
**			  the column's dbv from the frame
**
** Outputs:
**	adbvptr will be updated to point to the dbv for the column from
**	the frame.
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Side Effects:
**
** History:
**	xx-feb-1987	(drh)	Modified for ADTs and NULLs
**	13-apr-92 (seg)
**	    Can't dereference or do arithmetic on a PTR variable.  Must cast.
**	
*/

static i4
tb_ret(colptr, adbvptr )
char		*colptr;
DB_DATA_VALUE	**adbvptr;
{
	register TBSTRUCT	*tb;		/* current table field */
	i4			retstat;

	tb = IIcurtbl;

	if (IIgetoper((i4)0))
	{
		*((char *)(*adbvptr)->db_data) = fdNOP;	/* initialize */
		  
		if (tb->tb_mode != fdtfQUERY)
		{
			IIFDerror(TBQRYMD, 1, (char *) tb->tb_name);
		}
		else	/* normal display request for operator */
		{
			FDcolop(tb->tb_fld, tb->tb_rnum -1, colptr,
				(i4 *) ((*adbvptr)->db_data));
		}
		return( TRUE );
	}


	retstat = FDgetcol((i4) TRUE, tb->tb_fld, tb->tb_rnum - 1,
		colptr, adbvptr );
	
	return(retstat);
}

/*{
** Name:	ds_ret	-	Get column value from data set
**
** Description:
**	Get the data value for a column.  If the tablefield is
**	in read mode and column is not a hidden column, call tb_ret to 
**	get the data, otherwise call ret_col.
**
** Inputs:
**	colptr		Name of the column to get
**	adbvptr		Address of a DBV pointer to update
**
** Outputs:
**	adbvptr will be updated to point to the appropriate db_data_value
**	for the column.
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Side Effects:
**
** History:
**	
*/

static i4
ds_ret(colptr, adbvptr )
char		*colptr;
DB_DATA_VALUE	**adbvptr;
{
	register TBSTRUCT	*tb;		/* current table field */
	register COLDESC	*cd;		/* column descriptor */


	tb = IIcurtbl;

	/*
	** User column request, get column descriptor
	*/
	if ((cd = IIcdget(tb, colptr)) == NULL)
	{
		/* column name is not found in table */
		IIFDerror(TBBADCOL, 2, (char *) tb->tb_name, colptr);
		return (FALSE);
	}
	/*
	** If the column is a hidden column then the data info is only
	** accessible form the data record.
	*/
	if (cd->c_hide)
	{
		return (ret_col(cd, (*adbvptr)));
	}

	/*
	** If this is a regular DISPLAY call then copy the data from
	** the column in the frame's table field .
	*/
	if (tb->tb_state == tbDISPLAY)
	{
		return (tb_ret(colptr, adbvptr ));
	}

	/* Execute data transfer if record is defined. */
	return (ret_col(cd, (*adbvptr) ) );
}

/*{
** Name:	ret_col	-	Get column data from dataset
**
** Description:
**	Get the column's value from the dataset.
**
**	The column descriptor contains a dbv for the column, without
**	an actual data pointer.  This data pointer will be calculated
**	using the column structure's offset member, which is an
**	offset for the column value into each row's chunk of data.
**
** Inputs:
**	cd		Column descriptor to return value for
**	dbvptr		Pointer to a dbv that will be updated to point to
**				the appropriate data for the column.  
**
** Outputs:
**	dbvptr		The DBV this points to will point to the data for
**			the column - either it's real data value or oper.
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Side Effects:
**
** History:
**	xx-feb-1987	(drh)	Modified for ADTs and NULLs
**	
*/

static i4
ret_col(cd, dbvptr)
register COLDESC	*cd;
DB_DATA_VALUE		*dbvptr;
{

	register TBSTRUCT	*tb;
	register DATSET		*ds;
	PTR			datarec;

	tb = IIcurtbl;
	ds = tb->dataset;
	datarec = ds->crow->rp_data;

	if (IIgetoper((i4)0))
	{
		/*
		**  The caller has set up a DB_INT_TYPE dbv for the
		**  default case, that we can use directly for getoper
		**  requests.  By default, the oper is a no-op.  If the
		**  getoper request is legal, change dbv's data to point to
		**  the real oper for the row and column.
		*/

		*( (i4 *) dbvptr->db_data) = (i4) fdNOP;

		if (tb->tb_mode != fdtfQUERY)
		{
			IIFDerror(TBQRYMD, 1, (char *) tb->tb_name);
		}
		else if (cd->c_hide)
		{
			/* cannot query on hidden column */

			IIFDerror(TBQRYHIDE, 2, (char *) tb->tb_name,
				cd->c_name);
		}
		else	/* query request during unload loop */
		{
			dbvptr->db_data = (PTR) ( (char *) datarec +
							cd->c_qryoffset );
		}
	}
	else
	{
		/*
		**  Copy the dbv for the column into the one provided by
		**  the caller, and use the column offset to point to the
		**  correct data value.
		*/

		MEcopy( (PTR) &cd->c_dbv, (u_i2) sizeof( DB_DATA_VALUE),
			(PTR) dbvptr );
		dbvptr->db_data = (PTR) ( (char * ) datarec + cd->c_offset);
	}

	return (TRUE);
}

/*{
** Name:	ret_dsinfo	-	Return dataset info
**
** Description:
**	This routine returns data set information (i.e. _STATE or
**	_RECORD) to the user.  It fills in the db_data_value provided
**	by the caller with  the appropriate value from the dataset.
**	
**	If the _RECORD value is negative then the unloading is in
**	the delete list.  This does not effect anything but it may
**	later. (see IItunld() ).
**
** Inputs:
**	infostr		Char string _STATE or _RECORD
**	request		Code for request type
**	dbvptr		Ptr to dbv to udpate with value
**
** Outputs:
**	The data area pointed to by the DBV will be updated with
**	a i4  that reflects the dataset information requested.
**
** Returns:
**	i4	TRUE
**		FALSE
**
** Exceptions:
**	none
**
** Side Effects:
**
** History:
**	
*/

static i4
ret_dsinfo( infostr, request, dbvptr)
char		*infostr;
i4		request;	/* type of data set info to return */
DB_DATA_VALUE	*dbvptr;	/* dbv to update */
{	
	TBSTRUCT		*tb;
	register DATSET		*ds;
	register TBROW		*rp;
	register i4		rec;
	i4			*data;

	tb = IIcurtbl;
	ds = tb->dataset;

	data = (i4 *) dbvptr->db_data;
	*data = (i4) 0;		/* initialize */

	if (ds == NULL)
	{

		IIFDerror(TBDSINFO, 2, (char *) tb->tb_name, infostr);
		return ( FALSE );
	}

	switch (request)
	{
	  case STATE:
		/* missassigned current row */
		if ((rp = ds->crow) == NULL)
		{
			*data = (i4) stUNDEF;
		}
		/* during unloading loop */
		else if (tb->tb_state == tbUNLOAD)
		{
			if (rp->rp_state == stNEWEMPT)
				*data = (i4) stUNDEF;
			else
				*data = (i4) rp->rp_state;
		}
		/* normal display request for state */
		else
		{
			/* retrieve the row to update the state */
			if (FDckrow(tb->tb_fld, tb->tb_rnum -1))
			{
				IIretrow(tb, tb->tb_rnum - 1, rp);
				if (rp->rp_state == stNEWEMPT)
					*data = (i4) stUNDEF;
				else
					*data = rp->rp_state;
			}
			else
			{
				*data = (i4) stUNDEF;
			}
		}
		break;

	  case RECORD:
		/* during unloading loop */
		if (tb->tb_state == tbUNLOAD)
		{
			*data = IIrec_num();
		}
		/* empty data set */
		else if (ds->top == NULL || ds->crow == NULL)
		{
			*data = 0;
		}
		/* get number of current record */
		else
		{
			for (rec = 1, rp = ds->top; rp != NULL && rp != ds->crow; rec++, rp = rp->nxtr)
				;
			*data = rec;
		}
		break;
	}
	return (TRUE);
}

/*{
** Name:	nd_dsinfo	- Check for data set info request
**
** Description:
**	Compare the column name to '_state' and '_record' to determine
**	if this is a request for data set info.  Return a code indicating
**	the type of data set information requested.
**
** Inputs:
**	cname		Column name 
**
** Outputs:
**
** Returns:
**	i4	0 if not a data set info request, or values for STATE
**		or RECORD.
**
** Exceptions:
**	none
**
** Side Effects:
**
** History:
**	11-feb-1986 (drh)	Created.
*/
static i4
nd_dsinfo( cname )
char	*cname;
{
	i4	retval = 0;

	if (STcompare( cname, ERx("_state")) == 0)
		retval = STATE;
	else if (STcompare( cname, ERx("_record")) == 0)
		retval = RECORD;

	return ( retval );
}
