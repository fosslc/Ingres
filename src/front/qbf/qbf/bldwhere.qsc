/*
**	BLDWHERE.QSC  -	This module builds the where clause
**			for the current qdef based on the
**			fields the user has filled in on
**			the form before running the query.
**
**	Routines:
**	     mqbldwhere()
**
**	Written: 1/26/84 (nml)
**		07-dec-87 (kenl)
**			Turned module into a .QSC file in order to incorporate
**			the new header file: mqbf.qsh
**		10-aug-88 (kenl)
**			Added routine IIQFbwv_buildVALGEN().  This routine is
**			passed as a parameter to QG who then calls it.  This
**			routine handles the processing of potentially NULL
**			DBDVs that are used for joining the detail to the 
**			master in a JoinDef.
**		04-nov-88 (kenl)
**			Removed "internal coding error" messages for two
**			reasons: 1. Lower level routines report errors. 
**			2. The error may very likely be bad user input for
**			a query and have nothing to do with anything internal.
**		03-oct-90 (emerson)
**			Don't display logical keys (bug 8593).
**
**	Copyright (c) 2004 Ingres Corporation
*/

# include	<compat.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
## include	<ui.qsh>
## include	"mqbf.qsh"
# include	"mqeglobs.h"
# include	"mqqg.h"
# include	<multi.h>
# include	<st.h>
# include	<er.h>
# include	"erqf.h"

FUNC_EXTERN bool IIrnxtrow();

GLOBALREF	i4	MQdblang;

/* Some definitions were static in 3.0, auto in 5.0.
** static again in 5.0/03, and auto agai in 6.0.  They blow the stack on
** some machines (eg BT and Tower).  Since they are in frequent use
** it imay be better that they be static rather than allocated
** dynamically.
*/

/*{
** Name:	mqbldwhere	- Build the where clause for a query.
**
** Description:
**	This routine builds the where clause for a query using the
**	query entered in the form.
**
**	This routine is called by the qg module when it needs the where
**	clause for a query.  It is passed a MQQG_GEN which points
**	at the qdef for the query.
**
**	At this point, the where clause that was given to QG has
**	the preset joins followed by an "and", if no joins are present
**	then the where clause is empty.	 This means, that the first
**	clause generated by this routine does not need a preceding
**	"and".
**
** Inputs:
**	gen		{PTR} This is really a pointer to a MQQG_GEN
**			structure that contains the qdef to build the
**			query from.
**
**	qgfunc		{STATUS (*)()} This is the function to pass each
**			QRY_SPEC to.
**
**	qgvalue		{PTR} This is the value to pass to the function
**			along with the QRY_SPEC.
** Outputs:
**	Returns:
**		OK if everything is fine.
**		QG_NOSPEC if no QRY_SPEC was generated.
**		any other values is an error.
**
** History:
**	13-may-1987 (Joe)
**		Modified to use the qgfunc and qgvalue.
**	10-jul-1987 (danielt)
**		Changed type of gen and qgvalue from (PTR *) to PTR
**	11-aug-1987 (danielt)
**		Misc message extraction changes, including conversion
**		from ERmsg() to IIUGerr().
**	02/04/88 (dkh) - Changed to pass FEDMLQUEL instead of DB_QUEL
**			 to IIrngget(), IIqryfield() and IItqrycol().
**	18-jul-88 (kenl)
**		Bug fix #2767.  Fixed bug where too many rows were being
**		retrieved for detail when detail qualification was provided.
**	10-aug-88 (kenl)
**		Changed FEDML references to MQdblang which is set up in
**		mqbfmain.qsc to be either UI_DML_SQL or UI_DML_GTWSQL.
**	1-dec-1993 (rdrane)
**		Ensure that column names and correlation names are
**		unnormalized as required when generating the WHERE clause.
**		This addresses bug 57465.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	24-Aug-2009 (kschendel) 121804
**	    Need ui.h to satisfy gcc 4.3.
*/
STATUS
mqbldwhere(gen, qgfunc, qgvalue)
PTR	gen;
STATUS	(*qgfunc)();
PTR	qgvalue;
{
	MQQG_GEN	*mqgen = (MQQG_GEN *) gen;
	STATUS		mqjoinwhere();
	VOID		MQtunend();
	bool		MQrgetinit();
	STATUS		MQfldqry();
	STATUS		MQcolqry();
	STATUS		qs_s_text();
	bool		MQrtbact();
	bool		MQrnxtrow();
	ATTRIBINFO	*catt;
	QDESC		*qdesc;
	MQQDEF		*qdef;
	STATUS		rval;
	STATUS		ret_stat = QG_NOSPEC;
	bool		master;
	bool		detail;
	char		*prefix;	/* A string to proceed any clause */
	bool		row_sent;	/* If any quals sent for a row. */
	bool		fld_sent;	/* If any quals sent for the fields */
	bool		join_in;
	i4		i;
	bool		tbl_sent;	/* If any quals sent for a table. */
	char		xri_col_buf[(FE_UNRML_MAXNAME + 1)];
	char		xri_rvar_buf[(FE_UNRML_MAXNAME + 1)];
##	char		*formname;
##	char		*fieldname;
##	char		fldmode[10];

	qdef = mqgen->mqqg_qdef;
	master = (mqgen->mqqg_where == MQQG_MASTER);
	detail = (mqgen->mqqg_where == MQQG_DETAIL);
	qdesc = qdef->mqqdesc;

	join_in = FALSE;
	formname = mq_frame;

	/*
	** prefix is any string that needs to be placed
	** in front of any qualification clause that are sent.
	**
	** Typically these are "and" to separate clauses.
	** Because of the way that the where clause given to QG
	** is set up, there is no need to put an and before
	** the first clause sent.
	** BUG 1481
	** However, because the FRS does range queries for
	** QBF, the clause for a field may contain ands and ors.
	** Thus it must be enclosed in parens.
	*/
	prefix = "(";
	fld_sent = FALSE;

	/* Bug fix #2767
	** removed check on 'master' from the following if.
	** ie. Call MQrgetinit for both master and detail.
	*/
	if (!MQrgetinit(formname))
	{
		IIUGerr(E_QF0018_bldwhere__couldn_t_in,0,1,formname);
		return(FAIL);
	}
	for (i = 0; i < qdef->mqnumatts; i++)
	{
	    catt = qdef->mqatts[i];
	    /* if current field is not part of a table field */
	    if (!catt->intbl)
	    {
		fieldname = catt->formfield;
		if (fieldname[0] == EOS)
		    continue;  
		if (catt->lkeyinfo != 0)
		    continue;
		if (catt->jpart == 0)
		    continue;
##		inquire_frs field formname (fldmode = mode(fieldname))
		if (STcompare(fldmode, ERx("READ")) == 0)
		    continue;
		/*
		** These test to see if any qualification in this field
		** should be sent for this where clause.
		** The tests go like this:
		**    master && "field is part of master"
		**    master && "field is part of detail"
		**	in this case, need to make sure master-detail
		**	joins get into where clause too.
		**    detail && "field is part of detail"
		**
		** To do these tests use following info.
		**	catt->ttype == 0 if field is part of master
		**	qdef_type == 0 if query is master detail.
		**
		*/
		if ((master && (catt->ttype == 0 || qdef_type == 0))
		    || (detail && catt->ttype != 0))
		{
		    IIUGxri_id(catt->col,&xri_col_buf[0]);
		    IIUGxri_id(catt->rvar,&xri_rvar_buf[0]);
		    rval = MQfldqry(formname, fieldname, &xri_rvar_buf[0],
				    &xri_col_buf[0], prefix, qgfunc, qgvalue);
		    if (rval == QG_NOSPEC)
			continue;
		    if (rval != OK)
		    {
			return(rval);
		    }
		    /*
		    ** At this point, the fields qualification were sent
		    ** to QG.  Now must put an "and" before any new clauses.
		    ** Also must record the fact that the qualification was
		    ** sent.
		    */
		    ret_stat = OK;
		    prefix = ERx(") and (");
		    fld_sent = TRUE;
		    /*
		    ** if this is master's where clause and field is part
		    ** of detail, then need to send master-detail joins
		    ** too.
		    ** Should only do this once.
		    */
		    if (!join_in && master && catt->ttype != 0)
		    {
			mqjoinwhere(qdef, qgfunc, qgvalue, prefix);
			join_in = TRUE;
		    }
		}
	    }
	}

	/*
	** Send down a ) to close the paren for the last
	** regular field clause if a clause was sent.
	*/
	if (fld_sent)
	{
	    if ((rval = qs_s_text(ERx(")"), qgfunc, qgvalue)) != OK)
		return rval;
	}
	/*
	** At this point, two conditions exists: Either some
	** clauses were sent down above, or no clauses were sent.
	** If clauses were sent down, an "and" must preceed any
	** other clauses.
	** Also, since a clause was sent down, the open paren
	** for the clause must be closed.
	** If no clauses were sent down, then no "and" can be
	** generated.
	** These cases are distinguished by fld_sent.  If it
	** is FALSE, then no clauses were sent.
	**
	** Furthermore, at this point we are going to examine
	** the table field to see if it has any qualifcations.
	** We want to and the columns and or the rows.
	** The query we want to build is:
	**     (
	**	((qual(c1,1)) and (qual(c2,1)) and ... and (qual(cN,1))) or
	**	((qual(c1,2)) and (qual(c2,2)) and ... and (qual(cN,2))) or
	**			...
	**	((qual(c1,N)) and (qual(c2,N)) and ... and (qual(cN,1))) or
	**     )
	**  where qual(cI,J) is the qualifications for colunm I in row J.
	**
	** Thus, if fld_sent is FALSE, the new prefix is "(((" otherwise
	** it is " and ((("
	*/


	if (tblfield)
	{
	    if (!fld_sent)
	    {
		prefix = ERx(" (((");
	    }
	    else
	    {
		prefix = ERx(" and (((");
	    }

	    if (!MQrtbact(formname, mq_tbl))
	    {
		goto qryend;
	    }

	    tbl_sent = FALSE;
	    while (MQrnxtrow(mq_tbl))
	    {
		row_sent = FALSE;
		for (i=0; i< qdef->mqnumatts; i++)
		{
		    catt = qdef->mqatts[i];
		    if (catt->formfield[0] == EOS)
			continue;
		    if (catt->lkeyinfo != 0)
			continue;
		    if ((catt->intbl) && (catt->jpart != 0))
		    {
			/*
			** As above for MQfldqry, we have to determine
			** if the qualifications in this column
			** of the table field should be sent down.
			** This is simple, since if a table field
			** is present then both clauses need any
			** qualifications.
			*/
			IIUGxri_id(catt->col,&xri_col_buf[0]);
			IIUGxri_id(catt->rvar,&xri_rvar_buf[0]);
			rval = MQcolqry(mq_tbl, catt->formfield,
					&xri_rvar_buf[0], &xri_col_buf[0],
					prefix, qgfunc, qgvalue);
			if (rval == QG_NOSPEC)
			    continue;
			if (rval != OK)
			{
			    return(rval);
			}
			/*
			** At this point, a clause has been put
			** out, any new clause must have an "and"
			*/
			ret_stat = OK;
			prefix = ERx(") and (");
			row_sent = TRUE;
			tbl_sent = TRUE;
		    }
		}
		/*
		** If any qualifications were sent for this row,
		** then the prefix changes to ")) or ((".
		*/
		if (row_sent)
		{
		    prefix = ERx(")) or ((");
		}
	    }
	    MQtunend();
	    /*
	    ** If any qualifications were sent for the table
	    ** field, then send down the closing "))" and
	    ** if this is the master where clause, send down
	    ** the master-detail joins too.
	    */

	    if (tbl_sent)
	    {
		if ((rval = qs_s_text(ERx(")))"), qgfunc, qgvalue)) != OK)
		    return rval;
		/*
		** If this is the master where clause, and the joins
		** haven't been sent, then send them down.
		*/
		if (master && qdef_type == 0 && !join_in)
		{
		    mqjoinwhere(qdef, qgfunc, qgvalue, ERx(" and "));
		    join_in = TRUE;
		}
	    }
	}
qryend:
	/*
	** If any clauses have been sent return OK
	** otherwise return QG_NOSPEC
	*/
	return ret_stat;
}


STATUS
mqjoinwhere(qdef, qgfunc, qgvalue, prefix)
MQQDEF	*qdef;
STATUS	(*qgfunc)();
PTR	qgvalue;
char	*prefix;
{
    i4		j;
    JOININFO	*currj;
    STATUS	rval;
    STATUS	mq_s_joincat();

    for (j = 0; j < qdef->mqnumjoins; j++)
    {
	currj = qdef->mqjoins[j];
	if (STcompare(currj->jcode, ERx("MM")) != 0)
	{
	    if ((rval = qs_s_text(prefix, qgfunc, qgvalue)) != OK)
		return rval;
	    if ((rval = mq_s_joincat(qgfunc, qgvalue, currj, 0)) != OK)
		return rval;
	}
    }
}


bool
MQrgetinit(formname)
char	*formname;
{
# ifndef	NOLASTQRY
	if (IIrgetinit(formname) == FAIL)
		return(FALSE);
# endif		/* NOLASTQRY */
	return (TRUE);
}


STATUS
MQfldqry(form, fieldname, relname, attrname, prefix, qgfunc, qgvalue)
char	*form;
char	*fieldname;
char	*relname;
char	*attrname;
char	*prefix;
STATUS	(*qgfunc)();
PTR	qgvalue;
{
	STATUS	IIrngget();
	STATUS	IIqryfield();

# ifndef	NOLASTQRY
	return (IIrngget(fieldname, NULL, relname, attrname,
		MQdblang, prefix, qgfunc, qgvalue));
# else

	if (!IIfsetio(form))
	{
		return (FAIL);
	}

	if (!IIqryfield(fieldname, MQdblang, prefix, qgfunc, qgvalue))
	{
		return (FAIL);
	}

	return(OK);
# endif		/* NOLASTQRY */
}


bool
MQrtbact(formname, tfldname)
char	*formname;
char	*tfldname;
##{
# ifndef	NOLASTQRY
	return (TRUE);
# else
##	char	*fname;
##	char	*tfld;
##	i4	rstate;
##	i4	lrow;
##	i4	ncols;

	fname = formname;
	tfld = tfldname;
##	scroll fname tfld to 1
##	getrow fname tfld 1 (rstate = _STATE)
##	inquire_frs table fname (lrow = lastrow(tfld), ncols = maxcol(tfld))
	if (lrow == 1 && rstate == UNDEF)
		return (FALSE);
	/*
	**	Begin an "unloadtable" command
	*/
	if (!IItbact(fname, tfld, 0))
	{
		IItunend();
		return (FALSE);
	}
	return (TRUE);
# endif		/* NOLASTQRY */
##}


VOID
MQtunend()
{
# ifndef	NOLASTQRY
	return;
# else
	_VOID_ IItunend();
# endif		/* NOLASTQRY */
}


bool
MQrnxtrow(tfld)
char	*tfld;
{
# ifndef	NOLASTQRY
	return (IIrnxtrow(tfld));
# else
	return (IItunload());
# endif		/* NOLASTQRY */
}


STATUS
MQcolqry(tfld, colname, relname, attrname, prefix, qgfunc, qgvalue)
char	*tfld;
char	*colname;
char	*relname;
char	*attrname;
char	*prefix;
STATUS	(*qgfunc)();
PTR	qgvalue;
{
	STATUS	IIrngget();
	STATUS	IItqrycol();

# ifndef	NOLASTQRY
	return (IIrngget(tfld, colname, relname, attrname, MQdblang,
		prefix, qgfunc, qgvalue));
# else
	return	(IItqrycol(colname, MQdblang, prefix, qgfunc, qgvalue))
# endif		/* NOLASTQRY */
}

/*{
** Name:	qs_s_text	- Send a text QRY_SPEC to function.
**
** Description:
**	This function takes a text string, places it in a QRY_SPEC
**	of type QS_TEXT, and passes it the the function given
**	by the argument qgfunc.
**
** Inputs:
**	text		{char *} The text string to build a QRY_SPEC
**			for.
**
**	qgfunc		{STATUS (*)()} The function to call.
**
**	qgvalue		{PTR} A	 value to pass to the function.
**
** Outputs:
**	Returns:
**		Value from qgfunc.
**
** History:
**	13-may-1987 (Joe)
**		Initial Version.
*/
STATUS
qs_s_text(text, qgfunc, qgvalue)
char	*text;
STATUS	(*qgfunc)();
PTR	qgvalue;
{
    QRY_SPEC	qs;
    STATUS	rval;

    qs.qs_var = (PTR) text;
    qs.qs_type = QS_TEXT;
    return (*qgfunc)(qgvalue, &qs);
}

STATUS
IIQFbwv_buildVALGEN(gen, qgfunc, qgvalue)
PTR	gen;
STATUS	(*qgfunc)();
PTR	qgvalue;
{
	QRY_SPEC	*qs = (QRY_SPEC *) gen;
	QRY_SPEC	*spec;
	QRY_SPEC	sendspec;
	i4		isnull;
	ADF_CB		*adf_cb;
	STATUS		rval;
	bool		firstjoin;

	firstjoin = TRUE;
	adf_cb = FEadfcb();

	do
	{
		/* 2nd and later joins must be joined by 'and' */
		if (firstjoin)
		{
			firstjoin = FALSE;
		}
		else
		{
			if ((rval = qs_s_text(ERx(" and "), qgfunc,
 				qgvalue)) != OK)
			{
				return rval;
			}
		}

		/* qs points to the text part of join */
		spec = qs;

		/* spec points to the DB DATA VALUE */
		spec++;

		/* if DBDV is NULL this WHERE clause will be FALSE */
		_VOID_ adc_isnull(adf_cb, (DB_DATA_VALUE *)spec->qs_var,
			&isnull);
		if (isnull)
		{
			if ((rval = qs_s_text(ERx(" 1=2 "), qgfunc,
 				qgvalue)) != OK)
			{
				return rval;
			}
			return OK;
		}
		else
	 	{
			/* DBDV is not NULL - send down text */
			sendspec.qs_var = qs->qs_var;
			sendspec.qs_type = QS_TEXT;
			rval = (*qgfunc)(qgvalue, &sendspec);
			if (rval != OK)
			{
				return rval;
			}

			/* send down DB DATA VALUE */
			sendspec.qs_var = spec->qs_var;
			sendspec.qs_type = QS_VALUE;
			rval = (*qgfunc)(qgvalue, &sendspec);
			if (rval != OK)
			{
				return rval;
			}
		}
		qs = ++spec;
	} while (qs->qs_type != QS_END);

	return (OK);
}
