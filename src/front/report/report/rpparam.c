/*
** Copyright (c) 2004 Ingres Corporation
*/

# include	<compat.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include       <st.h>
# include	<fe.h>
# include	<adf.h>
# include	<fmt.h>
# include	 <rtype.h> 
# include	 <rglob.h> 
# include	<er.h>

/*
**   R_P_PARAM - process and set up a variable found in an expression.
**	Variable are evaluated in the following order:
**	domain values, declared variables, report constants
**	(current_date, etc.), report variables (page_number, etc.), aggregates,
**	and then functions.
**
**	Parameters:
**		name	name of the parameter.
**		item	ITEM structure generated by this routine
**			which contains type of item and a pointer
**			to the value of the item.
**		type	datatype of variable
**
**	Returns:
**		status of variable:
**			GOOD_EXP	a legal variable found
**			BAD_EXP		bad variable found
**			NULL_EXP	"null" found
**
**	Side Effects:
**		none.
**
**	Called by:
**		r_g_expr.
**
**	Error messages:
**		102.
**
**	Trace Flags:
**		3.0, 3.6.
**
**	History:
**		3/31/81 (ps) - written.
**		11/29/83 (gac)	now calls r_gt_vcode.
**		12/15/83 (gac)	now called by r_g_expr.
**		9/10/84	(gac)	fixed bug 3904 -- now if column name is also
**				a RW keyword, it will refer to column.
**      3/20/90 (elein) performance
**          Change STcompare to STequal
**	08-oct-92 (rdrane)
**		Converted r_error() err_num value to hex to facilitate
**		lookup in errw.msg file.  Allow for delimited identifiers, and
**		normalize them based upon the type of lookup being effected.
**		This avoids failure due to "delim, but is_nrml == FALSE".  Note
**		that now NULL as a regular identifier represents the keyword,
**		while "NULL" as a delimited identifier does not represent the
**		keyword!  Ensure db_prec is initialized/propagated for
**		proper DECIMAL support.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
*/


i4
r_p_param(name, item, type)
char		*name;
ITEM		*item;
DB_DATA_VALUE	*type;
{
	/* internal declarations */

	ATTRIB		ordinal;	/* ordinal of attribute name */
	i4		status;
	char	namebuf[(FE_UNRML_MAXNAME + 1)];

	/* start of routine */




	if (STbcompare(name,0,ERx("null"),0,TRUE) == 0)
	{
		return(NULL_EXP);
	}


	/*
	** Now compare to the attribute names
	*/
	STcopy(name,&namebuf[0]);
	_VOID_ IIUGdlm_ChkdlmBEobject(&namebuf[0],&namebuf[0],FALSE);
	ordinal = r_mtch_att(&namebuf[0]);
	if (ordinal != A_ERROR)
	{
		status = r_p_att(ordinal, item, type);
		return(status);
	}

	/* Now compare to the declared variables,
	** which are not supported as delimited identifiers.
	** Thus, always case as if it were a regular identifier.
	** Note that we want it to fail if it's explicitly delimited.
	*/
	STcopy(name,&namebuf[0]);
	IIUGdbo_dlmBEobject(&namebuf[0],FALSE);
	status = r_p_tparam(&namebuf[0], FALSE, item, type);
	if (status != NO_EXP)
	{
		return(status);
	}

	/*
	** Now compare to the program constants.
	** This routine effects case insensitive comparisons,
	** so just pass the original parameter through.
	*/
	switch (r_pc_set(name, item))
	{
		case(PC_CNAME):
			type->db_datatype = DB_CHR_TYPE;
			type->db_length = FE_MAXNAME;
			type->db_prec = 0;
			return(GOOD_EXP);

		case(PC_DAY):
			type->db_datatype = St_cday.db_datatype;
			type->db_length = St_cday.db_length;
			type->db_prec = 0;
			return(GOOD_EXP);

		case(PC_DATE):
			type->db_datatype = St_cdate.db_datatype;
			type->db_length = St_cdate.db_length;
			type->db_prec = 0;
			return(GOOD_EXP);

		case(PC_TIME):
			type->db_datatype = St_ctime.db_datatype;
			type->db_length = St_ctime.db_length;
			type->db_prec = 0;
			return(GOOD_EXP);
	}

	/*
	** Now compare to the program variables.
	** This routine effects case insensitive comparisons,
	** so just pass the original parameter through.
	*/
	if (r_p_var(name, item))
	{
		type->db_datatype = DB_INT_TYPE;
		type->db_length = sizeof(i4);
		type->db_prec = 0;
		return(GOOD_EXP);
	}

	/*
	** Now compare to aggregates.
	*/
	STcopy(name,&namebuf[0]);
	_VOID_ IIUGdlm_ChkdlmBEobject(&namebuf[0],&namebuf[0],FALSE);
	status = r_p_agg(&namebuf[0], item, type);
	if (status != NO_EXP)
	{
		return(status);
	}

	/*
	** Now compare to functions.  This routine effects case insensitive
	** comparisons, so just pass the original parameter through.
	*/
	status = r_p_funct(name, item, type);
	if (status != NO_EXP)
	{
		return(status);
	}

	/* doesn't match any parameter */

	r_error(0x66,NONFATAL,name,Cact_tname,Cact_attribute,Cact_command,
			Cact_rtext,0);
	return(BAD_EXP);

}
