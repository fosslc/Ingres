/*
** Copyright (c) 2004 Ingres Corporation
*/

/* ===ICCS===\50\3\3\	ingres 5.0/03  (pyr.u42/01)	*/

/* static char	Sccsid[] = "@(#)rfscan.c	30.1	11/14/84"; */

# include	<compat.h>
# include	<st.h>		/* 6-x_PC_80x86 */
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<cm.h>
# include	<me.h>
# include	<fe.h>
# include	<ug.h>
# include       "rbftype.h"
# include       "rbfglob.h"

/*
**   RFSCAN - scan and process TCMD structures in the linked list until
**	either the end of the list, or an end of a type of block is found.
**	This processes and evaluates the lists as well.
**	It checks for the type of underlining in that section as well.
**
**	Parameters:
**	   flag
**		TRUE	if an end to the block of the type currently
**			in Cact_tcmd is to return.
**		FALSE	if an end of block is not to be found.
**	   blklevel  --  The block level.
**	   in_detail  
**		TRUE	processing commands in a detail section
**			   needed for processing trim in label reports because
**			   ALL detail trim in label reports are unassociated,
**			   that is, no column headings exist
**		
**
**	Returns:
**		The type of underlining in the section.
**			ULS_NONE - if no underlining.
**			ULS_LAST - if underlining within blocks.
**			ULS_ALL	 - if underlining around entire section.
**
**	Side Effects:
**		Update Cact_tcmd, Curx, Cury, Curordinal, Curtop, Curaggregate.
**		May set values of St_ulchar, St_pl_set,
**		St_p_length and St_ff_on.
**
**	Called by:
**		rFdisplay.
**
**	Trace Flags:
**		200, 216, 217.
**
**	Error Messages:
**		Syserr:	 Bad code.
**		Syserr:	 Bad end code.
**
**	History:
**		2/15/82 (ps)	written.
**		2/27/84 (gac)	added printing of expressions.
**		12-jan-87 (marian)	bug 10738
**			Set St_ff_on to FALSE when the tcmd->tcmd_code = P_END
**		and tcmd_val.t_v_long = P_FF.
**      9/22/89 (elein) UG changes ingresug change #90045
**	changed <rbftype.h> & <rbfglob.h> to "rbftype.h" & "rbfglob.h"
**		22-nov-89 (cmr)	support for editable aggregates.  Use agg_level
**			variable to determine if we are dealing with an agg.
**			Look for RBFAGGS when END is encountered and look for 
**			an ACC/CUM when PRINT is encountered.
**	12/18/89 (martym) (garnet)
**			Added support for the scanning a labels style reports 
**			generated by RBF; also as a result the block level is 
**			now passed in.
**	2/5/90 (martym)
**			Changed the handling of P_LET, and coding standard 
**			fixes.
**	3/2/90 (martym)
**			Added check to ignore tabs to expressions. These 
**			tabs should only show up in Labels Style Reports, 
**			and since the evaluation of the expression is a 
**			runtime event and we want to ignore them here.
**	10-apr-90 (cmr)
**			The aggregate # (which is used to index into Cs_top
**			array) is now stored in the rcommands table so 
**			Curaggregate gets set to this #.
**	02-may-90 (cmr)	Make sure old reports with aggregates work.
**	04-jun-90 (cmr)	Put back in support for TFORMAT.
**	14-sep-90 (sylviap)	
**		Added parameter, in_detail, to rFatrim calls.  If in the detail
**		section of a label report, ALL trim is unassociated.  (#32744)
**	04-mar-91 (steveh)
**		Fixed bug 9527.  This bug caused backslahes in the nullstring
**		to corrupt a report.
**	30-oct-1992 (rdrane)
**		Ensure that unsupported datatype fields cannot be
**		selected.  Remove declaration of r_gt_att() since
**		already declared in included hdr files.  Declare static
**		routines ProcessOldAggs() and DoOldAgg() as returning VOID.
**		Declare static variable num_lines as an explicit nat.
**	22-jun-1993 (rdrane)
**		Add support for suppression of initial formfeed.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
*/

static	bool	OldAggBlock();
static	VOID	ProcessOldAggs();
static	VOID	DoOldAgg();

static	i4	num_lines;	/* used only by ProcessOldAggs and DoOldAgg */


char
rFscan(flag, blklevel, in_detail)
bool	flag;
i4	blklevel;	/* nesting of BLOCK cmds */
bool	in_detail;	/* TRUE = processing the detail section */
{
	/* internal declarations */

	char		ultype;			/* temporary return value */
	register TCMD	*tcmd;			/* fast ptr to TCMD */
	VP		*vp = 0;		/* shorthand for VP struct */
	ATT		*att = 0;		/* shorthand for ATT struct */
	FIELD		*field;			/* ptr to field structure */
	i4		stopcode;		/* code to stop the skip */
	i4		agglevel = 0;
	bool		done = FALSE;		/* TRUE when finished */
	bool		any_ul = FALSE;		/* TRUE if any underlining */
	bool		any_nlul = FALSE; /* TRUE if any underlined over NL  */
	DB_DATA_VALUE	*dbv;
	LET     	*let;
	DB_DATA_VALUE   value;
	STATUS      	status;

	/* start of routine */

#	ifdef	xRTR1
	if(TRgettrace(200,0) || TRgettrace(216,0))
	{
		SIprintf(ERx("rFscan:entry.\n"));
	}
#	endif

#	ifdef	xRTR2
	if (TRgettrace(216,0))
	{
		SIprintf(ERx("	flag:%d\n"),flag);
		r_pr_tcmd(Cact_tcmd,FALSE);
		SIprintf(ERx("	Curx:%d"),Curx);
		SIprintf(ERx("	Cury:%d\n"),Cury);
		SIprintf(ERx("	R.M.:%d"),St_right_margin);
		SIprintf(ERx("	L.M.:%d\n"),St_left_margin);
		SIprintf(ERx("	R_RM:%d"),St_r_rm);
		SIprintf(ERx("	R_LM:%d\n"),St_r_lm);
	}
#	endif

	St_underline = FALSE;

	if (flag)
	{
		stopcode = Cact_tcmd->tcmd_code;
		Cact_tcmd = Cact_tcmd->tcmd_below;
	}

	St_right_margin = St_r_rm;
	St_left_margin = St_r_lm;

	while (Cact_tcmd!=NULL)
	{
#		ifdef	xRTR2
		if (TRgettrace(217,0))
		{
		 SIprintf(ERx("		At start of loop in rFscan.\n"));
		 r_pr_tcmd(Cact_tcmd,FALSE);
		 SIprintf(ERx("			Curx:%d"),Curx);
		 SIprintf(ERx("			Cury:%d\r\n"),Cury);
		 SIprintf(ERx("			R.M.:%d"),St_right_margin);
		 SIprintf(ERx("			L.M.:%d\r\n"),St_left_margin);
		 SIprintf(ERx("			Curtop:%d"),Curtop);
		 SIprintf(ERx("			Curbot:%d"),Curbot);
		 SIprintf(ERx("			Curordinal:%d\r\n"),Curordinal);
		}
#		endif

		tcmd = Cact_tcmd;
		switch(tcmd->tcmd_code)
		{
			/*
			** Added P_ERROR, since r_x_tcmd() has them. 
			** In the case of "endlet" the tcmd_code will 
			** be P_ERROR (-1):
			*/
			case (P_ERROR):
			case (P_NOOP):
			case (P_IF):
				break;

			case(P_PRINT):
				switch (tcmd->tcmd_val.t_v_pel->pel_item.item_type)
				{

				case(I_CON):
					dbv = tcmd->tcmd_val.t_v_pel->
						pel_item.item_val.i_v_con;
					if (dbv->db_datatype == DB_CHR_TYPE)
					{
					    if ( agglevel )
						rFatrim((char *)(dbv->db_data),
							TRUE, in_detail);
					    else
						rFatrim((char *)(dbv->db_data),
							FALSE, in_detail);
					    Curx += dbv->db_length;
					    any_ul = (St_underline) ? TRUE : 
						any_ul;
					}
					break;

				case(I_ATT):

					/*
					** FIXME:
					if (Curordinal != tcmd->
						tcmd_val.t_v_pel->
						pel_item.item_val.i_v_att)
					    IIUGerr(
					      E_RF003F_rFscan__Bad_within_or, 
					      UG_ERR_FATAL, 1, 
					      tcmd->tcmd_val.t_v_long);
					*/
					if (Curordinal != 
						tcmd->tcmd_val.t_v_pel->
						pel_item.item_val.i_v_att)
						Curordinal = tcmd->
						tcmd_val.t_v_pel->pel_item.
						item_val.i_v_att;

					/*
					** If the column already exists
					** then we assume we are looking at
					** an old report in which the column
					** is printed again with an aggregate.
					*/
					if (Cs_top[Curordinal - 1].cs_flist)
					{
						att = r_gt_att(Curordinal);
						Curordinal = 0;
						rFatrim(att->att_name, FALSE, 
							in_detail);
					    	Curx += STlength(att->att_name);
					    	any_ul = St_underline ? TRUE : 
							any_ul;
						break;
					}
					field = rFafield(FALSE, NULL);
					Curx += field->flmaxx;
					Curbot = max(Curbot,Cury+field->flmaxy);
					any_ul = (St_underline) ? TRUE : any_ul;
					break;
				case(I_ACC):	/* an aggregate */
				case(I_CUM):
					field = rFafield( TRUE,
						tcmd->tcmd_val.t_v_pel);
					Curx += field->flmaxx;
					Curbot = max(Curbot,Cury+field->flmaxy);
					any_ul = (St_underline) ? TRUE : any_ul;
					break;
				}
				break;

			case(P_TAB):
				/*
				** If we have a tab to expression, ignore it, 
				** since the expression hasn't been evaluated 
				** at this point yet. We should only get this 
				** for Label Style Reports:
				*/
				if (tcmd->tcmd_item->item_type != I_EXP)
				{
					vp = tcmd->tcmd_val.t_v_vp;
					switch(vp->vp_type)
					{
						case(B_ABSOLUTE):
							Curx = vp->vp_value;
							break;
	
						case(B_RELATIVE):
							Curx += vp->vp_value;
							break;

						case(B_DEFAULT):
							Curx = St_left_margin;
							break;

						case(B_COLUMN):
							Curx = r_gt_att(
						vp->vp_value)->att_position;
							break;
					}
				}
				break;

			case(P_LINESTART):
				Curx = St_left_margin;
				break;

			case(P_NEWLINE):
				Cury += tcmd->tcmd_val.t_v_long;
				Curx = St_left_margin;
				if (blklevel > 0)
				{
					Curbot = max(Curbot,Cury);
				}
				any_nlul = (St_underline) ? TRUE : any_nlul;
				break;

			case(P_FORMAT):
				/* set a format */
				r_x_sformat(tcmd->tcmd_val.t_v_ap->ap_ordinal,
					tcmd->tcmd_val.t_v_ap->ap_format);
				break;

			case (P_TFORMAT):
				/* 
				** If next tcmd is format, ignore it. This
				** happens when RBF calls r_m_rcolumn() to
				** generate a default column report.
				*/
				tcmd = tcmd->tcmd_below;
				if (tcmd && tcmd->tcmd_code == P_FORMAT)
					Cact_tcmd = Cact_tcmd->tcmd_below;
				break;

			case(P_POSITION):
				/* set a default position */
				r_x_spos(tcmd->tcmd_val.t_v_ps->ps_ordinal,
					tcmd->tcmd_val.t_v_ps->ps_position);
				break;

			case(P_WIDTH):
				/* set a default width */
				r_x_swidth(tcmd->tcmd_val.t_v_ws->ws_ordinal,
					tcmd->tcmd_val.t_v_ws->ws_width);
				break;

			case(P_LM):
				St_r_lm = tcmd->tcmd_val.t_v_vp->vp_value;
				Curx = St_left_margin = St_r_lm;
				break;

			case(P_RM):
				St_r_rm = tcmd->tcmd_val.t_v_vp->vp_value;
				St_right_margin = St_r_rm;
				break;

			case(P_END):
				if (flag && (stopcode == 
					Cact_tcmd->tcmd_val.t_v_long))
				{	/* get out */
					done = TRUE;
					break;
				}

				switch(tcmd->tcmd_val.t_v_long)
				{
					case(P_BLOCK):
						/* 
						** get the current position 
						** set up 
						*/
						if (--blklevel <= 0)
						{
							Cury = Curbot;
							Curx = St_left_margin;
							Curtop = Cury;
						}
						break;

					case(P_PRINT):
						break;

					case(P_WITHIN):
						Curx = St_right_margin;
						Curordinal = 0;
						St_left_margin = St_r_lm;
						St_right_margin = St_r_rm;
						break;

					case(P_UL):
						St_underline = FALSE;
						break;

					case(P_FF):
						/* bug 10738
						**	Set formfeeds off
						*/

						St_ff_on = FALSE;
						break;

					case(P_RBFAGGS):
						/* end of this aggregate */
						agglevel--;
						Curaggregate = 0;
						break;
					default:
						{
						    i4 templong;

						    templong = tcmd->tcmd_code;
						    IIUGerr(
						 E_RF0041_rFscan__Bad_command_c,
				  		    UG_ERR_FATAL, 1, &templong);
						}
				}
				break;

			case(P_WITHIN):
				Curordinal = tcmd->tcmd_val.t_v_long;
				att = r_gt_att(Curordinal);
				St_left_margin = att->att_position;
				St_right_margin = St_left_margin + 
					r_ret_wid(Curordinal);
				Curx = St_left_margin;
				break;

			case(P_BLOCK):
				if (blklevel++ <= 0)
				{	/* first block command.	 Set Curtop */
					Curtop = Cury;
					Curbot = Cury;
				}
				if (OldAggBlock())
					ProcessOldAggs(&blklevel);
				break;

			case(P_RBFAGGS):
				/* begin aggregate */
				Curaggregate = tcmd->tcmd_val.t_v_long;
				agglevel++;
				break;

			case(P_TOP):
				Cury = Curtop;
				Curx = St_left_margin;
				break;

			case(P_UL):
				/* The underlining mode is determined by **
				** the following criteria:		 **
				**  ULS_NONE - if none found at all.	 **
				**  ULS_ALL - if underlining is in effect**
				**    across a newline boundary		 **
				**  ULS_LAST - if anything is printed	 **
				**    but not across a newline		 */

				St_underline = TRUE;
				break;

			case(P_ULC):
				St_ulchar = Cact_tcmd->tcmd_val.t_v_char;
				break;

			case(P_NULLSTR):
				/* insert backslashes and quotes to fix
				   bug 9527. (steveh)                  */
				rF_bstrcpy(Opt.rnulstr, 
					Cact_tcmd->tcmd_val.t_v_str);
				break;

			case(P_FF):
				St_ff_on = TRUE;
				break;

			case(P_NO1STFF):
				St_no1stff_on = TRUE;
				break;

			case(P_PL):
				St_pl_set = TRUE;
				St_p_length = Cact_tcmd->tcmd_val.t_v_long;
				break;

			case(P_NEED):
			case(P_AOP):
			case(P_ACLEAR):
			case(P_NPAGE):
				break;

			case(P_LET):
				/*
				** Since we should only get this for 
				** RBF generated label style reports 
				** and we aren't interested in the 
				** value just break:
				*/
				break;

			case (P_RBFPTOP):
			case (P_RBFPBOT):
				rFskip(TRUE);
				break;

			default:
				{
				    i4 templong;

				    templong = tcmd->tcmd_val.t_v_long;
				    IIUGerr(E_RF0040_rFscan__Bad_end_of_co, 
				      UG_ERR_FATAL, 1, &templong);
				}
		}

		if (done)
		{
			break;
		}
		Cact_tcmd = Cact_tcmd->tcmd_below;
	}

	/* Now figure out the ultype from any_ul and any_noul  */

	if (!any_ul)
	{
		ultype = ULS_NONE;
	}
	else if (!any_nlul)
	{
		ultype = ULS_LAST;
	}
	else
	{
		ultype = ULS_ALL;
	}

#	ifdef	xRTR2
	if (TRgettrace(216,0))
	{
		SIprintf(ERx("	At end of rFscan.\n"));
		r_pr_tcmd(Cact_tcmd,FALSE);
		SIprintf(ERx("	Curx:%d"),Curx);
		SIprintf(ERx("	Cury:%d\n"),Cury);
		SIprintf(ERx("	R.M.:%d"),St_right_margin);
		SIprintf(ERx("	L.M.:%d\n"),St_left_margin);
		SIprintf(ERx("	R_RM:%d"),St_r_rm);
		SIprintf(ERx("	R_LM:%d\n"),St_r_lm);
		SIprintf(ERx("	ultype:%c\n"),ultype);
	}
#	endif

	return(ultype);
}


/*
** OldAggBlock() - Returns TRUE if this is an old-style report with
**		   aggregates.  This means that the aggregates will
**		   need to be converted.  The way it figures it out
**		   is by look ahead.  We scan the block and if we see 
**		   that an aggregate is being printed inside a .within 
**		   then we are dealing with an old-style report.
*/
static
bool
OldAggBlock()
{
	bool	in_within = FALSE;
	bool	done = FALSE;
	TCMD	*tcmd;
	ITEM	item;

	tcmd = Cact_tcmd;	

	while (tcmd)
	{
		switch (tcmd->tcmd_code) {
			case P_PRINT:
				item = tcmd->tcmd_val.t_v_pel->pel_item;
				if (item.item_type == I_ACC && in_within)
					return(TRUE);
				break;
			case P_WITHIN:
				in_within = TRUE;
				break;
			case P_END:
				switch (tcmd->tcmd_val.t_v_long) {
					case P_WITHIN:
						in_within = FALSE;
						break;
					case P_BLOCK:
						done = TRUE;
						break;
				}
				break;
		}
		if (done) break;
		tcmd = tcmd->tcmd_below;
	}
	return (FALSE);
}


/*
** ProcessOldAggs - Converts the old-style aggregates to the new style
**		    for this block.  The aggregate will have the appropriate
**		    label.
*/
static
VOID
ProcessOldAggs(blklevel)
i4	*blklevel;
{

	bool	done = FALSE;
	ITEM	item;
	ATT	*att;

	while (Cact_tcmd)	/* Scan the block */
	{
		switch (Cact_tcmd->tcmd_code) {
			case P_PRINT:
				item = Cact_tcmd->tcmd_val.t_v_pel->pel_item;
				if (item.item_type == I_ACC)
					DoOldAgg();
				break;
			case P_WITHIN:
				Curordinal = Cact_tcmd->tcmd_val.t_v_long;
				break;
			case P_END:
				switch (Cact_tcmd->tcmd_val.t_v_long) {
					case P_WITHIN:
						Curordinal = 0;
						break;
					case P_BLOCK:
						done = TRUE;
						break;
				}
				break;
		}
		if (done) break;
		Cact_tcmd = Cact_tcmd->tcmd_below;
	}
	Cury += num_lines;
	Curx = St_r_lm;
	Curbot = max(Curbot, Cury);
	if (--*blklevel <= 0)
	{
		Cury = Curbot;
		Curx = St_left_margin;
		Curtop = Cury;
	}
	num_lines = 0;
	
}
/*
** DoOldAgg() - Convert the Aggregate.  Write out the trim and the field.
**		Keeps track of when the go to a new line.  
**
** History:
**	23-oct-1992 (rdrane)
**		Ensure that db_prec is set in the associated DB_DATA_VALUE
**		structure for DECIMAL datatype support.
**	30-oct-1992 (rdrane)
**		Ensure that all string constants are generated with single,
**		not double quotes.  Ensure that all attributes are generated
**		in unnormalized form.
*/
static
VOID
DoOldAgg()
{

	i4	saveCurx, i;
	char	trimstr[100];
	char	fmtstr[MAX_FMTSTR + 1];
	bool	agunique;
	ACC	*acc;
	ATT	*att;
	char	*aggname;
	TCMD	*tcmd;
	ADI_FI_ID agfi;
	AGG_INFO  info;
	COPT	*copt;
	FIELD	*f;
	FMT	*fmt;
	DB_DATA_VALUE dbv;
	PTR	area;
	i4	numrow, numcol;
	i4	fmtlen, areasize;
	STATUS	status;
	ADI_OP_ID ag_id, cnt_id, any_id;
	char	tmp_buf1[(FE_MAXNAME + 1)];
	char	tmp_buf2[(FE_UNRML_MAXNAME + 1)];


	tcmd = Cact_tcmd;
	acc = tcmd->tcmd_val.t_v_pel->pel_item.item_val.i_v_acc;
	copt = rFgt_copt(acc->acc_attribute);
	att = r_gt_att(acc->acc_attribute);
	agfi = acc->acc_ags.adf_agfi;
	agunique = acc->acc_unique;

	tmp_buf1[0] = EOS;
	tmp_buf2[0] = EOS;

	/* Get the aggregate function name */
	for ( i = 0; i < copt->num_ags; i++ )
	{
		info = copt->agginfo[i];
		if (info.agnames->ag_fid == agfi &&
			info.agnames->ag_prime == agunique)
		{
			aggname = info.agnames->ag_funcname;
			ag_id = info.agnames->ag_opid;
			break;
		}
	}

	adi_opid( Adf_scb, ERx("count"), &cnt_id );
	adi_opid( Adf_scb, ERx("any"), &any_id );
	if (ag_id == cnt_id || ag_id == any_id)
	{
		dbv.db_datatype = DB_INT_TYPE;
		dbv.db_length = (ag_id == cnt_id ? 4 : 1 );
		dbv.db_prec = 0;

		status = fmt_deffmt( Adf_scb, &dbv, 0, TRUE, fmtstr );
		if ( status != OK )
			FEafeerr( Adf_scb );
		status = fmt_areasize( Adf_scb, fmtstr, &areasize );
		if ( status != OK )
			FEafeerr( Adf_scb );
		area = MEreqmem( 0, areasize, TRUE, NULL );
		status = fmt_setfmt( Adf_scb, fmtstr, area, &fmt, &fmtlen );
		if ( status != OK )
			FEafeerr( Adf_scb );
	}
	else
	{
		dbv = att->att_value;
		fmt = att->att_format;
	}

	CMtoupper(aggname,&tmp_buf1[0]);
	_VOID_ IIUGxri_id(att->att_name,&tmp_buf2[0]);
	STpolycat(5, &tmp_buf1[0], ERx("("), &tmp_buf2[0],
		ERx(")"), ERx(": "), trimstr);

	/* see if the trim + field will fit on this line */
	if (fmt_size(Adf_scb, fmt, &dbv, &numrow, &numcol) != OK)
	{
		IIUGerr((E_RF008F_DoOldAgg__Can_t_get_f), UG_ERR_FATAL, 0);
	}

	/*
	** num_lines keeps track of how many newlines we
	** need so as not to overwrite multi-line columns.
	*/
	num_lines = max(num_lines, numrow);
	if(Curx + STlength(trimstr) + numcol > St_r_rm)
	{
		Cury += num_lines;
		Curx = St_r_lm;
		Curbot = max(Curbot,Cury);
		num_lines = 0;
	}

	/* update Curaggregate; used in rFatrim() and rFafield() */
	Curaggregate++;
	/* Aggregates MUST be in Footers, so set in_detail to FALSE */
	rFatrim(trimstr, TRUE, FALSE);
	Curx += STlength(trimstr);

	tcmd->tcmd_val.t_v_pel->pel_fmt = fmt;
	f = rFafield( TRUE, tcmd->tcmd_val.t_v_pel);
	Curx += f->flmaxx +1;
	Curbot = max(Curbot,Cury+f->flmaxy);

	return;
}
