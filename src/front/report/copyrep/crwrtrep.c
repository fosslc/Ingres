/*
**	 Copyright (c) 2004 Ingres Corporation
*/
# include	<compat.h>
# include	<cv.h>		/* 6-x_PC_80x86 */
# include	<st.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
# include	 <stype.h>
# include	 <sglob.h>
# include	<afe.h>
# include	 <fedml.h>
# include	<cm.h>
# include	<oocat.h>
# include	"errc.h"
# include	<errw.h>
# include	<er.h>

static	VOID	cr_tab();
static	VOID	env_setup();



/*
**   CR_WRT_REP - write out one report to a file.  This routine
**	assumes that the existence of the report has been checked.
**
**	B 33894: A report page width (En_pg_width) can be set in two ways -   
**		 either through a .PAGEWIDTH command  (done by a user) or in 
**		 the first row of the query in ii_rcommands (generated by RBF).
**		 When copyrep'ing or archiving a report out, we need to save
**		 the page width.  When a .PAGEWIDTH command is in the report,
**		 a .PAGEWIDTH command will be generated.  If the width is buried
**		 in ii_rcommands in the query, the width will be saved in a 
**		 comment block AFTER the .QUERY.
**
**		 We cannot generate a .PAGEWIDTH (when width is in ii_rcommands)
**		 because this will render the report incompatible w/pre 6.4 
**		 RW/RBF since the .PAGEWIDTH was introduced w/6.4.
**
**		 SREPORT and REPORT -i have been changed to look at the comment
**		 block to get the page width.
**		
**	Parameters:
**		ren		REN structure for report.
**		unit		file number for file to write.
**		makecopy	TRUE if RBF commands to be include<d>
**				in the output.
**
**	Returns:
**		TRUE		if ok.
**		FALSE		if anything wrong.
**
**	Called by:
**		cr_dmp_rep.
**
**	History:
**		9/12/82 (ps)	written.
**		11/9/83 (gac)	added RX_LRTAB for if statement's ELSE and
**				 ELSEIF.
**		5/8/84	(gac)	RBF bug 1489 fixed -- date & time modified is
**				now correct.
**		5/14/84 (gac)	RBF bug 1853 fixed -- .query statements without
**				where clause now printed correctly.
**		12/1/84 (rlm)	ACT reduction - make call to r_gch_act.
**				must copy a retained action to a temp buffer
**				rather than saving a pointer, and get report
**				writer environment variables set up for
**				r_rco_set also.
**		1/8/85 (rlm)	SORT, SRT structures merged.  Changed to use
**				Ptr_sort_top.
**		7/17/85 (drh)	Modified to write sql queries if En_qlang is SQL
**		4/28/87 (grant) Removed dbb support kludge.
**		11/1/89 (elein) Added setup/cleanup sections
**		1/24/90 (elein) En_file_name changed to array rather that char *
**		10-apr-90 (cmr)	RBF saves the aggregate # with the ctext for 
**				.BEGIN RBFAGGS so we need to strip the # before 
**				calling r_gt_rtext() so RBF match occurs.
**		17-apr-90 (sylviap)	
**			Added support to archive/copyrep out the .PAGEWIDTH
**			command (#129, #588)
**		4/27/90 (martym)
**			Changed to only convert to uppercase the text 
**			of BEGIN command up to the first ','. This is 
**			to support the storage of the type and name 
**			of the source of data for an RBF report. The 
**			format of the command text is :
**				    RBFSETUP,DataSourceType,DataSourceName
**		05-nov-90 (sylviap)	
**			Fixed bug 33894.  See above for more info.
**		11-dec-91 (pearl)
**			Fixed bug 40655.  "all" or "distinct" was not picked
** 			up for sql queries, neither was "unique" for quel.
**		1-apr-92 (rdrane)
**			Correct fix for 33894.  Now compares against the
**			initial char En_pg_width instead of the effective
**			pointer value.  So, no more generation of WIDTH
**			comments w/ no width value.
**		3-apr-92 (rdrane)
**			Fix bug 43337.  Fix for bug 40655 caused open parens
**			to be placed at the beginning of each TLIST entry
**			instead of just the first.
**		12-aug-1992 (rdrane)
**			Use new constants in (s/r)_reset invocations.  Make
**			cr_tab() exlplicitly static, and make both cr_tab() and
**			env_setup() explicitly return VOID.  Re-format wrapped
**			source lines.
**		4-sep-92 (rdrane)
**			Fix bug 46249.  Fix for bug 40655 caused DISTINCT, ALL,
**			and UNIQUE to be placed at the beginning of each TLIST
**			entry after SELECT/RANGE instead of just the first.
**			Fix for bug 43337 did not recognize the generality of
**			the problem, so reimplement the whole set of these
**			related fixes.
**		23-sep-1992 (rdrane)
**			Add support for expanded namespace command.  Replace
**			En_relation reference with global FE_RSLV_NAME
**			structure name reference.
**		25-nov-92 (rdrane)
**			Rename .ANSI92 expanded name space (xns) command
**			to .DELIMID as per the LRC.
**		23-feb-1993 (rdrane)
**			Re-parameterize r_wrt_eol() invocation to include LN
**			structure pointer (changed due to fix for q0 format
**			bugs 46393 and 46713).  Took this opportunity to ensure
**			that all literal strings expressed via ERx() and that
**			all NULL's are properly cast.
**              19-may-1993 (rdrane)
**			Re-parameterize calls to r_wrt() to include explicit
**			length of line to be written, and ensure that we
**			compute that length here (changed to support q0
**			control sequences containing an embedded ASCII NUL).
**		13-sep-1993 (rdrane)
**			Output leading comment detailing report level.
**		9-dec-1993 (rdrane)
**			Rework delimited identifier support such that
**			the attribute name is stored normalized (b54950).
**		03-nov-1997 (kitch01)
**			Bug 85471. Add check for paramters being present in header section and
**			if so just write it out rather than try to un-normalize it.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	26-May-2009 (kschendel) b122041
**	    Compiler warning fixes.
*/

bool
cr_wrt_rep(ren,unit,makecopy)
register REN	*ren;
FILE		*unit;
bool		makecopy;
{
	/* internal declarations */

	char	tbuffer[256];		/* string buffer for output */
	char	cbuffer[100];		/* command name buffer */
	char	tabbuf[100];		/* holds tabs for commands */
	char	tempbuf[100];		/* text buffer */
	i4	seq;			/* sequence number for commands */
	QUR	*qur;			/* a .QUERY line */
	SORT	*srt;			/* a .SORT line */
	ACT	*act;			/* and ACTION line */
	RTEXT	*rtext,*trtext;		/* RTEXT for this command */
	RCMD_REC old;			/* to hold old type of command */
	bool	inprint = FALSE;	/* .PRINT in effect */
	bool	inif = FALSE;		/* .IF ...  or .ELSEIF ...  in effect */
	bool	inlet = FALSE;		/* .LET in effect */
	RTEXT	*r_gt_rtext();
	ACT	*r_gch_act();
	char	*lrp;
	char	*tbp;
	char	*tbpend;
	char	*lrspace;
	char	*tbspace;
	char	*delim;
	char	**brk;
	char	longrem[OOLONGREMSIZE+1];
	bool	first_declared = FALSE;
	DCL	*dcl;
	SC	*sc_ptr;		/* Setup and cleanup structure pointer*/
	char 	*textptr;
	char	unrml_buf[(FE_UNRML_MAXNAME + 1)];


	/* start of routine */

	if (ren == (REN *)NULL)
	{
		return(FALSE);
	}

	/*
	** reset global variables
	*/
	r_reset(RP_RESET_RELMEM4,RP_RESET_RELMEM5,RP_RESET_LIST_END);
	s_reset(RP_RESET_REPORT,RP_RESET_LIST_END);

#ifdef IBM
	/*
	**    Make sure we don't put in carriage control under IBM
	*/
	St_ff_on = FALSE;
#endif
	/* Read in the report specifications */

	env_setup(ren);
	r_rco_set();

	/* Write out the heading for the file */

	r_wrt_eol(unit,ERx(""),(LN *)NULL);	     /* only a blank line */
	r_wrt(unit,ERx("/"),1);
	r_wrt_eol(unit,ERx("*"),(LN *)NULL);
	STprintf(tbuffer,ERget(F_RC0001_Report_name_comment),ren->ren_report);
	r_wrt_eol(unit,tbuffer,(LN *)NULL);
	r_wrt_eol(unit,ERx("**"),(LN *)NULL);
	STprintf(tbuffer,ERget(F_RC0002_Last_Modified_comment),
		 ren->ren_modified);
	r_wrt_eol(unit,tbuffer,(LN *)NULL);
	STprintf(tbuffer,ERget(F_RC0003_Level_comment),ren->ren_level);
	r_wrt_eol(unit,tbuffer,(LN *)NULL);
	r_wrt(unit,ERx("*"),1);
	r_wrt_eol(unit,ERx("/"),(LN *)NULL);
	r_wrt_eol(unit,ERx(""),(LN *)NULL);

	/* Now write out some of the commands */

	STprintf(tbuffer,ERx(".NAME\t%s"),ren->ren_report);
	if ((STcompare(ren->ren_type,ERx("f"))==0) && makecopy)
	{	/* Write of forms report */
		STcat(tbuffer,ERx(" form"));
	}
	r_wrt_eol(unit,tbuffer,(LN *)NULL);

	if ((ren->ren_shortrem != NULL) &&
	    (STcompare(ren->ren_shortrem, ERx("")) != 0))
	{	/* .SHORTREMARK specified */
		STprintf(tbuffer, ERx(".SHORTREMARK\t%s"), ren->ren_shortrem);
		r_wrt_eol(unit, tbuffer,(LN *)NULL);
	}

	if (OOrd_seqText(ren->ren_id, longrem, _ii_longremarks, _long_remark)
			== 0)
	{
		return FALSE;
	}

	if (STcompare(longrem, ERx("")) != 0)
	{
		r_wrt_eol(unit, ERx(".LONGREMARK"),(LN *)NULL);

		tbpend = tbuffer + 80;
		tbp = tbuffer;
		for (lrp = longrem; *lrp; )
		{
			if (CMspace(lrp))
			{
				lrspace = lrp;
				tbspace = tbp;
			}

			if (tbp < tbpend)
			{
				CMcpyinc(lrp, tbp);
			}
			else
			{
				/* if we're in the middle of a word when we
				** hit the right margin, backup to the last
				** space and break the line there.
				*/
				lrp = lrspace;
				CMnext(lrp);
				tbp = tbspace;
				*tbp = EOS;
				r_wrt_eol(unit, tbuffer,(LN *)NULL);
				tbp = tbuffer;
			}
		}
		*tbp = EOS;
		r_wrt_eol(unit, tbuffer,(LN *)NULL);

		r_wrt_eol(unit, ERx(".ENDREMARK"),(LN *)NULL);
	}

	if ( STlength(En_file_name) > 0 )
	{	/* .OUTPUT specified */
		STprintf(tbuffer,ERx(".OUTPUT\t%s"),En_file_name);
		r_wrt_eol(unit,tbuffer,(LN *)NULL);
	}

	if (( STlength(En_pg_width) > 0 ) && St_pgwdth_cmd)
	{	/* 
		** write out .PAGEWIDTH since page width was specified through
		** command, rather than being buried in the query 
		** See file header above for more info(#33894)
		*/
		STprintf(tbuffer,ERx(".PAGEWIDTH\t%s"),En_pg_width);
		r_wrt_eol(unit,tbuffer,(LN *)NULL);
	}

	if  (St_xns_given)
	{
		/*
		** Enable the expanded namespace (delimited identifiers)
		*/
		r_wrt_eol(unit,ERx(".DELIMID"),(LN *)NULL);
	}

	/* SETUP SECTION */
	for (sc_ptr = Ptr_set_top; sc_ptr != (SC *)NULL;
	     sc_ptr = sc_ptr->sc_below)
	{
		if( sc_ptr == Ptr_set_top )
		{
			r_wrt_eol(unit, ERx(".SETUP"),(LN *)NULL);
		}
		STprintf(tbuffer,ERx("\t%s"), sc_ptr->sc_text);
		r_wrt_eol(unit, tbuffer,(LN *)NULL);
	}

	for (dcl = Ptr_dcl_top; dcl != (DCL *)NULL; dcl = dcl->dcl_below)
	{
		/* .DECLARE specified */
		if (!first_declared)
		{
			STcopy(ERx(".DECLARE"), tbuffer);
			first_declared = TRUE;
		}
		else
		{
			STcat(tbuffer, ERx(","));
		}
		r_wrt_eol(unit, tbuffer,(LN *)NULL);
		STcopy(ERx("\t"), tbuffer);

		STcat(tbuffer, dcl->dcl_name);
		STcat(tbuffer, ERx(" = "));
		STcat(tbuffer, dcl->dcl_datatype);

		if (dcl->dcl_below != (DCL *)NULL &&
		    STcompare(dcl->dcl_below->dcl_name, dcl->dcl_name) == 0)
		{
			/* declaration continued for this variable */
			r_wrt_eol(unit, tbuffer,(LN *)NULL);
			STcopy(ERx("\t\t"), tbuffer);
			dcl = dcl->dcl_below;
			STcat(tbuffer, dcl->dcl_datatype);
		}
	}
	if (first_declared)
	{
		r_wrt_eol(unit, tbuffer,(LN *)NULL);
	}

	if (ren->ren_qcount == 0)
	{	/* no query.  Only data command */
		STprintf(tbuffer,ERx(".DATA\t%s"),En_ferslv.name);
		r_wrt_eol(unit,tbuffer,(LN *)NULL);
	}
	else
	{	/* Query specified */
		r_wrt_eol(unit,ERx(".QUERY"),(LN *)NULL);
		(old.b_sect)[0] = '\0';
		for(seq=1,qur=Ptr_qur_arr; seq<=ren->ren_qcount; seq++,qur++)
		{	/* next command */
			CVlower(qur->qur_section);
			if (STcompare(qur->qur_section,NAM_RANGE) == 0)
			{	/* RANGE statement */
				STprintf(tbuffer,ERx("\tRANGE OF %s IS %s"),
					qur->qur_attid,qur->qur_text);
				r_wrt_eol(unit,tbuffer,(LN *)NULL);
			}
			else if (STcompare(qur->qur_section,NAM_TLIST) == 0)
			{	/* piece of the target list */
				if (STcompare(qur->qur_section,old.b_sect) != 0)
				{	/* first in Target list */
					if ( En_qlang == FEDMLSQL )
					{
						r_wrt(unit,ERx("\tSELECT "),8);
					}
					else
					{
						r_wrt(unit,ERx("\tRETRIEVE "),
						      10);
					}
					/* bug 40655 - and bug 46249 */
					if (qur->qur_attid != NULL)
					{
						r_wrt (unit,qur->qur_attid,
						      STlength(qur->qur_attid));
					   	r_wrt (unit, ERx (" "),1);
					}
					/* end, bug 40655 */
					if  (En_qlang == FEDMLQUEL)
					{
						/* Only put the parens on first
						** in TLIST! Fixes bug 43337.
						*/
						r_wrt (unit, ERx("("),1);
					}
				}
				else
				{
					r_wrt_eol(unit,ERx(""),(LN *)NULL);
					r_wrt(unit,ERx("\t\t"),2);
				}
				r_wrt (unit,qur->qur_text,
				       STlength(qur->qur_text));
			}
			else if (STcompare(qur->qur_section,NAM_FROM) == 0)
			{
				if (STcompare(qur->qur_section,old.b_sect) != 0)
				{	/* first in FROM clause (sql) */
					r_wrt_eol(unit,ERx(""),(LN *)NULL);
					r_wrt(unit,ERx("\tFROM\t"),6);
				}
				STprintf(tbuffer,ERx("%s"), qur->qur_text);
				r_wrt(unit, tbuffer, STlength(tbuffer));
			}
			else if (STcompare(qur->qur_section,NAM_WHERE) == 0)
			{	/* piece of the where clause */
				if (STcompare(qur->qur_section,old.b_sect) != 0)
				{	/* first in WHERE clause */
					if ( En_qlang == FEDMLQUEL )
					{ /* if QUEL, end the target list */
						r_wrt_eol(unit,ERx(")"),
							  (LN *)NULL);
					}
					else
					{ /* if SQL, end the FROM clause */
						r_wrt_eol(unit,ERx(""),
							  (LN *)NULL);
					}
					r_wrt(unit,ERx("\tWHERE\t"),7);
				}
				else
				{
					r_wrt(unit,ERx("\t\t"),2);
				}
				r_wrt_eol(unit,qur->qur_text,(LN *)NULL);
			}
 			else if (STcompare(qur->qur_section,NAM_REMAINDER) == 0)
 			{	/* remainder of query */
 				if (STcompare(qur->qur_section,old.b_sect) != 0)
 				{	/* first in WHERE clause */
 					if ( En_qlang == FEDMLQUEL )
 					{ /* if QUEL, end the target list */
 						r_wrt_eol(unit,ERx(")"),
							  (LN *)NULL);
 					}
 					else
 					{ /* if SQL, end the FROM clause */
 						r_wrt_eol(unit,ERx(""),
							  (LN *)NULL);
 					}
 					r_wrt(unit,ERx("\t"),1);
 				}
 				else
 				{
 					r_wrt(unit,ERx("\t\t"),2);
 				}
 				r_wrt_eol(unit,qur->qur_text,(LN *)NULL);
 			}
 
			STcopy (qur->qur_section,old.b_sect);
		}

		if (STcompare(old.b_sect, NAM_TLIST) == 0)
		{
			r_wrt_eol(unit,ERx(")"),(LN *)NULL);
		}

		if (STcompare(old.b_sect, NAM_FROM) == 0)
		{
			r_wrt_eol(unit,ERx(""),(LN *)NULL);
		}
		/* 
		** Put page width in comments IF was NOT set using the 
		** .PAGEWIDTH command.  See file header above for more 
		** info(#33894)
		** Fixed to compare against the initial char of En_pg_width
		** instead of the effective pointer value.
		*/
		if ((En_pg_width[0] != '\0') && !St_pgwdth_cmd)
		{
			STprintf(tbuffer,ERx("/* WIDTH  %s"), En_pg_width);
 			r_wrt(unit,ERx("\t\t"),2);
			r_wrt_eol (unit,tbuffer,(LN *)NULL);

 			r_wrt(unit,ERx("\t\t"),2);
			r_wrt_eol (unit,ERget(E_RW1413_do_not_modify),
				   (LN *)NULL);

 			r_wrt(unit,ERx("\t\t"),2);
			r_wrt_eol (unit,ERx("*/"),(LN *)NULL);
			
		}
	}

	/* Now the SORT list */

	for (seq=1,srt=Ptr_sort_top; seq<=ren->ren_scount; seq++,srt++)
	{
		if (seq == 1)
		{
			r_wrt(unit,ERx(".SORT\t"),6);
		}
		else
		{
			r_wrt(unit,ERx("\t,"),2);
		}
		/*
		** Watch out for parameters!
		*/
		if  (*srt->sort_attid != ERx('$'))
		{
			IIUGxri_id(srt->sort_attid,&unrml_buf[0]);
		}
		else
		{
			STcopy(srt->sort_attid,&unrml_buf[0]);
		}
		if (STlength(srt->sort_direct) < 1)
		{
			STprintf(tbuffer,ERx("%s"),&unrml_buf[0]);
		}
		else
		{
			STprintf(tbuffer,ERx("%s : %s"),&unrml_buf[0],
				 srt->sort_direct);
		}
		r_wrt_eol(unit,tbuffer,(LN *)NULL);
	}

	/* Now the BREAK list */

	for (seq = 1, brk = Ptr_break_top; seq <= ren->ren_bcount; seq++, brk++)
	{
		if (seq == 1)
		{
			r_wrt(unit,ERx(".BREAK\t"),7);
		}
		else
		{
			r_wrt(unit,ERx("\t,"),2);
		}

		/*
		** Watch out for parameters!
		*/
		if  (**brk != ERx('$'))
		{
			IIUGxri_id(*brk,&unrml_buf[0]);
			STprintf(tbuffer,ERx("%s"), &unrml_buf[0]);
		}
		else
		{
			STprintf(tbuffer,ERx("%s"), *brk);
		}
		r_wrt_eol(unit,tbuffer,(LN *)NULL);
	}

	/* Now write out the action lines */

	(old.b_sect)[0] = '\0';		/* will find changes in sections */
	(old.b_attid)[0] = '\0';	/* will find changes in sections */
	STcopy(ERx("\t"), tabbuf);

	for (act = r_gch_act((i2)1,(i4)1); act != (ACT *)NULL;
	     act = r_gch_act((i2)0,(i4)1))
	{
		CVlower(act->act_section);
		CVlower(act->act_command);
		if ((STcompare(old.b_sect,act->act_section)!=0) ||
		    (STcompare(old.b_attid,act->act_attid)!=0))
		{	/* new section in the report */
			inprint = FALSE;
			STcopy(ERx("\t"), tabbuf);
			STcopy(act->act_section,old.b_sect);
			STcopy(act->act_attid,old.b_attid);

     			/* put in a blank line */
			r_wrt_eol(unit,ERx(""),(LN *)NULL);

			if (STcompare(old.b_attid,NAM_DETAIL) == 0)
			{	/* .DETAIL section */
				STprintf(tbuffer,ERx(".DETAIL"));
			}
			else if (STcompare(old.b_sect,B_HEADER) == 0)
			{	/* .HEADER */
				/* Bug 85471
				** Watch out for parameters!
				*/
				if  (old.b_attid[0] != ERx('$'))
				{
					IIUGxri_id(old.b_attid,&unrml_buf[0]);
					STprintf(tbuffer,ERx(".HEADER\t%s"), &unrml_buf[0]);
				}
				else
				{
					STprintf(tbuffer,ERx(".HEADER\t%s"), old.b_attid);
				}
			}
			else
			{	/* .FOOTER */
				/* Bug 85471
				** Watch out for parameters!
				*/
				if  (old.b_attid[0] != ERx('$'))
				{
					IIUGxri_id(old.b_attid,&unrml_buf[0]);
					STprintf(tbuffer,ERx(".FOOTER\t%s"), &unrml_buf[0]);
				}
				else
				{
					STprintf(tbuffer,ERx(".FOOTER\t%s"), old.b_attid);
				}
			}
			r_wrt_eol(unit,tbuffer,(LN *)NULL);
		}
		rtext = r_gt_rtext(act->act_command);
		if (rtext == (RTEXT *)NULL)
		{
			continue;		/* can't recognize command */
		}

		STcopy(ERx("."), cbuffer);
		STcat(cbuffer,act->act_command);
		CVupper(cbuffer);
		STcopy(tabbuf, tbuffer);

		switch (rtext->rt_type)
		{
			case (RX_BEGIN):
				/*
				** RBF stores the agg # with the RBFAGGS
				** text so we need to strip it for r_gt_rtext.
				*/
				STcopy(act->act_text, tempbuf);
				delim = STindex(tempbuf, ERx(" "), 0);
				if (delim)
					*delim = '\0';
				delim = STindex(tempbuf, ERx(","), 0);
				if (delim)
					*delim = '\0';
				trtext = r_gt_rtext(tempbuf);
				if ((trtext != (RTEXT *)NULL) &&
				    (trtext->rt_type==RX_RBF) &&
				    (!makecopy))
				{	/* don't write RBF commands */
					continue;
				}
				/*
				** RBF may store the type and name 
				** of the data source. Don't capitalize 
				** it. It starts with a ',' after a 
				** RBFSETUP:
				*/
				textptr = act->act_text;
				while (*textptr != EOS && *textptr != ',')
				{
					CMtoupper(textptr, textptr);
					_VOID_ CMnext(textptr);
				}
				cr_tab(tabbuf,1);
				break;

			case (RX_END):
				trtext = r_gt_rtext(act->act_text);
				if ((trtext != (RTEXT *)NULL) &&
				    (trtext->rt_type==RX_RBF) &&
				    (!makecopy))
				{	/* don't write RBF commands */
					continue;
				}
				CVupper(act->act_text);
				cr_tab(tabbuf,-1);
				cr_tab(tbuffer,-1);	/* even for cur cmd */
				break;

			case (RX_RTAB):
				cr_tab(tabbuf,1);
				break;

			case (RX_LTAB):
				cr_tab(tabbuf,-1);
				cr_tab(tbuffer,-1);	/* also current */
				break;

			case (RX_IF):
				if (inif)
				{	/* skip the command name */
					r_wrt_eol(unit,ERx(""),(LN *)NULL);
					STcopy(ERx("\t"), cbuffer);
				}
				r_wrt(unit,tbuffer,STlength(tbuffer));
				STprintf(tbuffer,ERx("%s %s"),cbuffer,
					 act->act_text);
				r_wrt(unit,tbuffer,STlength(tbuffer));
				inif = TRUE;
				continue;

			case (RX_ELSEIF):
				if (!inif)
				{
					cr_tab(tabbuf,-1);
					cr_tab(tbuffer,-1);
					inif = TRUE;
				}
				else
				{	/* skip the command name */
					r_wrt_eol(unit,ERx(""),(LN *)NULL);
					STcopy(ERx("\t"), cbuffer);
				}
				r_wrt(unit,tbuffer,STlength(tbuffer));
				STprintf(tbuffer,ERx("%s %s"),cbuffer,
					 act->act_text);
				r_wrt(unit,tbuffer,STlength(tbuffer));
				continue;

			case (RX_THEN):
				cr_tab(tabbuf, 1);
				STprintf(tbuffer,ERx(" %s"),cbuffer);
				r_wrt_eol(unit,tbuffer,(LN *)NULL);
				inif = FALSE;
				continue;

			case (RX_LRTAB):	
				/*
				** like doing a left tab followed by a
				** right tab
				 */
				cr_tab(tbuffer,-1);	/* for current only */
				break;

			case (RX_PRINT):
				if (inprint)
				{	/* skip the command name */
					STcopy(ERx("\t"), cbuffer);
				}
				inprint = TRUE;
				break;

			case (RX_EPRINT):
				if (!inprint)
				{
					return (FALSE);
				}
				inprint = FALSE;
				continue;

			case (RX_RBF):
				if (!makecopy)
				{
					continue;
				}
				cr_tab(tabbuf,1);
				break;

			case (RX_LET):
				if (inlet)
				{	/* skip the command name */
					STcopy(ERx("\t"), cbuffer);
				}
				inlet = TRUE;
				break;

			case (RX_ELET):
				if (!inlet)
				{
					return (FALSE);
				}
				inlet = FALSE;
				continue;

			default:
				break;

		}

		r_wrt(unit,tbuffer,STlength(tbuffer));
		STprintf(tbuffer,ERx("%s %s"),cbuffer,act->act_text);
		r_wrt_eol(unit,tbuffer,(LN *)NULL);
	}
	r_wrt_eol(unit,ERx(""),(LN *)NULL);	     /* one extra line */

	/* CLEANUP SECTION */
	for (sc_ptr = Ptr_clean_top; sc_ptr != (SC *)NULL;
	     sc_ptr = sc_ptr->sc_below)
	{
		if( sc_ptr == Ptr_clean_top )
		{
			r_wrt_eol(unit, ERx(".CLEANUP"),(LN *)NULL);
		}
		STprintf(tbuffer,ERx("\t%s"), sc_ptr->sc_text);
		r_wrt_eol(unit, tbuffer,(LN *)NULL);
	}
	r_wrt_eol(unit,ERx(""),(LN *)NULL);	     /* one extra line */

	return (TRUE);
}




/*
**   CR_TAB - add a tab, or delete a tab from the buffer.
**
**	Parameters:
**		buffer address containing tabs.
**		number or tabs to add or delete.
**
**	Returns:
**		none.
*/

static
VOID
cr_tab(buf,ntabs)
char	*buf;
i4	ntabs;
{
	for(; ntabs > 0; ntabs--)
	{	/* add tabs */
		STcat(buf,ERx("\t"));
	}

	for(; ntabs < 0; ntabs++)
	{
		if (STlength(buf) > 0)
		{	/* must have at least one */
			buf[STlength(buf)-1] = '\0';
		}
	}

	return;
}

/*
**	env_setup utility gets report writer environment variables
**	to agree with ren argument.  Mimics r_env_set in a lot of ways,
**	except it doen't allocate space, or call r_chk_rep which has
**	already been done.  It might be better to fix up r_env_set to have
**	an argument which would be NULL if it is to allocate space, or a
**	REN structure to point En_ren to as is done here.  Would have to
**	be coordinated with rbf and report writer.
*/

static
VOID
env_setup (ren)
REN *ren;
{
	En_ren = ren;

	En_rep_owner = En_ren->ren_owner;
	En_acount = En_ren->ren_acount;
	En_qcount = En_ren->ren_qcount;
	En_scount = En_ren->ren_scount;
	En_bcount = En_ren->ren_bcount;
	En_rtype = *(En_ren->ren_type);

	return;
}
