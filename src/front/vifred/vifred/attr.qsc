/*
**  Copyright (c) 2004 Ingres Corporation
*/

/*
** ATTR.QSC
** code to get values from the attribute form
**
** History:
**	01/16/85 (drh)	Modified to eliminate MEfree of fld1list and pslist1,
**			since these are now allocated and freed by tag.
**	02/04/85 (drh)	Added Dave H.'s bug fixes from VMS.
**	06/27/85 (gac)	Replaced sleeped messages by FEmsg.
**	07/18/85 (dkh)	Added changes for international support.  Checking
**			to make sure internal field names are 7 bit ascii.
**	08/19/85 (dkh)	Added support for new field attributes.
**	01/20/86 (prs)	Change "color" title to "Color"
**	03/23/87 (dkh) -Added support for ADTs.
**	03/27/87 (dkh) -Added datatype editing support.
**	10/20/86 (KY)  -- Changed CH.h to CM.h.
**	01/13/87 (wolf) Drop CMS support of NoAutoTab attribute(part of
**			fix for bug #10816)
**	05/06/87 (dkh) - Take away include of afe.h, done by decls.h.
**	08-may-87 (bruceb)
**		Rather than clear fhdflags to 0, set it to the previous
**		value of the fdREVDIR bit.  This has the same effect as
**		clearing to 0, but without the additional result of losing
**		any other bits set in fhdflags prior to editing the
**		attributes.
**	06/30/87 (dkh) - Fix for jup bug 377.
**	13-jul-87 (bruceb) Changed calls on allocArr() to return a PTR (for DG.)
**	08/04/87 (dkh) - Changed to use compiled forms in a file.
**	08/08/87 (dkh) - Usability changes for editing datatypes/formats.
**	08/14/87 (dkh) - ER changes.
**	08/28/87 (dkh) - Fixed buffer size to use FE_MAXNAME.
**	11-sep-87 (bruceb)
**		Changed cast in call on FDfind from char** to nat**.
**	10/02/87 (dkh) - Help file changes.
**	09-nov-87 (bruceb)
**		Code added to allow internal version of scrolling
**		field interface.  This includes IIVFsflScrollFld,
**		internal routine dw_isok, and code dealing with
**		the proper display of the 'Scrolling Data Width'
**		field.
**	10/25/87 (dkh) - Error message cleanup.
**	12/16/87 (dkh) - Fixed jup bug 1609.
**	11-jan-88 (sylviap)
**		Created the .qsc file.
**	09-feb-88 (bruceb)
**		fdSCRLFD no longer referenced through fhdflags; use of
**		the most significant bit of fhdflags caused problems.
**	04/09/88 (dkh) - Integrated a 5.0 bug fix.
**	05/18/88 (dkh) - Added user support for scrollable fields.
**	05/26/88 (dkh) - Cleaned up code.
**	05/26/88 (dkh) - Added additional code to disallow scrolling fields
**			 if attributes DISPLAY ONLY or NO ECHO are also set.
**	06/22/88 (dkh) - Fixed venus bug 2810.
**	08/30/88 (dkh) - Fixed venus bug 3287 & 3288.
**	16-dec-88 (bruceb)
**		Added fdREADONLY and fdINVISIBLE attributes.  Additionally,
**		code modified to expect that no non-sequence fields or
**		fdtfCOLREAD attributes exist (both entities will be folded
**		on top of fdREADONLY at VIFRED startup).  It follows that
**		any form saved in VIFRED will have 'no' non-sequence fields.
**	12/31/88 (dkh) - Perf changes.
**	01/30/89 (dkh) - Integrated CMS changes.
**	02/18/89 (dkh) - Yet more changes for performance.
**	21-mar-89 (bruceb)
**		In attrinit(), use hdr->fhdflags for setting the color,
**		rather than the potentially uninitialized 'flags'.
**	05-apr-89 (bruceb)
**		Use invisible fields rather than query/fill modes.  Made
**		scrollsz field a numeric rather than char field.  Made
**		corresponding changes to the vifattr form.  Only visual
**		change is that scrollsz field will display a 0 rather than
**		blank space as the default.
**		Also, removed IIVFirtInternalRTI and IIVFsflScrollFld();
**		no longer used.
**		Also, no longer modify activate(previousfield); set
**		properly in FEforms().
**	07-apr-89 (bruceb)
**		Retain fdVQLOCK setting in fhd2flags.  If so locked, make
**		datatype and name fields displayonly.
**	20-jun-89 (bruceb)
**		Modified to use two forms for editing attributes:  vifattr
**		and vifvalder (validation string/derivation formula.)
**		Valstr and valmsg made scrollable with fully visible versions
**		available on the vifvalder form.
**	06/23/89 (dkh) - Fixed bug 6745.
**	08/03/89 (dkh) - Updated with interface change to adc_lenchk().
**	11-sep-89 (bruceb)
**		Added invisible table field columns.  If all columns for a
**		table field are made invisible, make the table field invisible.
**	05-dec-89 (bruceb)
**		Derivation formula/validation string field now is modified
**		when the derived (y/n) response is changed.  No longer
**		continue to display the prior contents on the off chance of
**		a user error.
**	01/24/90 (dkh) - Moved include of er.h ahead of uf.h due to changes
**			 in uf.h.
**	01/30/90 (dkh) - Added fix to get around cpp problem with comments.
**	04/18/90 (dkh) - Integrated IBM porting changes.
**	18-apr-90 (bruceb)
**		Lint cleanup; removed 'hdr' arg from vfputdtype.
**      06/09/90 (esd) - Check IIVFsfaSpaceForAttr instead of
**                       calling FTspace, so that whether or not
**                       to leave room for attribute bytes can be
**                       controlled on a form-by-form basis.
**      06/12/90 (esd) - Tighten up the meaning of the global variable
**                       endxFrm.  In the past, it was usually (but
**                       not always) assumed that in a 3270 environment,
**                       the form included a blank column on the right,
**                       so that endxFrm was the 0-relative column
**                       number of that blank column at the right edge.
**                       I am removing that assumption:  endxFrm will
**                       now typically be the 0-relative column number
**                       of the rightmost column containing a feature.
**      06/12/90 (esd) - When boxing a field on a 3270, leave space
**                       for an attribute between the box and title/data
**                       on the left as well as the right (bug 21618).
**      06/12/90 (esd) - When boxing or unboxing a field, set new member
**                       ps_attr of POS structure appropriately.
**	09/07/90 (dkh) - Fixed nattrCom() so that if the form started with
**			 an empty name or datatype (or both), then one can
**			 still exit with the "End" menuitem/frskey.
**	10/26/90 (dkh) - Put in fix to make sure attributes for derived
**			 fields aren't lost when the field is edited.
**	12/05/90 (dkh) - Fixed typo to do bit manipulation correctly.
**	04/06/91 (dkh) - Fixed double byte handling in error handler.
**	08/02/91 (dkh) - Fixed bug 38378.  The code now checks to make
**			 sure the Query Only attribute is disallowed for
**			 derived fields.
**	06/17/92 (dkh) - Added support for decimal datatype for 6.5.
**	12/12/92 (dkh) - Added ability to toggle use of input masks.
**	04/15/93 (dkh) - Fixed bug 50604.  Screened out unsupported
**			 datatypes by calling IIAFfedatatype().
**      07/06/99 (hweho01) 
**              Added function prototype of allocArr().
**              Without the explicit declaration, the default int return
**              value for a function will truncate a 64-bit address 
**              on ris_u64 platform.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	15-Oct-2007 (kibro01) b119305
**	    Add in list choices for data type
**	21-Aug-2009 (kschendel/stephenb) 121804
**	    Need frame.h to satisfy gcc 4.3.  Add some more declarations.
**	24-Feb-2010 (frima01) Bug 122490
**	    Update return types and add header files as neccessary
**	    to eliminate gcc 4.3 warnings.
*/
# include	<compat.h>
# include	<cv.h>		/* 6-x_PC_80x86 */
# include	<st.h>		/* 6-x_PC_80x86 */
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<fe.h>
# include	"decls.h"
# include	"vfunique.h"
# include	<cm.h>
# include	<lo.h>
# include	<si.h>
# include	<er.h>
# include	<fedml.h>
# include	<uf.h>
# include	<ug.h>
# include	"ervf.h"
# include	"vfhlp.h"
# include	<frame.h>

# define	RMAXATTR	15
# define	TFMAXATTR	13

/*
**  These two defines should be in a header file
*/
# define	NEXT		0
# define	PREVIOUS	1

typedef struct attribs
{
	i4	attribute;
	char	*name;
	bool	use_fhd2flags;
} ATTRIBS;

static	char	curname[FE_MAXNAME + 1] = {0};

static	FRAME		*vfattr = NULL;
static	DB_USER_TYPE	attrdtype = {0};
static	i4		vfdml = FEDMLQUEL;

static ATTRIBS	attrflag[RMAXATTR] =
{
	{fdBOXFLD,	(char *)NULL,	(bool)0},
	{fdKPREV,	(char *)NULL,	(bool)0},
	{fdMAND,	(char *)NULL,	(bool)0},
	{fdRVVID,	(char *)NULL,	(bool)0},
	{fdBLINK,	(char *)NULL,	(bool)0},
	{fdUNLN,	(char *)NULL,	(bool)0},
	{fdCHGINT,	(char *)NULL,	(bool)0},
	{fdQUERYONLY,	(char *)NULL,	(bool)0},
	{fdLOWCASE,	(char *)NULL,	(bool)0},
	{fdUPCASE,	(char *)NULL,	(bool)0},
	{fdNOAUTOTAB,	(char *)NULL,	(bool)0},
	{fdNOECHO,	(char *)NULL,	(bool)0},
	{fdREADONLY,	(char *)NULL,	(bool)1},
	{fdINVISIBLE,	(char *)NULL,	(bool)0},
	{fdEMASK,	(char *)NULL,	(bool)1}
};

static ATTRIBS	tfattrflag[TFMAXATTR] =
{
	{fdMAND,	(char *)NULL,	(bool)0},
	{fdRVVID,	(char *)NULL,	(bool)0},
	{fdBLINK,	(char *)NULL,	(bool)0},
	{fdUNLN,	(char *)NULL,	(bool)0},
	{fdCHGINT,	(char *)NULL,	(bool)0},
	{fdQUERYONLY,	(char *)NULL,	(bool)0},
	{fdLOWCASE,	(char *)NULL,	(bool)0},
	{fdUPCASE,	(char *)NULL,	(bool)0},
	{fdNOAUTOTAB,	(char *)NULL,	(bool)0},
	{fdNOECHO,	(char *)NULL,	(bool)0},
	{fdREADONLY,	(char *)NULL,	(bool)1},
	{fdINVISIBLE,	(char *)NULL,	(bool)0},
	{fdEMASK,	(char *)NULL,	(bool)1}
};

static	FIELD	**fld1list = NULL;
static	FIELD	**fld2list = NULL;
static	FIELD	**fld3list = NULL;
static	POS	**pslist1 = NULL;
static	POS	**pslist2 = NULL;
static	POS	**pslist3 = NULL;
static	i4	atcurfld = 0;
static	i4	attotflds = 0;
static	FLDHDR	*colorhdr = NULL;
static	i4	colorseq = 0;

static	bool	scrlfld = FALSE;	/* is current field scrollable */
static	bool	form_alloced = FALSE;

static	bool	can_scroll = FALSE;	/* field is potentially scrollable */
static	i4	scrsize = 0;		/* Real scroll length of field */
static	bool	was_chartype = FALSE;	/* was previous datatype a string */
static	i4	fmt_length = 0;		/* Length of format */

static	bool	der_fld = FALSE;

FUNC_EXTERN	i4	FTspace();
FUNC_EXTERN	void	vfdelnm();
FUNC_EXTERN	i4	vfnmunique();
FUNC_EXTERN	i4	nxtfattr();
FUNC_EXTERN	FIELD	*FDfind();
FUNC_EXTERN	FLDHDR	*IIFDgfhGetFldHdr();
FUNC_EXTERN	STATUS	afe_vtyoutput();
FUNC_EXTERN	STATUS	afe_vtychk();
FUNC_EXTERN	STATUS	fmt_vfvalid();
FUNC_EXTERN	STATUS	fmt_ftot();
FUNC_EXTERN	char	*saveStr();
FUNC_EXTERN	VOID	IIAFddcDetermineDatatypeClass();
FUNC_EXTERN	bool	fmt_justify();
FUNC_EXTERN     PTR     allocArr();

char		*flgToChar();
VOID		charToFlag();

static	bool	scr_check();
static	VOID	valderhdlr();


# ifndef FORRBF
VOID
allocAttr()
{
    REGFLD	*dummy;
    FIELD	*fld;
    FRAME	*tframe;
    i4		lang;

    if (form_alloced)
    {
	return;
    }

    FDsetparse(FALSE);

    if (IIUFgtfGetForm(IIUFlcfLocateForm(), ERx("vifattr")) != OK)
    {
	syserr(ERget(S_VF0001_Can_not_access_form), ERx("vifattr"));
    }
    if (IIUFgtfGetForm(IIUFlcfLocateForm(), ERx("vifvalder")) != OK)
    {
	syserr(ERget(S_VF0001_Can_not_access_form), ERx("vifvalder"));
    }

    FDsetparse(TRUE);

    /*
    **  Workaround to get things running.  Not sure why this
    **  is needed.
    */
    tframe = IIfindfrm(ERx("vifattr"));
    fld = FDfind((i4 **)tframe->frfld, ERx("colortitle"),
	tframe->frfldno, IIFDgfhGetFldHdr);
    colorseq = FDgtfldno(FT_UPDATE, tframe, fld, &dummy);
    colorhdr = FDgethdr(fld);

    vfattr = tframe;
    attrflag[0].name = ERget(F_VF0001_Box_Field);
    attrflag[1].name = ERget(F_VF0002_Keep_Previous_Value);
    attrflag[2].name = tfattrflag[0].name = ERget(F_VF0003_Mandatory_Field);
    attrflag[3].name = tfattrflag[1].name = ERget(F_VF0004_Reverse_Video);
    attrflag[4].name = tfattrflag[2].name = ERget(F_VF0005_Blinking);
    attrflag[5].name = tfattrflag[3].name = ERget(F_VF0006_Underline);
    attrflag[6].name = tfattrflag[4].name = ERget(F_VF0007_Brightness_Change);
    attrflag[7].name = tfattrflag[5].name = ERget(F_VF0008_Query_Only);
    attrflag[8].name = tfattrflag[6].name = ERget(F_VF0009_Force_Lower_Case);
    attrflag[9].name = tfattrflag[7].name = ERget(F_VF000A_Force_Upper_Case);
    attrflag[10].name = tfattrflag[8].name = ERget(F_VF000B_No_Auto_Tab);
    attrflag[11].name = tfattrflag[9].name = ERget(F_VF000C_No_Echo);
    attrflag[12].name = tfattrflag[10].name = ERget(F_VF000D_Display_Only);
    attrflag[13].name = tfattrflag[11].name = ERget(F_VF0068_Invisible);
    attrflag[14].name = tfattrflag[12].name = ERget(F_VF00BF_Input_mask);

    /*
    **  Set up default dm.
    */
    _VOID_ FEdml(&vfdml, &lang);

    form_alloced = TRUE;
}

/*
** tfattr:
**	Routine to handle table field attributes.
*/

VOID
tfattr(col, writeout, tfseq)
FLDCOL	*col;
bool	writeout;
i4	tfseq;
{
	FLDHDR	*hdr;
	FLDTYPE *type;

	allocAttr();

	hdr = &col->flhdr;
	type = &col->fltype;
##	set_frs field vifattr (invisible(defval) = 1)
	attrhandler(hdr, type, writeout, tfseq);
}


/*
** writeout is true if frame is being written out
** only allow changes to validation string
*/
void
attrCom(fd, writeout)
reg	FIELD	*fd;
	bool	writeout;
{
	reg	i4	i;
	reg	VFNODE	**lp;
	reg	VFNODE	*lt;
		FLDHDR	*hdr;
		FLDTYPE *type;
		i4	rfldcount = 0;

	allocAttr();

	attotflds = frame->frfldno;
	fld1list = fld2list = (FIELD **)allocArr(attotflds);
	pslist1 = pslist2 = (POS **)allocArr(attotflds);
	lp = line;
	for (i = 0; i < endFrame; i++, lp++)
	{
		for (lt = *lp; lt != NNIL; lt = vflnNext(lt, i))
		{
			if (lt->nd_pos->ps_begy == i)
			{
				if (lt->nd_pos->ps_name == PFIELD)
				{
				    *fld2list++ = (FIELD *)lt->nd_pos->ps_feat;
				    *pslist2++ = lt->nd_pos;
				    rfldcount++;
				}
			}
		}
	}
	fld3list = --fld2list;
	pslist3 = --pslist2;
	atcurfld = -1;
	fld2list = fld1list;
	pslist2 = pslist1;
	attotflds = rfldcount;
	for (i = 0; i < attotflds; i++)
	{
		if (fd == *fld2list)
		{
			atcurfld = i;
			atcurfld++;
			break;
		}
		else
		{
			fld2list++;
			pslist2++;
		}
	}
	if (atcurfld == -1)
	{
		IIUGerr(E_VF0002_Cant_find_field, UG_ERR_ERROR, 0);
		return;
	}
	hdr = FDgethdr(fd);
	type = FDgettype(fd);
	vfdmpoff();
##	set_frs field vifattr (invisible(defval) = 0)
	attrhandler(hdr, type, writeout, (i4) -1);
}

attrinit(hdr, type, fromtf, colorval, der_buf, val_buf)
FLDHDR	*hdr;
FLDTYPE *type;
bool	fromtf;
i4	*colorval;
char	*der_buf;
char	*val_buf;
{
	i4		flags;
	i4		i;
##	char		*cp;
##	char		*cp2;
##	char		*cp3;
##	char		*iattrptr;
##	char		iuflag[5];
##	i4		attrcolor;
	i4		maxattr;
	ATTRIBS		*attr;
##	char		*lyes1;
##	char		*lno1;
##	i4		scroll_width;
	i4		class;
	i4		x;
	i4		y;
	i4		justify;
	DB_DATA_VALUE	dbv;
	DB_DATA_VALUE	sdbv;

	lyes1 = IIVF_yes1;
	lno1 = IIVF_no1;

	STcopy(hdr->fhdname, curname);

	if (fromtf)
	{
		maxattr = TFMAXATTR;
		attr = tfattrflag;
	}
	else
	{
		maxattr = RMAXATTR;
		attr = attrflag;
	}
##	inittable vifattr vifattr UPDATE
	for (i = 0; i < maxattr; i++, attr++)
	{
		if (attr->use_fhd2flags)
			flags = hdr->fhd2flags;
		else
			flags = hdr->fhdflags;

		/* If derived field, don't show the (internal) disponly flag. */
		if (attr->attribute & fdREADONLY && hdr->fhd2flags & fdDERIVED)
			STcopy(flgToChar(flags, (i4)0), iuflag);
		else
			STcopy(flgToChar(flags, attr->attribute), iuflag);
		iattrptr = attr->name;

##		loadtable vifattr vifattr (attr = iattrptr, sett = iuflag)
	}

	if (hdr->fhd2flags & fdVQLOCK)
	{
##		set_frs field vifattr (displayonly(datatype) = 1,
##			displayonly(name) = 1)
	}
	else
	{
##		set_frs field vifattr (displayonly(datatype) = 0,
##			displayonly(name) = 0)
	}

	/*
	** Check whether this is the proper sort of field for the
	** scrolling attribute (basically, a character field).  This
	** type of check means that on creation of a new regular field,
	** since the datatype is initially unknown, this section will
	** not be triggered.
	*/
	IIAFddcDetermineDatatypeClass(type->ftdatatype, &class);
	if (type->ftfmt)
	{
		_VOID_ fmt_size(FEadfcb(), type->ftfmt, NULL, &y, &x);
		justify = fmt_justify(FEadfcb(), type->ftfmt);
		fmt_length = x;
	}
	else
	{
		y = 2;
		justify = TRUE;
		fmt_length = 0;
	}
	can_scroll = FALSE;
	was_chartype = FALSE;
	if (class == CHAR_DTYPE && y == 1 && justify == FALSE)
	{
		can_scroll = TRUE;
		was_chartype = TRUE;
	}
	if (can_scroll)
	{
		/*
		**  If field is already set to be scrollable, set
		**  up special fields for display.
		*/
		if (hdr->fhd2flags & fdSCRLFD)
		{
			dbv.db_datatype = type->ftdatatype;
			dbv.db_length = type->ftlength;
			dbv.db_prec = type->ftprec;
			if (adc_lenchk(FEadfcb(), FALSE, &dbv, &sdbv)
				!= E_DB_OK)
			{
				scroll_width = 0;
			}
			else
			{
				scroll_width = sdbv.db_length;
			}
			scrsize = scroll_width;
##			putform vifattr (scrollable = lyes1,
##				scrollsz = scroll_width)
##			set_frs field vifattr (invisible(scrollable) = 0,
##				invisible(scrollsz) = 0)
			scrlfld = TRUE;		/* this is a scrollable field */
		}
		else
		{
##			putform vifattr(scrollable = lno1, scrollsz = 0)
##			set_frs field vifattr (invisible(scrollable) = 0,
##				invisible(scrollsz) = 1)
			scrlfld = FALSE;
		}
		/*
		** Don't allow scrollable, derived fields; turn off the
		** scrollable flag (since this is really an error condition).
		*/
		if (hdr->fhd2flags & fdDERIVED)
		{
			hdr->fhd2flags &= ~fdSCRLFD;
			scrlfld = FALSE;
##			putform vifattr(scrollable = lno1, scrollsz = 0)
##			set_frs field vifattr (invisible(scrollable) = 1,
##				invisible(scrollsz) = 1)
		}
	}
	else
	{
		scrlfld = FALSE;	/* this is not a scrollable field */
##		putform vifattr(scrollable = lno1, scrollsz = 0)
##		set_frs field vifattr (invisible(scrollable) = 1,
##			invisible(scrollsz) = 1)

		/*
		**  If field is scrollable, things are out of sync.
		**  This can happen if user is editing a table field,
		**  sets scrollability and then later on changes the
		**  format for the column to make it ineligible for
		**  scrollability.  Unset it and put out error message.
		*/
		if (hdr->fhd2flags & fdSCRLFD)
		{
			hdr->fhd2flags &= ~fdSCRLFD;
			IIUGerr(E_VF011B_scroll_sync, UG_ERR_ERROR, 1,
				hdr->fhdname);
		}
	}

	*der_buf = EOS;
	*val_buf = EOS;
	if (hdr->fhd2flags & fdDERIVED)
	{
		der_fld = TRUE;
		cp = IIVF_yes1;
		cp2 = ERget(F_VF0069_Der_Form);
		cp3 = ERget(F_VF006D_ValNotAllowed);
##		set_frs field vifattr (invisible(valmsg) = 1)
##		set_frs field vifvalder (invisible(valmsg) = 1)
##		set_frs field vifattr (invisible(defval) = 1)
	}
	else
	{
		der_fld = FALSE;
		cp = IIVF_no1;
		cp2 = ERget(F_VF006A_Val_Chk);
		cp3 = ERget(F_VF006C_ValAllowed);
##		set_frs field vifattr (invisible(valmsg) = 0)
##		set_frs field vifvalder (invisible(valmsg) = 0)
		if (!fromtf)
##			set_frs field vifattr (invisible(defval) = 0)
	}
##	putform vifattr (derived = cp)
##	putform vifattr (valstrtitle = cp2)
##	putform vifvalder (valstrtitle = cp2)
##	putform vifattr (expl_text = cp3)

	cp = type->ftvalstr;
##	putform vifattr (valstr = cp)

	cp = type->ftvalmsg;
##	putform vifattr (valmsg = cp)

	cp = type->ftdefault;
##	putform vifattr (defval = cp)

	cp = hdr->fhdname;
##	putform vifattr (name = cp)

	attrcolor = vfgetcolor(hdr->fhdflags);
	colorhdr->fhdflags &= ~fdCOLOR;
	colorhdr->fhdflags |= hdr->fhdflags & fdCOLOR;
	*colorval = attrcolor;

##	putform vifattr (color = attrcolor)
##	putform vifattr (colortitle = ERget(F_VF0010_Color))

	FTsetda(vfattr, colorseq, FT_UPDATE, FT_REGFLD, 0, 0,
		colorhdr->fhdflags);
}


vfputdtype(type)
FLDTYPE *type;
{
	DB_DATA_VALUE	dbv;
##	char		*isnull;
##	char		*dtype;

	/*
	**  Decode datatype information and put it into the form.
	**  Also save this in attrdtype so we can put it back
	**  if there is a conflict with the datatype entered by
	**  the user.
	*/
	dtype = attrdtype.dbut_name;
	attrdtype.dbut_kind = DB_UT_NOTNULL;
	if (type->ftdatatype == DB_NODT)
	{
		*dtype = '\0';
	}
	else
	{
		dbv.db_datatype = type->ftdatatype;
		dbv.db_length = type->ftlength;
		dbv.db_prec = type->ftprec;

		if (afe_vtyoutput(FEadfcb(), &dbv, &attrdtype) != OK)
		{
			IIUGerr(E_VF0003_Could_not_decode_data,
				UG_ERR_ERROR, 0);
		}
	}
	/*
	**  Only set the nullable field to "y" if dbut_kind is
	**  set to DB_UT_NULL.	Any other value is treated as
	**  non NULL.
	*/
	if (attrdtype.dbut_kind == DB_UT_NULL)
	{
		isnull = IIVF_yes1;
	}
	else
	{
		isnull = IIVF_no1;
	}
##	putform vifattr (datatype = dtype)
##	putform vifattr (nullable = isnull)
}


/*
** vfretattr:
**	Retrieve attribute information from the form
**	before exiting or going to the next field.
*/

STATUS
vfretattr(nhdr, ntype, oldname, writeout, fromtf)
FLDHDR	*nhdr;
FLDTYPE *ntype;
char	*oldname;
bool	writeout;
bool	fromtf;
##{
##	char		uattr[30];
##	char		uflag[6];
##	i4		acolor;
	i4		i;
##	char		*cptr;
##	char		*cp;
##	char		*no_1;
	char		buf[BUFSIZ];
	SMLFLD		smallfd;
	SMLFLD		*sfd;
	POS		*ps;
	i4		maxattr;
	ATTRIBS		*attr;
	i4		nametype;
	i4		spacesize;
	bool		badattr = FALSE;
	DB_USER_TYPE	usertype;
	DB_DATA_VALUE	dbv;
	bool		valid;
	bool		is_str;
	i4		*flags;		

	spacesize = IIVFsfaSpaceForAttr;

	no_1 = IIVF_no1;

	if (!writeout)
	{
		if (fromtf)
		{
			maxattr = TFMAXATTR;
			attr = tfattrflag;
			nametype = ATBLFD;
		}
		else
		{
			maxattr = RMAXATTR;
			attr = attrflag;
			nametype = AFIELD;
		}
		/*
		** clear all field attributes except those that can
		** obtain values outside of the edit attribute form.
		*/
		nhdr->fhdflags &= fdREVDIR;
		nhdr->fhd2flags &= (fdSCRLFD | fdVQLOCK);
		i = 0;
##		unloadtable vifattr vifattr (uattr = attr, uflag = sett)
##		{
			if (i < maxattr)
			{
				if (attr->use_fhd2flags)
					flags = &nhdr->fhd2flags;
				else
					flags = &nhdr->fhdflags;

				charToFlag(flags, uflag, attr->attribute);
				attr++;
				i++;
			}
			else
			{
##				endloop
			}
##		}

		if ((nhdr->fhd2flags & fdREADONLY)
		    && (nhdr->fhdflags & fdQUERYONLY))
		{
			IIUGerr(E_VF0004_Cant_set_both, UG_ERR_ERROR, 0);
			badattr = TRUE;
		}
		if ((nhdr->fhdflags & fdLOWCASE) && (nhdr->fhdflags & fdUPCASE))
		{
			IIUGerr(E_VF0005_Cant_set_low_up, UG_ERR_ERROR, 0);
			badattr = TRUE;
		}
		if ((nhdr->fhd2flags & fdSCRLFD) && (nhdr->fhdflags & fdNOECHO))
		{
			IIUGerr(E_VF0120_scroll_badattr, UG_ERR_ERROR, 0);
			badattr = TRUE;
		}
		if (badattr)
		{
			return(FAIL);
		}
	}

	cptr = buf;
##	getform vifattr (cptr = valstr)
	ntype->ftvalstr = saveStr(cptr);

##	getform vifattr (uflag = derived)
	charToFlag(&nhdr->fhd2flags, uflag, fdDERIVED);

	if (nhdr->fhd2flags & fdDERIVED)
	{
		if (ntype->ftvalstr[0] == EOS)
		{
			nhdr->fhd2flags &= ~fdDERIVED;
		}
		else if ((nhdr->fhdflags & fdMAND)
			|| (nhdr->fhdflags & fdLOWCASE)
			|| (nhdr->fhdflags & fdUPCASE)
			|| (nhdr->fhdflags & fdQUERYONLY)
			|| (nhdr->fhd2flags & fdREADONLY))	/* User set. */
		{
			IIUGerr(E_VF012C_Cant_set_derived_and, UG_ERR_ERROR, 0);

			/* Turn off the offending attributes. */
			nhdr->fhdflags &= ~(fdMAND | fdLOWCASE | fdUPCASE | fdQUERYONLY);

			/* Turn on the (internal) disponly flag if derived. */
			nhdr->fhd2flags |= fdREADONLY;	/* Internally set. */
		}
		else
		{
			/* Turn on the (internal) disponly flag if derived. */
			nhdr->fhd2flags |= fdREADONLY;	/* Internally set. */
		}
	}

##	getform vifattr (cptr = defval)
	if (nhdr->fhd2flags & fdDERIVED)
	{
		/* No default values for derived fields. */
		cptr[0] = EOS;
	}
	ntype->ftdefault = saveStr(cptr);

##	getform vifattr (acolor = color)
	vfsetcolor(&nhdr->fhdflags, acolor);

	/*
	**  Clear out validation tree pointer in case user
	**  changed a field from writeable to display-only.
	**  Trees will be recreated, if necessary, when form
	**  is written to the database.
	*/
	ntype->ftvalchk = NULL;

##	getform vifattr (cptr = valmsg)
	if (nhdr->fhd2flags & fdDERIVED)
	{
		/* No validation error message for derived fields. */
		cptr[0] = EOS;
	}
	ntype->ftvalmsg = saveStr(cptr);

	/*
	**  Get and check datatype/nullability from form.
	*/
##	getform vifattr (cptr = datatype)
	STcopy(cptr, usertype.dbut_name);

	/*
	**  If from a table field, and the datatype type is
	**  blank and we started with blank, then let user
	**  get out.
	*/
	if (fromtf && *cptr == '\0' && attrdtype.dbut_name[0] == '\0')
	{
		ntype->ftdatatype = DB_NODT;
		ntype->ftlength = 0;
		ntype->ftprec = 0;
		nhdr->fhd2flags &= ~fdSCRLFD;
	}
	else
	{
##		getform vifattr (cptr = nullable)
		CVlower(cptr);
		if (*cptr == *IIVF_yes1)
		{
			usertype.dbut_kind = DB_UT_NULL;
		}
		else
		{
			usertype.dbut_kind = DB_UT_NOTNULL;
		}
		if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
		{
			/*
			**  This should not happen since this check
			**  should have already been done before
			**  this is called.  This call is made
			**  here to get the dbv set up.
			*/
			IIUGerr(E_VF0007_not_valid_datatype, UG_ERR_ERROR,
				1, usertype.dbut_name);
			cp = attrdtype.dbut_name;
			if (*cp != '\0')
			{
##				putform vifattr (datatype = cp)
			}
			return(FAIL);
		}

		/*
		**  Check for compatiblity with the format if we are not
		**  called from table field creation.
		**  Otherwise, assign datatype information for
		**  table field column.
		*/
		if (!fromtf)
		{
			if (fmt_vfvalid(FEadfcb(), ntype->ftfmt, &dbv,
				&valid, &is_str) != OK || !valid)
			{
				IIUGerr(E_VF0008_datatype_not_compat,
					UG_ERR_ERROR, 2,
					usertype.dbut_name, ntype->ftfmtstr);
				cp = attrdtype.dbut_name;
##				putform vifattr (datatype = cp)

				/*
				**  Setup scrollability again if we
				**  came in with scrollability.  All
				**  we need to check is "can_scroll"
				**  since it is set from the datatype
				**  that we are restoring.
				*/
				if (can_scroll && !was_chartype)
				{
##				    putform vifattr (scrollable = no_1,
##					scrollsz = 0)
				    was_chartype = TRUE;
				    if (!(nhdr->fhd2flags & fdDERIVED))
				    {
##					set_frs field vifattr
##						(invisible(scrollable) = 0)
				    }
				}
				return(FAIL);
			}

			/*
			**  If the datatype is decimal, make sure we
			**  pick up the latest precision/scale values.
			**
			**  This is not needed since it is done below.
			**
			if (dbv.db_datatype == DB_DEC_TYPE)
			{
				ntype->ftlength = dbv.db_length;
				ntype->ftprec = dbv.db_prec;
			}
			*/
		}

		ntype->ftdatatype = dbv.db_datatype;
		ntype->ftlength = dbv.db_length;
		ntype->ftprec = dbv.db_prec;

		/*
		**  If called from a table field editing phase,
		**  then need to check if the data length is zero
		**  (set by call to afe_vtychk).  If so, put in
		**  a fake length so that things will still work
		**  if user cycles around to this column again.
		**  This is OK, since data length can only be zero
		**  if the datatype is one of the character ones.
		**  The character data length will be filled in
		**  at table field creation time.
		*/
		if (fromtf && ntype->ftlength == 0)
		{
			if (abs(ntype->ftdatatype) == DB_DEC_TYPE)
			{
				DB_DATA_VALUE	dbv1;
				DB_DATA_VALUE	dbv2;

				dbv1.db_datatype = ntype->ftdatatype;
				dbv1.db_length = DB_PREC_TO_LEN_MACRO(10);
				dbv1.db_prec = DB_PS_ENCODE_MACRO(10, 0);
				(void)adc_lenchk(FEadfcb(), TRUE, &dbv1, &dbv2);
				ntype->ftlength = dbv2.db_length;
				ntype->ftprec = dbv1.db_prec;
			}
			else
			{
				ntype->ftlength = 10;
			}
		}
	}

	cptr = nhdr->fhdname;
##	getform vifattr (cptr = name)
	if (STcompare(oldname, cptr) != 0 &&
		!vffnmchk(cptr, ERget(F_VF0011_field)))
	{
		return(FAIL);
	}

	CVlower(nhdr->fhdname);
	/*
	**  Fix for jup bug 377. (dkh)
	*/
	if (STbcompare(nhdr->fhdname, 0, curname, 0, TRUE) != 0)
	{
		if (vfnmunique(nhdr->fhdname, TRUE, nametype) != FOUND)
		{
			vfdelnm(curname, nametype);
		}
		else
		{
			IIUGerr(E_VF000A_internal_name_exists, UG_ERR_ERROR,
				1, nhdr->fhdname);
			return(FAIL);
		}
	}


	if (!fromtf)
	{
		/*
		**  Everything OK, set new datatype/nullability information
		**  only if not from a table field.
		*/
		ntype->ftdatatype = dbv.db_datatype;
		ntype->ftprec = dbv.db_prec;

		/*
		**  Finally, set scroll length, which is the internal
		**  adf length for the datatype if the field is
		**  still qualified to be scrollable.  This value was set up
		**  by a previous call to scr_check().
		*/
		if (nhdr->fhd2flags & fdSCRLFD)
		{
			ntype->ftlength = scrsize;
		}
		else
		{
			ntype->ftlength = dbv.db_length;
		}

		FDToSmlfd(&smallfd, *pslist2);
		wrOver();
		unLinkPos(*pslist2);
		vfersPos(*pslist2);
		savePos(*pslist2);
		ps = *pslist2;
		sfd = &smallfd;
		ps->ps_begx = min(sfd->tx, sfd->dx);
		ps->ps_begy = min(sfd->ty, sfd->dy);
		ps->ps_endx = max(sfd->tex, sfd->dex);
		ps->ps_endy = max(sfd->tey, sfd->dey);
		if (nhdr->fhdflags & fdBOXFLD)
		{
			/*
			**  spacesize used to account for attribute byte space
			**  needed by some terminals, most notably the 3270.
			**  (dkh)
			*/

			if (ps->ps_begy == 0 || ps->ps_begx <= spacesize ||
				ps->ps_endx >= endxFrm - spacesize)
			{
				IIUGerr(E_VF000B_Cant_box_this_field, 
					UG_ERR_ERROR, 0);
				nhdr->fhdflags &= (~fdBOXFLD);
			}
			else
			{
				ps->ps_begx -= 1 + spacesize;
				ps->ps_endx += 1 + spacesize;
				ps->ps_begy--;
				ps->ps_endy++;
			}
		}
		fitPos(*pslist2, TRUE);
		insPos(*pslist2, TRUE);
		moveComp(*pslist2, &smallfd);
	}
	else
	{
		if (nhdr->fhd2flags & fdSCRLFD)
		{
			ntype->ftlength = scrsize;
		}
	}
	return(OK);
##}



/*
** nxregattr:
**	Find the next regular field for setting
**	attributes.
*/

nxregattr(type, hdrptr, typeptr)
i4	type;
FLDHDR	**hdrptr;
FLDTYPE **typeptr;
{
	FIELD	*fld;

	if (type == NEXT)
	{
		if (atcurfld == attotflds)
		{
			atcurfld = 1;
			fld = *fld1list;
			fld2list = fld1list;
			pslist2 = pslist1;
		}
		else
		{
			atcurfld++;
			fld = *++fld2list;
			pslist2++;
		}
	}
	else
	{
		if (atcurfld == 1)
		{
			atcurfld = attotflds;
			fld = *fld3list;
			fld2list = fld3list;
			pslist2 = pslist3;
		}
		else
		{
			atcurfld--;
			fld = *--fld2list;
			pslist2--;
		}
	}
	*hdrptr = FDgethdr(fld);
	*typeptr = FDgettype(fld);
	vfDispAll(endFrame);
	setGlobUn((i4) edATTR, *pslist2, fld);
}



/*
** nomoreattr:
**	Routine to print out message saying there are no
**	more attributes to edit.  This only happens if
**	there is only one column in a table field or
**	there is only one regular field in the form.
*/

nomoreattr()
{
	IIUGerr(E_VF000C_There_are_no_other_at, UG_ERR_ERROR, 0);
}



/*
** attrhandler:
**	Code to control the attribute form
*/

attrhandler(hdr, type, writeout, tfseq)
FLDHDR	*hdr;
FLDTYPE *type;
bool	writeout;
i4	tfseq;
{
# ifndef FORRBF
	i4	curfield;
# endif
	FLDHDR	*nhdr;
	FLDTYPE *ntype;
##	i4	afldcolor;
	i4	colorval;
	char	oldnm[FE_MAXNAME + 1];
	bool	fromtf = FALSE;
	bool	nomore = FALSE;
	char	hlpbuf[100];
##	char	isscrollable[2];
##	char	dttype[40];
	i4	class;
##	char	*no1;
##	char	dval[2];
##	char	formula[fdVSTRLEN + 1];
##	char	msg[fdVMSGLEN + 1];
##	char	*chp;
##	char	*chp2;
	DB_DATA_VALUE	dbv;
	DB_USER_TYPE	usertype;
##	char	der_buf[fdVSTRLEN + 1];
##	char	val_buf[fdVSTRLEN + 1];

	no1 = IIVF_no1;

	/*
	** first fill in the attributes from the field
	** structure and then drive the form
	** when control comes back fill in the field
	*/
	nhdr = hdr;
	ntype = type;
	FTclear();
	/*
	** now drive the form
	** when we get back fill in
	*/
	if (tfseq != -1)
	{
# ifndef FORRBF
		curfield = tfseq;
# endif
		fromtf = TRUE;
	}
##	display ERx("vifattr") UPDATE
##	initialize
##	{
		STcopy(hdr->fhdname, oldnm);
		attrinit(hdr, type, fromtf, &colorval, der_buf, val_buf);
		vfputdtype(type);
##	}
##	activate scrollup vifattr, scrolldown vifattr
##	{
##		resume	/* Do nothing; just return. */
##	}
##	activate field ERx("color")
##	{
##		getform (afldcolor = color)
		if (colorval != afldcolor)
		{
			vfsetcolor(&colorhdr->fhdflags, afldcolor);
			colorval = afldcolor;
			FTsetda(vfattr, colorseq, FT_UPDATE, FT_REGFLD, 0, 0,
				colorhdr->fhdflags);
		}
		else
		{
##			resume next
		}
##	}
##	activate field ERx("datatype")
##	{
##		getform vifattr (dttype = datatype)
		STcopy(dttype, usertype.dbut_name);
		usertype.dbut_kind = DB_UT_NOTNULL;
		if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
		{
			IIUGerr(E_VF0007_not_valid_datatype,
				UG_ERR_ERROR, 1, usertype.dbut_name);
##			resume
		}
		/*
		**  Need to check if datatype is not one of the
		**  string types.  If not a string type anymore,
		**  we need to remove the scrollable fields
		**  We probably want to save info in the scrollable
		**  fields to display them again if datatype is
		**  changed back to a string type.
		*/
		if (can_scroll)
		{
			IIAFddcDetermineDatatypeClass(dbv.db_datatype, &class);

			/*
			**  Display scrollable field if string datatype.
			*/
			if (class == CHAR_DTYPE)
			{
				if (!was_chartype)
				{
##					putform (scrollable = no1,
##						scrollsz = 0)
##					getform (dval = derived)
					if (*dval == *IIVF_no1)
					{
##					    set_frs field vifattr
##						(invisible(scrollable) = 0)
					}
				}
				was_chartype = TRUE;
			}
			else
			{
				was_chartype = FALSE;
				/*
				**  Otherwise, make scroll fields disappear.
				*/
				scrlfld = FALSE;
##				putform (scrollable = no1, scrollsz = 0)
##				set_frs field vifattr
##					(invisible(scrollable) = 1,
##					invisible(scrollsz) = 1)
			}
		}
##		resume next
##	}
##	activate field ERx("scrollable")
##	{
##		getform (isscrollable = scrollable)
		if (*isscrollable == *IIVF_yes1)
		{
			/*
			**  If not scrollable, display other
			**  field.  Otherwise, do nothing.
			*/
			if (!scrlfld)
			{
##				set_frs field vifattr (invisible(scrollsz) = 0)
				scrlfld = TRUE;
			}
		}
		else if (*isscrollable == *IIVF_no1)
		{
			/*
			**  If scrollable, remove other field.
			**  Otherwise, do nothing.
			*/
			if (scrlfld)
			{
				/*
				**  Retain value even though now invisible.
				*/
##				set_frs field vifattr (invisible(scrollsz) = 1)
				scrlfld = FALSE;
			}
		}
		else
		{
			IIUGerr(E_VF011C_bad_scroll_val, UG_ERR_ERROR, 0);
##			resume
		}
##		resume next
##	}
##	activate field ERx("derived")
##	{
##	    getform (dval = derived)
	    if (*dval == *IIVF_yes1)
	    {
		if (der_fld == FALSE)
		{
		    der_fld = TRUE;
##		    getform (val_buf = valstr)
##		    putform (valstr = der_buf)
		}
		chp = ERget(F_VF0069_Der_Form);
		chp2 = ERget(F_VF006D_ValNotAllowed);
##	    	set_frs field vifattr (invisible(valmsg) = 1)
##	    	set_frs field vifvalder (invisible(valmsg) = 1)
##	    	set_frs field vifattr (invisible(defval) = 1)
##	    	set_frs field vifattr (invisible(scrollable) = 1,
##	    		invisible(scrollsz) = 1)
	    }
	    else	/* *dval == *IIVF_no1 */
	    {
		if (der_fld == TRUE)
		{
		    der_fld = FALSE;
##		    getform (der_buf = valstr)
##		    putform (valstr = val_buf)
		}
		chp = ERget(F_VF006A_Val_Chk);
		chp2 = ERget(F_VF006C_ValAllowed);
##	    	set_frs field vifattr (invisible(valmsg) = 0)
##	    	set_frs field vifvalder (invisible(valmsg) = 0)
		if (!fromtf)
##	    		set_frs field vifattr (invisible(defval) = 0)
		if (can_scroll)
##	    		set_frs field vifattr (invisible(scrollable) = 0);
		if (scrlfld)
##	    		set_frs field vifattr (invisible(scrollsz) = 0);
	    }
##	    putform vifattr (valstrtitle = chp)
##	    putform vifvalder (valstrtitle = chp)
##	    putform vifattr (expl_text = chp2)
##	    resume next
##	}
##	activate menuitem ERget(FE_Next)
##	{
##		validate field vifattr
##		validate field nullable
##		validate field derived
##		getform vifattr (dttype = datatype)
		STcopy(dttype, usertype.dbut_name);
		usertype.dbut_kind = DB_UT_NOTNULL;
		if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
		{
			IIUGerr(E_VF0007_not_valid_datatype,
				UG_ERR_ERROR, 1, usertype.dbut_name);
##			resume field datatype
		}
		if (!scr_check(nhdr, ntype))
		{
##			resume field scrollsz
		}
		if (vfretattr(nhdr, ntype, oldnm, writeout, fromtf) == FAIL)
		{
##			resume
		}
# ifndef FORRBF
		if (fromtf)
		{
			curfield = nxtfattr((i4) NEXT, &nhdr, &ntype, curfield);
			if (curfield == -1)
			{
				nomoreattr();
				nomore = TRUE;
##				resume
			}
		}
		else
# endif
		{
			if (attotflds == 1)
			{
				nomoreattr();
				nomore = TRUE;
##				resume
			}
			nxregattr((i4) NEXT, &nhdr, &ntype);
		}
		STcopy(nhdr->fhdname, oldnm);
		attrinit(nhdr, ntype, fromtf, &colorval, der_buf, val_buf);
		vfputdtype(ntype);
##		resume field vifattr
##	}
##	activate menuitem ERget(FE_Previous)
##	{
##		validate field vifattr
##		validate field nullable
##		validate field derived
##		getform vifattr (dttype = datatype)
		STcopy(dttype, usertype.dbut_name);
		usertype.dbut_kind = DB_UT_NOTNULL;
		if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
		{
			IIUGerr(E_VF0007_not_valid_datatype,
				UG_ERR_ERROR, 1, usertype.dbut_name);
##			resume field datatype
		}
		if (!scr_check(nhdr, ntype))
		{
##			resume field scrollsz
		}
		if (vfretattr(nhdr, ntype, oldnm, writeout, fromtf) == FAIL)
		{
##			resume
		}
# ifndef FORRBF
		if (fromtf)
		{
			curfield = nxtfattr((i4) PREVIOUS, &nhdr, &ntype,
				curfield);
			if (curfield == -1)
			{
				nomoreattr();
				nomore = TRUE;
##				resume
			}
		}
		else
# endif
		{
			if (attotflds == 1)
			{
				nomoreattr();
				nomore = TRUE;
##				resume
			}
			nxregattr((i4) PREVIOUS, &nhdr, &ntype);
		}
		STcopy(nhdr->fhdname, oldnm);
		attrinit(nhdr, ntype, fromtf, &colorval, der_buf, val_buf);
		vfputdtype(ntype);
##		resume field vifattr
##	}
##	activate menuitem ERget(F_VF006B_MoreEdit)
##	{
##		getform vifattr (formula = valstr, msg = valmsg)
##		putform vifvalder (valstr = formula, valmsg = msg)
		valderhdlr();
##		getform vifvalder (formula = valstr, msg = valmsg)
##		putform vifattr (valstr = formula, valmsg = msg)
##	}
##	ACTIVATE MENUITEM ERget(FE_Lookup) (VALIDATE = 0, ACTIVATE = 0,
##			EXPL = ERget(FE_LookupExpl)), 
##			FRSkey10 (VALIDATE = 0, ACTIVATE = 0)
##	{
		IIUFfieldHelp();
##	}
##	activate menuitem ERget(FE_Help) (validate = 0, activate = 0),
##		FRSkey1 (validate = 0, activate = 0)
##	{
		STcopy(ERget(S_VF000D_Field_Attributes), hlpbuf);
		FEhelp(VFH_ATTRIBUTE, hlpbuf);
##	}
##	activate menuitem ERget(FE_End), FRSkey3
##	{
		if (!nomore)
		{
##			validate field vifattr
##			validate field nullable
##			validate field derived
##			getform vifattr (dttype = datatype)
			STcopy(dttype, usertype.dbut_name);
			usertype.dbut_kind = DB_UT_NOTNULL;
			if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
			{
				IIUGerr(E_VF0007_not_valid_datatype,
					UG_ERR_ERROR, 1, usertype.dbut_name);
##				resume field datatype
			}
			if (!scr_check(nhdr, ntype))
			{
##				resume field scrollsz
			}
			if (vfretattr(nhdr, ntype, oldnm, writeout,
				fromtf) == FAIL)
			{
##				resume
			}
		}
##		enddisplay
##	}
	if (!fromtf)
	{
		globy = (*pslist2)->ps_begy;
		globx = (*pslist2)->ps_begx;
	}
	FTclear();
}


/*{
** Name:	vfndeftype - Get default data type.
**
** Description:
**	Get the default datatype type information for a field
**	that is being created.	The format string is used to
**	derived the default datatype.  If the string is empty
**	or datatype information is already present, do nothing.
**
**	The derived datatype is placed into form "vifattr".
**
** Inputs:
**	hdr	Pointer to a FLDHDR structure for the new field.
**	type	Pointer to a FLDTYPE structure for the new field.
**
** Outputs:
**	None.
**
**	Returns:
**		None.
**	Exceptions:
**		None.
**
** Side Effects:
**	None.
**
** History:
**	03/27/87 (dkh) -Initial version written.
*/
VOID
vfndeftype(hdr, type)
FLDHDR	*hdr;
FLDTYPE *type;
{
##	char		*dptr;
	DB_USER_TYPE	usertype;
	DB_DATA_VALUE	dbv;
##	char		*llyes1;
##	char		*llno1;

	llyes1 = IIVF_yes1;
	llno1 = IIVF_no1;

	if (vfdml == FEDMLSQL)
	{
##		putform vifattr (nullable = llyes1)
		attrdtype.dbut_kind = DB_UT_NULL;
	}
	else
	{
##		putform vifattr (nullable = llno1)
		attrdtype.dbut_kind = DB_UT_NOTNULL;
	}
##	clear field datatype
	attrdtype.dbut_name[0] = EOS;
	if (type->ftdatatype == DB_NODT && type->ftfmt == NULL)
	{
		return;
	}
	if (type->ftdatatype != DB_NODT)
	{
		dbv.db_datatype = type->ftdatatype;
		dbv.db_length = type->ftlength;
		dbv.db_prec = type->ftprec;
	}
	else
	{
		if (fmt_ftot(FEadfcb(), type->ftfmt, &dbv) != OK)
		{
			IIUGerr(E_VF000E_Error_in_getting_defa,
				UG_ERR_ERROR, 0);
			return;
		}
	}
	if (afe_vtyoutput(FEadfcb(), &dbv, &usertype) != OK)
	{
		IIUGerr(E_VF000F_Error_in_converting_d, UG_ERR_ERROR, 0);
		return;
	}
	dptr = usertype.dbut_name;
	STcopy(dptr, attrdtype.dbut_name);
##	putform vifattr (datatype = dptr)
	if (usertype.dbut_kind == DB_UT_NULL)
	{
		dptr = IIVF_yes1;
	}
	else
	{
		dptr = IIVF_no1;
	}
##	putform vifattr (nullable = dptr)
	attrdtype.dbut_kind = usertype.dbut_kind;
}




nattrCom(fd, writeout)
FIELD	*fd;
bool	writeout;
{
	FLDHDR		*hdr;
	FLDTYPE		*type;
	i4		i;
	i4		colorval;
##	i4		bfldcolor;
##	i4		bcolor;
	ATTRIBS		*attr;
##	char		*ptr;
##	i4		browno;
	char		buf[BUFSIZ];
##	char		i4tr[30];
##	char		bbuf[40];
##	char		nflag[5];
	DB_DATA_VALUE	dbv;
	DB_USER_TYPE	usertype;
##	char		dbuf[50];
	i4		*flags;
##	char		*local_no1 = IIVF_no1;;
##	char		derval[2];
##	char		dvstr[fdVSTRLEN + 1];
##	char		vmsg[fdVMSGLEN + 1];
##	char		*chr;
##	char		*chr2;
##	char		der_str[fdVSTRLEN + 1];
##	char		val_str[fdVSTRLEN + 1];
	char		old_name[FE_MAXNAME + 1];

	allocAttr();

	hdr = FDgethdr(fd);
	type = FDgettype(fd);
	FTclear();
	vfdmpoff();
##	display ERx("vifattr") UPDATE
##	initialize
##	{
##		set_frs field vifattr (invisible(defval) = 0)
		attrinit(hdr, type, FALSE, &colorval, der_str, val_str);
		vfndeftype(hdr, type);
		can_scroll = FALSE;
		scrlfld = FALSE;
##		putform (scrollable = local_no1, scrollsz = 0)
##		set_frs field vifattr (invisible(scrollable) = 1,
##			invisible(scrollsz) = 1)
		old_name[0] = EOS;
		if (hdr->fhdname != NULL)
		{
			STcopy(hdr->fhdname, old_name);
		}
##	}
##	activate scrollup vifattr, scrolldown vifattr
##	{
##		resume	/* Do nothing; just return. */
##	}
##	activate field ERx("color")
##	{
##		getform (bfldcolor = color)
		if (colorval != bfldcolor)
		{
			vfsetcolor(&colorhdr->fhdflags, bfldcolor);
			colorval = bfldcolor;
			FTsetda(vfattr, colorseq, FT_UPDATE, FT_REGFLD,
				0, 0, colorhdr->fhdflags);
		}
		else
		{
##			resume next
		}
##	}
##	activate field ERx("datatype")
##	{
##		getform vifattr (bbuf = datatype)
		STcopy(bbuf, usertype.dbut_name);
		usertype.dbut_kind = DB_UT_NOTNULL;
		if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
		{
			IIUGerr(E_VF0007_not_valid_datatype, UG_ERR_ERROR,
				1, usertype.dbut_name);
##			resume
		}
##		resume next
##	}
##	activate field ERx("derived")
##	{
##	    getform (derval = derived)
	    if (*derval == *IIVF_yes1)
	    {
		if (der_fld == FALSE)
		{
		    der_fld = TRUE;
##		    getform (val_str = valstr)
##		    putform (valstr = der_str)
		}
		chr = ERget(F_VF0069_Der_Form);
		chr2 = ERget(F_VF006D_ValNotAllowed);
##	    	set_frs field vifattr (invisible(valmsg) = 1)
##	    	set_frs field vifvalder (invisible(valmsg) = 1)
##	    	set_frs field vifattr (invisible(defval) = 1)
	    }
	    else	/* *derval == *IIVF_no1 */
	    {
		if (der_fld == TRUE)
		{
		    der_fld = FALSE;
##		    getform (der_str = valstr)
##		    putform (valstr = val_str)
		}
		chr = ERget(F_VF006A_Val_Chk);
		chr2 = ERget(F_VF006C_ValAllowed);
##	    	set_frs field vifattr (invisible(valmsg) = 0)
##	    	set_frs field vifvalder (invisible(valmsg) = 0)
##	    	set_frs field vifattr (invisible(defval) = 0)
	    }
##	    putform vifattr (valstrtitle = chr)
##	    putform vifvalder (valstrtitle = chr)
##	    putform vifattr (expl_text = chr2)
##	    resume next
##	}
##	activate menuitem ERget(F_VF006B_MoreEdit)
##	{
##		getform vifattr (dvstr = valstr, vmsg = valmsg)
##		putform vifvalder (valstr = dvstr, valmsg = vmsg)
		valderhdlr();
##		getform vifvalder (dvstr = valstr, vmsg = valmsg)
##		putform vifattr (valstr = dvstr, valmsg = vmsg)
##	}
##	ACTIVATE MENUITEM ERget(FE_Lookup) (VALIDATE = 0, ACTIVATE = 0,
##			EXPL = ERget(FE_LookupExpl)), 
##			FRSkey10 (VALIDATE = 0, ACTIVATE = 0)
##	{
##		char		locfld[FE_MAXNAME+1];
		FLD_VALUE	fv;

		fv._form = ERx("vifattr");
		fv._field = locfld;
		fv._column = NULL;

/* If this is field "datatype", offer a list of data types (kibro01) b119305 */
##		inquire_frs form ( locfld = field );
		if ( STequal(locfld, ERx("datatype")) )
		{
			IIUFhlpType( NULL, 0, FALSE, &fv);
		} else
		{
			IIUFfieldHelp();
		}
##	}
##	activate menuitem ERget(FE_Help) (validate = 0, activate = 0),
##		FRSkey1 (validate = 0, activate = 0)
##	{
		FEhelp(VFH_ATTRIBUTE, ERget(S_VF000D_Field_Attributes));
##	}
##	activate menuitem ERget(FE_End), FRSkey3
##	{
##		validate field vifattr
##		validate field nullable
##		validate field derived
##		getform vifattr (bbuf = datatype)
		STcopy(bbuf, usertype.dbut_name);
		usertype.dbut_kind = DB_UT_NOTNULL;
		/*
		**  If we started out with no datatype, then allow
		**  no datatype.
		*/
		if (!(bbuf[0] == EOS && attrdtype.dbut_name[0] == EOS))
		{
			if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
			{
				IIUGerr(E_VF0007_not_valid_datatype,
					UG_ERR_ERROR, 1, usertype.dbut_name);
##				resume field datatype
			}
		}
		/*
		** clear all field attributes except those that can
		** obtain values outside of the edit attribute form.
		*/
		hdr->fhdflags &= fdREVDIR;
		hdr->fhd2flags &= (fdSCRLFD | fdVQLOCK);
		i = 0;
		attr = attrflag;
##		unloadtable vifattr vifattr (nflag = sett)
##		{
			if (i < RMAXATTR)
			{
				if (attr->use_fhd2flags)
					flags = &hdr->fhd2flags;
				else
					flags = &hdr->fhdflags;
				charToFlag(flags, nflag, attr->attribute);
				attr++;
				i++;
			}
			else
			{
##				endloop
			}
##		}

		if ((hdr->fhd2flags & fdREADONLY)
		    && (hdr->fhdflags & fdQUERYONLY))
		{
			IIUGerr(E_VF0004_Cant_set_both, UG_ERR_ERROR, 0);
##			resume
		}
		if ((hdr->fhdflags & fdLOWCASE) && (hdr->fhdflags & fdUPCASE))
		{
			IIUGerr(E_VF0005_Cant_set_low_up, UG_ERR_ERROR, 0);
##			resume
		}


		ptr = buf;
##		getform vifattr (ptr = valstr)
		type->ftvalstr = saveStr(ptr);

##		getform vifattr (nflag = derived)
		charToFlag(&hdr->fhd2flags, nflag, fdDERIVED);

		if (hdr->fhd2flags & fdDERIVED)
		{
			if (type->ftvalstr[0] == EOS)
			{
				hdr->fhd2flags &= ~fdDERIVED;
			}
			else if ((hdr->fhdflags & fdMAND)
				|| (hdr->fhdflags & fdLOWCASE)
				|| (hdr->fhdflags & fdUPCASE)
				|| (hdr->fhdflags & fdQUERYONLY)
				|| (hdr->fhd2flags & fdREADONLY))
			{
				IIUGerr(E_VF012C_Cant_set_derived_and,
					UG_ERR_ERROR, 0);

				/* Turn off the offending attributes. */
				hdr->fhdflags
					&= ~(fdMAND | fdLOWCASE | fdUPCASE | fdQUERYONLY);

				/*
				** Turn on the (internal) disponly flag if
				** derived.  Used by FRS code to prevent
				** user access to this field.
				*/
				hdr->fhd2flags |= fdREADONLY;
			}
			else
			{
				/*
				** Turn on the (internal) disponly flag if
				** derived.
				*/
				hdr->fhd2flags |= fdREADONLY;
			}
		}

##		getform vifattr (ptr = defval)
		if (hdr->fhd2flags & fdDERIVED)
		{
			/* No default values for derived fields. */
			ptr[0] = EOS;
		}
		type->ftdefault = saveStr(ptr);

##		getform vifattr (ptr = valmsg)
		if (hdr->fhd2flags & fdDERIVED)
		{
			/* No validation error message for derived fields. */
			ptr[0] = EOS;
		}
		type->ftvalmsg = saveStr(ptr);

		ptr = hdr->fhdname;
##		getform vifattr (ptr = name)

		/*
		**  Allow empty name if we started with empty name.
		*/
		if (!(old_name[0] == EOS && *ptr == EOS))
		{
			if (!vffnmchk(ptr, ERget(F_VF0011_field)))
			{
##				resume field name
			}
		}

		CVlower(hdr->fhdname);

##		getform vifattr (bcolor = color)
		vfsetcolor(&hdr->fhdflags, bcolor);

		/*
		**  Get and check datatype/nullability from form.
		*/
##		getform vifattr (dbuf = datatype)

		/*
		**  Let datatype be blank if we started with
		**  blank as well.
		*/
		if (dbuf[0] == '\0' && attrdtype.dbut_name[0] == '\0')
		{
			type->ftdatatype = DB_NODT;
		}
		else
		{
			STcopy(dbuf, usertype.dbut_name);
##			getform vifattr (dbuf = nullable)
			CVlower(dbuf);
			if (*dbuf == *IIVF_yes1)
			{
				usertype.dbut_kind = DB_UT_NULL;
			}
			else
			{
				usertype.dbut_kind = DB_UT_NOTNULL;
			}
			if (afe_vtychk(FEadfcb(), &usertype, &dbv) != OK)
			{
				IIUGerr(E_VF0007_not_valid_datatype,
					UG_ERR_ERROR, 1, usertype.dbut_name);
				ptr = attrdtype.dbut_name;
				if (*ptr != '\0')
				{
##					putform vifattr (datatype = ptr)
				}
##				resume field datatype
			}

			/*
			**  Put in a fake length if db_length
			**  is zero (i.e., one of the character
			**  datatypes.
			*/
			if (dbv.db_length == 0)
			{
				dbv.db_length = 10;
				/*
				**  If we have a decimal datatype, we also want
				**  to fake up a precision/scale combo value
				**  as well.
				*/
				if (abs(dbv.db_datatype) == DB_DEC_TYPE)
				{
					DB_DATA_VALUE	dbv1;

					dbv.db_length =
						DB_PREC_TO_LEN_MACRO(10);
					dbv.db_prec =
						DB_PS_ENCODE_MACRO(10, 0);
					(void)adc_lenchk(FEadfcb(), TRUE,
						&dbv, &dbv1);
					dbv.db_length = dbv1.db_length;
				}
			}

			type->ftdatatype = dbv.db_datatype;
			type->ftlength = dbv.db_length;
			type->ftprec = dbv.db_prec;
		}

##		enddisplay
##	}
	FTclear();
}


# endif /* FORRBF */

char *
flgToChar(flag, val)
i4	flag;
i4	val;
{
	if (flag & val)
		return(IIVF_yes1);
	else
		return(IIVF_no1);
}

VOID
charToFlag(flag, ch, val)
i4	*flag;
char	*ch;
i4	val;
{
	if (STcompare(ch, IIVF_yes1) == 0)
		*flag |= val;
}

# ifndef FORRBF

i4
vffnmchk(name, fldtype)
char	*name;
char	*fldtype;
{
	i4	retval = TRUE;
	char	*namestart;
	char	badchar[5];

	namestart = name;
	if (*name == EOS)
	{
		IIUGerr(E_VF0051_empty, UG_ERR_ERROR, 2, fldtype, fldtype);
		return(FALSE);
	}

	if (!CMnmstart(name))
	{
		IIUGerr(E_VF0010_First_character_of_fi, UG_ERR_ERROR, 
			2, fldtype, namestart);
		return(FALSE);
	}
	while(*name)
	{
		if (!CMnmchar(name))
		{
			CMcpychar(name,badchar);
			IIUGerr(E_VF0011_Character_not_ok, UG_ERR_ERROR,
				3, badchar, fldtype, namestart);
			retval = FALSE;
			break;
		}
		CMnext(name);
	}
	return(retval);
}

# endif /* FORRBF */

/*{
** Name:	vfgetcolor	- get color number from flags 
**
** Description:
**	This function translates a form system (frame.h) fdCOLOR 
**	flag bit definition into a form color number (0-7) which
**	is used on forms to represent the color number.
**
** Inputs:
**	i4	*flags; - pointer to form system flags as in frame.h
**	i4	color;	- form derived color number  (0-7)
**
** Outputs:
**
**	Returns:
**		i4	- color number to be displayed on a form
**
**	Exceptions:
**
** Side Effects:
**
** History:
**	05/10/88  (tom) - comment written
*/
i4
vfgetcolor(flags)
i4	flags;
{

	if (flags & fd1COLOR)
		return 1;
	else if (flags & fd2COLOR)
		return 2;
	else if (flags & fd3COLOR)
		return 3;
	else if (flags & fd4COLOR)
		return 4;
	else if (flags & fd5COLOR)
		return 5;
	else if (flags & fd6COLOR)
		return 6;
	else if (flags & fd7COLOR)
		return 7;
	else 
		return 0;
}
  
  
/*{
** Name:	vfsetcolor	- set flags from color number (0-7)
**
** Description:
**	This function translates the vifred form color number (0-7)
**	into the approriate fdCOLOR bit flags and posts the flag
**	a pointer to which is passed in as an argument.
**
** Inputs:
**	i4	*flags; - pointer to form system flags as in frame.h
**	i4	color;	- form derived color number  (0-7)
**
** Outputs:
**
**	Returns:
**		none 
**
**	Exceptions:
**
** Side Effects:
**	*flags is posted
**
** History:
**	05/10/88  (tom) - comment written
*/
VOID
vfsetcolor(flags, color)
i4	*flags;
i4	color;
{
	static i4  mask[8] = 
	{ 	0, fd1COLOR, fd2COLOR, fd3COLOR, fd4COLOR, 
		fd5COLOR, fd6COLOR, fd7COLOR 
	};

	if (color < 0 || color > 7)
		return;
	*flags &= ~fdCOLOR;
	*flags |= mask[color];
}


# ifndef FORRBF

/*{
** Name:	scr_check - Scrollability Check.
**
** Description:
**	Do sanity check on scrollability for a field/column.
**	If field is scrollable, then check datatype, scroll
**	size for validity.
**
**	This routine is being called as part of exiting the Edit Attributes
**	frame, so reset scrollable and scrollsz settings for derived fields.
**
** Inputs:
**	hdr	FLDHDR structure for field/column.
**	type	FLDTYPE structure for field/column.
**
** Outputs:
**
**	Returns:
**		TRUE	If sanity check is OK.
**		FALSE	Sanity check failed.
**
**	Exceptions:
**		None.
**
** Side Effects:
**	Field may be flagged as a scrollable field and data length may
**	also be set to the scroll length.
**
** History:
**	05/21/88 (dkh) - Initial version.
*/
static bool
scr_check(hdr, type)
FLDHDR	*hdr;
FLDTYPE	*type;
{
##	char		tbuf[40];
##	char		nbuf[2];
##	char		derbuf[2];
##	i4		scrlength;
	DB_USER_TYPE	usertype;
	DB_DATA_VALUE	dbv;
	DB_DATA_VALUE	sdbv;
	i4		class;
	i4		intern_length;
##	char		*loc_no1;
	i4		maxlen;

	if (!can_scroll)
	{
		return(TRUE);
	}

	loc_no1 = IIVF_no1;

	/*
	**  Get datatype so we can see if we have to turn off scrollability.
	**  Note that the "nullable" field has already been checked
	**  before this routine is called.
	*/

##	getform vifattr (tbuf = datatype, nbuf = nullable, derbuf = derived)
	CVlower(nbuf);

	/* If derived, simply zap scrollability. */
	if (*derbuf == *IIVF_yes1)
	{
##	    putform vifattr (scrollable = loc_no1, scrollsz = 0)
##	    set_frs field vifattr (invisible(scrollable) = 1,
##		invisible(scrollsz) = 1)
	    scrlfld = FALSE;
	    hdr->fhd2flags &= ~fdSCRLFD;
	    return(TRUE);
	}

	STcopy(tbuf, usertype.dbut_name);
	if (*nbuf == *IIVF_yes1)
	{
		usertype.dbut_kind = DB_UT_NULL;
	}
	else
	{
		usertype.dbut_kind = DB_UT_NOTNULL;
	}
	if ((afe_tychk(FEadfcb(), &usertype, &dbv) != OK) ||
		(!IIAFfedatatype(&dbv)))
	{
		IIUGerr(E_VF0007_not_valid_datatype, UG_ERR_ERROR, 1,
			usertype.dbut_name);
		return(FALSE);
	}
	IIAFddcDetermineDatatypeClass(dbv.db_datatype, &class);

	/*
	**  If datatype is no longer a string, reset world and
	**  return good status.
	*/
	if (class != CHAR_DTYPE)
	{
##		putform vifattr (scrollable = loc_no1, scrollsz = 0)
##		set_frs field vifattr (invisible(scrollable) = 1,
##			invisible(scrollsz) = 1)
		scrlfld = FALSE;
		hdr->fhd2flags &= ~fdSCRLFD;
		return(TRUE);
	}

	/*
	**  Check if scrollability has been turned off.  If so, return.
	*/
##	getform vifattr (tbuf = scrollable)
	if (*tbuf == *IIVF_no1)
	{
		scrlfld = FALSE;
		hdr->fhd2flags &= ~fdSCRLFD;
		return(TRUE);
	}
	else if (*tbuf != *IIVF_yes1)
	{
		/* Not a 'y' or 'n'.  This is an error.  */
		IIUGerr(E_VF011C_bad_scroll_val, UG_ERR_ERROR, 0);
		return(FALSE);
	}

	/*
	**  Datatype has already been validated as a string.  Need to check it
	**  against the scroll length.
	*/
##	getform vifattr (scrlength = scrollsz)

	/*
	**  Now check length for datatype to make sure that's OK too.
	*/
	maxlen = DB_GW4_MAXSTRING;
	dbv.db_length = scrlength;
	dbv.db_prec = 0;	/* Character datatype. */
	if (adc_lenchk(FEadfcb(), TRUE, &dbv, &sdbv) != E_DB_OK)
	{
		/* Invalid number for datatype.  */
		IIUGerr(E_VF0164_bad_scroll_len, UG_ERR_ERROR, 2,
		    &fmt_length, &maxlen);
		return(FALSE);
	}
	intern_length = sdbv.db_length;

	/*
	**  Finally, check length against the format length.
	**  If it is too small give an error.
	*/
	if (fmt_length > scrlength)
	{
		IIUGerr(E_VF0164_bad_scroll_len, UG_ERR_ERROR, 2,
		    &fmt_length, &maxlen);
		return(FALSE);
	}

	/*
	**  Everything appears to be OK, set scroll flag and length.
	*/
	scrsize = intern_length;
	hdr->fhd2flags |= fdSCRLFD;
	return(TRUE);
}


/*{
** Name:	valderhdlr	- Display loop for vifvalder frame.
**
** Description:
**	Run the display of the vifvalder frame.  This frame allows the
**	user to set the validation string or derivation formula for a field.
**
** Inputs:
**
** Outputs:
**
**	Returns:
**		VOID
**
**	Exceptions:
**		None
**
** Side Effects:
**	None
**
** History:
**	21-jun-89 (bruceb)	Written.
*/
static VOID
valderhdlr()
{
##  char	drived[2];

    /* Display form in update mode to save values set by calling routines. */
##  display vifvalder update
##  activate menuitem ERget(FE_Help), FRSkey1
##  {
##	getform vifattr (drived = derived)
	if (*drived == *IIVF_yes1)
	    FEhelp(VFH_DERIVE, ERget(S_VF013A_Field_Derivations));
	else
	    FEhelp(VFH_VALID, ERget(S_VF0137_Field_Validations));
##  }
##  activate menuitem ERget(FE_End), FRSkey3
##  {
##	enddisplay
##  }
}
# endif /* FORRBF */
