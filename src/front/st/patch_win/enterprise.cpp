/*
**  Copyright (c) 2006 Ingres Corporation. All Rights Reserved.
*/

/*
**  Name: enterprise.cpp
**
**  Description:
**	Defines the class behaviors for the application.
**
**  History:
**	05-Jun-2001 (penga03)
**	    Created.
**	07-Jun-2001 (penga03)
**	    Added Execute() which creates a new process to execute an
**	    executable file. 
**	15-Jun-2001 (penga03)
**	    Added function Local_NMgtIngAt, a revised version of
**	    NMgtIngAt independent of Ingres CL functions.
**	23-July-2001 (penga03)
**	    Added functions IsWindows9X, GetII_SYSTEM, Local_PMget,
**	    IngresAlreadyRunning, WinstartRunning(), IsVer25().
**	23-July-2001 (penga03)
**	    For silence mode installation, also check if there exists
**	    an installation installed by old installer, if there exists,
**	    ask user if upgrade this installation.
**	23-July-2001 (penga03)
**	    For silence mode installation, if ingres is running,
**	    terminate installing.
**	15-aug-2001 (somsa01)
**	    In IngresAlreadyRunning(), since users are told to remove
**	    everything in their bin and utility directories before
**	    performing an upgrade, iigcn.exe will not exist. Therefore,
**	    we'll use the check for config.dat as the surefire way of
**	    letting us know that there is a valid installation here,
**	    then go on from there to see if Ingres is running.
**	24-oct-2001 (penga03)
**	    If Local_NMgtIngAt and Local_PMget don't find the value for the 
**	    string, return FALSE. 
**	05-nov-2001 (penga03)
**	    Removed GetII_SYSTEM and IsVer25. 
**	    In silence mode, according to the comparision of the installation 
**	    id read from response file and the ids already found, set the 
**	    property INGRES_VER25 and pass it to MsiExec.exe.
**	08-nov-2001 (somsa01)
**	    Made the changes corresponding to the new CA marketing campaign.
**	10-nov-2001 (somsa01)
**		Cleaned up 64-bit compiler warnings.
**	30-jan-2002 (penga03)
**	    Changed the registry key for Ingres from 
**	    "HKEY_LOCAL_MACHINE\\Software\\ComputerAssociates\\IngresII\\" to 
**	    "HKEY_LOCAL_MACHINE\\Software\\ComputerAssociates\\Advantage Ingres\\".
**	30-aug-2002 (penga03)
**	    Added a new command line option, /l, so that a verbose log 
**	    file will be generated by Windows Installer.
**	19-feb-2004 (penga03)
**	    Added ExecuteEx() and InstallMSRedistributions().
**	17-jun-2004 (somsa01)
**	    Added ExecuteEx(), which spawns a command and waits for it without
**	    popping up a Command Prompt window.
**	16-jul-2004 (penga03)
**	    Added a new command line parameter /nomdb.
**	26-jul-2004 (penga03)
**	    Removed all references to "Advantage".
**	10-sep-2004 (penga03)
**	    Removed MDB.
**	13-dec-2004 (penga03)
**	    Modified InitInstance() to get the upgrade type based on the
**	    chosen installation identifier (for silent install).
**	16-dec-2004 (penga03)
**	    Corrected the error when stopping ivm.
**	17-dec-2004 (penga03)
**	    Stop IVM before upgrade, even Ingres is not running.
**	08-feb-2005 (penga03)
**	    Added two more parameters for Error() and MyMessageBox().
**	28-feb-2005 (penga03)
**	    Corrected the error when setting m_RestartIngres.
**	14-march-2005 (penga03)
**	    Shut down Ingres by taking the resource offline in a cluster 
**	    environment.
**	08-apr-2005 (penga03)
**	    Close opened handles in ExecuteEx().
**	23-jun-2005 (penga03)
**	    Added ExitInstance() and return_code to return the 
**	    install.exe's exit code.
**	30-jun-2005 (penga03)
**	    Added two more controls to stop Ingres. 
**	18-jul-2005 (penga03)
**	    Fail the installation if the user tries to install an existing
**	    instance to another II_SYSTEM.
**	03-aug-2005 (penga03)
**	    Delete the tailing back slash of the II_SYSTEM got from rsp file.
**	18-aug-2005 (penga03) 
**	    Write the return code to the install.log in ExitInstance(). And 
**	    also initialize the return_code and hLogFile in InitInstance().
**	01-Mar-2006 (drivi01)
**	    Reused and adopted for MSI Patch Installer on Windows.
**	25-Apr-2006 (drivi01)
**	    Porting patch installer to Ingres 2006.
**	05-May-2009 (drivi01)
**	    Update the way the application is initialized in effort
**	    to port to Visual Studio 2008.
*/

#include "stdafx.h"
#include "enterprise.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HANDLE hLogFile=0;
int	return_code=0;
HPALETTE hSystemPalette=0;

static BOOL FileExists(LPCSTR s);
INT CompareIngresVersion(char *ii_system);

/*
**	History:
**	23-July-2001 (penga03)
**	    Make the current property page is the owner window of the message box.
*/
static UINT MyMessageBox(UINT uiStrID,UINT uiFlags,LPCSTR param=0, LPCSTR param2=0, LPCSTR param3=0)
{
	UINT ret;
	CString title;
	CString text;
	
	title.LoadString(IDS_TITLE);
	if (param3)
		text.Format(uiStrID,param, param2, param3);
	else if (param2)
		text.Format(uiStrID,param, param2);
	else if (param)
		text.Format(uiStrID,param);
	else
		text.LoadString(uiStrID);

	HWND hwnd=property ? property->m_hWnd : 0;
	if(!hwnd)
	 uiFlags|=MB_APPLMODAL;

	ret=::MessageBox(hwnd, text,title,uiFlags);
	return ret;
}

void Error(UINT uiStrID,LPCSTR param,LPCSTR param2,LPCSTR param3)
{
	MyMessageBox(uiStrID,MB_OK|MB_ICONEXCLAMATION,param, param2, param3);
}

BOOL AskUserYN(UINT uiStrID,LPCSTR param)
{
	return (MyMessageBox(uiStrID,MB_YESNO|MB_ICONQUESTION,param)==IDYES);
}

static BOOL IsGoodOSVersionAndRights()
{
	OSVERSIONINFO osver; 
	
	memset((char *) &osver,0,sizeof(osver)); 
	osver.dwOSVersionInfoSize=sizeof(osver); 
	GetVersionEx(&osver);
	
	if(	(osver.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS && osver.dwMajorVersion==4 && osver.dwMinorVersion>=10) ||
		(osver.dwPlatformId==VER_PLATFORM_WIN32_NT && osver.dwMajorVersion>=4) )
	{
		/* Windows 98(410), Windows ME(490); Windows NT(400), Windows 2000(500) */
		return TRUE;
	}
	else
	{
		Error(IDS_SUPPORTVERSION);
		return FALSE;
	}
}

static BOOL AlreadyRunning()
{
	CString s; 
	
	s.LoadString(IDS_TITLE);
	if (FindWindow(NULL,s)!=0)
	{
		Error(IDS_ALREADYRUNNING);
		return TRUE;
	}
	return FALSE;
}

/*
**	History:
**	23-July-2001 (penga03)
**	    Modified Execute so that it can receive a parameter and run the command 
**	    by ingwrap.
*/
BOOL 
Execute(char *cmd, char *par /* =0 */, BOOL bWait /* =TRUE */)
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	char CmdLine[2048];
	
	memset((char *)&pi, 0, sizeof(pi));
	memset((char *)&si, 0, sizeof(si));
	si.cb=sizeof(si);
	
	sprintf(CmdLine, "%s", cmd);
	if(par)
	{
		strcat(CmdLine, " ");
		strcat(CmdLine, par);
	}
	if(CreateProcess(NULL, CmdLine, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi))
	{
		if(bWait)
		{
			DWORD dw;

			WaitForSingleObject(pi.hProcess, INFINITE);
			GetExitCodeProcess(pi.hProcess, &dw);
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
			return(dw==0);
		}
		else
		{
			CloseHandle(pi.hProcess);
			CloseHandle(pi.hThread);
			return TRUE;
		}
	}
	return FALSE;
}

BOOL 
Local_NMgtIngAt(CString strKey, CString ii_system, CString &strRetValue)
{
	char szFileName[MAX_PATH+1];
	CStdioFile theInputFile;
	int iPos;
	CString strInputString;

	if(strKey.IsEmpty() || ii_system.IsEmpty())
		return FALSE;

	sprintf(szFileName, "%s\\ingres\\files\\symbol.tbl", ii_system.GetBuffer((ii_system.GetLength()+1)));
	if(!theInputFile.Open(szFileName, CFile::modeRead | CFile::typeText, 0))
		return FALSE;
	while(theInputFile.ReadString(strInputString) != FALSE)
	{
		strInputString.TrimRight();
		iPos=strInputString.Find(strKey);
		if(iPos>=0)
		{
			if( (strInputString.GetAt(iPos+strKey.GetLength()) == '\t') || 
				(strInputString.GetAt(iPos+strKey.GetLength()) == ' ') )
			{ 
				strInputString = strInputString.Right(strInputString.GetLength()-strKey.GetLength());
				strInputString.TrimLeft();
				strRetValue=strInputString;
				theInputFile.Close();
				return TRUE;
			}
		}
	}
	theInputFile.Close();
	return FALSE;
}

/*
**	Name: IsWindows9X
**
**	Description:
**	Check if the operating system that is currently running is Windows9X.
**
**	History:
**	23-July-2001 (penga03)
**	    Created.
**	07-Sep-2001 (penga03)
**	    Also checked the major version number.
*/
BOOL 
IsWindows9X()
{
	OSVERSIONINFO osver;

	memset((char *)&osver, 0, sizeof(osver));
	osver.dwOSVersionInfoSize=sizeof(osver);

	GetVersionEx(&osver);
	if((osver.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS) && (osver.dwMajorVersion>=4))
		return TRUE;
	else
		return FALSE;
}

/*
**	Name: Local_PMget
**
**	Description:
**	A revised version of PMget independent of Ingres CL functions. 
**
**	History:
**	23-July-2001 (penga03)
**	    Created.
*/
BOOL 
Local_PMget(CString strKey, CString ii_system, CString &strRetValue)
{
	char szFileName[MAX_PATH+1];
	CStdioFile theInputFile;
	int iPos;
	CString strInputString;

	if(strKey.IsEmpty() || ii_system.IsEmpty())
		return FALSE;

	sprintf(szFileName, "%s\\ingres\\files\\config.dat", ii_system.GetBuffer((ii_system.GetLength()+1)));
	if(!theInputFile.Open(szFileName, CFile::modeRead | CFile::typeText, 0))
		return FALSE;
	while(theInputFile.ReadString(strInputString) != FALSE)
	{
		strInputString.TrimRight();
		iPos=strInputString.Find(strKey);
		if(iPos>=0)
		{
			if( (strInputString.GetAt(iPos+strKey.GetLength()) == ':') || 
				(strInputString.GetAt(iPos+strKey.GetLength()) == ' ') )
			{ 
				strInputString = strInputString.Right(strInputString.GetLength()-strKey.GetLength()-1);
				strInputString.TrimLeft();
				strRetValue=strInputString;
				theInputFile.Close();
				return TRUE;
			}
		}
	}
	theInputFile.Close();
	return FALSE;
}

/*
**  Name: IngresAlreadyRunning
**
**  Description:
**	Check if Ingres identified by II_SYSTEM is already running.
**
**  Returns:
**	-1	config.dat doesn't exist
**		(Ingres identified by II_SYSTEM is not installed)
**	 0	config.dat exists but Ingres not running
**		(Ingres indentified by II_SYSTEM is installed but not running)
**	 1	iigcn is running
**		(Ingres indentified by II_SYSTEM is installed and running)
**
**  History:	
**	23-Jul-2001 (penga03)
**	    Created.
**	15-aug-2001 (somsa01)
**	    Since users are told to remove everything in their bin and
**	    utility directories before performing an upgrade, iigcn.exe will
**	    not exist. Therefore, we'll use the check for config.dat as
**	    the surefire way of letting us know that there is a valid
**	    installation here, then go on from there to see if Ingres is
**	    running.
**	10-sep-2001 (penga03)
**	    Use GetFileAttributes to check whether a file exists or not.
**  01-apr-2008 (wonca01) BUG 120024
**      Add return code 2 and throw error message to user for situations
**      Iigcn.exe cannot be deleted to due permission.
*/
int
IngresAlreadyRunning()
{
    CString	csIigcn, csTemp, ii_system, csConfig;
    char	SubKey[128], SubKey2[128];
    HKEY	hkSubKey;
    DWORD	type, size, attrib;

	sprintf(SubKey2, "SOFTWARE\\IngresCorporation\\Ingres\\%s_Installation",
		thePreInstall.m_InstallCode);
    sprintf(SubKey, "SOFTWARE\\ComputerAssociates\\Ingres\\%s_Installation",
	    thePreInstall.m_InstallCode);
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SubKey, 0, KEY_QUERY_VALUE,
		     &hkSubKey) == ERROR_SUCCESS 
		|| RegOpenKeyEx(HKEY_LOCAL_MACHINE, SubKey2, 0, KEY_QUERY_VALUE,
			 &hkSubKey) == ERROR_SUCCESS)
	{
	RegQueryValueEx(hkSubKey, "II_SYSTEM", 0, &type,
			(BYTE *)ii_installpath, &size);
	RegCloseKey(hkSubKey);
    }
    else
	return -1;

    csConfig.Format("%s\\ingres\\files\\config.dat", ii_installpath);
    if (GetFileAttributes(csConfig) != -1)
    {
	/*
	** We have an installation. Now we have to see if it is running...
	*/
	csIigcn.Format("%s\\ingres\\bin\\iigcn.exe", ii_installpath);
	attrib = GetFileAttributes(csIigcn);
	if ((attrib != -1) && !(attrib & FILE_ATTRIBUTE_READONLY))
	{
	    /*
	    ** We have to use a hack to see if the installation is
	    ** running. This is by trying to delete the iigcn.exe
	    ** executable. We must use the hack so that we do not
	    ** have to link with Ingres libraries (which then
	    ** causes the install.exe to use the Ingres DLLs) to
	    ** utilize ping_iigcn().
	    */
	    csTemp.Format("%s\\ingres\\bin\\temp.exe", ii_installpath);
	    CopyFile(csIigcn, csTemp, FALSE);
	    if (DeleteFile(csIigcn))
	    {
		/* iigcn is not running */
		CopyFile(csTemp, csIigcn, FALSE);
		DeleteFile(csTemp);
		return 0;
	    }
	    else
	    {
		/* iigcn is running */
		DeleteFile(csTemp);
		return 1;
	    }
	}
	else
	{
	    /*
	    ** iigcn.exe does not exist. Therefore, the installation
	    ** cannot possibly be running.
	    */
		MessageBox(NULL,"Iigcn.exe cannot be READONLY\n",NULL,MB_OK);
	    return 2;
	}
    }
    else
	return 0;
}

/*
**	Name: WinstartRunning
**
**	Description:
**	Check if Winstart is running.
**
**	History:	
**	23-July-2001 (penga03)
**	    Created.
*/
BOOL
WinstartRunning()
{
	CString title;
	/*
	HANDLE hSemaphore;
	CString SemaphoreName;

	SemaphoreName.Format("IngresII_Winstart_%s", thePreInstall.m_InstallCode); 
	hSemaphore=OpenSemaphore(SEMAPHORE_ALL_ACCESS, FALSE, SemaphoreName);
	if (hSemaphore != NULL)
	{
		CloseHandle(hSemaphore);
		return TRUE;
	}
	*/
	title.Format("Ingres - Service Manager [%s]", thePreInstall.m_InstallCode);
	if(FindWindow(NULL, title) != 0)
		return TRUE;

	title=CString("Ingres - Service Manager");
	if(FindWindow(NULL, title) != 0)
		return TRUE;

	title=CString("Ingres - IngStart");
	if(FindWindow(NULL, title) != 0)
		return TRUE;

	return FALSE;
}

/*
**  Name: ExecuteEx
**
**  Description:
**	Create a new process to execute an executable file.
**
**  History:
**	19-feb-2004 (penga03)
**	    Created.
*/
BOOL 
ExecuteEx(LPCSTR lpCmdLine, BOOL bWait/*=TRUE*/, BOOL bWindow/*=FALSE*/)
{
    PROCESS_INFORMATION	pi;
    STARTUPINFO		si;
    DWORD dwCreationFlags=CREATE_NO_WINDOW | NORMAL_PRIORITY_CLASS;

    memset((char*)&pi, 0, sizeof(pi)); 
    memset((char*)&si, 0, sizeof(si)); 
    si.cb = sizeof(si);

    if (bWindow)
    {
	si.dwFlags=STARTF_USESHOWWINDOW;
	si.wShowWindow=SW_MINIMIZE;
	dwCreationFlags=NORMAL_PRIORITY_CLASS;
    }
    if (CreateProcess(NULL, (LPSTR)lpCmdLine, NULL, NULL, TRUE, 
                      dwCreationFlags, NULL, NULL, &si, &pi))
    {
	if (bWait)
	{
	    DWORD   dw;

	    WaitForSingleObject(pi.hProcess, INFINITE);
	    GetExitCodeProcess(pi.hProcess, &dw);
	    CloseHandle(pi.hProcess);
	    CloseHandle(pi.hThread);
	    return(dw==0);
	}
	else
	{
	    CloseHandle(pi.hProcess);
	    CloseHandle(pi.hThread);
	    return TRUE;
	}
    }
    return FALSE;
}
/*
**	Name: InstallMSRedistributions
**
**	Description:
**	Install Microsoft redistributions.
**
**	History:	
**	19-Feb-2004 (penga03)
**	    Created. Install mfc71.dll, mfc71u.dll, msvcp71.dll 
**	    and msvcr71.dll.
*/
BOOL 
InstallMSRedistributions()
{
    char ach[MAX_PATH+1], *p, msredistloc[MAX_PATH+1], systemfolder[MAX_PATH+1];

    GetModuleFileName(AfxGetInstanceHandle(),ach,sizeof(ach));
    p=_tcsrchr(ach,'\\');
    if(*p) *(p)=0;
    sprintf(msredistloc, "%s\\msredist", ach);
    GetSystemDirectory(systemfolder, sizeof(systemfolder));

    sprintf(ach, 
	"MsiExec.exe /i \"%s\\MSRedists.msi\" /qn INSTALLDIR=%s", 
	msredistloc, systemfolder);
    if (ExecuteEx(ach)) {return TRUE;}
    else {return FALSE;}
}

void 
AppendToLog(LPCSTR p)
{
    DWORD   dw;
    CString s;

    if (!hLogFile) 
	return;

    if (_tcsstr(p,"..."))
    {
	s.LoadString(IDS_SEPARATOR);
	WriteFile(hLogFile, s, s.GetLength(), &dw, NULL);
    }
    s = p;
    s += "\r\n"; 
    WriteFile(hLogFile, s, s.GetLength(), &dw, NULL);
}

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseApp

BEGIN_MESSAGE_MAP(CEnterpriseApp, CWinApp)
//{{AFX_MSG_MAP(CEnterpriseApp)
// NOTE - the ClassWizard will add and remove mapping macros here.
//    DO NOT EDIT what you see in these blocks of generated code!
//}}AFX_MSG
ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseApp construction

CEnterpriseApp::CEnterpriseApp()
{
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEnterpriseApp object

CEnterpriseApp theApp;
CPreInstallation thePreInstall;
HICON theIcon=0;
CPropSheet *property=0;
char ii_installpath[MAX_PATH+1];

/////////////////////////////////////////////////////////////////////////////
// CEnterpriseApp initialization

/*
**	History:
**	23-July-2001 (penga03)
**	    For silence mode installation, also check if there exists an installation 
**	    installed by old installer, if there exists, ask user if upgrade this 
**	    installation.
**	23-July-2001 (penga03)
**	    For silence mode installation, if ingres is running, terminate installing.
**	31-dec-2001 (penga03)
**	    Removed m_SkipLicenseCheck.
**	14-jan-2002 (penga03)
**	    Trim the quotes around the path of the response file passed by the command 
**	    line, otherwise GetFileAttributes will fail.
**	30-jul-2002 (penga03)
**	    If the Ingres instance being upgraded was embedded, 
**	    keep the way it was.
**	28-oct-2004 (penga03)
**	    Removed the checking of /embed.
*/
BOOL CEnterpriseApp::InitInstance()
{
	// Standard initialization
	hLogFile=0;
	return_code=0;
	hSystemPalette=0;
	theIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
	BOOL installRes = 0;
	
/*	// InitCommonControlsEx() is required on Windows XP if an application
	// manifest specifies use of ComCtl32.dll version 6 or later to enable
	// visual styles.  Otherwise, any window creation will fail.
	INITCOMMONCONTROLSEX InitCtrls;
	InitCtrls.dwSize = sizeof(InitCtrls);
	// Set this to include all the common control classes you want to use
	// in your application.
	InitCtrls.dwICC = ICC_WIN95_CLASSES;
	InitCommonControlsEx(&InitCtrls);
*/
	InitCommonControls();
	CWinApp::InitInstance();

	AfxEnableControlContainer();
	
	if(IsGoodOSVersionAndRights())
	{
		if(m_lpCmdLine)
		{
			CString strBuffer;
			int iPos;
			char ach[2048], ii_system[1024];
			BOOL bInstalled=FALSE;

			strBuffer=m_lpCmdLine;
			strBuffer.MakeLower();
			
			iPos=strBuffer.Find("/?");
			if(iPos>=0)
			{
				Error(IDS_INSTALLERUSAGE);
				return FALSE;
			}
			
			
			iPos=strBuffer.Find("/l");
			if(iPos>=0)
			{
			    if (GetTempPath(sizeof(ach), ach))
			    {
				if (ach[strlen(ach)-1] == '\\') ach[strlen(ach)-1]='\0';
				thePreInstall.m_MSILog.Format("%s\\patchmsi.log", ach);
			    }
			    else
				thePreInstall.m_MSILog ="C:\\Temp\\patchmsi.log";
			}

			
			iPos=strBuffer.Find("/id");
			if(iPos>=0)
			{
				char iicode[3];
				char szKey[256], szKey2[256], szResName[256];
				int idx;
				HKEY hKey;
				BOOL bCluster;

				/* silent mode */

				CString strRSPFile, csTemp;
				
				strRSPFile=strBuffer.Mid(iPos+3);
				strRSPFile.TrimLeft();
				strRSPFile.TrimLeft('\"');
				strRSPFile.TrimRight();
				strRSPFile.TrimRight('\"');
				
				if (strRSPFile.IsEmpty())
				{
					Error(IDS_INSTALLERUSAGE);
					return FALSE;

				}
				iicode[0] = strRSPFile.GetAt(0);
				iicode[1] = strRSPFile.GetAt(1);
				iicode[2] = '\0';

				if (isalpha(iicode[0]) && (isalpha(iicode[1]) || isdigit(iicode[1])))
					thePreInstall.m_InstallCode=iicode;
				else
				{
					Error(IDS_INVALIDINSTALLATIONCODE, iicode);
					return FALSE;
				}			

				sprintf(szKey, "SOFTWARE\\IngresCorporation\\Ingres\\%s_Installation", iicode);
				sprintf(szKey2, "SOFTWARE\\ComputerAssociates\\Ingres\\%s_Installation", iicode);
				if (!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hKey) 
					|| !RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey2, 0, KEY_QUERY_VALUE, &hKey))
				{
					DWORD dwSize=sizeof(ii_system);

					if (RegQueryValueEx(hKey,"II_SYSTEM",0,0,(BYTE *)ii_system,&dwSize))
					{
						return_code=1;
						return TRUE;
					}
				}


				if (_stricmp(iicode, "II"))
				{
					/* Compute the GUID index from the installation code */
					idx = (toupper(iicode[0]) - 'A') * 26 + toupper(iicode[1]) - 'A';
					if (idx <= 0)
						idx = (toupper(iicode[0]) - 'A') * 26 + toupper(iicode[1]) - '0';

					sprintf(szKey, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{A78D%04X-2979-11D5-BDFA-00B0D0AD4485}",idx);
				}
				else 
					sprintf(szKey, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\{A78D00D8-2979-11D5-BDFA-00B0D0AD4485}");


				bCluster=FALSE;
				if(!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hKey))
				{
					char szData[2];
					DWORD dwSize;

					dwSize=sizeof(szData); *szData=0;
					if (!RegQueryValueEx(hKey,"IngresClusterInstall", NULL, NULL, (BYTE *)szData, &dwSize) && !strcmp(szData, "1"))
						bCluster=TRUE;
					dwSize=sizeof(szResName); *szResName=0;
					if (!RegQueryValueEx(hKey,"IngresClusterResource", NULL, NULL, (BYTE *)szResName, &dwSize))
						sprintf(szResName, "Ingres Service [ %s ]", iicode);
					RegCloseKey(hKey);
				}
					
				if(IngresAlreadyRunning()==1)
				{
					char buf[2048];

					thePreInstall.m_RestartIngres=1;

					SetEnvironmentVariable("II_SYSTEM", ii_system);
					GetEnvironmentVariable("PATH", buf, sizeof(buf));
					sprintf(ach, "%s\\ingres\\bin;%s\\ingres\\utility;%s", 
						ii_system, ii_system, buf);
					SetEnvironmentVariable("PATH", ach);

					if (!bCluster)
					{
					sprintf(ach, "\"%s\\ingres\\utility\\ingstop.exe\"", ii_system);
					ExecuteEx(ach);
					}
					else
					{
						HCLUSTER hCluster = NULL;
						HRESOURCE hResource = NULL;
						WCHAR lpwResourceName[256];

						hCluster = OpenCluster(NULL);
						if (hCluster)
						{
							mbstowcs(lpwResourceName, szResName, 256);
							hResource = OpenClusterResource(hCluster, lpwResourceName);
							if (hResource)
							{
								OfflineClusterResource(hResource);
								CloseClusterResource(hResource);
							}
						}
					}
					while (IngresAlreadyRunning()==1)
						Sleep(1000);

					sprintf(ach, "\"%s\\ingres\\bin\\ivm.exe\"", ii_system);
					if (!Execute(ach, "-stop", TRUE))
					{
						sprintf(ach, "\"%s\\ingres\\vdba\\ivm.exe\"", ii_system);
						Execute(ach, "-stop", TRUE);
					}
				}

				
				if (strBuffer.Find("/silent") < 0 && (installRes = thePreInstall.LaunchPatchInstaller()) == ERROR_SUCCESS)
					return TRUE;
				else if (installRes != ERROR_SUCCESS)
				{
					if (hLogFile)
						CloseHandle(hLogFile);
					return_code = 1;
					return FALSE;
				}
			}

			iPos=strBuffer.Find("/silent");
			if (iPos>=0)
			{
				thePreInstall.m_SilentInstall=TRUE;
				if (thePreInstall.m_InstallCode.IsEmpty())
				{
					Error( IDS_INSTALLERUSAGE);
					return FALSE;
				}

				

				if ((installRes = thePreInstall.LaunchPatchInstaller()) == ERROR_SUCCESS)
					return TRUE;
				else
				{
					if (hLogFile)
						CloseHandle(hLogFile);
					return_code = 1;
					return FALSE;
				}
			}

				
			
		}/* if(m_lpCmdLine) */
		
				/* Check if Wizard is already running */
		if(!AlreadyRunning())
		{
			property=new CPropSheet(IDS_TITLE);

			m_pMainWnd=property;
			INT_PTR response=property->DoModal();
		}
	}/* if(IsGoodOSVersionAndRights()) */
	
	return FALSE;
}

static BOOL
FileExists(LPCSTR s)
{
    HANDLE File = CreateFile(s,0,0,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);

    if (File == INVALID_HANDLE_VALUE)
	return FALSE;

    CloseHandle(File);
    return TRUE;
}

int 
CEnterpriseApp::ExitInstance()
{
	char szBuf[1024], szBuf2[1024], szII_SYSTEM[1024];
	HKEY hKey;
	DWORD dwSize;
	
	sprintf(szBuf, "SOFTWARE\\IngresCorporation\\Ingres\\%s_Installation", thePreInstall.m_InstallCode);
	sprintf(szBuf2, "SOFTWARE\\ComputerAssociates\\Ingres\\%s_Installation", thePreInstall.m_InstallCode);
	if ((!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf, 0, KEY_QUERY_VALUE, &hKey) ||
		!RegOpenKeyEx(HKEY_LOCAL_MACHINE, szBuf2, 0, KEY_QUERY_VALUE, &hKey)) && thePreInstall.m_SilentInstall)
	{
		dwSize=sizeof(szII_SYSTEM); *szII_SYSTEM=0;
		if (!RegQueryValueEx(hKey, "II_SYSTEM", 0, 0, (BYTE *)szII_SYSTEM, &dwSize))
		{
			sprintf(szBuf, "%s\\ingres\\files\\patch.log", szII_SYSTEM);
			
			hLogFile=CreateFile(szBuf, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL, 0);
			if (hLogFile == INVALID_HANDLE_VALUE)
				hLogFile=0;
			else
			{
				SetFilePointer(hLogFile, 0, 0, FILE_END);
				
				sprintf(szBuf, "PatchUpdate.exe: RC = %d", return_code);
				AppendToLog(szBuf);

				CloseHandle(hLogFile);
			}
		}

		RegCloseKey(hKey);
	}
	
	return return_code;
}
