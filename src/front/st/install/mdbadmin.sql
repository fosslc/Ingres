/*
** Copyright (c) 2004 Ingres Corporation
*/

/* SQL script created by COPYDB, version II 3.0/0404 (int.w32/85). */

\sql
set autocommit on
\p\g
set nojournaling
\p\g
\sql
set session with privileges=all
\p\g

	/* TABLES */
\nocontinue
create table acc_lvls(
	id integer not null,
	persid varchar(30),
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify acc_lvls to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy acc_lvls () from 'acc_lvls.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on acc_lvls
\p\g
create table access_policy_identity_asc(
	user_group_identity_asc_id byte(16) not null,
	access_policy_uuid byte(16) not null,
	identity_label varchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify access_policy_identity_asc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy access_policy_identity_asc () from 'access_policy_identity_asc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on access_policy_identity_asc
\p\g
create table acctyp(
	id integer not null,
	del integer not null,
	sym varchar(30) not null,
	description varchar(100),
	view_internal integer,
	form_group integer,
	initial_form varchar(256),
	domain integer,
	domain_flag integer not null,
	external_auth integer not null,
	user_auth integer not null,
	pin_field varchar(50),
	interface_type integer,
	sd_admin integer,
	sd_analyst integer,
	sd_employee integer,
	sd_customer integer,
	kt_admin integer,
	kt_manager integer,
	kt_engineer integer,
	kt_analyst integer,
	kt_customer integer,
	ct_analyst integer,
	ct_customer integer,
	config integer,
	pref_doc integer,
	access_level integer not null,
	grant_level integer not null,
	ct_type integer,
	kt_type integer,
	call_mgr integer,
	change_mgr integer,
	issue_mgr integer,
	inventory integer,
	reference integer,
	notify integer,
	admin integer,
	security integer,
	kd integer,
	kcat integer,
	default_flag integer,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	ldap_access_group varchar(512)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify acctyp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy acctyp () from 'acctyp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on acctyp
\p\g
create table act_log(
	id integer not null,
	persid varchar(30),
	call_req_id varchar(30),
	last_mod_dt integer,
	time_spent integer,
	time_stamp integer,
	system_time integer,
	analyst byte varying(16),
	description long varchar,
	action_desc long varchar,
	type varchar(30),
	knowledge_session varchar(80),
	knowledge_tool varchar(12),
	internal integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify act_log to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy act_log () from 'act_log.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on act_log
\p\g
create table act_type(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	description varchar(500),
	notify integer,
	notify_level integer,
	notify_body long varchar,
	notify_body_html long varchar,
	notify_title varchar(80),
	notify_ack varchar(240),
	code varchar(12) not null,
	internal integer,
	flag1 integer,
	flag2 integer,
	flag3 integer,
	flag4 integer,
	flag5 integer,
	cr_notify_info varchar(30),
	chg_notify_info varchar(30),
	iss_notify_info varchar(30),
	mgs_notify_info varchar(30),
	kd_notify_info varchar(30),
	cr_send_survey integer,
	cr_survey_msgbody long varchar,
	cr_default_survey integer,
	cr_survey_msgtitle varchar(80),
	cr_survey_method integer,
	chg_send_survey integer,
	chg_survey_msgbody long varchar,
	chg_default_survey integer,
	chg_survey_msgtitl varchar(80),
	chg_survey_method integer,
	iss_send_survey integer,
	iss_survey_msgbody long varchar,
	iss_default_survey integer,
	iss_survey_msgtitl varchar(80),
	iss_survey_method integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify act_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy act_type () from 'act_type.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on act_type
\p\g
create table actbool(
	id integer not null,
	del integer not null,
	enum integer not null,
	last_mod_dt integer,
	sym varchar(12),
	description varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify actbool to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy actbool () from 'actbool.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on actbool
\p\g
create table action(
	actionid integer not null,
	requesttime date,
	starttime date,
	finishtime date,
	actiongroupid integer not null,
	actiontype integer,
	actionstatus integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify action to btree unique on
	actionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy action () from 'action.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on action
\p\g
create table actiongroup(
	actiongroupid integer not null,
	requestid integer not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify actiongroup to btree unique on
	actiongroupid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy actiongroup () from 'actiongroup.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on actiongroup
\p\g
create table actiontype(
	actiontype integer not null,
	description varchar(50),
	entityname varchar(50)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify actiontype to btree unique on
	actiontype
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy actiontype () from 'actiontype.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on actiontype
\p\g
create table actors(
	actor varchar(50) not null,
	actorinfo long byte,
	adapter varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify actors to btree unique on
	actor
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy actors () from 'actors.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on actors
\p\g
create table actrbool(
	id integer not null,
	del integer not null,
	enum integer not null,
	last_mod_dt integer,
	sym varchar(12),
	description varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify actrbool to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy actrbool () from 'actrbool.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on actrbool
\p\g
create table addmemo(
	domainid integer not null,
	adid integer not null,
	adtype integer not null,
	part integer not null,
	admemo text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify addmemo to btree unique on
	adid,
	adtype,
	part,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy addmemo () from 'addmemo.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on addmemo
\p\g
create table address(
	location_id byte(16) not null,
	person_uuid byte(16) not null,
	address_type varchar(20),
	address_text long varchar,
	city varchar(50),
	state varchar(50),
	postal_code varchar(20),
	country varchar(50),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify address to heap
with extend = 16,
	allocation = 4
\p\g
/* copy address () from 'address.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on address
\p\g
create table addtext(
	domainid integer not null,
	adid integer not null,
	adtype integer not null,
	part integer not null,
	adtext varchar(127)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify addtext to btree unique on
	adid,
	adtype,
	part,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy addtext () from 'addtext.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on addtext
\p\g
create table admin_tree(
	id integer not null,
	caption varchar(50),
	description varchar(255),
	has_children integer,
	parent_id integer,
	resource varchar(255),
	sd_admin integer,
	kt_admin integer,
	kt_manager integer,
	kt_ks_flag integer,
	kt_ks_caption varchar(50),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify admin_tree to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy admin_tree () from 'admin_tree.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on admin_tree
\p\g
create table aec_policy(
	name varchar(50) not null,
	classid varchar(50),
	description varchar(255),
	launchtype char(10),
	created integer,
	createdby varchar(60),
	modified integer,
	modifiedby varchar(60),
	evalnode varchar(64),
	status char(15),
	rulecontent long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify aec_policy to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy aec_policy () from 'aec_policy.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table alamode(
	type varchar(20),
	int_val integer,
	str_val varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alamode to heap
with extend = 16,
	allocation = 4
\p\g
/* copy alamode () from 'alamode.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on alamode
\p\g
create table alarm(
	eoid varchar(32),
	alarm integer,
	alarm_time integer,
	job_name varchar(64),
	joid integer,
	evt_num integer,
	state integer,
	the_user varchar(60),
	state_time integer,
	event_comment varchar(255),
	len integer,
	response varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alarm to btree unique on
	eoid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy alarm () from 'alarm.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alarm
\p\g
create table alert_action_history(
	alert_action_history_id integer not null,
	alert_message_id integer,
	action integer,
	contacts char(1),
	status integer,
	severity integer,
	origin varchar(255),
	notes char(1),
	creation_date date,
	system_status integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alert_action_history to btree unique on
	alert_action_history_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy alert_action_history () from 'alert_action_history.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alert_action_history
\p\g
create table alert_message(
	alert_message_id integer not null,
	monitor_id integer,
	operation_group_id integer,
	service_name varchar(255),
	operation_name varchar(255),
	message_time date,
	server_ip varchar(255),
	port_address varchar(255),
	severity integer,
	severity_name varchar(255),
	monitor_type integer,
	message_status integer,
	threshold integer,
	violation integer,
	requestor_ip varchar(255),
	requestor_domain varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alert_message to btree unique on
	alert_message_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy alert_message () from 'alert_message.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alert_message
\p\g
create table alert_message_property(
	alert_message_property_id integer not null,
	alert_message_id integer,
	name varchar(255),
	value_data_type integer,
	value_int integer,
	value_char varchar(255),
	value_date date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alert_message_property to btree unique on
	alert_message_property_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy alert_message_property () from 'alert_message_property.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alert_message_property
\p\g
create table alert_recipient(
	alert_recipient_id integer not null,
	notification_type integer,
	alert_message_id integer,
	contact_id integer,
	snmp_manager_id integer,
	ext_command_id integer,
	contact_list_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alert_recipient to btree unique on
	alert_recipient_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy alert_recipient () from 'alert_recipient.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alert_recipient
\p\g
create table alert_transaction(
	alert_transaction_id integer not null,
	transaction_id varchar(255),
	alert_message_id integer,
	fault_code varchar(255),
	fault_string varchar(255),
	request char(1),
	response char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alert_transaction to btree unique on
	alert_transaction_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy alert_transaction () from 'alert_transaction.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alert_transaction
\p\g
create table alertdata(
	tstamp date not null,
	qmgrid integer not null,
	objectid integer not null,
	objectmetric varchar(10) not null,
	objectgroup varchar(10),
	objectstatus integer,
	objectdescription varchar(75),
	objectmetricunit varchar(12),
	objectmetrictype char(48),
	objectvalue varchar(15),
	objectwarn char(48),
	objectcrit char(48),
	issent smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alertdata to heap
with extend = 16,
	allocation = 4
\p\g
/* copy alertdata () from 'alertdata.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on alertdata
\p\g
create table alertdrillmap(
	fieldindex integer not null,
	rptindex integer,
	tablename varchar(32),
	columnname varchar(64)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alertdrillmap to hash unique on
	fieldindex
with fillfactor = 50,
	extend = 4
\p\g
/* copy alertdrillmap () from 'alertdrillmap.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alertdrillmap
\p\g
create table alias(
	eid integer not null not default,
	a_eid integer not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify alias to btree unique on
	eid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy alias () from 'alias.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on alias
\p\g
create table am_map(
	id integer not null,
	persid varchar(30),
	am_unit_domain_id integer,
	am_unit_id integer,
	am_type integer,
	am_dmuuid varchar(64),
	am_server varchar(64),
	am_domain_id integer,
	version integer not null,
	ob_persid varchar(30),
	ob_type varchar(30),
	int1_rsrved integer,
	int2_rsrved integer,
	str1_rsrved varchar(80),
	str2_rsrved varchar(80)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify am_map to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy am_map () from 'am_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on am_map
\p\g
create table amaccmap(
	domainid integer not null,
	acid integer not null,
	acsrv varchar(127),
	acname varchar(127),
	actype integer,
	acdesc varchar(127),
	acstate integer,
	acrights text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify amaccmap to btree unique on
	acid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy amaccmap () from 'amaccmap.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on amaccmap
\p\g
create table amepdef(
	domainid integer not null,
	epid integer not null,
	eptitle varchar(127),
	eparea integer,
	epevent integer,
	epsev integer,
	epstate integer,
	epflags integer,
	ephisday integer,
	epid1 integer,
	epid2 integer,
	epid3 integer,
	epid4 integer,
	epjsup varchar(127),
	epvfmt integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify amepdef to btree unique on
	epid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy amepdef () from 'amepdef.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on amepdef
\p\g
create table amephis(
	domainid integer,
	epid integer,
	eparea integer,
	epevent integer,
	hdate integer,
	hpri varchar(100),
	hpritype integer,
	hpridid integer,
	hpriid integer,
	hsec varchar(100),
	hsectype integer,
	hsecdid integer,
	hsecid integer,
	hter varchar(100),
	htertype integer,
	hterdid integer,
	hterid integer,
	huser varchar(100),
	huserdid integer,
	huserid integer,
	hold varchar(100),
	hnew varchar(50),
	epvfmt integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify amephis to btree on
	huserid,
	huserdid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy amephis () from 'amephis.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on amephis
\p\g
create table amepjobs(
	epdomid integer not null,
	epid integer not null,
	epjtype integer not null,
	epjorder integer not null,
	epjcont text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify amepjobs to btree unique on
	epid,
	epdomid,
	epjtype,
	epjorder
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy amepjobs () from 'amepjobs.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on amepjobs
\p\g
create table analysis(
	analysisid integer not null,
	name varchar(255) not null,
	owner varchar(255),
	propertytype integer not null,
	propertyid integer,
	filterid integer,
	listtype integer,
	matchestype integer,
	casesensitive integer,
	usebasecolor integer,
	basecolor integer,
	checkoutsid varchar(100),
	checkoutname varchar(100),
	psname varchar(255),
	altpropid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify analysis to btree unique on
	analysisid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy analysis () from 'analysis.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on analysis
\p\g
create table analysisproperties(
	analysisid integer not null,
	expression varchar(255),
	position integer not null,
	condtype integer,
	red integer,
	green integer,
	blue integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify analysisproperties to btree unique on
	analysisid,
	position
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy analysisproperties () from 'analysisproperties.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on analysisproperties
\p\g
create table analyzer_event(
	event_id decimal(5,0) not null,
	event_name varchar(15) not null,
	event_desc varchar(40) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify analyzer_event to btree unique on
	event_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy analyzer_event () from 'analyzer_event.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on analyzer_event
\p\g
create table analyzer_metric(
	metric_id decimal(5,0) not null,
	metric_name varchar(30) not null,
	created_by varchar(30),
	created_date date,
	query_id decimal(5,0),
	column_nbr decimal(5,0),
	metric_internal decimal(1,0),
	metric_version decimal(1,0) not null,
	metric_type decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify analyzer_metric to btree unique on
	metric_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy analyzer_metric () from 'analyzer_metric.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on analyzer_metric
\p\g
create table analyzer_part_tab_files(
	part_key decimal(5,0) not null,
	mb_spread decimal(5,0) not null,
	device_id decimal(5,0) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify analyzer_part_tab_files to heap
with extend = 16,
	allocation = 4
\p\g
/* copy analyzer_part_tab_files () from 'analyzer_part_tab_files.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on analyzer_part_tab_files
\p\g
create table analyzer_part_tables(
	part_key decimal(3,0) not null,
	table_name varchar(30) not null,
	table_owner varchar(30) not null,
	type decimal(5,0) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify analyzer_part_tables to btree unique on
	part_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy analyzer_part_tables () from 'analyzer_part_tables.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on analyzer_part_tables
\p\g
create table analyzer_profile(
	profile_id decimal(5,0) not null,
	collect_id decimal(5,0),
	profile varchar(30),
	resource_name varchar(32),
	type varchar(8),
	limit varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify analyzer_profile to btree unique on
	profile_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy analyzer_profile () from 'analyzer_profile.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on analyzer_profile
\p\g
create table anima(
	id integer not null,
	a_name varchar(30),
	t_persid varchar(30),
	t_method varchar(30),
	t_type integer,
	a_time integer,
	a_org integer,
	a_delta integer,
	a_lock varchar(200),
	a_string varchar(30),
	a_act integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify anima to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy anima () from 'anima.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on anima
\p\g
create table anomaly(
	id integer,
	ruleid varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify anomaly to heap
with extend = 16,
	allocation = 4
\p\g
/* copy anomaly () from 'anomaly.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on anomaly
\p\g
create table anomalychange(
	anomalyid integer,
	comment varchar(255),
	score integer,
	active i1,
	timestamp date,
	adminid varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify anomalychange to heap
with extend = 16,
	allocation = 4
\p\g
/* copy anomalychange () from 'anomalychange.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on anomalychange
\p\g
create table anomalylinkobject(
	anomalyid integer,
	objectid integer,
	objecttable varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify anomalylinkobject to heap
with extend = 16,
	allocation = 4
\p\g
/* copy anomalylinkobject () from 'anomalylinkobject.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on anomalylinkobject
\p\g
create table appappr(
	mdomid integer not null,
	adomid integer not null,
	approved integer,
	apid integer,
	domainid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify appappr to btree unique on
	mdomid,
	adomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy appappr () from 'appappr.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on appappr
\p\g
create table application_instance(
	product_instance_id byte(16) not null,
	product_instance_name varchar(50),
	brand varchar(50),
	major_version varchar(20),
	minor_version varchar(20),
	description long varchar,
	install_date integer,
	product_instance_type varchar(20),
	translation_buffer long varchar,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	generation integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify application_instance to heap
with extend = 16,
	allocation = 4
\p\g
/* copy application_instance () from 'application_instance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on application_instance
\p\g
create table application_option(
	application_option_id byte(16) not null,
	unit_id byte(16) not null,
	application_type_id byte(16) not null,
	activation_date integer,
	deactivation_date integer,
	creation_user nvarchar(64),
	creation_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify application_option to btree unique on
	application_option_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy application_option () from 'application_option.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on application_option
\p\g
create table application_type(
	application_type_id byte(16) not null,
	application_type_name nvarchar(20),
	creation_user nvarchar(64),
	creation_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify application_type to btree unique on
	application_type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy application_type () from 'application_type.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on application_type
\p\g
create table applicationcfg(
	applicationid integer not null,
	applicationname varchar(48) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify applicationcfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy applicationcfg () from 'applicationcfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on applicationcfg
\p\g
create table applicationgroups(
	protocolname varchar(32) not null,
	family varchar(32),
	application varchar(32),
	port integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify applicationgroups to btree on
	protocolname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy applicationgroups () from 'applicationgroups.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on applicationgroups
\p\g
create table applicationitems(
	applicationid integer not null,
	qmgrid integer not null,
	objectid integer not null,
	objecttype varchar(48) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify applicationitems to heap
with extend = 16,
	allocation = 4
\p\g
/* copy applicationitems () from 'applicationitems.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on applicationitems
\p\g
create table applied_remediation(
	applied_remediation_rec_id byte(16) not null,
	asset_detection_profile_rec_id byte(16) not null,
	remediation_profile_id byte(16) not null,
	applied_remed_status_id byte(16) not null,
	task_status_date integer not null,
	status_changed_by nvarchar(64),
	note long nvarchar,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify applied_remediation to btree unique on
	applied_remediation_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy applied_remediation () from 'applied_remediation.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on applied_remediation
\p\g
create table applied_remediation_status(
	applied_remed_status_id byte(16) not null,
	name nvarchar(50) not null,
	creation_user nvarchar(64),
	creation_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify applied_remediation_status to btree unique on
	applied_remed_status_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy applied_remediation_status () from 'applied_remediation_status.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on applied_remediation_status
\p\g
create table approvalaction(
	actionid integer not null,
	approvercountry varchar(50),
	approverorganisation varchar(50),
	approverorgunit varchar(50),
	approvername varchar(50),
	approval integer,
	actortype integer,
	actorname varchar(50),
	approvercomment varchar(300),
	approvalcomment varchar(300)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify approvalaction to btree unique on
	actionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy approvalaction () from 'approvalaction.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on approvalaction
\p\g
create table appuknow(
	domainid integer not null,
	unitid integer not null,
	filepart integer not null,
	contain text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify appuknow to btree unique on
	unitid,
	domainid,
	filepart
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy appuknow () from 'appuknow.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on appuknow
\p\g
create table arcpur_hist(
	id integer not null,
	persid varchar(30),
	del integer not null,
	rule_name varchar(30) not null,
	start_time integer,
	end_time integer,
	obj_deleted integer,
	chd_obj_deleted integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify arcpur_hist to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy arcpur_hist () from 'arcpur_hist.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on arcpur_hist
\p\g
create table arcpur_rule(
	id integer not null,
	persid varchar(30),
	del integer not null,
	name varchar(30) not null,
	conf_obj_name varchar(30),
	days_inactive integer not null,
	arc_file_name varchar(240),
	sched varchar(30),
	reoccur_interv integer,
	oper_type integer not null,
	add_query varchar(240),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify arcpur_rule to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy arcpur_rule () from 'arcpur_rule.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on arcpur_rule
\p\g
create table arg_action(
	acadid integer not null,
	object_uuid byte(16) not null,
	ac1ivid smallint not null,
	acdatedt integer not null,
	actimetm nvarchar(8) not null,
	object_type smallint,
	accommnt nvarchar(255),
	actext1 nvarchar(50),
	acint1 smallint,
	acdate1 integer,
	acus1 nvarchar(50),
	acus2 nvarchar(50),
	acus3 nvarchar(50),
	acus4 nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_action to hash on
	acadid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_action () from 'arg_action.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_actiondf(
	adid integer not null,
	adtext nvarchar(50),
	adnxndid smallint,
	ad1obty smallint,
	adprot smallint,
	adtype smallint,
	adsystem smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_actiondf to hash on
	adid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_actiondf () from 'arg_actiondf.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_actionlk(
	lkacadid integer not null,
	primary_object_uuid byte(16) not null,
	lkac1ivi smallint not null,
	lkacdadt integer not null,
	lkactitm nvarchar(8) not null,
	lkndid smallint not null,
	secondary_object_uuid byte(16) not null,
	lk2ivid smallint not null,
	lkinstnc smallint not null,
	primary_object_type smallint,
	secondary_object_type smallint,
	lkstrtdt integer,
	lkenddt integer,
	lkcommnt nvarchar(255),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_actionlk to hash on
	lkacadid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_actionlk () from 'arg_actionlk.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_argdeflt(
	dfid integer not null,
	dfkey nvarchar(50) not null,
	dfsubkey nvarchar(10) not null,
	dftype integer,
	dfvalue long nvarchar,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_argdeflt to hash on
	dfid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_argdeflt () from 'arg_argdeflt.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_assetver(
	own_resource_uuid byte(16) not null,
	avivid smallint not null,
	model_uuid byte(16),
	avacqdt integer,
	avstatus smallint,
	avstatdt integer,
	avcurrnt smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_assetver to hash on
	own_resource_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_assetver () from 'arg_assetver.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_attachmt(
	object_uuid byte(16) not null,
	amid integer not null,
	object_type smallint,
	amfile nvarchar(250),
	amdesc nvarchar(255),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_attachmt to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_attachmt () from 'arg_attachmt.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_attribute_def(
	class_name nvarchar(100) not null,
	attribute_name nvarchar(100) not null,
	attribute_label nvarchar(255),
	attribute_alias nvarchar(100),
	relation_type smallint,
	table_name nvarchar(32),
	field_name nvarchar(32),
	attribute_type nvarchar(100),
	join_name nvarchar(100),
	class_template nvarchar(100),
	extensible smallint,
	control_object nvarchar(50),
	control_name nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_attribute_def to hash on
	class_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_attribute_def () from 'arg_attribute_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_class_def(
	class_name nvarchar(100) not null,
	class_label nvarchar(255),
	class_alias nvarchar(100),
	table_name nvarchar(32),
	class_template nvarchar(100),
	extensible smallint,
	control_object nvarchar(50),
	control_name nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_class_def to hash on
	class_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_class_def () from 'arg_class_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_controls(
	cnid integer not null,
	cnobject nvarchar(50),
	cnname nvarchar(50),
	table_name nvarchar(32),
	field_name nvarchar(32),
	cndefid integer,
	cntype smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_controls to hash on
	cnid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_controls () from 'arg_controls.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_costdet(
	object_uuid byte(16) not null,
	cdid smallint not null,
	object_type smallint,
	cdbegdt integer,
	cdivid smallint,
	cduntamt f4,
	company_uuid byte(16),
	cdbillcd nvarchar(50),
	cdcommnt nvarchar(255),
	cdamtper nvarchar(255),
	cdreunt smallint,
	cdreper smallint,
	cdretmdt integer,
	cdreact smallint,
	cdrecap smallint,
	cdreespc smallint,
	cdcstctr nvarchar(50),
	cdus1 nvarchar(50),
	cdus2 nvarchar(50),
	cdus3 nvarchar(50),
	cdus4 nvarchar(50),
	cdcurrty smallint,
	cdtype smallint,
	cdglcode nvarchar(50),
	cdpaytype smallint,
	cdpaytot f4,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_costdet to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_costdet () from 'arg_costdet.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_drpdnlst(
	dlldid integer not null,
	dlvalue nvarchar(50),
	dlpavalu nvarchar(50),
	dldesc nvarchar(50),
	dlprot smallint,
	dlkey smallint not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_drpdnlst to hash on
	dlldid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_drpdnlst () from 'arg_drpdnlst.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_evdefhdr(
	evid integer not null,
	evname nvarchar(50),
	evenable smallint,
	evaction smallint,
	evntfreq smallint,
	evdef smallint,
	table_name nvarchar(32),
	field_name nvarchar(32),
	evfrdef smallint,
	evfrtext nvarchar(255),
	evtodef smallint,
	evtotext nvarchar(255),
	evfirst smallint,
	evconfrm smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_evdefhdr to hash on
	evid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_evdefhdr () from 'arg_evdefhdr.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_evdefny(
	enevid integer not null,
	enid smallint not null,
	enenable smallint,
	entype smallint,
	enrtype smallint,
	enrecip nvarchar(50),
	contact_uuid byte(16),
	endaysa integer,
	entext long nvarchar,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_evdefny to hash on
	enevid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_evdefny () from 'arg_evdefny.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_evnotify(
	nyerid integer not null,
	nyid smallint not null,
	nysys smallint,
	nytype smallint,
	nytext long nvarchar,
	nyissudt integer,
	nyrecip nvarchar(50),
	nyrtype smallint,
	contact_uuid byte(16),
	nysndate integer,
	nyrvdate integer,
	nyrvfrom nvarchar(50),
	nyrvtype smallint,
	nycpdate integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_evnotify to hash on
	nyerid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_evnotify () from 'arg_evnotify.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_evrem(
	erid integer not null,
	object_uuid byte(16),
	erobtype smallint,
	erissudt integer,
	erstat smallint,
	ersys smallint,
	erevid integer,
	erivid smallint,
	erkey1 integer,
	erkey2 integer,
	erkey3 integer,
	erkey4 integer,
	erkey5 integer,
	erkey6 integer,
	erkey7 integer,
	erevntdt integer,
	contact_uuid byte(16),
	erchngdt integer,
	eroldv nvarchar(255),
	ernewv nvarchar(255),
	erextup smallint,
	eradinfo nvarchar(255),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_evrem to hash on
	erid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_evrem () from 'arg_evrem.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_extension_rule_def(
	rule_id integer,
	rule_name nvarchar(100),
	rule_description nvarchar(255),
	table_name nvarchar(32),
	field_name nvarchar(32),
	field_value nvarchar(255),
	ext_table_name nvarchar(32),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_extension_rule_def to hash on
	rule_id
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_extension_rule_def () from 'arg_extension_rule_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_extsys(
	esid integer not null,
	object_uuid byte(16) not null,
	esivid smallint not null,
	esobty smallint,
	esvalue1 nvarchar(50),
	esvalue2 nvarchar(50),
	esvalue3 nvarchar(50),
	esvalue4 nvarchar(50),
	esvalue5 nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_extsys to hash on
	esid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_extsys () from 'arg_extsys.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_field_def(
	table_name nvarchar(32),
	field_name nvarchar(32),
	field_description nvarchar(255),
	additional_info nvarchar(255),
	actual_table_name nvarchar(32),
	actual_field_name nvarchar(32),
	data_type smallint,
	data_size smallint,
	field_unique smallint,
	field_required smallint,
	primary_key smallint,
	foreign_key smallint,
	extended smallint,
	generate_reminder smallint,
	generate_event smallint,
	auditable smallint,
	attribute_popup smallint,
	attribute_autopopup smallint,
	attribute_formatted smallint,
	attribute_hidden smallint,
	attribute_codedpopup smallint,
	attribute_audited smallint,
	mass_change smallint,
	label_customizable smallint,
	user_field smallint,
	report_included smallint,
	lookup_included nvarchar(30),
	list_id integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_field_def to hash on
	table_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_field_def () from 'arg_field_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_filtcrit(
	fcfeid integer not null,
	fcid smallint not null,
	fcname nvarchar(100),
	fcenable smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_filtcrit to hash on
	fcfeid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_filtcrit () from 'arg_filtcrit.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_filtdata(
	ftfeid integer not null,
	ftfcid smallint not null,
	ftid smallint not null,
	ftfiname nvarchar(20),
	ftvalue long nvarchar,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_filtdata to hash on
	ftfeid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_filtdata () from 'arg_filtdata.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_filtdef(
	feid integer not null,
	fename nvarchar(100),
	fedesc nvarchar(255),
	feobtype smallint,
	fefields long nvarchar,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_filtdef to hash on
	feid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_filtdef () from 'arg_filtdef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_filtind(
	fnfeid integer not null,
	fnfcid smallint not null,
	object_uuid byte(16) not null,
	object_type smallint,
	fnenable smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_filtind to hash on
	fnfeid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_filtind () from 'arg_filtind.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_flagsobj(
	object_uuid byte(16) not null,
	object_type smallint,
	flflags nvarchar(20),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_flagsobj to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_flagsobj () from 'arg_flagsobj.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_history(
	object_uuid byte(16) not null,
	table_name nvarchar(32),
	field_name nvarchar(32) not null,
	hsinstnc integer not null,
	object_type smallint,
	hsaction nvarchar(10),
	hstblbl nvarchar(60),
	hsfddefi integer,
	hsfilbl nvarchar(60),
	hsovalue nvarchar(50),
	hsvalue nvarchar(50),
	hsotext nvarchar(255),
	hstext nvarchar(255),
	hsadinfo nvarchar(255),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer not null,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_history to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_history () from 'arg_history.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_hsnotify(
	hnhrid integer not null,
	hnid smallint not null,
	hnsys smallint,
	hntype smallint,
	hntext long nvarchar,
	hnissudt integer,
	hnrecip nvarchar(50),
	hnrtype smallint,
	contact_uuid byte(16),
	hnsndate integer,
	hnrvdate integer,
	hnrvfrom nvarchar(50),
	hnrvtype smallint,
	hncpdate integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_hsnotify to hash on
	hnhrid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_hsnotify () from 'arg_hsnotify.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_hsrem(
	hrid integer not null,
	object_uuid byte(16),
	hrobtype smallint,
	hrissudt integer,
	hrstat smallint,
	hrsys smallint,
	hrevid integer,
	hrivid smallint,
	hrkey1 integer,
	hrkey2 integer,
	hrkey3 integer,
	hrkey4 integer,
	hrkey5 integer,
	hrkey6 integer,
	hrkey7 integer,
	hrevntdt integer,
	contact_uuid byte(16),
	hrchngdt integer,
	hroldv nvarchar(255),
	hrnewv nvarchar(255),
	hrextup smallint,
	hradinfo nvarchar(255),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_hsrem to hash on
	hrid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_hsrem () from 'arg_hsrem.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_index_def(
	index_name nvarchar(32) not null,
	index_description nvarchar(255),
	table_name nvarchar(32),
	index_primary smallint,
	index_unique smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_index_def to hash on
	index_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_index_def () from 'arg_index_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_index_member(
	index_name nvarchar(32) not null,
	member_instance integer not null,
	table_name nvarchar(32),
	field_name nvarchar(32),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_index_member to hash on
	index_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_index_member () from 'arg_index_member.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_intrface(
	ifdssys nvarchar(50),
	ifdbnbr smallint,
	ifsrobj nvarchar(20),
	ifseq smallint,
	ifdatest integer,
	ifrectyp integer,
	ifdsobnm nvarchar(50),
	ifdsobid nvarchar(50),
	ifaction nvarchar(10),
	ifcommnt nvarchar(50),
	ifdsfld nvarchar(50),
	ifdstype nvarchar(5),
	ifdsparm nvarchar(255),
	ifdstext long nvarchar,
	ifdsdate integer,
	ifdsnum f4,
	ifmsgtxt nvarchar(255),
	ifsntosc nvarchar(50),
	ifsntofl nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_intrface to hash on
	ifdssys
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_intrface () from 'arg_intrface.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_intxref(
	ixatfrid integer not null,
	ixuuid nvarchar(64),
	ixhostnm nvarchar(64),
	ixdomid integer,
	ixunitid integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_intxref to hash on
	ixatfrid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_intxref () from 'arg_intxref.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_itemver(
	model_uuid byte(16) not null,
	ivid smallint not null,
	ivname nvarchar(20),
	ivavfrdt integer,
	ivavtodt integer,
	ivsuppdt integer,
	ivyear2k integer,
	ivmannbr nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_itemver to hash on
	model_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_itemver () from 'arg_itemver.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_join_def(
	join_name nvarchar(100) not null,
	join_description nvarchar(255),
	relation_type smallint,
	join_type smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_join_def to hash on
	join_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_join_def () from 'arg_join_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_join_member(
	join_name nvarchar(100) not null,
	member_instance integer not null,
	left_side_table nvarchar(100),
	left_side_field nvarchar(100),
	left_side_value nvarchar(255),
	right_side_table nvarchar(100) not null,
	right_side_field nvarchar(100) not null,
	right_side_value nvarchar(255),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_join_member to hash on
	join_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_join_member () from 'arg_join_member.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_keydef(
	kdid integer not null,
	kdkwtext nvarchar(50),
	kdprot smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_keydef to hash on
	kdid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_keydef () from 'arg_keydef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_keyword(
	kwkdid integer not null,
	object_uuid byte(16) not null,
	object_type smallint,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_keyword to hash on
	kwkdid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_keyword () from 'arg_keyword.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_legaldef(
	lgid integer not null,
	lgtype nvarchar(50),
	lgprot smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_legaldef to hash on
	lgid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_legaldef () from 'arg_legaldef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_legaldet(
	legaldoc_uuid byte(16) not null,
	lttdid integer not null,
	ltstrtdt integer,
	ltenddt integer,
	ltcommnt nvarchar(255),
	ltincltc smallint,
	ltsectn nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_legaldet to hash on
	legaldoc_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_legaldet () from 'arg_legaldet.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_legaldoc(
	legaldoc_uuid byte(16) not null,
	lelgid integer,
	external_company_uuid byte(16),
	internal_company_uuid byte(16),
	ledocidn nvarchar(50),
	negotiator_contact_uuid byte(16),
	ledesc nvarchar(100),
	leeffdt integer,
	letermdt integer,
	ledocloc nvarchar(50),
	leeleloc nvarchar(50),
	leinact smallint,
	lestatdt integer,
	lestatus smallint,
	leus1 nvarchar(50),
	leus2 nvarchar(50),
	leus3 nvarchar(50),
	leus4 nvarchar(50),
	requestor_contact_uuid byte(16),
	vendor_contact_uuid byte(16),
	lecnused smallint,
	leglcode nvarchar(50),
	lecstctr nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_legaldoc to hash on
	legaldoc_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_legaldoc () from 'arg_legaldoc.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_legalpar(
	legaldoc_uuid byte(16) not null,
	company_uuid byte(16) not null,
	lpcommnt nvarchar(255),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_legalpar to hash on
	legaldoc_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_legalpar () from 'arg_legalpar.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_legasset(
	own_resource_uuid byte(16) not null,
	legaldoc_uuid byte(16) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_legasset to hash on
	own_resource_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_legasset () from 'arg_legasset.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_legasstc(
	own_resource_uuid byte(16) not null,
	legaldoc_uuid byte(16) not null,
	lctdid integer not null,
	lcstrtdt integer,
	lcenddt integer,
	lccommnt nvarchar(255),
	lcincltc smallint,
	lcsectn nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_legasstc to hash on
	own_resource_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_legasstc () from 'arg_legasstc.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_linkdef(
	ndadid integer not null,
	ndid smallint not null,
	ndtext nvarchar(50),
	nd2obty smallint,
	nd2subty smallint,
	ndreqd smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_linkdef to hash on
	ndadid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_linkdef () from 'arg_linkdef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_listdef(
	ldid integer not null,
	ldlist nvarchar(50),
	description nvarchar(255),
	ldformat smallint,
	attribute_popup smallint,
	attribute_codedpopup smallint,
	ldprot smallint,
	ldtype smallint,
	translation_list_type smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_listdef to hash on
	ldid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_listdef () from 'arg_listdef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_ltcdef(
	tdid integer not null,
	tdtext nvarchar(255),
	tddatesp smallint,
	tdprot smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_ltcdef to hash on
	tdid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_ltcdef () from 'arg_ltcdef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_map(
	old_object_id_1 integer not null,
	old_object_id_2 integer not null,
	new_object_uuid byte(16),
	new_list_id integer,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_map to hash on
	old_object_id_1
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_map () from 'arg_map.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_map_db(
	old_table_name nvarchar(32),
	old_field_name nvarchar(32),
	new_table_name nvarchar(32),
	new_field_name nvarchar(32),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_map_db to hash on
	old_table_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_map_db () from 'arg_map_db.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_note_text(
	object_uuid byte(16) not null,
	instance smallint not null,
	text nvarchar(4000),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_note_text to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_note_text () from 'arg_note_text.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_notes(
	object_uuid byte(16) not null,
	noinstnc smallint not null,
	object_type smallint,
	nodate integer,
	notime nvarchar(8),
	contact_uuid byte(16),
	noivid smallint,
	notype nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_notes to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_notes () from 'arg_notes.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_paydet(
	object_uuid byte(16) not null,
	pdcdid smallint not null,
	pdid smallint not null,
	object_type smallint,
	pdduedt integer,
	pddueamt f4,
	pdpaydt integer,
	pdpayamt f4,
	pdintref nvarchar(35),
	pdpayref nvarchar(35),
	pdus1 nvarchar(50),
	pdus2 nvarchar(50),
	pdus3 nvarchar(50),
	pdus4 nvarchar(50),
	pdcstctr nvarchar(50),
	pdcommnt nvarchar(255),
	pdglcode nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_paydet to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_paydet () from 'arg_paydet.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_popuplst(
	plldid integer not null,
	plvalue varchar(255) not null,
	pldesc nvarchar(50) not null,
	plprot smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_popuplst to hash on
	plldid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_popuplst () from 'arg_popuplst.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_query_assignment(
	query_id integer not null,
	assignment_uuid nvarchar(32) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_query_assignment to hash on
	query_id
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_query_assignment () from 'arg_query_assignment.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_query_def(
	query_id integer not null,
	instance smallint not null,
	protected smallint,
	category nvarchar(255),
	title nvarchar(255),
	description nvarchar(4000),
	definition long nvarchar,
	export_type smallint,
	refresh_interval smallint,
	last_refresh_date integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_query_def to hash on
	query_id
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_query_def () from 'arg_query_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_quey_def(
	table_name nvarchar(32)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_quey_def to hash on
	table_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_quey_def () from 'arg_quey_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_reconcile_data(
	task_uuid byte(16) not null,
	reconcile_data_id integer not null,
	reconcile_data_type smallint,
	own_resource_uuid byte(16),
	discovery_id_1 nvarchar(64),
	discovery_id_2 nvarchar(64),
	discovery_id_3 nvarchar(64),
	discovery_id_4 nvarchar(64),
	discovery_id_5 nvarchar(64),
	discovery_asset_name nvarchar(255),
	discovery_operating_sys nvarchar(127),
	discovery_capacity f4,
	discovery_capacity_unit smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_reconcile_data to hash on
	task_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_reconcile_data () from 'arg_reconcile_data.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_reconcile_modification(
	sys_name nvarchar(30) not null,
	reconcile_modification_id integer not null,
	reconcile_action smallint,
	own_resource_uuid byte(16),
	own_resource_serial_num nvarchar(30),
	own_resource_host_name nvarchar(255),
	own_resource_alias nvarchar(30),
	own_resource_alternate_id nvarchar(30),
	discovery_id_1 nvarchar(64),
	discovery_id_2 nvarchar(64),
	discovery_id_3 nvarchar(64),
	discovery_id_4 nvarchar(64),
	discovery_id_5 nvarchar(64),
	dis_hw_uuid byte(16),
	discovery_asset_name nvarchar(255),
	discovery_asset_serial_num nvarchar(64),
	discovery_asset_sys_model nvarchar(127),
	discovery_asset_sys_vendor nvarchar(127),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_reconcile_modification to hash on
	sys_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_reconcile_modification () from 'arg_reconcile_modification.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_reconcile_msg_queue(
	task_uuid byte(16) not null,
	reconcile_msg_id integer not null,
	msg_creation_date integer,
	debug_level smallint,
	error_num integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_reconcile_msg_queue to hash on
	task_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_reconcile_msg_queue () from 'arg_reconcile_msg_queue.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_reconcile_msg_text(
	task_uuid byte(16) not null,
	reconcile_msg_id integer not null,
	msg_text nvarchar(4000),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_reconcile_msg_text to hash on
	task_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_reconcile_msg_text () from 'arg_reconcile_msg_text.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_reconcile_rule(
	task_uuid byte(16) not null,
	rule_id smallint not null,
	own_resource_field_name smallint,
	discovery_field_name smallint,
	translation_list_id integer,
	operator_type_indicator smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_reconcile_rule to hash on
	task_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_reconcile_rule () from 'arg_reconcile_rule.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_reconcile_task(
	task_uuid byte(16) not null,
	task_name nvarchar(100),
	task_description nvarchar(255),
	match_indicator smallint,
	add_assets_indicator smallint,
	asset_changes_indicator smallint,
	own_resource_deletes_indicator smallint,
	own_resource_deactiv_indicator smallint,
	discovery_deleted_indicator smallint,
	undo_match_indicator smallint,
	send_msg_to_queue_switch smallint,
	send_msg_to_event_log_switch smallint,
	send_msg_to_email_switch smallint,
	email_ids nvarchar(255),
	watch_os_switch smallint,
	watch_computer_name_switch smallint,
	watch_capacity_indicator smallint,
	load_capacity_indicator smallint,
	set_contact_switch smallint,
	add_item_switch smallint,
	item_translation_list_id integer,
	os_translation_list_id integer,
	new_asset_status integer,
	missing_asset_status integer,
	deactivated_asset_status integer,
	external_sys_id integer,
	locking_flag smallint,
	refresh_interval integer,
	last_refresh_date integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_reconcile_task to hash on
	task_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_reconcile_task () from 'arg_reconcile_task.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_roledef(
	rdid integer not null,
	rdname nvarchar(100),
	rddesc nvarchar(255),
	role_uuid byte(16),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_roledef to hash on
	rdid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_roledef () from 'arg_roledef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_script(
	sctype smallint not null,
	scobtype smallint not null,
	scname nvarchar(50),
	sctext long nvarchar,
	sclang nvarchar(50),
	scenable smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_script to hash on
	sctype
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_script () from 'arg_script.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_security(
	serdid integer not null,
	secnid integer not null,
	seattadd smallint,
	seattupd smallint,
	seattad2 smallint,
	seattup2 smallint,
	seprot smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_security to hash on
	serdid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_security () from 'arg_security.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_stathist(
	object_uuid byte(16) not null,
	shivid smallint not null,
	shstatus smallint not null,
	shstatdt integer not null,
	object_type smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_stathist to hash on
	object_uuid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_stathist () from 'arg_stathist.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_strlst(
	slid smallint not null,
	slentry smallint not null,
	slvalue1 nvarchar(60),
	slvalue2 nvarchar(60),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_strlst to hash on
	slid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_strlst () from 'arg_strlst.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_table_def(
	table_name nvarchar(32) not null,
	table_description nvarchar(255),
	database_name nvarchar(100),
	subschema_name nvarchar(100),
	extended smallint,
	virtual_table smallint,
	inactive smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_table_def to hash on
	table_name
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_table_def () from 'arg_table_def.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_tclgdef(
	tllgid integer not null,
	tltdid integer not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_tclgdef to hash on
	tllgid
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_tclgdef () from 'arg_tclgdef.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_translation_list(
	translation_list_id integer not null,
	translation_list_entry smallint not null,
	own_resource_value nvarchar(200),
	discovery_value nvarchar(200),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_translation_list to hash on
	translation_list_id
with fillfactor = 50,
	extend = 16,
	page_size = 4096
\p\g
/* copy arg_translation_list () from 'arg_translation_list.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table arg_xmlcache(
	cache_id integer,
	xml_data long nvarchar
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify arg_xmlcache to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy arg_xmlcache () from 'arg_xmlcache.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table as_cycle(
	cycname varchar(30),
	cycperiod integer,
	cycperst date,
	cycperen date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify as_cycle to btree unique on
	cycname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy as_cycle () from 'as_cycle.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on as_cycle
\p\g
create table asbnode(
	nod_name varchar(65) not null,
	nod_ckpt varchar(16),
	nod_boot varchar(16)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify asbnode to btree unique on
	nod_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy asbnode () from 'asbnode.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on asbnode
\p\g
create table asset_detection_profile(
	asset_detection_profile_rec_id byte(16) not null,
	dis_hw_uuid byte(16) not null,
	notes long nvarchar,
	status_changed_by varchar(85),
	locked_by varchar(85),
	global_status_rec_id byte(16),
	asset_detect_profile_status_id byte(16) not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify asset_detection_profile to btree unique on
	asset_detection_profile_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy asset_detection_profile () from 'asset_detection_profile.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on asset_detection_profile
\p\g
create table asset_detection_profile_status(
	asset_detect_profile_status_id byte(16) not null,
	name nvarchar(50) not null,
	creation_user nvarchar(64),
	creation_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify asset_detection_profile_status to btree unique on
	asset_detect_profile_status_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy asset_detection_profile_status () from 'asset_detection_profile_status.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on asset_detection_profile_status
\p\g
create table asset_group_process_schedule(
	asset_grp_proc_sched_rec_id byte(16) not null,
	asset_group_id byte(16) not null,
	process_schedule_id byte(16) not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify asset_group_process_schedule to btree unique on
	asset_grp_proc_sched_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy asset_group_process_schedule () from 'asset_group_process_schedule.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on asset_group_process_schedule
\p\g
create table asset_work_archive(
	archive_rec_id byte(16) not null,
	hardware_id byte(16) not null,
	remediation_profile_id byte(16),
	detection_profile_id byte(16) not null,
	task_status_date integer not null,
	status_updated_by nvarchar(64),
	note long nvarchar,
	archive_reason nvarchar(32),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify asset_work_archive to btree unique on
	archive_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy asset_work_archive () from 'asset_work_archive.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on asset_work_archive
\p\g
create table assettyp_profile(
	type varchar(24) not null,
	violmode varchar(8),
	accessread char(1),
	accesswrite char(1),
	accessdelete char(1),
	accessupdate char(1),
	accessexecute char(1),
	accesssearch char(1),
	accesscreate char(1),
	accesscontrol char(1),
	definitionmode char(1),
	protectionlevel varchar(20),
	createdate integer,
	createtime integer,
	createsource varchar(64),
	createnode varchar(64),
	createuser varchar(32),
	createpid char(5),
	updatedate integer,
	updatetime integer,
	updatesource varchar(64),
	updatenode varchar(64),
	updateuser varchar(32),
	updatepid char(5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify assettyp_profile to btree unique on
	type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy assettyp_profile () from 'assettyp_profile.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on assettyp_profile
\p\g
create table assignments(
	workitemid varchar(30) not null,
	workitemname varchar(30) not null,
	delegatedto varchar(30),
	delegatedby varchar(30),
	takenby varchar(30),
	takenfrom varchar(30),
	complete float,
	mustcomplete float,
	usertype varchar(4)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify assignments to heap
with extend = 16,
	allocation = 4
\p\g
/* copy assignments () from 'assignments.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on assignments
\p\g
create table ata_result(
	ata_result_id integer not null,
	name varchar(255),
	creation_date date,
	modification_date date,
	operation_group_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ata_result to btree unique on
	ata_result_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ata_result () from 'ata_result.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ata_result
\p\g
create table ata_result_entry(
	ata_result_entry_id integer not null,
	ata_result_id integer,
	monitor_type integer,
	severity_level integer,
	high_threshold integer,
	low_threshold integer,
	operation_id integer,
	result_mean integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ata_result_entry to btree unique on
	ata_result_entry_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ata_result_entry () from 'ata_result_entry.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ata_result_entry
\p\g
create table atn(
	id integer not null,
	del integer not null,
	at_name varchar(30),
	at_dflt varchar(30),
	at_sys varchar(30),
	at_obj varchar(30),
	at_desc varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify atn to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy atn () from 'atn.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on atn
\p\g
create table atomic_cond(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sequence integer not null,
	owning_macro varchar(30),
	lval varchar(30) not null,
	rval varchar(50),
	rval_assoc varchar(30),
	cond_code varchar(500),
	l_paran integer not null,
	r_paran integer not null,
	description varchar(240),
	operator integer not null,
	connecter integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify atomic_cond to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy atomic_cond () from 'atomic_cond.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on atomic_cond
\p\g
create table att_evt(
	id integer not null,
	persid varchar(30),
	last_mod_dt integer,
	obj_id varchar(30) not null,
	event_tmpl varchar(30) not null,
	start_time integer,
	wait_time integer,
	fire_time integer,
	first_fire_time integer,
	cancel_time integer,
	num_fire integer,
	status_flag integer,
	user_smag varchar(200),
	group_name varchar(30),
	owning_ast integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify att_evt to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy att_evt () from 'att_evt.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on att_evt
\p\g
create table attached_sla(
	id integer not null,
	persid varchar(30),
	map_sdsc varchar(30) not null,
	ticket_id integer not null,
	ticket_type varchar(30) not null,
	sla_viol_status integer,
	time_to_violation integer,
	last_ttv_upd integer,
	ttv_event varchar(30),
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	_mapped_cr varchar(30),
	_mapped_chg integer,
	_mapped_iss varchar(30),
	_mapped_wf integer,
	_mapped_iss_wf integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify attached_sla to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy attached_sla () from 'attached_sla.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on attached_sla
\p\g
create table attmnt(
	id integer not null,
	persid varchar(30),
	del integer not null,
	description varchar(500),
	orig_file_name varchar(240),
	attmnt_name varchar(240),
	file_name varchar(240),
	file_date integer,
	file_size integer,
	file_type varchar(12),
	folder_id integer,
	folder_path_ids varchar(255),
	inherit_permission_id integer,
	read_pgroup integer,
	write_pgroup integer,
	rel_file_path varchar(512),
	zip_flag integer,
	last_mod_by byte varying(16),
	last_mod_dt integer,
	created_by integer,
	created_dt integer,
	repository varchar(30),
	exec_cmd varchar(12),
	status varchar(12),
	link_only integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify attmnt to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy attmnt () from 'attmnt.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on attmnt
\p\g
create table attmnt_folder(
	id integer not null,
	folder_type integer,
	folder_name varchar(255),
	description varchar(500),
	parent_id integer,
	folder_path_ids varchar(255),
	has_children integer,
	inherit_permission_id integer,
	read_pgroup integer,
	write_pgroup integer,
	repository varchar(30),
	last_mod_date integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify attmnt_folder to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy attmnt_folder () from 'attmnt_folder.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on attmnt_folder
\p\g
create table attmnt_lrel(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify attmnt_lrel to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy attmnt_lrel () from 'attmnt_lrel.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on attmnt_lrel
\p\g
create table attr(
	aid smallint not null not default,
	syntax smallint not null not default,
	description varchar(40) not null not default,
	objectid varchar(88) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify attr to btree unique on
	aid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy attr () from 'attr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on attr
\p\g
create table atyp_asc(
	id integer not null,
	persid varchar(30),
	sym varchar(30) not null,
	code varchar(12) not null,
	description varchar(80),
	ob_type varchar(30),
	ob_type_attr varchar(50),
	act_type varchar(30),
	log_me_f integer,
	str1_rsrved varchar(30),
	str2_rsrved varchar(30),
	str3_rsrved varchar(30),
	int1_rsrved integer,
	int2_rsrved integer,
	int3_rsrved integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify atyp_asc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy atyp_asc () from 'atyp_asc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on atyp_asc
\p\g
create table audit_alamode(
	type varchar(20),
	int_val integer,
	str_val varchar(255),
	action char(10),
	user_name varchar(30),
	as_current_date varchar(30),
	hostname char(10),
	program_name char(16)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify audit_alamode to heap
with extend = 16,
	allocation = 4
\p\g
/* copy audit_alamode () from 'audit_alamode.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on audit_alamode
\p\g
create table audit_info(
	audit_info_num integer,
	entity varchar(80),
	time integer,
	type varchar(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify audit_info to btree unique on
	audit_info_num
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy audit_info () from 'audit_info.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on audit_info
\p\g
create table audit_log(
	id integer not null,
	persid varchar(30),
	change_date integer,
	analyst byte varying(16),
	aud_opr integer,
	audobj_persid varchar(30),
	audobj_uniqueid varchar(30),
	audobj_name varchar(10),
	audobj_trkid varchar(40),
	attr_name varchar(80),
	attr_before_val varchar(160),
	attr_after_val varchar(160),
	str1_rsrved varchar(25),
	int1_rsrved integer,
	int2_rsrved integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify audit_log to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy audit_log () from 'audit_log.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on audit_log
\p\g
create table audit_msg(
	audit_info_num integer,
	seq_no integer,
	attribute varchar(30),
	value varchar(255),
	value2 varchar(255),
	is_edit varchar(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify audit_msg to btree unique on
	audit_info_num,
	seq_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy audit_msg () from 'audit_msg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on audit_msg
\p\g
create table audithis(
	domainid integer not null,
	unitid integer not null,
	exename varchar(32) not null,
	sttotal integer not null,
	vernr integer not null,
	exepath varchar(127),
	acid integer,
	stdate integer,
	sttime integer,
	enddate integer,
	endtime integer,
	endtotal integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify audithis to btree unique on
	unitid,
	exename,
	sttotal,
	domainid,
	vernr
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy audithis () from 'audithis.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on audithis
\p\g
create table auto_discover_scan_ip_range(
	begin_ip_range nvarchar(15) not null,
	end_ip_range nvarchar(15) not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify auto_discover_scan_ip_range to heap
with extend = 16,
	allocation = 4
\p\g
/* copy auto_discover_scan_ip_range () from 'auto_discover_scan_ip_range.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on auto_discover_scan_ip_range
\p\g
create table avg_job_runs(
	joid integer,
	avg_runtime integer,
	num_runs integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify avg_job_runs to btree unique on
	joid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy avg_job_runs () from 'avg_job_runs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on avg_job_runs
\p\g
create table baseline(
	base_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	owner_id decimal(31,0) not null,
	owner_type decimal(31,0) not null,
	base_saved_datetime date,
	base_start_datetime date,
	base_finish_datetime date,
	base_duration decimal(31,0),
	base_type_object smallint,
	base_type_dur smallint,
	base_cost_var float,
	base_cost_ovhead float,
	base_cost_fix float,
	base_tot_cost float,
	base_hrs decimal(31,0),
	base_units decimal(31,0),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify baseline to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy baseline () from 'baseline.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on baseline
\p\g
create table baselinebgp4(
	server_addr integer not null,
	probe_addr integer not null,
	bgpidentifier integer not null,
	bgppeeridentifier integer not null,
	bgppeerinupdatesu float not null,
	bgppeerinupdatesl float not null,
	bgppeeroutupdatesu float not null,
	bgppeeroutupdatesl float not null,
	bgppeerintotalmessagesu float not null,
	bgppeerintotalmessagesl float not null,
	bgppeerouttotalmessagesu float not null,
	bgppeerouttotalmessagesl float not null,
	bgppeerfsmestablishedtransu float not null,
	bgppeerfsmestablishedtransl float not null,
	bgppeerinupdateelapsedtimeu float not null,
	bgppeerinupdateelapsedtimel float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinebgp4 to btree on
	server_addr,
	probe_addr,
	bgpidentifier,
	bgppeeridentifier,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinebgp4 () from 'baselinebgp4.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinebgp4
\p\g
create table baselinecisco(
	server_addr integer not null,
	probe_addr integer not null,
	freememu float not null,
	freememl float not null,
	bufferelfreeu float not null,
	bufferelfreel float not null,
	bufferelmissu float not null,
	bufferelmissl float not null,
	bufferfailu float not null,
	bufferfaill float not null,
	buffernomemu float not null,
	buffernomeml float not null,
	avgbusy1u float not null,
	avgbusy1l float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinecisco to btree on
	probe_addr,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinecisco () from 'baselinecisco.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinecisco
\p\g
create table baselineciscotemp(
	server_addr integer not null,
	probe_addr integer not null,
	montemperaturestatusvalueu float not null,
	montemperaturestatusvaluel float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselineciscotemp to btree on
	server_addr,
	probe_addr,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselineciscotemp () from 'baselineciscotemp.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselineciscotemp
\p\g
create table baselineciscovolt(
	server_addr integer not null,
	probe_addr integer not null,
	monvoltagestatusvalueu float not null,
	monvoltagestatusvaluel float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselineciscovolt to btree on
	server_addr,
	probe_addr,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselineciscovolt () from 'baselineciscovolt.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselineciscovolt
\p\g
create table baselineconfig(
	tablename varchar(32) not null,
	baselinetable varchar(32) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselineconfig to heap
with extend = 16,
	allocation = 4
\p\g
/* copy baselineconfig () from 'baselineconfig.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on baselineconfig
\p\g
create table baselineetherstats(
	server_addr integer not null,
	probe_addr integer not null,
	etherstatsindex integer not null,
	etherstatsdropevents float not null,
	etherstatsoctets float not null,
	etherstatspkts float not null,
	etherstatsbroadcastpkts float not null,
	etherstatsmulticastpkts float not null,
	etherstatscrcalignerrors float not null,
	etherstatsundersizepkts float not null,
	etherstatsoversizepkts float not null,
	etherstatsfragments float not null,
	etherstatsjabbers float not null,
	etherstatscollisions float not null,
	intervaldate integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselineetherstats to btree on
	probe_addr,
	etherstatsindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy baselineetherstats () from 'baselineetherstats.mdbadmin' */
/* with allocation = 128, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselineetherstats
\p\g
create table baselinefr(
	server_addr integer not null,
	probe_addr integer not null,
	frcircuitifindex integer not null,
	frcircuitdlci integer not null,
	frcircuitsentoctetsu float not null,
	frcircuitsentoctetsl float not null,
	frcircuitsentframesu float not null,
	frcircuitsentframesl float not null,
	frcircuitreceivedfecnsu float not null,
	frcircuitreceivedfecnsl float not null,
	frcircuitreceivedbecnsu float not null,
	frcircuitreceivedbecnsl float not null,
	frcircuitreceivedframesu float not null,
	frcircuitreceivedframesl float not null,
	frcircuitreceivedoctetsu float not null,
	frcircuitreceivedoctetsl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinefr to btree on
	probe_addr,
	frcircuitifindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy baselinefr () from 'baselinefr.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinefr
\p\g
create table baselinefs(
	server_addr integer not null,
	probe_addr integer not null,
	probeindex integer not null,
	fileserverkeyid integer not null,
	readsvcsumu float not null,
	readsvcsuml float not null,
	readbytesu float not null,
	readbytesl float not null,
	writesvcsumu float not null,
	writesvcsuml float not null,
	writebytesu float not null,
	writebytesl float not null,
	othersvcsumu float not null,
	othersvcsuml float not null,
	siosumu float not null,
	siosuml float not null,
	linkerrcountu float not null,
	linkerrcountl float not null,
	fserrcountu float not null,
	fserrcountl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinefs to btree on
	probe_addr,
	probeindex,
	fileserverkeyid,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinefs () from 'baselinefs.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinefs
\p\g
create table baselinehopdelay(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldate integer not null,
	probeindex integer not null,
	hopdelayindex integer not null,
	hopdelaytotal float not null,
	hopdelayrel float not null,
	hopdelaytimeoutct float not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinehopdelay to btree on
	probe_addr,
	probeindex,
	hopdelayindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinehopdelay () from 'baselinehopdelay.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table baselineif(
	server_addr integer not null,
	probe_addr integer not null,
	ifindex integer not null,
	ifinoctets float not null,
	ifinucastpkts float not null,
	ifinnucastpkts float not null,
	ifindiscards float not null,
	ifinerrors float not null,
	ifinunknownprotos float not null,
	ifoutoctets float not null,
	ifoutucastpkts float not null,
	ifoutnucastpkts float not null,
	ifoutdiscards float not null,
	ifouterrors float not null,
	intervaldate integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselineif to btree on
	probe_addr,
	ifindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy baselineif () from 'baselineif.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselineif
\p\g
create table baselineip(
	server_addr integer not null,
	probe_addr integer not null,
	ipinreceives float not null,
	ipinhdrerrors float not null,
	ipinaddrerrors float not null,
	ipforwdatagrams float not null,
	ipinunknownprotos float not null,
	ipindiscards float not null,
	ipindelivers float not null,
	ipoutrequests float not null,
	ipoutdiscards float not null,
	ipoutnoroutes float not null,
	intervaldate integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselineip to btree on
	probe_addr,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselineip () from 'baselineip.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselineip
\p\g
create table baselinelp(
	server_addr integer not null,
	probe_addr integer not null,
	probeindex integer not null,
	protocolbytesu float not null,
	protocolbytesl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinelp to btree on
	probe_addr,
	probeindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 12
\p\g
/* copy baselinelp () from 'baselinelp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinelp
\p\g
create table baselinelu(
	server_addr integer not null,
	probe_addr integer not null,
	probeindex integer not null,
	utilsumu float not null,
	utilsuml float not null,
	broadcastframesu float not null,
	broadcastframesl float not null,
	multicastframesu float not null,
	multicastframesl float not null,
	frameslostprobeu float not null,
	frameslostprobel float not null,
	frameslostbufu float not null,
	frameslostbufl float not null,
	frameslosthardu float not null,
	frameslosthardl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinelu to btree on
	probe_addr,
	probeindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinelu () from 'baselinelu.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinelu
\p\g
create table baselinenbar(
	server_addr integer not null,
	probe_addr integer not null,
	ifindex integer not null,
	allstatsprotocolsindex integer not null,
	allstatshcinbytesu float not null,
	allstatshcinbytesl float not null,
	allstatshcoutbytesu float not null,
	allstatshcoutbytesl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinenbar to btree on
	server_addr,
	probe_addr,
	ifindex,
	allstatsprotocolsindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinenbar () from 'baselinenbar.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinenbar
\p\g
create table baselinermon2proto(
	server_addr integer not null,
	probe_addr integer not null,
	protocoldirrmindex integer not null,
	protocoldistdatasource integer not null,
	protocoldiststatspktsu float not null,
	protocoldiststatspktsl float not null,
	protocoldiststatsoctetsu float not null,
	protocoldiststatsoctetsl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinermon2proto to btree on
	server_addr,
	probe_addr,
	protocoldirrmindex,
	protocoldistdatasource,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinermon2proto () from 'baselinermon2proto.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinermon2proto
\p\g
create table baselinerttcapture(
	server_addr integer not null,
	probe_addr integer not null,
	ctrladminindex integer not null,
	statscapturepathindex integer not null,
	statscapturehopindex integer not null,
	statscaptureoverthresholdsu float not null,
	statscaptureoverthresholdsl float not null,
	statscapturesumcompletiontimeu float not null,
	statscapturesumcompletiontimel float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinerttcapture to btree on
	server_addr,
	probe_addr,
	ctrladminindex,
	statscapturepathindex,
	statscapturehopindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinerttcapture () from 'baselinerttcapture.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinerttcapture
\p\g
create table baselinerttcoll(
	server_addr integer not null,
	probe_addr integer not null,
	ctrladminindex integer not null,
	statscapturepathindex integer not null,
	statscapturehopindex integer not null,
	statscollectnumdisconnectsu float not null,
	statscollectnumdisconnectsl float not null,
	statscollecttimeoutsu float not null,
	statscollecttimeoutsl float not null,
	statscollectbusiesu float not null,
	statscollectbusiesl float not null,
	statscollectnoconnectionsu float not null,
	statscollectnoconnectionsl float not null,
	statscollectdropsu float not null,
	statscollectdropsl float not null,
	statscollectsequenceerrorsu float not null,
	statscollectsequenceerrorsl float not null,
	statscollectverifyerrorsu float not null,
	statscollectverifyerrorsl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinerttcoll to btree on
	server_addr,
	probe_addr,
	ctrladminindex,
	statscapturepathindex,
	statscapturehopindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinerttcoll () from 'baselinerttcoll.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinerttcoll
\p\g
create table baselinerttjitter(
	server_addr integer not null,
	probe_addr integer not null,
	ctrladminindex integer not null,
	jitterstatsoverthresholdsu float not null,
	jitterstatsoverthresholdsl float not null,
	jitterstatsrttsumu float not null,
	jitterstatsrttsuml float not null,
	jitterstatspacketlosssdu float not null,
	jitterstatspacketlosssdl float not null,
	jitterstatspacketlossdsu float not null,
	jitterstatspacketlossdsl float not null,
	jitterstatspacketoutofsequenceu float not null,
	jitterstatspacketoutofsequencel float not null,
	jitterstatspacketlatearrivalu float not null,
	jitterstatspacketlatearrivall float not null,
	jitterstatserroru float not null,
	jitterstatserrorl float not null,
	jitterstatsbusiesu float not null,
	jitterstatsbusiesl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinerttjitter to btree on
	server_addr,
	probe_addr,
	ctrladminindex,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy baselinerttjitter () from 'baselinerttjitter.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinerttjitter
\p\g
create table baselinets(
	server_addr integer not null,
	probe_addr integer not null,
	probeindex integer not null,
	termserverkeyid integer not null,
	bytestoclientsu float not null,
	bytestoclientsl float not null,
	bytestoserveru float not null,
	bytestoserverl float not null,
	rttermsumu float not null,
	rttermsuml float not null,
	nrtermsumu float not null,
	nrtermsuml float not null,
	linkerrcountu float not null,
	linkerrcountl float not null,
	intervaldate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify baselinets to btree on
	probe_addr,
	probeindex,
	termserverkeyid,
	intervaldate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 32
\p\g
/* copy baselinets () from 'baselinets.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on baselinets
\p\g
create table bckbin(
	udomid integer not null,
	unitid integer not null,
	bdomid integer not null,
	bkver integer not null,
	bknr integer not null,
	bkdate integer,
	bkfile text(1),
	sql_tstamp byte(8),
	bckid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify bckbin to btree unique on
	udomid,
	unitid,
	bdomid,
	bckid,
	bknr,
	bkver
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy bckbin () from 'bckbin.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bckbin
\p\g
create table bckdef(
	domainid integer not null,
	bckid integer not null,
	dbname varchar(50),
	filename varchar(127),
	version integer,
	bckflag integer,
	editor varchar(50),
	revnr integer,
	auto_server_version integer default 0,
	auto_rep_version byte(8)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify bckdef to btree unique on
	bckid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy bckdef () from 'bckdef.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bckdef
\p\g
create table bckfile(
	udomid integer not null,
	unitid integer not null,
	bdomid integer not null,
	bkver integer not null,
	bknr integer not null,
	bkdate integer,
	bkfile text(1),
	sql_tstamp byte(8),
	bckid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify bckfile to btree unique on
	udomid,
	unitid,
	bdomid,
	bckid,
	bknr,
	bkver
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy bckfile () from 'bckfile.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bckfile
\p\g
create table bgp4peerentry(
	server_addr integer not null,
	probe_addr integer not null,
	bgpidentifier integer not null,
	bgpidentifierip varchar(16) not null,
	bgppeeridentifier integer not null,
	bgppeeridentifierip varchar(16) not null,
	bgpversion varchar(255) not null,
	bgplocalas integer not null,
	bgppeernegotiatedversion integer not null,
	bgppeerlocaladdr integer not null,
	bgppeerlocalport integer not null,
	bgppeerremoteaddr integer not null,
	bgppeerremoteport integer not null,
	bgppeerremoteas integer not null,
	bgppeerconnectretryinterval integer not null,
	bgppeerholdtimeconfigured integer not null,
	bgppeerkeepaliveconfigured integer not null,
	bgppeerminasoriginationintval integer not null,
	bgppeerminrouteadinterval integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify bgp4peerentry to btree on
	bgplocalas,
	bgppeerremoteas,
	bgpidentifier,
	bgppeeridentifier
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy bgp4peerentry () from 'bgp4peerentry.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bgp4peerentry
\p\g
create table bgp4peerentrymessage(
	server_addr integer not null,
	probe_addr integer not null,
	bgpidentifier integer not null,
	bgppeeridentifier integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	bgppeerstate integer not null,
	bgppeeradminstatus integer not null,
	bgppeerinupdates integer not null,
	bgppeeroutupdates integer not null,
	bgppeerintotalmessages integer not null,
	bgppeerouttotalmessages integer not null,
	bgppeerlasterror integer not null,
	bgppeerfsmestablishedtrans integer not null,
	bgppeerfsmestablishedtime integer not null,
	bgppeerholdtime integer not null,
	bgppeerkeepalive integer not null,
	bgppeerinupdateelapsedtime integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify bgp4peerentrymessage to btree on
	bgpidentifier,
	bgppeeridentifier
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy bgp4peerentrymessage () from 'bgp4peerentrymessage.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bgp4peerentrymessage
\p\g
create table bhvtpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	last_mod_dt integer,
	last_mod_by integer,
	object_type varchar(30) not null,
	object_id integer not null,
	description varchar(500),
	context_type varchar(30) not null,
	context_attrname varchar(30),
	context_attrval integer,
	transition_test varchar(30),
	transition_errmsg varchar(240),
	macro_condition varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify bhvtpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy bhvtpl () from 'bhvtpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bhvtpl
\p\g
create table blob(
	eid integer not null not default,
	aid smallint not null not default,
	vid smallint not null not default,
	vfrag smallint not null not default,
	raw varchar(1900) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify blob to btree unique on
	eid,
	aid,
	vid,
	vfrag
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy blob () from 'blob.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on blob
\p\g
create table blob_fields(
	blob_id decimal(31,0) not null,
	description_blob long byte not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify blob_fields to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy blob_fields () from 'blob_fields.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on blob_fields
\p\g
create table bool_tab(
	id integer not null,
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify bool_tab to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy bool_tab () from 'bool_tab.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bool_tab
\p\g
create table bp_standard_category(
	bp_standard_category_id byte(16) not null,
	name nvarchar(255) not null,
	statement long nvarchar,
	number nvarchar(20) not null,
	config_standard_set_id byte(16) not null,
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify bp_standard_category to btree unique on
	bp_standard_category_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy bp_standard_category () from 'bp_standard_category.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bp_standard_category
\p\g
create table bpwshft(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	description varchar(80),
	sched varchar(1000),
	last_mod_dt integer,
	last_mod_by integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify bpwshft to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy bpwshft () from 'bpwshft.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bpwshft
\p\g
create table bu_trans(
	id integer not null,
	doc_id integer,
	index_id integer,
	bu_date integer,
	bu_rating float,
	user_id byte varying(16),
	bu_processed integer,
	hit_origin integer,
	hit_no_vote integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify bu_trans to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy bu_trans () from 'bu_trans.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on bu_trans
\p\g
create table building(
	id integer,
	screenname varchar(32) not null,
	description varchar(32),
	latitude float,
	longitude float,
	_3dresourceid integer,
	starttime date,
	endtime date,
	createdby integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify building to heap
with extend = 16,
	allocation = 4
\p\g
/* copy building () from 'building.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on building
\p\g
create table buscls(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	nx_desc varchar(40),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify buscls to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy buscls () from 'buscls.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on buscls
\p\g
create table business_hours(
	group_id integer not null,
	day_name varchar(15) not null,
	start_time integer,
	end_time integer,
	created integer,
	created_by varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify business_hours to btree unique on
	group_id,
	day_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy business_hours () from 'business_hours.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on business_hours
\p\g
create table buslrel(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify buslrel to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy buslrel () from 'buslrel.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on buslrel
\p\g
create table busmgt(
	id integer not null,
	persid varchar(30),
	hier_parent integer,
	hier_child integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	cost integer,
	sym varchar(60) not null,
	nx_desc varchar(40),
	bm_rep integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify busmgt to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy busmgt () from 'busmgt.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on busmgt
\p\g
create table busrep(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	nx_desc varchar(40),
	userid varchar(40),
	password varchar(200),
	hostname varchar(64) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify busrep to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy busrep () from 'busrep.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on busrep
\p\g
create table busstat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	nx_desc varchar(40),
	status_no integer not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify busstat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy busstat () from 'busstat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on busstat
\p\g
create table ca_agent(
	last_run_date integer,
	object_uuid byte(16) not null,
	agent_version varchar(32),
	description nvarchar(255),
	prev_manager byte(16),
	server_uuid byte(16),
	agent_area varchar(64),
	agent_file_id varchar(36),
	agent_type integer,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	agent_sub_type integer,
	domain_id integer,
	unit_id integer,
	agent_name varchar(192),
	boot_server_uuid byte(16),
	ip_address varchar(64),
	registration_type integer,
	auto_server_version integer default 0,
	auto_rep_version date,
	agent_ref_count integer,
	agent_lock integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_agent to btree unique on
	object_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_agent () from 'ca_agent.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_agent
\p\g
create table ca_agent_component(
	agent_comp_id integer not null,
	object_uuid byte(16) not null,
	agent_component_version nvarchar(255),
	server_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_agent_component to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ca_agent_component () from 'ca_agent_component.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ca_agent_component
\p\g
create table ca_asset(
	asset_uuid byte(16) not null,
	label nvarchar(255),
	asset_tag nvarchar(64),
	serial_number nvarchar(64),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	asset_type_id integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_asset to btree unique on
	asset_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_asset () from 'ca_asset.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_asset
\p\g
create table ca_asset_class_def(
	class_id integer not null,
	class_name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	class_description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_asset_class_def to btree unique on
	class_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_asset_class_def () from 'ca_asset_class_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_asset_class_def
\p\g
create table ca_asset_source(
	asset_source_uuid byte(16) not null,
	logical_asset_uuid byte(16),
	source_location_uuid byte(16),
	subschema_id integer not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_asset_source to btree unique on
	asset_source_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_asset_source () from 'ca_asset_source.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_asset_source
\p\g
create table ca_asset_source_location(
	source_location_uuid byte(16) not null,
	server_name varchar(20),
	db_instance_name varchar(255),
	db_name varchar(255),
	db_type integer,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_asset_source_location to btree unique on
	source_location_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_asset_source_location () from 'ca_asset_source_location.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_asset_source_location
\p\g
create table ca_asset_subschema(
	subschema_id integer not null,
	subschema_name varchar(255),
	subschema_version varchar(255),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_asset_subschema to btree unique on
	subschema_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_asset_subschema () from 'ca_asset_subschema.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_asset_subschema
\p\g
create table ca_asset_type(
	asset_type_id integer not null,
	asset_type_name varchar(255),
	asset_type_configuration nvarchar(1),
	creation_user nvarchar(255),
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	creation_date integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_asset_type to btree unique on
	asset_type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_asset_type () from 'ca_asset_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_asset_type
\p\g
create table ca_capacity_unit(
	id integer not null,
	inactive integer,
	name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_capacity_unit to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_capacity_unit () from 'ca_capacity_unit.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_capacity_unit
\p\g
create table ca_category_def(
	category_uuid byte(16) not null,
	category_name varchar(64) not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_category_def to btree unique on
	category_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_category_def () from 'ca_category_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_category_def
\p\g
create table ca_category_member(
	category_uuid byte(16) not null,
	sw_def_uuid byte(16) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_category_member to btree unique on
	category_uuid,
	sw_def_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_category_member () from 'ca_category_member.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_category_member
\p\g
create table ca_class_ace(
	ace integer not null,
	class_def_uuid byte(16) not null,
	security_profile_uuid byte(16) not null,
	access integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_class_ace to btree unique on
	security_profile_uuid,
	class_def_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_class_ace () from 'ca_class_ace.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_class_ace
\p\g
create table ca_class_def(
	class_def_uuid byte(16) not null,
	owner_uuid byte(16),
	class_type integer not null,
	creation_date integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_class_def to btree unique on
	class_def_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_class_def () from 'ca_class_def.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_class_def
\p\g
create table ca_company(
	company_uuid byte(16) not null,
	parent_company_uuid byte(16),
	company_name nvarchar(100),
	inactive integer,
	description nvarchar(400),
	company_type integer,
	alias nvarchar(30),
	month_fiscal_year_ends integer,
	web_address nvarchar(50),
	bbs nvarchar(30),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	location_uuid byte(16),
	primary_contact_uuid byte(16),
	version_number integer,
	last_update_date integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_company to btree unique on
	company_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_company () from 'ca_company.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_company
\p\g
create table ca_company_type(
	id integer not null,
	inactive integer,
	name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_company_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_company_type () from 'ca_company_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_company_type
\p\g
create table ca_config_item(
	config_item_uuid byte(16) not null,
	ci_version_label varchar(30),
	ci_version_number integer,
	supply_date integer,
	accept_date integer,
	current_status varchar(50),
	scheduled_status varchar(50),
	comments varchar(255),
	asset_uuid byte(16) not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_config_item to btree unique on
	config_item_uuid,
	asset_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_config_item () from 'ca_config_item.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_config_item
\p\g
create table ca_configuration_policy(
	uid byte(16) not null,
	uid_parent byte(16) not null,
	str_name varchar(64) not null,
	str_description varchar(128) not null,
	i_type integer not null,
	i_global integer not null,
	i_inherited integer not null,
	date_time_stamp date not null,
	i_delete_flag integer not null,
	uid_alternate byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_configuration_policy to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_configuration_policy () from 'ca_configuration_policy.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_configuration_policy
\p\g
create table ca_contact(
	contact_uuid byte(16) not null,
	middle_name nvarchar(100),
	alias nvarchar(30),
	last_name nvarchar(100) not null,
	first_name nvarchar(100),
	pri_phone_number nvarchar(32),
	alt_phone_cc integer,
	alt_phone_number nvarchar(32),
	fax_cc integer,
	fax_number nvarchar(32),
	mobile_phone_cc integer,
	mobile_phone_number nvarchar(32),
	pager_cc integer,
	pager_number nvarchar(32),
	email_address nvarchar(120),
	location_uuid byte(16),
	floor_location nvarchar(30),
	pager_email_address nvarchar(120),
	room_location nvarchar(30),
	contact_type integer,
	inactive integer not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	department nvarchar(30),
	comment nvarchar(255),
	company_uuid byte(16),
	organization_uuid byte(16),
	admin_organization_uuid byte(16),
	alternate_identifier nvarchar(30),
	job_title integer,
	job_function nvarchar(30),
	mail_stop nvarchar(30),
	cost_center nvarchar(50),
	userid nvarchar(100),
	pri_phone_cc integer,
	supervisor_contact_uuid byte(16),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_contact to btree unique on
	contact_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_contact () from 'ca_contact.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_contact
\p\g
create table ca_contact_type(
	id integer not null,
	inactive integer,
	name varchar(100),
	view_internal integer,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	user_uuid byte(16),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_contact_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_contact_type () from 'ca_contact_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_contact_type
\p\g
create table ca_country_code(
	country_code integer not null,
	country_name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	phone_mask varchar(60),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_country_code to btree unique on
	country_code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_country_code () from 'ca_country_code.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_country_code
\p\g
create table ca_directory_details(
	directory_uuid byte(16) not null,
	directory_name nvarchar(255),
	server_name nvarchar(255),
	port_number integer,
	binding integer,
	user_name nvarchar(255),
	password nvarchar(255),
	base_dn varchar(1023),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	directory_type integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_directory_details to btree unique on
	directory_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_directory_details () from 'ca_directory_details.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_directory_details
\p\g
create table ca_directory_schema_map(
	dir_schema_uuid byte(16) not null,
	dir_schema_map_name nvarchar(255),
	itrm_attrib nvarchar(255),
	dir_attrib nvarchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_directory_schema_map to btree unique on
	dir_schema_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_directory_schema_map () from 'ca_directory_schema_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_directory_schema_map
\p\g
create table ca_discovered_hardware(
	dis_hw_uuid byte(16) not null,
	host_name varchar(255) not null,
	domain_uuid byte(16) not null,
	label varchar(255) not null,
	serial_number varchar(64),
	primary_mac_address nvarchar(64),
	asset_tag varchar(64),
	usage_list varchar(255),
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	host_uuid char(36),
	creation_date integer,
	creation_user nvarchar(255),
	class varchar(255),
	primary_network_address nvarchar(255),
	disc_serial_number varchar(64),
	asset_source_uuid byte(16),
	auto_rep_version date,
	system_id nvarchar(255),
	uri nvarchar(255),
	vendor_name nvarchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_discovered_hardware to btree unique on
	dis_hw_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_discovered_hardware () from 'ca_discovered_hardware.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_discovered_hardware
\p\g
create table ca_discovered_hardware_ext_sys(
	dis_hw_uuid byte(16) not null,
	external_sys_name nvarchar(30),
	discovery_id_1 nvarchar(64),
	discovery_id_2 nvarchar(64),
	discovery_id_3 nvarchar(64),
	discovery_id_4 nvarchar(64),
	discovery_id_5 nvarchar(64),
	loader_processed_date integer,
	discovery_changed_date integer,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_discovered_hardware_ext_sys to btree unique on
	dis_hw_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_discovered_hardware_ext_sys () from 'ca_discovered_hardware_ext_sys.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_discovered_hardware_ext_sys
\p\g
create table ca_discovered_hardware_network(
	dis_hw_uuid byte(16) not null,
	mac_address nvarchar(64) not null,
	dns_name nvarchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_discovered_hardware_network to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ca_discovered_hardware_network () from 'ca_discovered_hardware_network.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ca_discovered_hardware_network
\p\g
create table ca_discovered_software(
	sw_def_uuid byte(16),
	dis_sw_uuid byte(16) not null,
	label varchar(255),
	serial_number varchar(64),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	product_guid varchar(64),
	version_number integer,
	last_update_date integer,
	install_path varchar(255),
	last_accessed integer,
	asset_source_uuid byte(16),
	license_uuid byte(16),
	auto_rep_version date,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_discovered_software to btree unique on
	dis_sw_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_discovered_software () from 'ca_discovered_software.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_discovered_software
\p\g
create table ca_discovered_software_prop(
	software_property_name varchar(50),
	dis_sw_prop_uuid byte(16) not null,
	software_property_value varchar(255),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	version_number integer,
	last_update_date integer,
	dis_sw_uuid byte(16),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_discovered_software_prop to btree unique on
	dis_sw_prop_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_discovered_software_prop () from 'ca_discovered_software_prop.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_discovered_software_prop
\p\g
create table ca_discovered_user(
	user_uuid byte(16) not null,
	label varchar(255) not null,
	user_name varchar(255) not null,
	domain_uuid byte(16) not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	auto_rep_version date,
	uri nvarchar(255),
	user_type integer,
	usage_list byte(32)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_discovered_user to btree unique on
	user_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_discovered_user () from 'ca_discovered_user.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_discovered_user
\p\g
create table ca_document(
	doc_uuid byte(16) not null,
	doc_content varchar(255) not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	compressed i1,
	format i1,
	checksum byte(2),
	original_size integer,
	current_size integer,
	attributes smallint,
	owner_user varchar(64),
	uri varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_document to btree unique on
	doc_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_document () from 'ca_document.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_document
\p\g
create table ca_engine(
	engine_uuid byte(16) not null,
	domain_uuid byte(16) not null,
	label varchar(255),
	host_name varchar(255),
	description varchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	dis_hw_uuid byte(16),
	auto_rep_version byte(8)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_engine to btree unique on
	engine_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_engine () from 'ca_engine.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_engine
\p\g
create table ca_geo_coord_type(
	id integer not null,
	inactive integer,
	name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_geo_coord_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_geo_coord_type () from 'ca_geo_coord_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_geo_coord_type
\p\g
create table ca_group_ace(
	group_def_uuid byte(16) not null,
	security_profile_uuid byte(16) not null,
	ace integer not null,
	access integer not null,
	enable_inheritance integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_group_ace to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ca_group_ace () from 'ca_group_ace.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ca_group_ace
\p\g
create table ca_group_def(
	group_uuid byte(16) not null,
	group_domain_uuid byte(16) not null,
	eval_freq integer,
	last_eval_date_time integer,
	query_uuid byte(16),
	member_type integer,
	label varchar(255),
	evaluation_uuid byte(16),
	group_inheritance smallint,
	evaluation_location smallint,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	creation_date integer,
	creation_user varchar(64),
	group_flag smallint,
	group_system smallint,
	directory_uuid byte(16),
	security_group integer,
	owner_uuid byte(16),
	description nvarchar(255),
	auto_rep_version byte(8)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_group_def to btree unique on
	group_uuid,
	group_domain_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_group_def () from 'ca_group_def.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_group_def
\p\g
create table ca_group_def_ace(
	group_def_ace_uuid byte(16) not null,
	security_profile_uuid byte(16),
	ace integer,
	inherit_ace integer,
	inheritance integer,
	access integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_group_def_ace to btree unique on
	group_def_ace_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_group_def_ace () from 'ca_group_def_ace.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_group_def_ace
\p\g
create table ca_group_member(
	member_uuid byte(16) not null,
	member_type smallint,
	group_domain_uuid byte(16) not null,
	group_uuid byte(16) not null,
	member_domain_uuid byte(16) not null,
	last_update_date integer,
	version_number integer,
	auto_rep_version byte(8)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_group_member to btree unique on
	member_uuid,
	group_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_group_member () from 'ca_group_member.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_group_member
\p\g
create table ca_job_title(
	id integer not null,
	inactive integer,
	name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_job_title to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_job_title () from 'ca_job_title.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_job_title
\p\g
create table ca_license_type(
	id integer not null,
	inactive integer,
	name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_license_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_license_type () from 'ca_license_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_license_type
\p\g
create table ca_link_asset_class_def(
	last_update_date integer,
	version_number integer,
	from_class_id integer not null,
	to_class_id integer not null,
	hierarchy_id integer not null,
	"level" integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_asset_class_def to btree unique on
	from_class_id,
	to_class_id,
	hierarchy_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_asset_class_def () from 'ca_link_asset_class_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_asset_class_def
\p\g
create table ca_link_config_item(
	config_item_uuid_1 byte(16) not null,
	asset_uuid_1 byte(16) not null,
	config_item_uuid_2 byte(16) not null,
	asset_uuid_2 byte(16) not null,
	link_type_id integer,
	version_number integer,
	last_update_date integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_config_item to btree unique on
	config_item_uuid_1,
	asset_uuid_1,
	config_item_uuid_2,
	asset_uuid_2
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_config_item () from 'ca_link_config_item.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_config_item
\p\g
create table ca_link_config_item_doc(
	config_item_uuid byte(16) not null,
	doc_uuid byte(16) not null,
	asset_uuid byte(16) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_config_item_doc to btree unique on
	doc_uuid,
	config_item_uuid,
	asset_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_config_item_doc () from 'ca_link_config_item_doc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_config_item_doc
\p\g
create table ca_link_configured_service(
	named_config_uuid byte(16) not null,
	own_resource_uuid byte(16) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_configured_service to btree unique on
	named_config_uuid,
	own_resource_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_configured_service () from 'ca_link_configured_service.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_configured_service
\p\g
create table ca_link_contact_user(
	user_uuid byte(16) not null,
	contact_uuid byte(16) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_contact_user to btree unique on
	contact_uuid,
	user_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_contact_user () from 'ca_link_contact_user.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_contact_user
\p\g
create table ca_link_dir_details_map(
	directory_uuid byte(16),
	dir_schema_uuid byte(16),
	dir_details_map_uuid byte(16) not null,
	last_update_user varchar(20),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_dir_details_map to btree unique on
	dir_details_map_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_dir_details_map () from 'ca_link_dir_details_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_dir_details_map
\p\g
create table ca_link_dis_hw(
	primary_dis_hw_uuid byte(16) not null,
	secondary_dis_hw_uuid byte(16),
	last_update_date integer,
	version_number float,
	ref_count integer,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user varchar(255),
	label nvarchar(255),
	link_dis_hw_uuid byte(16) not null,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_dis_hw to btree unique on
	link_dis_hw_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_dis_hw () from 'ca_link_dis_hw.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_dis_hw
\p\g
create table ca_link_dis_hw_user(
	dis_hw_uuid byte(16) not null,
	user_uuid byte(16) not null,
	last_update_date integer,
	version_number integer,
	ref_count integer,
	label varchar(255),
	creation_date integer,
	last_update_user varchar(255),
	creation_user varchar(255),
	link_dis_hw_user_uuid byte(16) not null,
	auto_rep_version date,
	usage_list byte(32)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_dis_hw_user to btree unique on
	link_dis_hw_user_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_dis_hw_user () from 'ca_link_dis_hw_user.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_dis_hw_user
\p\g
create table ca_link_dis_user_sec_profile(
	security_profile_uuid byte(16) not null,
	user_uuid byte(16) not null,
	creation_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_dis_user_sec_profile to btree unique on
	user_uuid,
	security_profile_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_dis_user_sec_profile () from 'ca_link_dis_user_sec_profile.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_dis_user_sec_profile
\p\g
create table ca_link_license_sw_def(
	license_uuid byte(16) not null,
	sw_def_uuid byte(16) not null,
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_license_sw_def to btree unique on
	license_uuid,
	sw_def_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_license_sw_def () from 'ca_link_license_sw_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_license_sw_def
\p\g
create table ca_link_logical_asset_class_def(
	class_id integer not null,
	logical_asset_uuid byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_logical_asset_class_def to btree unique on
	class_id,
	logical_asset_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_logical_asset_class_def () from 'ca_link_logical_asset_class_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_logical_asset_class_def
\p\g
create table ca_link_named_config_doc(
	doc_uuid byte(16) not null,
	named_config_uuid byte(16) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_named_config_doc to btree unique on
	doc_uuid,
	named_config_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_named_config_doc () from 'ca_link_named_config_doc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_named_config_doc
\p\g
create table ca_link_named_config_item(
	named_config_uuid byte(16) not null,
	config_item_uuid byte(16) not null,
	asset_uuid byte(16) not null,
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_named_config_item to btree unique on
	named_config_uuid,
	config_item_uuid,
	asset_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_named_config_item () from 'ca_link_named_config_item.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_named_config_item
\p\g
create table ca_link_object_owner(
	object_uuid byte(16) not null,
	owner_uuid byte(16) not null,
	security_profile_uuid byte(16) not null,
	creation_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_object_owner to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy ca_link_object_owner () from 'ca_link_object_owner.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ca_link_object_owner
\p\g
create table ca_link_own_dis_hw(
	own_link_status integer,
	dis_link_status integer,
	last_update_date integer,
	version_number integer,
	dis_hw_uuid byte(16) not null,
	own_resource_uuid byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_own_dis_hw to btree unique on
	dis_hw_uuid,
	own_resource_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_own_dis_hw () from 'ca_link_own_dis_hw.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_own_dis_hw
\p\g
create table ca_link_sw_def(
	last_update_date integer,
	version_number integer,
	seconday_sw_def_uuid byte(16) not null,
	primary_sw_def_uuid byte(16) not null,
	link_type_id integer not null,
	source_type_id integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_sw_def to btree unique on
	primary_sw_def_uuid,
	seconday_sw_def_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_sw_def () from 'ca_link_sw_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_sw_def
\p\g
create table ca_link_type(
	link_type_id integer not null,
	link_type_name varchar(20),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_link_type to btree unique on
	link_type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_link_type () from 'ca_link_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_link_type
\p\g
create table ca_location(
	location_uuid byte(16) not null,
	location_name nvarchar(100),
	inactive integer,
	location_type integer,
	pri_phone_cc integer,
	pri_phone_number nvarchar(32),
	fax_cc integer,
	fax_number nvarchar(32),
	address_1 nvarchar(50),
	address_2 nvarchar(50),
	mail_address_1 nvarchar(50),
	mail_address_2 nvarchar(50),
	mail_address_3 nvarchar(50),
	city nvarchar(50),
	state integer,
	address_3 nvarchar(50),
	mail_address_6 nvarchar(50),
	mail_address_5 nvarchar(50),
	mail_address_4 nvarchar(50),
	address_6 nvarchar(50),
	address_5 nvarchar(50),
	address_4 nvarchar(50),
	primary_contact_uuid byte(16),
	zip nvarchar(20),
	country nvarchar(50),
	county nvarchar(50),
	geo_coord_type integer,
	geo_coords nvarchar(40),
	company_uuid byte(16),
	contact_address_flag integer,
	creation_user nvarchar(255),
	site_id integer,
	creation_date integer,
	comment nvarchar(255),
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_location to btree unique on
	location_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_location () from 'ca_location.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_location
\p\g
create table ca_location_type(
	id integer not null,
	inactive integer,
	name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_location_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_location_type () from 'ca_location_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_location_type
\p\g
create table ca_logical_asset(
	logical_asset_uuid byte(16) not null,
	asset_uuid byte(16),
	host_name nvarchar(255),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_logical_asset to btree unique on
	logical_asset_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_logical_asset () from 'ca_logical_asset.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_logical_asset
\p\g
create table ca_logical_asset_property(
	dns_name nvarchar(20) not null,
	mac_address nvarchar(64) not null,
	logical_asset_uuid byte(16) not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_logical_asset_property to btree unique on
	dns_name,
	mac_address,
	logical_asset_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_logical_asset_property () from 'ca_logical_asset_property.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_logical_asset_property
\p\g
create table ca_manager(
	manager_uuid byte(16) not null,
	domain_uuid byte(16),
	label varchar(255),
	host_uuid nchar(36),
	host_name varchar(255),
	description varchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	dis_hw_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_manager to btree unique on
	manager_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_manager () from 'ca_manager.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_manager
\p\g
create table ca_manager_component(
	manager_uuid byte(16) not null,
	manager_comp_uuid byte(16) not null,
	domain_uuid byte(16),
	manager_comp_id integer,
	manager_comp_version varchar(64),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	auto_rep_version byte(8)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_manager_component to btree unique on
	manager_comp_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_manager_component () from 'ca_manager_component.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_manager_component
\p\g
create table ca_model_def(
	id integer not null,
	inactive integer,
	name varchar(100),
	abbreviation varchar(30),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	current_as_of_date integer,
	class_id integer,
	family_id integer,
	preferred_seller_uuid byte(16),
	manufacturer_uuid byte(16),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_model_def to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_model_def () from 'ca_model_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_model_def
\p\g
create table ca_n_tier(
	domain_uuid byte(16) not null,
	parent_domain_uuid byte(16),
	label varchar(255),
	description varchar(255),
	db_host_name varchar(255),
	db_server varchar(255),
	db_type varchar(255),
	db_name varchar(255),
	db_user_name varchar(255),
	db_password varchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	dis_hw_uuid byte(16),
	domain_type integer,
	domain_id integer,
	usage_list byte(32),
	contact_information nvarchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_n_tier to btree unique on
	domain_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_n_tier () from 'ca_n_tier.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_n_tier
\p\g
create table ca_named_configuration(
	named_config_uuid byte(16) not null,
	config_name varchar(100),
	config_version_label varchar(30),
	config_version_number integer,
	created_date integer,
	accepted_date integer,
	current_status varchar(50),
	scheduled_status varchar(50),
	comments varchar(255),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	resource_class integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_named_configuration to btree unique on
	named_config_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_named_configuration () from 'ca_named_configuration.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_named_configuration
\p\g
create table ca_object_ace(
	object_def_uuid byte(16) not null,
	security_profile_uuid byte(16) not null,
	ace integer not null,
	access integer not null,
	security_level integer not null,
	object_type integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_object_ace to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ca_object_ace () from 'ca_object_ace.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ca_object_ace
\p\g
create table ca_organization(
	organization_uuid byte(16) not null,
	parent_org_uuid byte(16),
	description nvarchar(255),
	org_name nvarchar(100) not null,
	abbreviation nvarchar(30),
	pri_phone_cc integer,
	pri_phone_number nvarchar(32),
	alt_phone_cc integer,
	alt_phone_number nvarchar(32),
	fax_cc integer,
	fax_number nvarchar(32),
	email_address nvarchar(120),
	location_uuid byte(16),
	pager_email_address nvarchar(120),
	inactive integer not null,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	company_uuid byte(16),
	comment nvarchar(255),
	contact_uuid byte(16),
	cost_center nvarchar(50),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_organization to btree unique on
	organization_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_organization () from 'ca_organization.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_organization
\p\g
create table ca_owned_resource(
	own_resource_uuid byte(16) not null,
	inactive integer,
	asset_type_id c18,
	resource_name varchar(100) not null,
	resource_description varchar(255),
	resource_family integer,
	resource_class integer,
	resource_status integer,
	manufacturer_uuid byte(16),
	responsible_vendor_uuid byte(16),
	maintenance_org_uuid byte(16),
	responsible_org_uuid byte(16),
	org_bought_for_uuid byte(16),
	resource_contact_uuid byte(16),
	resource_owner_uuid byte(16),
	location_uuid byte(16),
	floor_location varchar(30),
	room_location varchar(30),
	cabinet_location varchar(30),
	shelf_location varchar(30),
	slot_location varchar(30),
	model_id integer,
	host_name varchar(255),
	mac_address varchar(64),
	ip_address varchar(64),
	resource_tag varchar(64),
	operating_system varchar(30),
	product_version varchar(16),
	serial_number varchar(64),
	acquire_date integer,
	installation_date integer,
	cost_center varchar(50),
	gl_code varchar(50),
	resource_quantity integer,
	requisition_id varchar(50),
	purchase_order_id varchar(20),
	creation_system varchar(64),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	supply_vendor_uuid byte(16),
	maintenance_vendor_uuid byte(16),
	company_bought_for_uuid byte(16),
	resource_capacity_units integer,
	resource_capacity float,
	resource_alias varchar(30),
	asset_source_uuid byte(16),
	license_uuid byte(16),
	discovery_changes_switch smallint,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_owned_resource to btree unique on
	own_resource_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_owned_resource () from 'ca_owned_resource.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_owned_resource
\p\g
create table ca_proc_os(
	proc_os_uuid byte(16) not null,
	proc_os_id integer not null,
	proc_os_name nvarchar(128),
	msg_code_base integer,
	swd_extension nvarchar(33),
	object_uuid byte(16)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_proc_os to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ca_proc_os () from 'ca_proc_os.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ca_proc_os
\p\g
create table ca_query_def(
	domain_uuid byte(16) not null,
	query_uuid byte(16) not null,
	label varchar(255),
	query_type integer,
	query_cont varchar(1),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_query_def to btree unique on
	query_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_query_def () from 'ca_query_def.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_query_def
\p\g
create table ca_query_result(
	query_uuid byte(16) not null,
	member_uuid byte(16) not null,
	member_type integer,
	last_update_date integer,
	version_number integer,
	query_domain_uuid byte(16) not null,
	member_domain_uuid byte(16)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_query_result to btree unique on
	query_uuid,
	query_domain_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_query_result () from 'ca_query_result.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_query_result
\p\g
create table ca_query_version(
	query_uuid byte(16) not null,
	label varchar(255) not null,
	flag integer,
	query_domain_uuid byte(16) not null,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_query_version to btree unique on
	query_uuid,
	query_domain_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_query_version () from 'ca_query_version.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_query_version
\p\g
create table ca_reg_control(
	control_uuid byte(16) not null,
	control_name nvarchar(64) not null,
	control_intval integer,
	control_charval nvarchar(255),
	control_byteval byte varying(255),
	control_uuidval byte(16),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_reg_control to btree unique on
	control_uuid,
	control_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_reg_control () from 'ca_reg_control.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_reg_control
\p\g
create table ca_replication_conf(
	replication_conf_uuid byte(16) not null,
	table_name varchar(255),
	job_uuid byte(16),
	direction integer,
	domain_collection integer,
	job_domain_id integer,
	job_id integer,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	enterprise_uuid byte(16) not null,
	domain_uuid byte(16) not null,
	replication_order integer not null,
	primary_keys nvarchar(255),
	replication_column_filter nvarchar(255),
	where_clause nvarchar(255),
	unlink_where_clause nvarchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_replication_conf to btree unique on
	replication_conf_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_replication_conf () from 'ca_replication_conf.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_replication_conf
\p\g
create table ca_replication_history(
	primary_uuid byte(16) not null,
	secondary_uuid byte(16) not null,
	lng1 integer,
	lng2 integer,
	lng3 integer,
	lng4 integer,
	table_name varchar(255),
	action integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_replication_history to btree unique on
	primary_uuid,
	secondary_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_replication_history () from 'ca_replication_history.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_replication_history
\p\g
create table ca_replication_status(
	replication_conf_uuid byte(16) not null,
	domain_uuid byte(16) not null,
	modified_status date,
	deleted_status date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_replication_status to btree unique on
	replication_conf_uuid,
	domain_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_replication_status () from 'ca_replication_status.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_replication_status
\p\g
create table ca_resource_class(
	id integer not null,
	inactive integer,
	name varchar(100),
	family_id integer,
	parent_id integer,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_resource_class to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_resource_class () from 'ca_resource_class.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_resource_class
\p\g
create table ca_resource_family(
	id integer not null,
	inactive integer,
	name varchar(100),
	table_extension_name varchar(30),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_resource_family to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_resource_family () from 'ca_resource_family.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_resource_family
\p\g
create table ca_resource_status(
	id integer not null,
	inactive integer,
	name varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_resource_status to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_resource_status () from 'ca_resource_status.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_resource_status
\p\g
create table ca_schema_info(
	product_name varchar(255) not null,
	version_minor integer not null,
	version_build integer,
	version_spec_build integer,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_major integer not null,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_schema_info to btree unique on
	product_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_schema_info () from 'ca_schema_info.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_schema_info
\p\g
create table ca_security_profile(
	security_profile_uuid byte(16) not null,
	name varchar(255),
	description varchar(255),
	uri nvarchar(255),
	type integer,
	default_ace integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_security_profile to btree unique on
	security_profile_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_security_profile () from 'ca_security_profile.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_security_profile
\p\g
create table ca_server(
	domain_uuid byte(16) not null,
	host_name varchar(255),
	label varchar(255),
	share_unc_path varchar(127),
	server_con_type integer not null,
	val integer,
	sval integer,
	int integer,
	last_val_date integer,
	description varchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	server_uuid byte(16) not null,
	version_number integer,
	last_update_date integer,
	dis_hw_uuid byte(16),
	old_flg integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_server to btree unique on
	server_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_server () from 'ca_server.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_server
\p\g
create table ca_server_component(
	server_comp_uuid byte(16) not null,
	server_comp_id integer,
	server_comp_version varchar(32),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	server_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_server_component to btree unique on
	server_comp_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_server_component () from 'ca_server_component.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_server_component
\p\g
create table ca_server_push_status(
	server_uuid byte(16) not null,
	type integer not null,
	status integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_server_push_status to btree unique on
	server_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_server_push_status () from 'ca_server_push_status.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_server_push_status
\p\g
create table ca_server_queue(
	queue_id byte(16) not null,
	type integer,
	action integer,
	uuid1 byte(16),
	uuid2 byte(16),
	lng1 integer,
	lng2 integer,
	lng3 integer,
	lng4 integer,
	text1 varchar(127),
	text2 varchar(127),
	last_update_date integer,
	server_uuid byte(16)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_server_queue to btree unique on
	queue_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_server_queue () from 'ca_server_queue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_server_queue
\p\g
create table ca_settings(
	set_id integer not null,
	set_val_lng integer,
	set_val_uuid byte(16),
	set_val_text varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_settings to btree unique on
	set_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_settings () from 'ca_settings.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_settings
\p\g
create table ca_site(
	id integer not null,
	inactive integer,
	name varchar(100),
	alias varchar(30),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	contact_uuid byte(16),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_site to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_site () from 'ca_site.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_site
\p\g
create table ca_software_def(
	sw_def_uuid byte(16) not null,
	name varchar(255),
	sw_version_label varchar(64),
	language varchar(50),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	sw_version_number char(20),
	replication_flag integer,
	software_type_id integer not null,
	source_type_id integer not null,
	description nvarchar(1),
	auto_rep_version date,
	manufacturer_uuid byte(16)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_software_def to btree unique on
	sw_def_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_software_def () from 'ca_software_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_software_def
\p\g
create table ca_software_license(
	license_uuid byte(16) not null,
	license_type_id integer,
	license_count integer,
	license_duration_unit integer,
	license_key varchar(255),
	license_duration integer,
	asset_uuid byte(16),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_software_license to btree unique on
	license_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_software_license () from 'ca_software_license.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_software_license
\p\g
create table ca_software_signature(
	signature_uuid byte(16) not null,
	sw_def_uuid byte(16),
	signature_data varchar(16),
	version varchar(10),
	signature_type smallint,
	export_date integer,
	approved_date integer,
	delete_flag smallint,
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	comment nvarchar(1),
	published smallint,
	approved_by varchar(255),
	version_number integer,
	source_type_id integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_software_signature to btree unique on
	signature_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_software_signature () from 'ca_software_signature.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_software_signature
\p\g
create table ca_software_type(
	software_type_id integer not null,
	software_type_name varchar(255),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_software_type to btree unique on
	software_type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_software_type () from 'ca_software_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_software_type
\p\g
create table ca_source_type(
	source_type_id integer not null,
	source_type_name varchar(255),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_source_type to btree unique on
	source_type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_source_type () from 'ca_source_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_source_type
\p\g
create table ca_state_province(
	id integer not null,
	inactive integer,
	symbol varchar(100),
	creation_user nvarchar(255),
	creation_date integer,
	last_update_user nvarchar(255),
	last_update_date integer,
	version_number integer,
	description varchar(255),
	exclude_registration integer,
	delete_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_state_province to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ca_state_province () from 'ca_state_province.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_state_province
\p\g
create table ca_user(
	ca_user_id integer not null,
	contact_id integer,
	creation_date date not null,
	modification_date date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_user to btree unique on
	ca_user_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ca_user () from 'ca_user.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_user
\p\g
create table ca_user_preference(
	ca_user_preference_id integer not null,
	ca_user_id integer,
	category integer,
	sub_category varchar(255),
	name varchar(255),
	value varchar(255),
	sort_order integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_user_preference to btree unique on
	ca_user_preference_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ca_user_preference () from 'ca_user_preference.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_user_preference
\p\g
create table ca_user_principal(
	ca_user_principal_id integer not null,
	principal_type integer,
	principal_name varchar(255),
	ca_user_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ca_user_principal to btree unique on
	ca_user_principal_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ca_user_principal () from 'ca_user_principal.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ca_user_principal
\p\g
create table cai_version(
	name varchar(30) not null,
	value varchar(30) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify cai_version to heap
with extend = 16,
	allocation = 4
\p\g
/* copy cai_version () from 'cai_version.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on cai_version
\p\g
create table cal(
	id char(12) not null,
	fixed_year integer not null,
	locbin char(256) not null,
	loccmd char(256) not null,
	statbin integer not null,
	statcmd integer not null,
	calbin long byte not null,
	calcmd long byte not null,
	descr char(256) not null,
	createdate integer not null,
	createtime integer not null,
	createuser char(32) not null,
	updatedate integer not null,
	updatetime integer not null,
	updateuser char(32) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify cal to btree unique on
	id,
	fixed_year
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy cal () from 'cal.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cal
\p\g
create table calendar_categories(
	calendar_category_oid varchar(20) not null,
	calendar_oid varchar(20) not null,
	event_category_oid varchar(20) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify calendar_categories to btree unique on
	calendar_category_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy calendar_categories () from 'calendar_categories.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on calendar_categories
\p\g
create table calendar_detail(
	calendar_id decimal(31,0) not null,
	calendar_detail_id decimal(31,0) not null,
	dayofweek integer,
	start_datetime date,
	finish_datetime date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify calendar_detail to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy calendar_detail () from 'calendar_detail.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on calendar_detail
\p\g
create table calendar_exception(
	calendarexception_id decimal(31,0) not null,
	calendar_id decimal(31,0) not null,
	calendar_date date,
	starttime1 date,
	finishtime1 date,
	starttime2 date,
	finishtime2 date,
	starttime3 date,
	finishtime3 date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify calendar_exception to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy calendar_exception () from 'calendar_exception.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on calendar_exception
\p\g
create table calendars(
	calendar_oid varchar(20) not null,
	name varchar(50) not null,
	description varchar(255),
	status char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify calendars to btree unique on
	calendar_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy calendars () from 'calendars.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on calendars
\p\g
create table call_req(
	id integer not null,
	persid varchar(30),
	ref_num varchar(30) not null,
	summary varchar(240),
	description long varchar,
	status varchar(12),
	active_flag integer not null,
	open_date integer,
	time_spent_sum integer,
	last_mod_dt integer,
	close_date integer,
	resolve_date integer,
	rootcause integer,
	log_agent byte varying(16) not null,
	assignee integer,
	group_id integer,
	customer byte varying(16) not null,
	charge_back_id varchar(12),
	affected_rc byte varying(16),
	support_lev varchar(30),
	category varchar(30),
	solution varchar(30),
	impact integer,
	priority integer not null,
	urgency integer,
	severity integer,
	extern_ref varchar(30),
	last_act_id varchar(12),
	cr_tticket integer,
	parent varchar(30),
	template_name varchar(30),
	sla_violation integer,
	predicted_sla_viol integer,
	macro_predict_viol integer,
	created_via integer,
	call_back_date integer,
	call_back_flag integer,
	event_token varchar(30),
	sched_token varchar(128),
	type varchar(10),
	string1 varchar(40),
	string2 varchar(40),
	string3 varchar(40),
	string4 varchar(40),
	string5 varchar(40),
	string6 varchar(40),
	problem varchar(30),
	incident_priority integer,
	change integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify call_req to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy call_req () from 'call_req.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on call_req
\p\g
create table category(
	id integer,
	screenname varchar(32),
	description varchar(32),
	scope varchar(1024),
	iconresourceid integer,
	domain varchar(32),
	priority integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify category to heap
with extend = 16,
	allocation = 4
\p\g
/* copy category () from 'category.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on category
\p\g
create table ccat_grp(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ccat_grp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ccat_grp () from 'ccat_grp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ccat_grp
\p\g
create table ccat_loc(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ccat_loc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ccat_loc () from 'ccat_loc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ccat_loc
\p\g
create table ccat_wrkshft(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ccat_wrkshft to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ccat_wrkshft () from 'ccat_wrkshft.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ccat_wrkshft
\p\g
create table certificate(
	serno varchar(40) not null,
	commonname varchar(200),
	emailaddress varchar(50),
	validfrom varchar(50),
	validto varchar(50),
	revoked char(10),
	timeofinsertion varchar(50),
	timeofrevocation varchar(50),
	typeofservice varchar(20),
	certstring_lo byte varying(2000),
	certstring_hi byte varying(1000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify certificate to btree unique on
	serno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy certificate () from 'certificate.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on certificate
\p\g
create table certificaterequest(
	requestid integer not null,
	country varchar(50),
	organisation varchar(50),
	orgunit varchar(50),
	name varchar(50),
	certprofile varchar(50),
	emailaddress varchar(50),
	passphrase varchar(50),
	phonenumber varchar(50),
	reqreason varchar(300)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify certificaterequest to btree unique on
	requestid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy certificaterequest () from 'certificaterequest.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on certificaterequest
\p\g
create table change_log(
	change_log_id integer not null,
	table_name varchar(255),
	table_id integer,
	column_name varchar(255),
	old_value varchar(255),
	new_value varchar(255),
	date date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify change_log to btree unique on
	change_log_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy change_log () from 'change_log.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on change_log
\p\g
create table channel(
	oid integer not null,
	qmgr_oid integer not null,
	rqmgr_actv_oid integer,
	normalconn varchar(64),
	channel varchar(20) not null,
	chltype varchar(20) not null,
	descr varchar(64),
	hbint integer,
	maxmsgl integer,
	mcauser char(12),
	rcvdata varchar(500),
	rcvexit varchar(500),
	scydata varchar(500),
	scyexit varchar(500),
	senddata varchar(500),
	sendexit varchar(500),
	trptype char(10),
	batchsz integer,
	msgdata varchar(500),
	msgexit varchar(500),
	npmspeed char(6),
	seqwrap integer,
	conname varchar(264),
	mcaname varchar(20),
	mcatype char(7),
	modename char(8),
	passwordx char(12),
	tpname varchar(64),
	userid char(20),
	batchint integer,
	convertx char(3),
	discint integer,
	longrty integer,
	longtmr integer,
	shortrty integer,
	shorttmr integer,
	xmitq varchar(48),
	mrdata varchar(500),
	mrexit varchar(500),
	mrrty integer,
	mrtmr integer,
	putaut char(3),
	qmname varchar(48),
	altdate varchar(48),
	alttime varchar(48),
	clusnl varchar(48),
	clusterx varchar(48),
	netprty varchar(48),
	batchhb integer,
	kaint char(5),
	qsgdisp varchar(8),
	sslcauth char(8),
	sslciph varchar(32),
	sslpeer varchar(1024),
	locladdr varchar(64)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify channel to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy channel () from 'channel.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on channel
\p\g
create table channelcfg(
	qmgrid integer not null,
	channelid integer not null,
	channelname varchar(334) not null,
	type char(10) not null,
	status integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify channelcfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy channelcfg () from 'channelcfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on channelcfg
\p\g
create table channeldata(
	tstamp date not null,
	channelid integer not null,
	qmgrid integer not null,
	intvltype char(1) not null,
	intvlduration integer not null,
	msgcount float not null,
	buffersread float not null,
	bufferswrite float not null,
	bytesread float not null,
	byteswrite float not null,
	issent smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify channeldata to heap
with extend = 16,
	allocation = 4
\p\g
/* copy channeldata () from 'channeldata.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on channeldata
\p\g
create table charcodes(
	fld varchar(30),
	code char(6),
	text varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify charcodes to btree unique on
	fld,
	code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy charcodes () from 'charcodes.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on charcodes
\p\g
create table chase(
	nstart integer,
	joid integer,
	eoid varchar(32),
	job_name varchar(64),
	job_type char(1),
	status integer,
	run_machine varchar(80),
	pid integer,
	jc_pid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify chase to btree unique on
	nstart,
	joid,
	eoid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy chase () from 'chase.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on chase
\p\g
create table chg(
	id integer not null,
	persid varchar(30),
	chg_ref_num varchar(30) not null,
	summary varchar(240),
	description long varchar,
	status varchar(12),
	active_flag integer not null,
	start_date integer,
	open_date integer,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	close_date integer,
	resolve_date integer,
	rootcause integer,
	est_total_time integer,
	actual_total_time integer,
	log_agent byte varying(16) not null,
	assignee byte varying(16),
	organization byte varying(16),
	group_id byte varying(16),
	affected_contact byte varying(16) not null,
	requestor byte varying(16) not null,
	category varchar(12),
	priority integer not null,
	need_by integer,
	est_comp_date integer,
	actual_comp_date integer,
	est_cost integer,
	actual_cost integer,
	justification long varchar,
	backout_plan long varchar,
	impact integer,
	parent integer,
	effort varchar(240),
	support_lev varchar(30),
	template_name varchar(30),
	sla_violation integer,
	predicted_sla_viol integer,
	macro_predict_viol integer,
	created_via integer,
	call_back_date integer,
	call_back_flag integer,
	string1 varchar(40),
	string2 varchar(40),
	string3 varchar(40),
	string4 varchar(40),
	string5 varchar(40),
	string6 varchar(40),
	service_date integer,
	service_num varchar(30),
	product integer,
	actions varchar(750),
	type_of_contact integer,
	reporting_method integer,
	person_contacting integer,
	flag1 integer,
	flag2 integer,
	flag3 integer,
	flag4 integer,
	flag5 integer,
	flag6 integer,
	user1 varchar(100),
	user2 varchar(100),
	user3 varchar(100),
	cawf_procid integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify chg to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy chg () from 'chg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on chg
\p\g
create table chg_template(
	id integer not null,
	persid varchar(30),
	del integer not null,
	template_name varchar(30) not null,
	description varchar(1000),
	template integer,
	template_class varchar(12),
	quick_tmpl_type integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify chg_template to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy chg_template () from 'chg_template.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on chg_template
\p\g
create table chgalg(
	id integer not null,
	persid varchar(30),
	change_id integer,
	last_mod_dt integer,
	time_spent integer,
	time_stamp integer,
	system_time integer,
	analyst byte varying(16),
	description long varchar,
	action_desc long varchar,
	type varchar(12),
	internal integer,
	knowledge_session varchar(80),
	knowledge_tool varchar(12)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify chgalg to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy chgalg () from 'chgalg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on chgalg
\p\g
create table chgcat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	code varchar(12) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	organization byte varying(16),
	assignee byte varying(16),
	group_id byte varying(16),
	children_ok integer not null,
	service_type varchar(30),
	survey integer,
	schedule integer,
	auto_assign integer,
	owning_contract integer,
	cawf_defid integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify chgcat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy chgcat () from 'chgcat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on chgcat
\p\g
create table chgstat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	code varchar(12) not null,
	active integer,
	hold integer,
	resolved integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify chgstat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy chgstat () from 'chgstat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on chgstat
\p\g
create table chstatus(
	oid integer not null,
	qmgr_oid integer not null,
	channel varchar(20) not null,
	chltype varchar(20) not null,
	conname varchar(64),
	xmitq varchar(80),
	data_class char(8),
	curluwid varchar(16),
	curmsgs integer,
	curseqno integer,
	indoubt char(3),
	lstluwid varchar(16),
	lstseqno integer,
	status varchar(15),
	batches integer,
	batchsz integer,
	bufsrcvd integer,
	bufssent integer,
	bytsrcvd integer,
	bytssent integer,
	chstada char(10),
	chstati char(8),
	hbint integer,
	jobname varchar(48),
	longrts integer,
	lstmsgda char(10),
	lstmsgti char(8),
	maxmsgl integer,
	mcastat char(12),
	msgs integer,
	npmspeed char(10),
	shortrts integer,
	stopreq char(3)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify chstatus to heap
with extend = 16,
	allocation = 4
\p\g
/* copy chstatus () from 'chstatus.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on chstatus
\p\g
create table ci_actions(
	id integer not null,
	wf_template_id integer,
	action_title varchar(100),
	group_id byte varying(16),
	analyst_id byte varying(16),
	action_order integer,
	predefined integer,
	status_current_id integer,
	unpublish integer,
	unretire integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_actions to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_actions () from 'ci_actions.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_actions
\p\g
create table ci_actions_alternate(
	id integer not null,
	action_id integer,
	contact_type integer,
	contact_id byte varying(16),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_actions_alternate to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_actions_alternate () from 'ci_actions_alternate.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_actions_alternate
\p\g
create table ci_bookmarks(
	id integer not null,
	user_id byte varying(16),
	document_id integer,
	bookmark_title varchar(100),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_bookmarks to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_bookmarks () from 'ci_bookmarks.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_bookmarks
\p\g
create table ci_doc_links(
	id integer not null,
	doc_id1 integer,
	doc_id2 integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_doc_links to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_doc_links () from 'ci_doc_links.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_doc_links
\p\g
create table ci_doc_templates(
	id integer not null,
	template_name varchar(255),
	is_predefined integer,
	is_default integer,
	banner_height float,
	user_def_id integer,
	creation_date integer,
	modify_date integer,
	start_date integer,
	expiration_date integer,
	review_date integer,
	last_accepted_date integer,
	published_date integer,
	author integer,
	owner integer,
	subject_expert integer,
	initiator integer,
	assignee integer,
	priority integer,
	sd_product integer,
	sd_asset integer,
	sd_rootcause integer,
	sd_priority integer,
	sd_severity integer,
	sd_impact integer,
	sd_urgency integer,
	sd_accepted_hits integer,
	created_via integer,
	primary_index integer,
	current_action integer,
	doc_template integer,
	wf_template integer,
	doc_version integer,
	bu_result integer,
	status integer,
	doc_type integer,
	custom1 integer,
	custom2 integer,
	custom3 integer,
	custom4 integer,
	custom5 integer,
	custom_num1 integer,
	custom_num2 integer,
	show_caption integer,
	doc_id integer,
	hits integer,
	guest_option_off integer,
	banner_html long varchar,
	page_html long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_doc_templates to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_doc_templates () from 'ci_doc_templates.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_doc_templates
\p\g
create table ci_doc_types(
	id integer not null,
	doc_type_txt varchar(50),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_doc_types to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_doc_types () from 'ci_doc_types.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_doc_types
\p\g
create table ci_priorities(
	id integer not null,
	priority varchar(50),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_priorities to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_priorities () from 'ci_priorities.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_priorities
\p\g
create table ci_statuses(
	id integer not null,
	status varchar(50),
	status_order integer,
	predefined integer,
	status_description varchar(255),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_statuses to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_statuses () from 'ci_statuses.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_statuses
\p\g
create table ci_wf_templates(
	id integer not null,
	wf_name varchar(255),
	wf_description varchar(255),
	is_default integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ci_wf_templates to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ci_wf_templates () from 'ci_wf_templates.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ci_wf_templates
\p\g
create table cico_detail(
	rsrc_id decimal(31,0) not null,
	object_id decimal(31,0) not null,
	object_name varchar(1200) not null,
	checkout_option integer,
	checkout_status integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cico_detail to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy cico_detail () from 'cico_detail.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on cico_detail
\p\g
create table ciscostats(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	freemem float,
	bufferelfree integer,
	bufferelmax integer,
	bufferelhit float,
	bufferelmiss float,
	bufferelcreate float,
	buffersmtotal integer,
	buffersmhit float,
	buffersmmiss float,
	buffermdtotal integer,
	buffermdhit float,
	buffermdmiss float,
	bufferbgtotal integer,
	bufferbghit float,
	bufferbgmiss float,
	bufferlgtotal integer,
	bufferlghit float,
	bufferlgmiss float,
	bufferfail float,
	buffernomem float,
	avgbusy1 i1,
	avgbusy5 i1,
	bufferhgtotal integer,
	bufferhghit float,
	bufferhgmiss float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ciscostats to btree on
	probe_addr,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy ciscostats () from 'ciscostats.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ciscostats
\p\g
create table ciscotemperature_cfg(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	montemperaturestatusindex integer,
	montemperaturestatusdescr varchar(32),
	montemperaturethreshold integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ciscotemperature_cfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ciscotemperature_cfg () from 'ciscotemperature_cfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ciscotemperature_cfg
\p\g
create table ciscotemperature_stat(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	montemperaturestatusindex integer,
	montemperaturestatusvalue integer,
	montemperaturestatuslastshut integer,
	montemperaturestatusstate integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ciscotemperature_stat to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ciscotemperature_stat () from 'ciscotemperature_stat.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ciscotemperature_stat
\p\g
create table ciscovoltage_cfg(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	monvoltagestatusindex integer,
	monvoltagestatusdescr varchar(32),
	monvoltagestatusthresholdlow integer,
	monvoltagestatusthresholdhigh integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ciscovoltage_cfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ciscovoltage_cfg () from 'ciscovoltage_cfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ciscovoltage_cfg
\p\g
create table ciscovoltage_stat(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	monvoltagestatusindex integer,
	monvoltagestatusvalue integer,
	monvoltagestatuslastshutdown integer,
	monvoltagestate integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ciscovoltage_stat to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ciscovoltage_stat () from 'ciscovoltage_stat.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ciscovoltage_stat
\p\g
create table client_allocation(
	client_group_id decimal(31,0) not null,
	client_id decimal(31,0) not null,
	allocation_percentage float,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify client_allocation to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy client_allocation () from 'client_allocation.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on client_allocation
\p\g
create table client_object(
	client_object_id decimal(31,0) not null,
	client_object_code varchar(4000),
	client_object_name varchar(1200) not null,
	client_object_description varchar(4000),
	client_group_flag smallint,
	client_is_grp_member smallint,
	client_group_name varchar(1200),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify client_object to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy client_object () from 'client_object.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on client_object
\p\g
create table clone(
	cloneid integer not null,
	templateid integer,
	name varchar(255),
	parentregionid integer,
	parentboxid integer,
	cloneleft integer,
	cloneright integer,
	clonetop integer,
	clonebottom integer,
	lastsynctime integer,
	checkoutsid varchar(100),
	checkoutname varchar(100),
	instancename varchar(8),
	owner varchar(255),
	description varchar(255),
	psname varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify clone to btree unique on
	cloneid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy clone () from 'clone.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on clone
\p\g
create table cluster(
	clusterid integer not null,
	clustername char(254) not null,
	clustertype smallint not null,
	description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify cluster to btree unique on
	clusterid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy cluster () from 'cluster.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cluster
\p\g
create integrity  ON Cluster IS ClusterID >= 1
\p\g
create integrity  ON Cluster IS ClusterType IN (1, 2)
\p\g
create table cmprules(
	id integer not null,
	owner varchar(128) not null,
	name varchar(128) not null,
	server_type integer not null,
	shareable integer not null,
	locked integer not null,
	locked_by varchar(128),
	lock_datetime date,
	description varchar(256),
	upd_user varchar(128) not null,
	upd_datetime date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify cmprules to btree unique on
	owner,
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy cmprules () from 'cmprules.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cmprules
\p\g
create table cn(
	id integer not null,
	del integer not null,
	cn_name varchar(30),
	cn_dflt varchar(30),
	cn_sys varchar(30),
	cn_table varchar(30),
	cn_desc varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cn to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy cn () from 'cn.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cn
\p\g
create table cnote(
	id integer not null,
	persid varchar(30),
	del integer,
	posted_date integer,
	posted_by byte varying(16),
	text long varchar,
	control_group byte varying(16),
	internal integer,
	loc_id byte varying(16),
	organization byte varying(16),
	active_flag integer not null,
	cnote_type integer,
	close_date integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cnote to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy cnote () from 'cnote.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cnote
\p\g
create table codefragment(
	fragmentid integer not null,
	fragmentcode long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify codefragment to heap
with extend = 16,
	allocation = 4
\p\g
/* copy codefragment () from 'codefragment.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on codefragment
\p\g
create table col_map(
	oid integer not null,
	tab_map_oid integer not null,
	col_name varchar(18),
	tag varchar(64)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify col_map to heap
with extend = 16,
	allocation = 4
\p\g
/* copy col_map () from 'col_map.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on col_map
\p\g
create table coll_profile_attrs(
	pid integer not null,
	metric_name varchar(100) not null,
	field_name varchar(100) not null,
	value varchar(100) not null,
	agenthost varchar(100) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify coll_profile_attrs to btree unique on
	pid,
	metric_name,
	field_name,
	agenthost
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy coll_profile_attrs () from 'coll_profile_attrs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on coll_profile_attrs
\p\g
create table collect(
	collect_id decimal(5,0) not null,
	created_by varchar(30),
	start_time date,
	end_time date,
	scope_id decimal(5,0),
	filter_head_id decimal(5,0),
	collect_type decimal(1,0),
	update_dict decimal(8,0),
	estimate_rows decimal(5,0),
	estimate_pct decimal(3,0),
	table_cnt decimal(5,0),
	index_cnt decimal(5,0),
	cluster_cnt decimal(5,0),
	object_cnt decimal(5,0),
	user_cnt decimal(5,0),
	rollback_cnt decimal(5,0),
	other_cnt decimal(5,0),
	collect_event_id decimal(5,0),
	use_fast_anal decimal(1,0),
	nbr_threads decimal(1,0),
	histogram_options decimal(1,0),
	anal_type decimal(1,0),
	job_id decimal(5,0),
	collect_desc varchar(60),
	status varchar(1),
	auto_reorg decimal(1,0),
	reorg_scope_id decimal(5,0),
	reorg_and_or decimal(1,0),
	reorg_run decimal(5,0),
	reorg_type varchar(1),
	reorg_ts_pct decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify collect to btree unique on
	collect_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy collect () from 'collect.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on collect
\p\g
create table collected_data(
	dcid integer not null,
	sampletime integer not null,
	sampleperiod integer not null,
	qualifier integer not null,
	samples integer,
	avgval f4,
	minval f4,
	maxval f4,
	stddev f4
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify collected_data to btree unique on
	dcid,
	sampletime,
	qualifier
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy collected_data () from 'collected_data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on collected_data
\p\g
create table collection_profiles(
	pid integer not null,
	profile_name varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify collection_profiles to btree unique on
	pid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy collection_profiles () from 'collection_profiles.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on collection_profiles
\p\g
create table collectionparmgroups(
	parmgroup smallint not null,
	parmgroupname varchar(100) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify collectionparmgroups to hash on
	parmgroup
with fillfactor = 50,
	extend = 4
\p\g
/* copy collectionparmgroups () from 'collectionparmgroups.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on collectionparmgroups
\p\g
create table collectionparms(
	parmname varchar(100) not null,
	parmvalue varchar(132),
	parmindex integer not null,
	parmtype varchar(200),
	parmgroups varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify collectionparms to hash unique on
	parmname
with fillfactor = 50,
	extend = 16
\p\g
/* copy collectionparms () from 'collectionparms.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on collectionparms
\p\g
create table collectorpolling(
	collectorid integer not null,
	counterid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify collectorpolling to btree unique on
	collectorid,
	counterid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy collectorpolling () from 'collectorpolling.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on collectorpolling
\p\g
create integrity  ON CollectorPolling IS CollectorID >= 1
\p\g
create integrity  ON CollectorPolling IS CounterID >= 1
\p\g
create table collectserver(
	server_name varchar(32) not null,
	server_addr integer not null,
	server_u_id varchar(32),
	server_u_pswd varchar(64),
	db_server_name varchar(32) not null,
	db_id varchar(32),
	db_pswd varchar(64),
	server_type varchar(32) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify collectserver to hash on
	server_addr
with fillfactor = 50,
	extend = 4
\p\g
/* copy collectserver () from 'collectserver.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on collectserver
\p\g
create table columndefinition(
	tableidx integer not null,
	orderofcolumn integer not null,
	name varchar(32),
	typeid integer not null,
	rolluptype c1,
	reportlabel varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify columndefinition to heap
with extend = 16,
	allocation = 4
\p\g
/* copy columndefinition () from 'columndefinition.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on columndefinition
\p\g
create table common_extent(
	common_extent_id decimal(5,0) not null,
	object_id decimal(5,0) not null,
	datafile_id decimal(5,0),
	extent# decimal(5,0),
	offset decimal(5,0),
	blocks decimal(5,0),
	collect_id decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify common_extent to btree unique on
	common_extent_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy common_extent () from 'common_extent.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on common_extent
\p\g
create table compare(
	compare_id decimal(5,0) not null,
	first_collect_id decimal(5,0),
	last_collect_id decimal(5,0),
	nbr_datapoints decimal(5,0),
	auto_compare decimal(1,0),
	start_time date,
	end_time date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify compare to btree unique on
	compare_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy compare () from 'compare.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on compare
\p\g
create table compare_object(
	compare_id decimal(5,0) not null,
	first_object_id decimal(5,0),
	last_object_id decimal(5,0),
	status varchar(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify compare_object to heap
with extend = 16,
	allocation = 4
\p\g
/* copy compare_object () from 'compare_object.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on compare_object
\p\g
create table componentofindex(
	componentmibindexidx integer not null,
	componentofindexorder integer not null,
	mibidx integer not null,
	oididxformib integer not null,
	indexstart integer,
	indexlength integer,
	implied c1 not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify componentofindex to heap
with extend = 16,
	allocation = 4
\p\g
/* copy componentofindex () from 'componentofindex.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on componentofindex
\p\g
create integrity  ON ComponentOfIndex IS Implied IN ('Y', 'N')
\p\g
create table compressed_file(
	file_name varchar(228) not null,
	file_directory varchar(328) not null,
	file_type decimal(31,0),
	file_contents long byte,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify compressed_file to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy compressed_file () from 'compressed_file.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on compressed_file
\p\g
create table computer(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname varchar(64) not null,
	streamaddress byte varying(510) not null,
	strcamaddress varchar(64) not null,
	strdescription varchar(128) not null,
	uidconfigpolicy byte(16) not null,
	iinheritconfiguration integer not null,
	datelastaccess date not null,
	istatus integer not null,
	uidlastparent byte(16) not null,
	datelastevent date not null,
	dateconfigpolicy date not null,
	strversion varchar(64) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify computer to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy computer () from 'computer.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on computer
\p\g
create table computergroup(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname varchar(64) not null,
	strdescription varchar(128) not null,
	uidconfigpolicy byte(16) not null,
	iinheritconfiguration integer not null,
	isorthelp integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify computergroup to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy computergroup () from 'computergroup.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on computergroup
\p\g
create table config_vuln_category_matrix(
	config_vuln_cat_rec_id byte(16) not null,
	vuln_id byte(16) not null,
	bp_standard_category_id byte(16) not null,
	creation_user nvarchar(64) not null,
	creation_date integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify config_vuln_category_matrix to btree unique on
	config_vuln_cat_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy config_vuln_category_matrix () from 'config_vuln_category_matrix.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on config_vuln_category_matrix
\p\g
create table configuration_standard_set(
	config_standard_set_id byte(16) not null,
	description long nvarchar,
	name nvarchar(255) not null,
	is_user_defined i1 not null,
	is_ca_internal_set i1 not null,
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify configuration_standard_set to btree unique on
	config_standard_set_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy configuration_standard_set () from 'configuration_standard_set.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on configuration_standard_set
\p\g
create table configuration_standard_vuln(
	vuln_id byte(16) not null,
	implementation_procedure long nvarchar,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify configuration_standard_vuln to btree unique on
	vuln_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy configuration_standard_vuln () from 'configuration_standard_vuln.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on configuration_standard_vuln
\p\g
create table confmemo(
	domainid integer not null,
	unitid integer not null,
	conftype integer not null,
	confver integer not null,
	contents text(1),
	sql_tstamp byte(8)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify confmemo to btree unique on
	unitid,
	conftype,
	domainid,
	confver
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy confmemo () from 'confmemo.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on confmemo
\p\g
create table connectortype(
	connectortypeid integer not null,
	connectortypename varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify connectortype to btree unique on
	connectortypeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy connectortype () from 'connectortype.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on connectortype
\p\g
create integrity  ON ConnectorType IS ConnectorTypeID IN (0, 1, 2, 3, 
4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
\p\g
create table constants(
	constant_id decimal(5,0) not null,
	constant_name varchar(30) not null,
	constant_value varchar(30),
	created_by varchar(30) not null,
	bind_var decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify constants to btree unique on
	constant_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy constants () from 'constants.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on constants
\p\g
create table consult_57(
	date_and_time decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	calls_opened decimal(20,5),
	pattern_dow decimal(20,5),
	calls_resolved decimal(20,5),
	calls_esc decimal(20,5),
	calls_trans decimal(20,5),
	calls_reopened decimal(20,5),
	calls_closefirst decimal(20,5),
	avg_close_time decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify consult_57 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy consult_57 () from 'consult_57.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on consult_57
\p\g
create table consult_62(
	date_and_time decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	priority decimal(20,5),
	open_dow decimal(20,5),
	open_tod decimal(20,5),
	sla_violation_dow decimal(20,5),
	impact decimal(20,5),
	sla_time decimal(20,5),
	time_of_violation decimal(20,5),
	category_code_0 decimal(20,5),
	category_code_1 decimal(20,5),
	category_code_2 decimal(20,5),
	category_code_3 decimal(20,5),
	category_code_4 decimal(20,5),
	category_code_5 decimal(20,5),
	category_code_6 decimal(20,5),
	category_code_7 decimal(20,5),
	category_code_8 decimal(20,5),
	category_code_9 decimal(20,5),
	customer_code_0 decimal(20,5),
	customer_code_1 decimal(20,5),
	customer_code_2 decimal(20,5),
	customer_code_3 decimal(20,5),
	customer_code_4 decimal(20,5),
	customer_code_5 decimal(20,5),
	customer_code_6 decimal(20,5),
	status_changes decimal(20,5),
	transfers decimal(20,5),
	sla_violation decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify consult_62 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy consult_62 () from 'consult_62.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on consult_62
\p\g
create table consult_aux_57(
	date_and_time decimal(20,5),
	label_field char(50),
	calls_opened char(50),
	group_field char(50),
	pattern_date char(50),
	calls_resolved char(50),
	calls_esc char(50),
	calls_trans char(50),
	calls_reopened char(50),
	calls_closefirst char(50),
	avg_close_time char(50),
	calls_closed char(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify consult_aux_57 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy consult_aux_57 () from 'consult_aux_57.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on consult_aux_57
\p\g
create table consult_aux_62(
	date_and_time decimal(20,5),
	id char(50),
	open_date char(50),
	start_date char(50),
	close_date char(50),
	priority char(50),
	assignee char(50),
	start_time char(50),
	sla_time char(50),
	fire_time char(50),
	impact char(50),
	group_id char(50),
	category char(50),
	workshift char(50),
	customer char(50),
	status_changes char(50),
	transfers char(50),
	assignee_name char(50),
	group_name char(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify consult_aux_62 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy consult_aux_62 () from 'consult_aux_62.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on consult_aux_62
\p\g
create table consultable_57(
	date_and_time decimal(20,5),
	consulted decimal(20,5),
	neugents_ahd_time_stamp decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	calls_opened_m6 decimal(20,5),
	calls_opened_m5 decimal(20,5),
	calls_opened_m4 decimal(20,5),
	calls_opened_m3 decimal(20,5),
	calls_opened_m2 decimal(20,5),
	calls_opened_m1 decimal(20,5),
	calls_opened decimal(20,5),
	calls_opened_p1 decimal(20,5),
	calls_opened_p2 decimal(20,5),
	calls_opened_p3 decimal(20,5),
	calls_opened_p4 decimal(20,5),
	calls_opened_p5 decimal(20,5),
	calls_opened_p6 decimal(20,5),
	calls_opened_p7 decimal(20,5),
	calls_opened_p1_actual decimal(20,5),
	calls_opened_p2_actual decimal(20,5),
	calls_opened_p3_actual decimal(20,5),
	calls_opened_p4_actual decimal(20,5),
	calls_opened_p5_actual decimal(20,5),
	calls_opened_p6_actual decimal(20,5),
	calls_opened_p7_actual decimal(20,5),
	pattern_dow_m6 decimal(20,5),
	pattern_dow_m5 decimal(20,5),
	pattern_dow_m4 decimal(20,5),
	pattern_dow_m3 decimal(20,5),
	pattern_dow_m2 decimal(20,5),
	pattern_dow_m1 decimal(20,5),
	pattern_dow decimal(20,5),
	calls_resolved_m6 decimal(20,5),
	calls_resolved_m5 decimal(20,5),
	calls_resolved_m4 decimal(20,5),
	calls_resolved_m3 decimal(20,5),
	calls_resolved_m2 decimal(20,5),
	calls_resolved_m1 decimal(20,5),
	calls_resolved decimal(20,5),
	calls_resolved_p1 decimal(20,5),
	calls_resolved_p2 decimal(20,5),
	calls_resolved_p3 decimal(20,5),
	calls_resolved_p4 decimal(20,5),
	calls_resolved_p5 decimal(20,5),
	calls_resolved_p6 decimal(20,5),
	calls_resolved_p7 decimal(20,5),
	calls_resolved_p1_actual decimal(20,5),
	calls_resolved_p2_actual decimal(20,5),
	calls_resolved_p3_actual decimal(20,5),
	calls_resolved_p4_actual decimal(20,5),
	calls_resolved_p5_actual decimal(20,5),
	calls_resolved_p6_actual decimal(20,5),
	calls_resolved_p7_actual decimal(20,5),
	calls_esc_m6 decimal(20,5),
	calls_esc_m5 decimal(20,5),
	calls_esc_m4 decimal(20,5),
	calls_esc_m3 decimal(20,5),
	calls_esc_m2 decimal(20,5),
	calls_esc_m1 decimal(20,5),
	calls_esc decimal(20,5),
	calls_trans_m6 decimal(20,5),
	calls_trans_m5 decimal(20,5),
	calls_trans_m4 decimal(20,5),
	calls_trans_m3 decimal(20,5),
	calls_trans_m2 decimal(20,5),
	calls_trans_m1 decimal(20,5),
	calls_trans decimal(20,5),
	calls_reopened_m6 decimal(20,5),
	calls_reopened_m5 decimal(20,5),
	calls_reopened_m4 decimal(20,5),
	calls_reopened_m3 decimal(20,5),
	calls_reopened_m2 decimal(20,5),
	calls_reopened_m1 decimal(20,5),
	calls_reopened decimal(20,5),
	calls_closefirst_m6 decimal(20,5),
	calls_closefirst_m5 decimal(20,5),
	calls_closefirst_m4 decimal(20,5),
	calls_closefirst_m3 decimal(20,5),
	calls_closefirst_m2 decimal(20,5),
	calls_closefirst_m1 decimal(20,5),
	calls_closefirst decimal(20,5),
	avg_close_time_m6 decimal(20,5),
	avg_close_time_m5 decimal(20,5),
	avg_close_time_m4 decimal(20,5),
	avg_close_time_m3 decimal(20,5),
	avg_close_time_m2 decimal(20,5),
	avg_close_time_m1 decimal(20,5),
	avg_close_time decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify consultable_57 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy consultable_57 () from 'consultable_57.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on consultable_57
\p\g
create table consultable_62(
	date_and_time decimal(20,5),
	consulted decimal(20,5),
	neugents_ahd_time_stamp decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	priority decimal(20,5),
	open_dow decimal(20,5),
	open_tod decimal(20,5),
	sla_violation_dow decimal(20,5),
	impact decimal(20,5),
	sla_time decimal(20,5),
	time_of_violation decimal(20,5),
	category_code_0 decimal(20,5),
	category_code_1 decimal(20,5),
	category_code_2 decimal(20,5),
	category_code_3 decimal(20,5),
	category_code_4 decimal(20,5),
	category_code_5 decimal(20,5),
	category_code_6 decimal(20,5),
	category_code_7 decimal(20,5),
	category_code_8 decimal(20,5),
	category_code_9 decimal(20,5),
	customer_code_0 decimal(20,5),
	customer_code_1 decimal(20,5),
	customer_code_2 decimal(20,5),
	customer_code_3 decimal(20,5),
	customer_code_4 decimal(20,5),
	customer_code_5 decimal(20,5),
	customer_code_6 decimal(20,5),
	status_changes decimal(20,5),
	transfers decimal(20,5),
	sla_violation_actual decimal(20,5),
	sla_violation decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify consultable_62 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy consultable_62 () from 'consultable_62.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on consultable_62
\p\g
create table contact(
	contact_id integer not null,
	first_name varchar(50),
	middle_name varchar(50),
	last_name varchar(50),
	prefix varchar(20),
	suffix varchar(20),
	title varchar(20),
	organization1 varchar(50),
	organization2 varchar(50),
	email1 varchar(60),
	email2 varchar(60),
	phone1 varchar(40),
	phone2 varchar(40),
	pager varchar(40),
	pager_code varchar(20),
	im_type integer,
	im_address varchar(50),
	notes char(1),
	receive_system_messages decimal(1,0),
	creation_date date not null,
	modification_date date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify contact to btree unique on
	contact_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy contact () from 'contact.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on contact
\p\g
create table contact_list(
	contact_list_id integer not null,
	name varchar(100),
	creation_date date not null,
	modification_date date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify contact_list to btree unique on
	contact_list_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy contact_list () from 'contact_list.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on contact_list
\p\g
create table contact_list_contact(
	contact_list_contact_id integer not null,
	contact_list_id integer,
	contact_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify contact_list_contact to btree unique on
	contact_list_contact_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy contact_list_contact () from 'contact_list_contact.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on contact_list_contact
\p\g
create table context_group(
	product_instance_id decimal(31,0) not null,
	product_category_id decimal(31,0) not null,
	product_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify context_group to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy context_group () from 'context_group.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on context_group
\p\g
create table copy_index(
	copy_table char(50) not null,
	inserted integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify copy_index to btree unique on
	copy_table
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy copy_index () from 'copy_index.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on copy_index
\p\g
create table cost_accounting_period(
	cost_accounting_period_code decimal(31,0),
	period_start_date date,
	period_end_date date,
	posted_by_user_name varchar(1200),
	post_datetime date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cost_accounting_period to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy cost_accounting_period () from 'cost_accounting_period.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on cost_accounting_period
\p\g
create table cost_acctg_period_post(
	cost_accounting_period_code decimal(31,0),
	project_id decimal(31,0) not null,
	rsrc_id decimal(31,0) not null,
	client_object_id decimal(31,0) not null,
	project_account_id decimal(31,0),
	department_id decimal(31,0),
	project_code varchar(40),
	project_name varchar(120),
	client_object_code varchar(400),
	client_object_name varchar(120),
	rsrc_code varchar(400),
	rsrc_name varchar(120),
	account_code varchar(40),
	account_name varchar(120),
	project_type_code varchar(40),
	project_type_description varchar(2000),
	project_manager_code varchar(40),
	project_manager_name varchar(120),
	admin_manager_code varchar(40),
	admin_manager_name varchar(32),
	department_code varchar(40),
	department_name varchar(32),
	nonproject_event_id decimal(31,0),
	nonproject_event_name varchar(32),
	curr_base_hrs decimal(31,0),
	curr_base_var_cost decimal(31,2),
	tot_billable_hrs decimal(31,0),
	tot_billable_cost decimal(31,2),
	ovt_billable_hrs decimal(31,0),
	ovt_billable_cost decimal(31,2),
	tot_nonbillable_hrs decimal(31,0),
	tot_nonbillable_cost decimal(31,2),
	ovt_nonbillable_hrs decimal(31,0),
	ovt_nonbillable_cost decimal(31,2),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(32),
	last_update_datetime date,
	last_update_user_name varchar(32),
	comments varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cost_acctg_period_post to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy cost_acctg_period_post () from 'cost_acctg_period_post.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on cost_acctg_period_post
\p\g
create table counter(
	id integer not null,
	userid integer not null,
	eccm_userid integer not null,
	eccm_configurationid integer not null,
	ep_id integer not null,
	ewdb_id integer not null,
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify counter to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy counter () from 'counter.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on counter
\p\g
create table counterdata(
	counterid integer not null,
	personsourceid integer,
	tstamp date not null,
	objectid integer,
	delta float,
	warningthreshold float,
	criticalthreshold float,
	issent smallint not null,
	timeinterval float not null,
	countervalue float,
	stringvalue varchar(255),
	datevalue date,
	sourceid integer not null,
	personid integer,
	counterdataid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify counterdata to btree unique on
	counterid,
	sourceid,
	counterdataid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy counterdata () from 'counterdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on counterdata
\p\g
create integrity  ON CounterData IS CounterID >= 1
\p\g
create integrity  ON CounterData IS SourceID >= 1
\p\g
create integrity  ON CounterData IS CounterDataID >= 1
\p\g
create integrity  ON CounterData IS ObjectID >= 1
\p\g
create integrity  ON CounterData IS PersonSourceID >= 1
\p\g
create integrity  ON CounterData IS PersonID >= 1
\p\g
create table counterdefinition(
	counterid integer not null,
	unitid integer not null,
	fullcountername char(254) not null,
	countername char(254) not null,
	datatype smallint not null,
	class varchar(255) not null,
	subclass varchar(255),
	instance varchar(255),
	countertype integer not null,
	valuetype smallint not null default 1,
	algotype smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify counterdefinition to btree unique on
	counterid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy counterdefinition () from 'counterdefinition.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on counterdefinition
\p\g
create integrity  ON CounterDefinition IS CounterID >= 1
\p\g
create integrity  ON CounterDefinition IS UnitID >= 1
\p\g
create integrity  ON CounterDefinition IS DataType IN (0, 1, 2, 3, 4, 
8, 10)
\p\g
create integrity  ON CounterDefinition IS CounterType >= 1
\p\g
create integrity  ON CounterDefinition IS ValueType IN (1, 2, 3)
\p\g
create integrity  ON CounterDefinition IS AlgoType IN (1, 2, 3, 4, 5)
\p\g
create table counterpolling(
	sourceid integer not null,
	counterid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify counterpolling to btree unique on
	sourceid,
	counterid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy counterpolling () from 'counterpolling.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on counterpolling
\p\g
create integrity  ON CounterPolling IS SourceID >= 1
\p\g
create integrity  ON CounterPolling IS CounterID >= 1
\p\g
create table countersource(
	sourceid integer not null,
	collectorid integer not null,
	localeid integer not null default 1033,
	clusterid integer,
	siteid integer not null,
	sourcename char(254) not null,
	sourcetype integer not null,
	hostname char(64) not null,
	activestate smallint not null,
	username varchar(255),
	userpwd varchar(255),
	hostname1 varchar(64),
	hostname2 varchar(64),
	hostname3 varchar(64),
	srctimezone float not null default 0,
	mailorgid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify countersource to btree unique on
	sourceid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy countersource () from 'countersource.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on countersource
\p\g
create integrity  ON CounterSource IS SourceID >= 1
\p\g
create integrity  ON CounterSource IS CollectorID >= 1
\p\g
create integrity  ON CounterSource IS LocaleID >= 1
\p\g
create integrity  ON CounterSource IS ClusterID >= 1
\p\g
create integrity  ON CounterSource IS SiteID >= 1
\p\g
create integrity  ON CounterSource IS SourceType >= 1
\p\g
create integrity  ON CounterSource IS ActiveState IN (0, 1, 2)
\p\g
create integrity  ON CounterSource IS MailOrgID >= 1
\p\g
create table countertitle(
	localeid integer not null,
	counterid integer not null,
	fullcountername char(254) not null,
	sourcetype integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify countertitle to btree unique on
	localeid,
	counterid,
	sourcetype
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy countertitle () from 'countertitle.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on countertitle
\p\g
create integrity  ON CounterTitle IS LocaleID >= 1
\p\g
create integrity  ON CounterTitle IS CounterID >= 1
\p\g
create integrity  ON CounterTitle IS SourceType IN (1, 2, 4, 8, 16, 
32, 64, 128, 256, 512)
\p\g
create table cr_prp(
	id integer not null,
	persid varchar(30),
	sequence integer not null,
	label varchar(80) not null,
	description varchar(240),
	value varchar(240),
	required integer not null,
	sample varchar(240),
	owning_cr varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cr_prp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy cr_prp () from 'cr_prp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cr_prp
\p\g
create table cr_prptpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sequence integer not null,
	label varchar(80) not null,
	description varchar(240),
	code varchar(12) not null,
	required integer not null,
	sample varchar(240),
	owning_area varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cr_prptpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy cr_prptpl () from 'cr_prptpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cr_prptpl
\p\g
create table cr_stat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	code varchar(12) not null,
	active integer,
	hold integer,
	resolved integer,
	cr_flag integer,
	in_flag integer,
	pr_flag integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cr_stat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy cr_stat () from 'cr_stat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cr_stat
\p\g
create table cr_template(
	id integer not null,
	persid varchar(30),
	del integer not null,
	template_name varchar(30) not null,
	description varchar(1000),
	template varchar(30),
	template_class varchar(12),
	quick_tmpl_type integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify cr_template to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy cr_template () from 'cr_template.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cr_template
\p\g
create table crctmr(
	id integer not null,
	persid varchar(30),
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	threshold integer not null,
	color varchar(12),
	text varchar(240),
	beep integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify crctmr to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy crctmr () from 'crctmr.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on crctmr
\p\g
create table cred(
	cred_domain varchar(8) not null,
	domain_name varchar(64) not null,
	principal varchar(64) not null,
	cred_value varchar(64),
	owner varchar(80)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify cred to btree unique on
	cred_domain,
	domain_name,
	principal
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy cred () from 'cred.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on cred
\p\g
create table crepository(
	regno varchar(50) not null,
	mackey varchar(50) not null,
	signingkey varchar(50) not null,
	serno varchar(40),
	commonname varchar(200),
	profilename varchar(50),
	profileversion varchar(50),
	privatekey byte varying(2000),
	tbscert_lo byte varying(2000),
	tbscert_hi byte varying(1000),
	processing varchar(10),
	casigned varchar(20),
	retrieved varchar(10),
	emailaddress varchar(50),
	timeofcreation varchar(50),
	timeofsigning varchar(50),
	typeofservice varchar(20),
	craclient varchar(20)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify crepository to btree unique on
	regno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy crepository () from 'crepository.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on crepository
\p\g
create table crltable(
	sernum varchar(40) not null,
	dateint varchar(50),
	details varchar(1000),
	crevclient varchar(20)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify crltable to btree unique on
	sernum
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy crltable () from 'crltable.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on crltable
\p\g
create table crsol(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	last_mod_dt integer,
	sname varchar(40),
	description varchar(500),
	nx_desc varchar(40),
	solution varchar(1000),
	sapproved integer,
	cr_count integer,
	tcode integer,
	cr_flag integer,
	in_flag integer,
	pr_flag integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify crsol to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy crsol () from 'crsol.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on crsol
\p\g
create table crsq(
	id integer not null,
	persid varchar(30),
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	code varchar(12) not null,
	description varchar(240),
	criteria varchar(240),
	count_url varchar(240),
	label varchar(80),
	obj_type varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify crsq to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy crsq () from 'crsq.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on crsq
\p\g
create table crt(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	code varchar(10) not null,
	nx_desc varchar(30),
	display_name varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify crt to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy crt () from 'crt.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on crt
\p\g
create table csm_class(
	id integer not null,
	sysclass integer not null,
	name nvarchar(64) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify csm_class to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy csm_class () from 'csm_class.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on csm_class
\p\g
create table csm_link(
	child integer not null,
	parent integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify csm_link to btree on
	child
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy csm_link () from 'csm_link.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on csm_link
\p\g
create table csm_object(
	id integer not null,
	flag integer not null,
	uuid byte(16) not null,
	name nvarchar(255) not null,
	dname nvarchar(255) not null,
	class integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify csm_object to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy csm_object () from 'csm_object.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on csm_object
\p\g
create table csm_property(
	id integer not null,
	name byte varying(32) not null,
	value byte varying(1024) not null,
	object integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify csm_property to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy csm_property () from 'csm_property.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on csm_property
\p\g
create table ct_mth(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	nx_desc varchar(40),
	cm_template varchar(240),
	write_file integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ct_mth to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ct_mth () from 'ct_mth.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ct_mth
\p\g
create table ctab(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	obj_name varchar(30),
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ctab to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ctab () from 'ctab.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ctab
\p\g
create table d_painter(
	id integer not null,
	formid integer,
	formname varchar(50),
	formgroup varchar(50),
	seclevel integer,
	entityid integer,
	cntltype integer,
	cntlid integer,
	parentid integer,
	ddid integer,
	mapback varchar(30),
	tstamp float,
	proplist varchar(1000),
	formtype integer,
	predefined integer,
	extra_s1 varchar(50),
	extra_s2 varchar(50),
	extra_s3 varchar(50),
	extra_l1 integer,
	extra_l2 integer,
	extra_l3 integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify d_painter to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy d_painter () from 'd_painter.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on d_painter
\p\g
create table dao_reorg_def_metrics(
	metric_id decimal(5,0) not null,
	min_val decimal(5,0),
	max_val decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dao_reorg_def_metrics to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dao_reorg_def_metrics () from 'dao_reorg_def_metrics.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dao_reorg_def_metrics
\p\g
create table dao_reorg_metrics(
	collect_id decimal(5,0),
	metric_id decimal(5,0) not null,
	min_val decimal(5,0),
	max_val decimal(5,0),
	reorg_id decimal(5,0) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dao_reorg_metrics to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dao_reorg_metrics () from 'dao_reorg_metrics.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dao_reorg_metrics
\p\g
create table dao_reorg_objects(
	collect_id decimal(5,0) not null,
	owner varchar(30),
	obj_name varchar(30),
	obj_type decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dao_reorg_objects to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dao_reorg_objects () from 'dao_reorg_objects.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dao_reorg_objects
\p\g
create table dao_tmp(
	hostname varchar(40) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dao_tmp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dao_tmp () from 'dao_tmp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dao_tmp
\p\g
create table data_collect_attrs(
	dcid integer not null,
	metric_name varchar(100) not null,
	attr_name varchar(50) not null,
	value varchar(511)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify data_collect_attrs to btree unique on
	dcid,
	metric_name,
	attr_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy data_collect_attrs () from 'data_collect_attrs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on data_collect_attrs
\p\g
create table data_collections(
	dcid integer not null,
	metric_name varchar(100) not null,
	created integer,
	created_by varchar(50),
	last_modified integer,
	last_modified_by varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify data_collections to btree unique on
	dcid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy data_collections () from 'data_collections.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on data_collections
\p\g
create table databases(
	database_id decimal(31,0) not null,
	project_id decimal(31,0),
	next_update date,
	expertise_name1 varchar(320) default 'Expert',
	expertise_name2 varchar(320) default 'Skilled',
	expertise_name3 varchar(320) default 'Qualified',
	expertise_name4 varchar(320) default 'Inexperienced',
	expertise_name5 varchar(320) default 'Novice',
	database_version varchar(40) default '1',
	database_revision varchar(40) default '1',
	path varchar(40),
	web_index varchar(40),
	database_type integer default 2,
	left_margin float default 0.5,
	right_margin float default 0.5,
	top_margin float default 1,
	bottom_margin float default 1,
	header varchar(400),
	footer varchar(400),
	grid_lines_flag smallint default 1,
	monochrome_flag smallint default 1,
	column_headers_flag smallint default 1,
	duration_units integer default 2,
	hour_rate float default 1,
	day_rate float default 0.125,
	month_rate float default 0.00625,
	week_rate float default 0.025,
	format_decimal varchar(40),
	format_currency varchar(400),
	format_integer varchar(400),
	format_date varchar(400),
	units_suffix varchar(400) default 'hdwm',
	work_units decimal(31,0) default 2,
	time_units decimal(31,0) default 2,
	margin_units integer default 1,
	format_scientific varchar(400),
	search_path varchar(400),
	next_task_id decimal(31,0),
	next_asgn_id decimal(31,0),
	dm_tools_loaded integer,
	opr_created_date date,
	opr_modified_date date,
	creation_datetime date,
	creation_user_name varchar(120),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify databases to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy databases () from 'databases.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on databases
\p\g
create table datafile(
	datafile_id decimal(5,0) not null,
	file# decimal(5,0),
	tablespace_id decimal(5,0),
	collect_id decimal(5,0),
	file_name varchar(513),
	tablespace_name varchar(30),
	bytes decimal(5,0),
	status decimal(1,0),
	relative_fno decimal(5,0),
	maxbytes decimal(5,0),
	increment_by decimal(5,0),
	nbr_used_extents decimal(5,0),
	nbr_free_extents decimal(5,0),
	min_used_size decimal(5,0),
	max_used_size decimal(5,0),
	avg_used_size decimal(5,0),
	std_used_size decimal(5,0),
	min_free_size decimal(5,0),
	max_free_size decimal(5,0),
	avg_free_size decimal(5,0),
	std_free_size decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify datafile to btree unique on
	datafile_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy datafile () from 'datafile.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on datafile
\p\g
create table datarolldate(
	datatype i1 not null,
	finishdatetime date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify datarolldate to hash unique on
	datatype
with fillfactor = 50,
	extend = 4
\p\g
/* copy datarolldate () from 'datarolldate.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on datarolldate
\p\g
create table datarollup(
	datatype i1 not null,
	server_addr integer not null,
	probe_addr integer not null,
	rsrcindex integer not null,
	startdate date not null,
	enddate date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify datarollup to btree on
	probe_addr,
	rsrcindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy datarollup () from 'datarollup.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on datarollup
\p\g
create table datasource(
	id integer,
	sequence i1,
	template i1,
	screenname varchar(32) not null,
	plugin varchar(32),
	description varchar(32),
	priority integer,
	config varchar(1950)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify datasource to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy datasource () from 'datasource.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on datasource
\p\g
create table date_outline(
	dout_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	dout_is_heading smallint,
	dout_is_child_hidden smallint,
	dout_is_selected smallint,
	dout_date_level decimal(31,0),
	dout_start_date date,
	dout_end_date date,
	dout_tot_var_cost float,
	dout_tot_fix_cost float,
	dout_tot_ovt_cost float,
	dout_tot_ovhead_cost float,
	dout_tot_act_var_cost float,
	dout_tot_act_fix_cost float,
	dout_tot_act_ovt_cost float,
	dout_tot_act_ovhead_cost float,
	dout_tot_base_var_cost float,
	dout_tot_base_fix_cost float,
	dout_tot_bcwp float,
	dout_tot_asgn_hrs decimal(31,0),
	dout_tot_ovt_hrs decimal(31,0),
	dout_tot_oversch_hrs decimal(31,0),
	dout_tot_act_hrs decimal(31,0),
	dout_tot_act_ovt_hrs decimal(31,0),
	dout_tot_base_hrs decimal(31,0),
	dout_tot_mat_hrs decimal(31,0),
	dout_tot_act_mat_hrs decimal(31,0),
	dout_tot_upd_var_cost float,
	dout_tot_upd_fix_cost float,
	dout_tot_upd_ovt_cost float,
	dout_tot_upd_hrs decimal(31,0),
	dout_tot_upd_ovt_hrs decimal(31,0),
	dout_outline_root decimal(31,0),
	dout_sibling_id decimal(31,0),
	logical_delete_flag smallint,
	dout_child_id decimal(31,0),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify date_outline to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy date_outline () from 'date_outline.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on date_outline
\p\g
create table day_name_lookup(
	day_name_id decimal(31,0),
	day_name varchar(4000) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify day_name_lookup to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy day_name_lookup () from 'day_name_lookup.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on day_name_lookup
\p\g
create table db_application(
	dbrep_iid integer not null,
	dbrep_workflowspec varchar(128),
	dbrep_location varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_application to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_application () from 'db_application.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_application
\p\g
create table db_column(
	dbrep_iid integer not null,
	dbrep_sequencenum integer,
	dbrep_length integer,
	dbrep_precision integer,
	dbrep_scale integer,
	dbrep_isnullable i1,
	dbrep_datatypeiid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_column to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_column () from 'db_column.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_column
\p\g
create table db_datatype(
	dbrep_iid integer not null,
	dbrep_basetypeiid integer,
	dbrep_length integer,
	dbrep_precision integer,
	dbrep_scale integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_datatype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_datatype () from 'db_datatype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_datatype
\p\g
create table db_field(
	dbrep_iid integer not null,
	dbrep_sequencenum integer,
	dbrep_groupiid integer,
	dbrep_pictureclause varchar(31),
	dbrep_usageclause varchar(255),
	dbrep_synctype smallint,
	dbrep_isgroup smallint,
	dbrep_isnested smallint,
	dbrep_type smallint,
	dbrep_length integer,
	dbrep_precision integer,
	dbrep_scale integer,
	dbrep_blankwhenzero smallint,
	dbrep_justified smallint,
	dbrep_issigned smallint,
	dbrep_issignseparate smallint,
	dbrep_signtype smallint,
	dbrep_redefinesfieldname varchar(255),
	dbrep_dependsonfieldname varchar(255),
	dbrep_occursmin smallint,
	dbrep_occursmax smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_field to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_field () from 'db_field.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_field
\p\g
create table db_gator(
	dbrep_iid integer not null,
	dbrep_sourceiid integer,
	dbrep_location varchar(127)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_gator to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_gator () from 'db_gator.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_gator
\p\g
create table db_gatorstar(
	dbrep_gatoriid integer not null,
	dbrep_stariid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_gatorstar to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_gatorstar () from 'db_gatorstar.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_gatorstar
\p\g
create table db_index(
	dbrep_iid integer not null,
	dbrep_indextype smallint,
	dbrep_foreigntableiid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_index to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_index () from 'db_index.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_index
\p\g
create table db_indexcol(
	dbrep_indexiid integer not null,
	dbrep_columniid integer not null,
	dbrep_sequencenum integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_indexcol to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_indexcol () from 'db_indexcol.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_indexcol
\p\g
create table db_infoblob(
	dbrep_iid integer not null,
	dbrep_blob long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_infoblob to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_infoblob () from 'db_infoblob.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_infoblob
\p\g
create table db_layout(
	dbrep_iid integer not null,
	dbrep_normalizationlevel smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_layout to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_layout () from 'db_layout.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_layout
\p\g
create table db_object(
	dbrep_iid integer not null,
	dbrep_parentiid integer not null,
	dbrep_name varchar(255) not null,
	dbrep_status smallint not null,
	dbrep_version integer not null,
	dbrep_objecttype i1 not null,
	dbrep_description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_object to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_object () from 'db_object.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_object
\p\g
create table db_op(
	dbrep_iid integer not null,
	dbrep_optype integer,
	dbrep_owner varchar(128),
	dbrep_modifier varchar(128),
	dbrep_functionname varchar(128),
	dbrep_scriptname varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_op to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_op () from 'db_op.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_op
\p\g
create table db_opsegment(
	dbrep_iid integer not null,
	dbrep_opsegmenttype smallint,
	dbrep_isactive i1,
	dbrep_isscriptfunction i1,
	dbrep_scriptname varchar(127),
	dbrep_functionname varchar(128),
	dbrep_codeptr long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_opsegment to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_opsegment () from 'db_opsegment.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_opsegment
\p\g
create table db_parameter(
	dbrep_iid integer not null,
	dbrep_type varchar(127),
	dbrep_kind smallint,
	dbrep_sequencenum integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_parameter to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_parameter () from 'db_parameter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_parameter
\p\g
create table db_program(
	dbrep_iid integer not null,
	dbrep_executablename varchar(127),
	dbrep_location varchar(127),
	dbrep_lastexecution varchar(127),
	dbrep_rowsinserted integer,
	dbrep_rowsdeleted integer,
	dbrep_rowsupdated integer,
	dbrep_lastmodified varchar(30),
	dbrep_modifier varchar(127)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_program to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_program () from 'db_program.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_program
\p\g
create table db_programinstance(
	dbrep_iid integer not null,
	dbrep_version smallint,
	dbrep_left integer,
	dbrep_top integer,
	dbrep_right integer,
	dbrep_bottom integer,
	dbrep_proginsttype smallint,
	dbrep_executablename varchar(128),
	dbrep_location varchar(128),
	dbrep_lastexecution varchar(31),
	dbrep_userreturncode integer,
	dbrep_returncode integer,
	dbrep_runstatus integer,
	dbrep_programiid integer,
	dbrep_programtypeiid integer,
	dbrep_miscprogramtypeiid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_programinstance to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_programinstance () from 'db_programinstance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_programinstance
\p\g
create table db_programtype(
	dbrep_iid integer not null,
	dbrep_version smallint,
	dbrep_psafilename varchar(128),
	dbrep_psefilename varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_programtype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_programtype () from 'db_programtype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_programtype
\p\g
create table db_programtypemisc(
	dbrep_iid integer not null,
	dbrep_version smallint,
	dbrep_miscprogtype smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_programtypemisc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_programtypemisc () from 'db_programtypemisc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_programtypemisc
\p\g
create table db_psafile(
	dbrep_iid integer not null,
	dbrep_version smallint,
	dbrep_createtimestamp varchar(31)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_psafile to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_psafile () from 'db_psafile.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_psafile
\p\g
create table db_seqcolumn(
	dbrep_iid integer not null,
	dbrep_sync i1,
	dbrep_synctype smallint,
	dbrep_blankwhenzero i1,
	dbrep_signisseparate i1,
	dbrep_sign smallint,
	dbrep_justified smallint,
	dbrep_picture varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_seqcolumn to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_seqcolumn () from 'db_seqcolumn.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_seqcolumn
\p\g
create table db_seqtable(
	dbrep_iid integer not null,
	dbrep_aligned i1,
	dbrep_ibmcomp i1,
	dbrep_endian smallint,
	dbrep_mode smallint,
	dbrep_floatformat integer,
	dbrep_codepage integer,
	dbrep_location varchar(127),
	dbrep_generatorpath varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_seqtable to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_seqtable () from 'db_seqtable.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_seqtable
\p\g
create table db_servertype(
	dbrep_iid integer not null,
	dbrep_dbmsname varchar(255),
	dbrep_dbmsversion varchar(255),
	dbrep_accessmethod smallint,
	dbrep_levelssupported smallint,
	dbrep_type smallint,
	dbrep_dbmsmajorversion smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_servertype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_servertype () from 'db_servertype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_servertype
\p\g
create table db_star(
	dbrep_iid integer not null,
	dbrep_isflat i1,
	dbrep_isaggregated i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_star to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_star () from 'db_star.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_star
\p\g
create table db_startable(
	dbrep_stariid integer not null,
	dbrep_tableiid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_startable to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_startable () from 'db_startable.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_startable
\p\g
create table db_table(
	dbrep_iid integer not null,
	dbrep_tabletype smallint,
	dbrep_starrole integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_table to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_table () from 'db_table.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_table
\p\g
create table db_wkf(
	dbrep_iid integer not null,
	dbrep_version smallint,
	dbrep_psafilepath varchar(128),
	dbrep_pspfilepath varchar(128),
	dbrep_psefilepath varchar(128),
	dbrep_errhandlerwkfname varchar(255),
	dbrep_laststatus integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_wkf to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_wkf () from 'db_wkf.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_wkf
\p\g
create table db_wkfconnection(
	dbrep_iid integer not null,
	dbrep_version smallint,
	dbrep_conntype smallint,
	dbrep_srcproginstiid integer,
	dbrep_tgtproginstiid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify db_wkfconnection to heap
with extend = 16,
	allocation = 4
\p\g
/* copy db_wkfconnection () from 'db_wkfconnection.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on db_wkfconnection
\p\g
create table dbh_hist(
	seq_no decimal(31,0) not null,
	timestamp date not null,
	value decimal(31,5),
	text_value varchar(80)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dbh_hist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dbh_hist () from 'dbh_hist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dbh_hist
\p\g
create table dbh_key(
	seq_no decimal(31,0) not null,
	dbh_instance varchar(80) not null,
	name varchar(50) not null,
	sub_name varchar(80) not null,
	timestamp_first date,
	timestamp_last date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dbh_key to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dbh_key () from 'dbh_key.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dbh_key
\p\g
create table dcon(
	id integer not null,
	persid varchar(30),
	del integer not null,
	alias integer,
	last_mod integer,
	last_mod_by byte varying(16),
	dom_id integer not null,
	tbl_id integer not null,
	type integer not null,
	constraint_majic varchar(500),
	constraint_sql varchar(950),
	error_msg varchar(150)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify dcon to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy dcon () from 'dcon.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dcon
\p\g
create table dcon_typ(
	id integer not null,
	persid varchar(30),
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify dcon_typ to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy dcon_typ () from 'dcon_typ.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dcon_typ
\p\g
create table ddcolumn(
	ddtableid integer not null,
	ddcolumnname varchar(32) not null,
	ddcolumntype varchar(32) not null,
	ddcolumnnote varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ddcolumn to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ddcolumn () from 'ddcolumn.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ddcolumn
\p\g
create table ddtable(
	ddtableid integer not null,
	requestid integer,
	executionid integer,
	dduserid integer not null,
	ddproviderid integer not null,
	dddatabasename varchar(128),
	ddtablename varchar(128) not null,
	ddtablenote varchar(255),
	ddtablecreatetime date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ddtable to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ddtable () from 'ddtable.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ddtable
\p\g
create table ddtablemodify(
	requestid integer not null,
	executionid integer not null,
	ddtableproviderid integer,
	ddtablemodifytime date not null,
	ddtabledatabasename varchar(128),
	ddtablemodifyname varchar(128),
	ddtableuserid integer not null,
	ddnumrowsinserted integer,
	ddnumrowsupdated integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ddtablemodify to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ddtablemodify () from 'ddtablemodify.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ddtablemodify
\p\g
create table default_business_hours(
	day_name varchar(50) not null,
	start_time integer not null,
	end_time integer not null,
	created integer,
	created_by varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify default_business_hours to btree unique on
	day_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy default_business_hours () from 'default_business_hours.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on default_business_hours
\p\g
create table definitions(
	id varchar(20) not null,
	content long byte not null,
	name varchar(50) not null,
	shortname varchar(20) not null,
	modified float not null,
	description varchar(200)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify definitions to heap
with extend = 16,
	allocation = 4
\p\g
/* copy definitions () from 'definitions.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on definitions
\p\g
create table delete_list(
	qmgr_oid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify delete_list to heap
with extend = 16,
	allocation = 4
\p\g
/* copy delete_list () from 'delete_list.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on delete_list
\p\g
create table deletedjobs(
	instancename varchar(64) not null,
	jobname varchar(139) not null,
	triggertype varchar(9)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify deletedjobs to btree unique on
	instancename,
	jobname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy deletedjobs () from 'deletedjobs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on deletedjobs
\p\g
create table deliverable_state(
	product_instance_id decimal(31,0) not null,
	product_state_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify deliverable_state to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy deliverable_state () from 'deliverable_state.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on deliverable_state
\p\g
create table department(
	department_id decimal(31,0) not null,
	parent_dept_id decimal(31,0),
	department_code varchar(4000),
	department_name varchar(1200) not null,
	department_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify department to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy department () from 'department.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on department
\p\g
create table detection_profile(
	inventory_profile_id byte(16) not null,
	vuln_id byte(16) not null,
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify detection_profile to btree unique on
	inventory_profile_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy detection_profile () from 'detection_profile.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on detection_profile
\p\g
create table discovered_list(
	discovered_list_id byte(16) not null,
	ip_address nvarchar(15) not null,
	host_name nvarchar(255),
	qualified_domain_name nvarchar(255),
	operating_system nvarchar(100),
	date_discovered integer not null,
	manage_asset i1 not null,
	last_service_communication integer,
	source nvarchar(20),
	assigned_evm_ip_address nvarchar(15),
	ip_asset_status nvarchar(20) not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify discovered_list to btree unique on
	discovered_list_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy discovered_list () from 'discovered_list.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on discovered_list
\p\g
create table discoveryvariable(
	mibidx integer not null,
	typeid integer not null,
	oididxformib integer not null,
	discget c1 not null,
	discresplocation c1 not null,
	discrespvalue varchar(32) not null,
	oper c1 not null,
	description varchar(128) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify discoveryvariable to heap
with extend = 16,
	allocation = 4
\p\g
/* copy discoveryvariable () from 'discoveryvariable.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on discoveryvariable
\p\g
create integrity  ON DiscoveryVariable IS DiscGet IN ('G', 'N')
\p\g
create integrity  ON DiscoveryVariable IS DiscRespLocation IN ('V', 'O
')
\p\g
create integrity  ON DiscoveryVariable IS Oper IN ('=', '!', '<', '>')
\p\g
create table disp(
	dsa varchar(64) not null not default,
	id varchar(64) not null not default,
	updated varchar(15) not null not default,
	disabled integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify disp to btree unique on
	dsa,
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy disp () from 'disp.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on disp
\p\g
create table dispmoddn(
	updated varchar(15) not null not default,
	eid integer not null not default,
	parent integer not null not default,
	newparent integer not null not default,
	oldraw varchar(129) not null not default,
	raw varchar(129) not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dispmoddn to btree unique on
	updated,
	eid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy dispmoddn () from 'dispmoddn.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dispmoddn
\p\g
create table dit(
	parent integer not null not default,
	rdnkey integer not null not default,
	eid integer not null not default,
	rdn varchar(106) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dit to btree unique on
	rdnkey,
	parent,
	eid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy dit () from 'dit.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dit
\p\g
create table dlgtsrv(
	id integer not null,
	del integer not null,
	sym varchar(64) not null,
	nx_desc varchar(40),
	server varchar(128),
	metafile varchar(256),
	transport integer,
	default_assignee byte varying(16),
	appl_addr varchar(48),
	password varchar(16),
	default_userid varchar(8),
	anon_userid varchar(8)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify dlgtsrv to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy dlgtsrv () from 'dlgtsrv.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dlgtsrv
\p\g
create table dmn(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	nx_desc varchar(40),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify dmn to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy dmn () from 'dmn.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dmn
\p\g
create table doc_rep(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	default_rep integer,
	description varchar(500),
	repository_type integer,
	file_limit_size integer,
	prohibited_ext varchar(500),
	protocol varchar(12),
	server varchar(30),
	cgi_path varchar(255),
	upload_path varchar(255),
	retrieve_path varchar(255),
	last_mod_dt integer,
	archive_type integer,
	archive_path varchar(255),
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify doc_rep to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy doc_rep () from 'doc_rep.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on doc_rep
\p\g
create table documentation(
	prod char(4) not null,
	id varchar(57) not null,
	type smallint not null,
	text long varchar not null,
	summary varchar(80) not null,
	crt_date integer not null,
	crt_time integer not null,
	crt_id varchar(32) not null,
	upd_date integer not null,
	upd_time integer not null,
	upd_id varchar(32) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify documentation to btree unique on
	prod,
	id,
	type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy documentation () from 'documentation.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on documentation
\p\g
create table dominoeventtype(
	dominoeventtypeid integer not null,
	dominoeventtypename char(254) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dominoeventtype to btree unique on
	dominoeventtypeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy dominoeventtype () from 'dominoeventtype.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dominoeventtype
\p\g
create integrity  ON DominoEventType IS DominoEventTypeID IN (0, 1, 2,
3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 
22, 23)
\p\g
create table dominologeventtype(
	dominologeventtypeid integer not null,
	dominologeventtypename char(254) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dominologeventtype to btree unique on
	dominologeventtypeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy dominologeventtype () from 'dominologeventtype.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on dominologeventtype
\p\g
create integrity  ON DominoLogEventType IS DominoLogEventTypeID IN (1,
2, 3, 4)
\p\g
create table dts_dbversion(
	proplabel nvarchar(20),
	propvalue nvarchar(10)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dts_dbversion to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dts_dbversion () from 'dts_dbversion.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dts_dbversion
\p\g
create table dts_dtfilter(
	object_id integer not null,
	name nvarchar(10),
	label nvarchar(100),
	description nvarchar(150),
	user_data1 nvarchar(255),
	user_data2 nvarchar(255),
	permanent_filter nchar(1),
	reserved nchar(1),
	filter_type nvarchar(12),
	filter_path nvarchar(300),
	endec_key nvarchar(70),
	endec_algid integer,
	filter_op integer,
	filter_datatype integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify dts_dtfilter to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy dts_dtfilter () from 'dts_dtfilter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dts_dtfilter
\p\g
create table dts_dtsubscribers(
	object_id byte(16) not null,
	name nvarchar(100),
	description nvarchar(150),
	user_data1 nvarchar(255),
	user_data2 nvarchar(255),
	agent_version nvarchar(15),
	agent_installed nchar(1),
	nos_installed nchar(1),
	tos_installed nchar(1),
	sos_installed nchar(1),
	update_time integer,
	dis_hw_uuid byte(16)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dts_dtsubscribers to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dts_dtsubscribers () from 'dts_dtsubscribers.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dts_dtsubscribers
\p\g
create table dts_dttransfer(
	object_id integer not null,
	name nvarchar(10),
	label nvarchar(100),
	description nvarchar(150),
	user_data1 nvarchar(255),
	user_data2 nvarchar(255),
	max_parcel_size integer,
	session_retry_interval integer,
	start_time integer,
	end_time integer,
	restart_time integer,
	total_parcels integer,
	no_parcels_xferd integer,
	session_retry_limit integer,
	session_retry_count integer,
	flags integer,
	failure_code integer,
	throttle_factor integer,
	license_code integer,
	bytes_transferred integer,
	alternative_routes integer,
	alternative_routes_count integer,
	discreet_delivery_period integer,
	discreet_expiry_period integer,
	auto_resume nchar(1),
	ckp_restart nchar(1),
	commit_to_disk nchar(1),
	direction nchar(1),
	default_tob nchar(1),
	output_mode nchar(1),
	delconv nchar(1),
	i_use_trust nchar(1),
	r_use_trust nchar(1),
	trusted_user nchar(1),
	update_uuid_from_nos nchar(1),
	input nvarchar(255),
	output nvarchar(255),
	initiator nvarchar(50),
	responder nvarchar(50),
	initiator_naddr nvarchar(50),
	responder_naddr nvarchar(50),
	originator_naddr nvarchar(50),
	initiator_sec_token nvarchar(100),
	responder_sec_token nvarchar(100),
	p2m_naddr nvarchar(50),
	originator nvarchar(50),
	owner_name nvarchar(50),
	hop_pos nvarchar(10),
	hop_file nvarchar(45),
	parent nvarchar(10),
	next_tob nvarchar(10),
	root_id nvarchar(10),
	group_id nvarchar(10),
	fanout_protocol nvarchar(32),
	p2p_protocol nvarchar(32),
	p2m_protocol nvarchar(32),
	appl_id nvarchar(80),
	state nvarchar(20),
	state_further_info nvarchar(40),
	transfer_type nvarchar(16),
	dta_id nvarchar(18),
	osname nvarchar(16),
	initiator_priority nvarchar(10),
	responder_priority nvarchar(10),
	originator_uuid nvarchar(40),
	initiator_uuid nvarchar(40),
	responder_uuid nvarchar(40),
	i_notify nchar(1),
	r_notify nchar(1),
	udt_mechanism nvarchar(40),
	route_resolution nchar(1),
	udt_cam_queue_name nvarchar(40),
	udt_cam_queue_location nvarchar(40),
	responder_uasset_uuid nvarchar(40),
	initiator_uasset_uuid nvarchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify dts_dttransfer to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy dts_dttransfer () from 'dts_dttransfer.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dts_dttransfer
\p\g
create table dts_dttransfergroup(
	object_id integer not null,
	name nvarchar(10),
	label nvarchar(100),
	description nvarchar(150),
	user_data1 nvarchar(255),
	user_data2 nvarchar(255),
	start_time integer,
	end_time integer,
	restart_time integer,
	total_parcels integer,
	no_parcels_xferd integer,
	bytes_transferred integer,
	session_retry_limit integer,
	session_retry_interval integer,
	flags integer,
	tos_retry_limit integer,
	tos_retry_count integer,
	tos_retry_interval integer,
	alternative_routes integer,
	discreet_delivery_period integer,
	discreet_expiry_period integer,
	initiator_sec_token nvarchar(50),
	responder_sec_token nvarchar(50),
	owner_name nvarchar(50),
	sequential nchar(1),
	propagate nchar(1),
	ckp_restart nchar(1),
	commit_to_disk nchar(1),
	initiator_priority nvarchar(10),
	responder_priority nvarchar(10),
	implementation nvarchar(40),
	state nvarchar(20),
	appl_id nvarchar(80),
	originator_uuid nvarchar(40),
	multi_group_limit integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify dts_dttransfergroup to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy dts_dttransfergroup () from 'dts_dttransfergroup.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dts_dttransfergroup
\p\g
create table dts_dtversion(
	object_id integer not null,
	name nvarchar(10),
	label nvarchar(100),
	description nvarchar(150),
	user_data1 nvarchar(255),
	user_data2 nvarchar(255),
	version_number nvarchar(10)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dts_dtversion to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dts_dtversion () from 'dts_dtversion.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dts_dtversion
\p\g
create table dts_torproperties(
	object_id integer not null,
	row_num integer not null,
	object_data nvarchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dts_torproperties to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dts_torproperties () from 'dts_torproperties.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dts_torproperties
\p\g
create table dynamic_worklist(
	groupname varchar(50) not null,
	users varchar(250) not null,
	processid varchar(20) not null default '',
	activityname varchar(30) not null default '',
	activitydesc varchar(200) default NULL,
	processname varchar(30) not null default '',
	label varchar(30),
	operation long byte not null,
	activated float default NULL,
	completed float default NULL,
	duedate float default NULL,
	activityid varchar(20) default NULL,
	workitemid varchar(30) default NULL,
	executionid varchar(30) default NULL
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify dynamic_worklist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy dynamic_worklist () from 'dynamic_worklist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on dynamic_worklist
\p\g
create table e2e_alert(
	trans_id integer,
	trans_state i1,
	gmt_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_alert to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_alert () from 'e2e_alert.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_application(
	app_id integer not null,
	app_name varchar(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_application to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_application () from 'e2e_application.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_appop_ref(
	app_id integer not null,
	op_id integer not null,
	app_name varchar(64) not null,
	op_name varchar(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_appop_ref to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_appop_ref () from 'e2e_appop_ref.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_client(
	client_id integer not null,
	client_name varchar(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_client to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_client () from 'e2e_client.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_group(
	group_name varchar(64) not null,
	host_name varchar(64) not null,
	host_class varchar(32),
	host_ip varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_group to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_group () from 'e2e_group.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_group_update(
	group_name varchar(255) not null,
	last_updated date not null,
	members_count integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_group_update to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_group_update () from 'e2e_group_update.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_host(
	host_id integer not null,
	host_name varchar(64) not null,
	mac_address varchar(14) not null,
	mach_type varchar(20) not null,
	local_name varchar(64) not null,
	host_resolved integer not null,
	ip varchar(20) not null,
	os varchar(32) not null,
	aro_server varchar(50) not null,
	last_contact integer not null,
	startup_time integer not null,
	file_version integer not null,
	thresh_version integer not null,
	remark varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_host to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_host () from 'e2e_host.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_net_subs(
	parents_trans integer not null,
	query char(255),
	query_type char(64),
	duration float,
	server_name char(32),
	server_ip char(16),
	server_port smallint,
	packets integer,
	bytes integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_net_subs to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_net_subs () from 'e2e_net_subs.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_operation(
	op_id integer not null,
	op_name varchar(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_operation to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_operation () from 'e2e_operation.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_resp_data(
	trans_id integer not null,
	app_id integer not null,
	op_id integer not null,
	host_id integer not null,
	client_id integer not null,
	user_id integer not null,
	server_id integer not null,
	start_datetime date not null,
	gmt_datetime date not null,
	local_time integer not null,
	local_date integer not null,
	gmt_time integer not null,
	gmt_date integer not null,
	duration float not null,
	local_dur float not null,
	wire_dur float not null,
	server_dur float not null,
	num_complete integer not null,
	num_cancelled integer not null,
	num_exception integer not null,
	delta_threshold float not null,
	cpu_util integer not null,
	mem_util integer not null,
	net_global integer not null,
	net_total integer not null,
	packet_loss integer,
	source_id smallint,
	old_data i1 not null,
	trans_cached i1,
	trans_wellness i1,
	exception_threshold integer,
	trans_detail varchar(255),
	trans_title varchar(255),
	old_hourly i1 not null,
	old_daily i1 not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_resp_data to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_resp_data () from 'e2e_resp_data.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_resp_data_day(
	trans_id integer not null,
	app_id integer not null,
	op_id integer not null,
	host_id integer not null,
	client_id integer not null,
	user_id integer not null,
	server_id integer not null,
	start_datetime date not null,
	gmt_datetime date not null,
	local_time integer not null,
	local_date integer not null,
	gmt_time integer not null,
	gmt_date integer not null,
	duration float not null,
	local_dur float not null,
	wire_dur float not null,
	server_dur float not null,
	num_complete integer not null,
	num_cancelled integer not null,
	num_exception integer not null,
	delta_threshold float not null,
	cpu_util integer not null,
	mem_util integer not null,
	net_global integer not null,
	net_total integer not null,
	packet_loss integer,
	source_id smallint,
	old_data i1 not null,
	trans_cached i1,
	trans_wellness i1,
	exception_threshold integer,
	trans_detail varchar(255),
	trans_title varchar(255),
	old_hourly i1 not null,
	old_daily i1 not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_resp_data_day to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_resp_data_day () from 'e2e_resp_data_day.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_resp_data_hour(
	trans_id integer not null,
	app_id integer not null,
	op_id integer not null,
	host_id integer not null,
	client_id integer not null,
	user_id integer not null,
	server_id integer not null,
	start_datetime date not null,
	gmt_datetime date not null,
	local_time integer not null,
	local_date integer not null,
	gmt_time integer not null,
	gmt_date integer not null,
	duration float not null,
	local_dur float not null,
	wire_dur float not null,
	server_dur float not null,
	num_complete integer not null,
	num_cancelled integer not null,
	num_exception integer not null,
	delta_threshold float not null,
	cpu_util integer not null,
	mem_util integer not null,
	net_global integer not null,
	net_total integer not null,
	packet_loss integer,
	source_id smallint,
	old_data i1 not null,
	trans_cached i1,
	trans_wellness i1,
	exception_threshold integer,
	trans_detail varchar(255),
	trans_title varchar(255),
	old_hourly i1 not null,
	old_daily i1 not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_resp_data_hour to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_resp_data_hour () from 'e2e_resp_data_hour.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_server(
	server_id integer not null,
	server_name varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_server to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_server () from 'e2e_server.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_settings(
	variable varchar(255),
	value varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_settings to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_settings () from 'e2e_settings.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_sla(
	app_id integer not null,
	op_id integer not null,
	th_value float not null,
	sec_thresh_count integer not null,
	sec_thresh_time integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_sla to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_sla () from 'e2e_sla.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_temp_data(
	trans_id integer not null,
	app_id integer not null,
	op_id integer not null,
	host_id integer not null,
	client_id integer not null,
	user_id integer not null,
	server_id integer not null,
	start_datetime date not null,
	gmt_datetime date not null,
	local_time integer not null,
	local_date integer not null,
	gmt_time integer not null,
	gmt_date integer not null,
	duration float not null,
	local_dur float not null,
	wire_dur float not null,
	server_dur float not null,
	num_complete integer not null,
	num_cancelled integer not null,
	num_exception integer not null,
	delta_threshold float not null,
	cpu_util integer not null,
	mem_util integer not null,
	net_global integer not null,
	net_total integer not null,
	packet_loss integer,
	source_id smallint,
	old_data i1 not null,
	trans_cached i1,
	trans_wellness i1,
	exception_threshold integer,
	trans_detail varchar(255),
	trans_title varchar(255),
	old_hourly i1,
	old_daily i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_temp_data to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_temp_data () from 'e2e_temp_data.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_threshold(
	app_id integer not null,
	op_id integer not null,
	host_id integer not null,
	th_type integer,
	th_value float not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_threshold to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_threshold () from 'e2e_threshold.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table e2e_user(
	user_id integer,
	user_name varchar(64)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify e2e_user to heap
with extend = 16,
	allocation = 4
\p\g
/* copy e2e_user () from 'e2e_user.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table ebr_acronyms(
	id integer not null,
	acronym varchar(50),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_acronyms to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_acronyms () from 'ebr_acronyms.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_acronyms
\p\g
create table ebr_fulltext(
	id integer not null,
	entity_id integer,
	table_id integer,
	full_word varchar(50),
	full_word_reverse varchar(50),
	short_word varchar(50),
	word_type integer,
	word_order integer,
	word_idf integer,
	word_count integer,
	word_count_title integer,
	word_count_summary integer,
	word_count_problem integer,
	word_count_resolution integer,
	permission_index_id integer,
	product varchar(50),
	doc_type integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_fulltext to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_fulltext () from 'ebr_fulltext.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_fulltext
\p\g
create table ebr_fulltext_adm(
	id integer not null,
	entity_id integer,
	table_id integer,
	full_word varchar(50),
	full_word_reverse varchar(50),
	short_word varchar(50),
	word_type integer,
	word_order integer,
	word_idf integer,
	word_count integer,
	word_count_title integer,
	word_count_summary integer,
	word_count_problem integer,
	word_count_resolution integer,
	permission_index_id integer,
	product varchar(50),
	doc_type integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_fulltext_adm to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_fulltext_adm () from 'ebr_fulltext_adm.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_fulltext_adm
\p\g
create table ebr_fulltext_sd(
	id integer not null,
	entity_id integer,
	table_id integer,
	full_word varchar(50),
	full_word_reverse varchar(50),
	short_word varchar(50),
	word_type integer,
	word_order integer,
	word_idf integer,
	word_count integer,
	word_count_title integer,
	word_count_summary integer,
	word_count_problem integer,
	word_count_resolution integer,
	permission_index_id integer,
	product varchar(50),
	doc_type integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_fulltext_sd to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_fulltext_sd () from 'ebr_fulltext_sd.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_fulltext_sd
\p\g
create table ebr_fulltext_sd_adm(
	id integer not null,
	entity_id integer,
	table_id integer,
	full_word varchar(50),
	full_word_reverse varchar(50),
	short_word varchar(50),
	word_type integer,
	word_order integer,
	word_idf integer,
	word_count integer,
	word_count_title integer,
	word_count_summary integer,
	word_count_problem integer,
	word_count_resolution integer,
	permission_index_id integer,
	product varchar(50),
	doc_type integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_fulltext_sd_adm to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_fulltext_sd_adm () from 'ebr_fulltext_sd_adm.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_fulltext_sd_adm
\p\g
create table ebr_indexing_queue(
	id integer not null,
	action integer,
	action_date integer,
	indexed integer,
	priority integer,
	obj_persid varchar(30),
	text long varchar
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_indexing_queue to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_indexing_queue () from 'ebr_indexing_queue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_indexing_queue
\p\g
create table ebr_keywords(
	id integer not null,
	entity_id integer,
	ext_table_id integer,
	full_word varchar(50)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_keywords to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_keywords () from 'ebr_keywords.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_keywords
\p\g
create table ebr_log(
	id integer not null,
	search_text varchar(255),
	search_quality integer,
	num_matches integer,
	top_match_id integer,
	user_id varchar(100),
	asked_date integer,
	search_type integer,
	external_id varchar(50),
	method_type integer,
	method_performance integer,
	fuzziness integer,
	match_type integer,
	search_in integer,
	primary_order varchar(50),
	secondary_order integer,
	order_direction integer,
	rows_to_fetch integer,
	rows_found integer,
	status integer,
	workflow_priority integer,
	document_type integer,
	user_defined_id varchar(40),
	owner varchar(93),
	author varchar(93),
	subject_expert varchar(93),
	priority integer,
	severity integer,
	product varchar(60),
	affected_asset varchar(64),
	root_cause varchar(60),
	impact integer,
	urgency integer,
	keywords long varchar,
	sql_text long varchar
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_log to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_log () from 'ebr_log.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_log
\p\g
create table ebr_metrics(
	id integer not null,
	metric varchar(50),
	weight float,
	comments varchar(255)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_metrics to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_metrics () from 'ebr_metrics.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_metrics
\p\g
create table ebr_noise_words(
	id integer not null,
	noise_word varchar(50),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_noise_words to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_noise_words () from 'ebr_noise_words.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_noise_words
\p\g
create table ebr_patterns(
	id integer not null,
	pattern_name varchar(50),
	pattern_default varchar(255),
	pattern_value varchar(255),
	pattern_value_adm varchar(255)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_patterns to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_patterns () from 'ebr_patterns.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_patterns
\p\g
create table ebr_prefixes(
	id integer not null,
	prefix varchar(50)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_prefixes to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_prefixes () from 'ebr_prefixes.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_prefixes
\p\g
create table ebr_properties(
	id integer not null,
	property_name varchar(50),
	property_type varchar(50),
	property_admin integer,
	property_default varchar(50),
	property_value long varchar,
	property_value_adm long varchar
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_properties to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_properties () from 'ebr_properties.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_properties
\p\g
create table ebr_substits(
	id integer not null,
	symbol1 varchar(50),
	symbol2 varchar(50)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_substits to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_substits () from 'ebr_substits.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_substits
\p\g
create table ebr_suffixes(
	id integer not null,
	suffix varchar(50)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_suffixes to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_suffixes () from 'ebr_suffixes.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_suffixes
\p\g
create table ebr_synonyms(
	id integer not null,
	keyword1 varchar(50),
	keyword2 varchar(50),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_synonyms to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_synonyms () from 'ebr_synonyms.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_synonyms
\p\g
create table ebr_synonyms_adm(
	id integer not null,
	keyword1 varchar(50),
	keyword2 varchar(50),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ebr_synonyms_adm to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ebr_synonyms_adm () from 'ebr_synonyms_adm.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ebr_synonyms_adm
\p\g
create table eccm_actionlog(
	key1 integer not null,
	key2 integer not null,
	chrono1 integer not null,
	chrono2 integer not null,
	log_type smallint not null,
	seq smallint not null,
	log_text byte(1900)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify eccm_actionlog to btree unique on
	key1,
	key2,
	chrono1,
	chrono2,
	log_type,
	seq
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy eccm_actionlog () from 'eccm_actionlog.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on eccm_actionlog
\p\g
create table eccm_configuration(
	eccm_configurationid integer not null,
	provider_name char(20) not null,
	product_code integer not null,
	provider_number integer not null,
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify eccm_configuration to btree unique on
	eccm_configurationid,
	provider_name,
	product_code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy eccm_configuration () from 'eccm_configuration.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on eccm_configuration
\p\g
create table eccm_log(
	key1 integer not null,
	key2 integer not null,
	chrono1 integer not null,
	chrono2 integer not null,
	log_type smallint not null,
	seq smallint not null,
	log_datetime date not null,
	severity_level integer not null,
	log_text byte(133),
	actionlog_url char(100)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify eccm_log to btree unique on
	key1,
	key2,
	chrono1,
	chrono2,
	log_type,
	seq
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy eccm_log () from 'eccm_log.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on eccm_log
\p\g
create table eccm_user(
	eccmuserid integer not null,
	userid integer not null,
	eccm_configurationid integer not null,
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify eccm_user to btree unique on
	eccmuserid,
	userid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy eccm_user () from 'eccm_user.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on eccm_user
\p\g
create table efficiency(
	efficiency_id decimal(31,0) not null,
	opruid decimal(31,0),
	efficiency_name varchar(4000) not null,
	efficiency_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify efficiency to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy efficiency () from 'efficiency.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on efficiency
\p\g
create table efficiency_metric(
	expertise_modifier integer not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify efficiency_metric to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy efficiency_metric () from 'efficiency_metric.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on efficiency_metric
\p\g
create table emailaction(
	actionid integer not null,
	fromaddress varchar(50),
	toaddress varchar(50),
	ccaddress varchar(50),
	bccaddress varchar(50),
	template varchar(50),
	subject varchar(200)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify emailaction to btree unique on
	actionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy emailaction () from 'emailaction.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on emailaction
\p\g
create table emc_menu_item(
	emc_menu_id decimal(31,0) not null,
	emc_menu_name varchar(1200) not null,
	emc_menu_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify emc_menu_item to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy emc_menu_item () from 'emc_menu_item.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on emc_menu_item
\p\g
create table emevt_mib(
	name varchar(100),
	enabled smallint,
	vendor varchar(250),
	nameoffile varchar(250),
	description varchar(250),
	internalversion varchar(250),
	lastmodified integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify emevt_mib to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy emevt_mib () from 'emevt_mib.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on emevt_mib
\p\g
create table emevt_trap(
	eid varchar(250),
	generic integer,
	specific integer,
	alarmtype integer,
	alarmname varchar(250),
	format varchar(250),
	formatattr integer,
	args varchar(250),
	severity char(3),
	mibname varchar(100),
	enabled smallint,
	modified integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify emevt_trap to btree unique on
	eid,
	generic,
	specific
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy emevt_trap () from 'emevt_trap.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on emevt_trap
\p\g
create table engine_config(
	name varchar(32) not null,
	sequence i1,
	job_name varchar(32),
	engine_type varchar(8),
	xml_config varchar(1950)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify engine_config to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy engine_config () from 'engine_config.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on engine_config
\p\g
create table enterprise_calendar(
	enterprise_calendar_id decimal(31,0) not null,
	occurence_date date not null,
	project_id decimal(31,0),
	description varchar(4000) not null,
	exception_hrs_per_day float,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify enterprise_calendar to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy enterprise_calendar () from 'enterprise_calendar.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on enterprise_calendar
\p\g
create table enterprise_package(
	ep_id integer not null,
	ep_name char(40) not null,
	eccm_configurationid integer not null,
	submitting_eccmuserid integer not null,
	ep_lastaction integer not null,
	ep_executionstate integer not null,
	ep_executionstatus integer not null,
	comments char(80),
	ep_executionwindowbegin date not null,
	ep_executionwindowend date not null,
	ep_executionstart date not null,
	ep_executionfinish date not null,
	datetime_updated date not null,
	chrono1 integer not null,
	chrono2 integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify enterprise_package to btree unique on
	ep_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy enterprise_package () from 'enterprise_package.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on enterprise_package
\p\g
create table enterprise_package_history(
	ep_id integer not null,
	chrono1 integer not null,
	chrono2 integer not null,
	action_datetime date not null,
	action integer not null,
	enterprise_package_name char(40),
	product_name char(60),
	provider_name char(20),
	usernames char(40) not null,
	product_package_name char(60)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify enterprise_package_history to btree unique on
	ep_id,
	chrono1,
	chrono2
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy enterprise_package_history () from 'enterprise_package_history.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on enterprise_package_history
\p\g
create table enterprise_package_subpackage(
	sp_id integer not null,
	ep_id integer not null,
	product_code integer not null,
	provider_name char(20),
	product_packageid integer not null,
	product_package_name char(60),
	sp_priority integer not null,
	sp_lastaction integer not null,
	sp_executionstate integer not null,
	sp_executionstatus integer not null,
	comments char(80),
	sp_executionstart date not null,
	sp_executionfinish date not null,
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify enterprise_package_subpackage to btree unique on
	sp_id,
	ep_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy enterprise_package_subpackage () from 'enterprise_package_subpackage.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on enterprise_package_subpackage
\p\g
create table entry(
	eid integer not null not default,
	aid smallint not null not default,
	vid smallint not null not default,
	raw varchar(115) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify entry to btree unique on
	eid,
	aid,
	vid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy entry () from 'entry.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on entry
\p\g
create table epd_job_details(
	id integer not null,
	parent_id integer not null,
	parent_type integer not null,
	log_pathname varchar(1024),
	src_server varchar(256) not null,
	gcs_id integer,
	tgt_dbms_vers integer not null,
	tgt_server varchar(256),
	src_server_type varchar(30) not null,
	recovery_strat_id integer not null,
	dscript_pathname varchar(1024),
	dunload_pathname varchar(1024),
	rscript_pathname varchar(1024),
	runload_pathname varchar(1024),
	strategy_id integer not null,
	strategy_type integer not null,
	report_pathname varchar(1024),
	tgt_server_type varchar(30) not null,
	sync_point varchar(30),
	anal_machine varchar(256),
	encrypt_src_login varchar(255),
	encrypt_tgt_login varchar(255),
	attrex_id integer,
	map_id integer,
	options1 integer,
	options2 integer,
	options3 integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify epd_job_details to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy epd_job_details () from 'epd_job_details.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on epd_job_details
\p\g
create table eproduct(
	oid integer not null,
	product_name varchar(250) not null,
	major_version integer not null,
	minor_version integer not null,
	patch_level varchar(254)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify eproduct to heap
with extend = 16,
	allocation = 4
\p\g
/* copy eproduct () from 'eproduct.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on eproduct
\p\g
create table error(
	requestid integer not null,
	executionid integer not null,
	errororder integer not null,
	errorcode integer not null,
	errormessage varchar(255) not null,
	errorseverity integer not null,
	errortime date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify error to heap
with extend = 16,
	allocation = 4
\p\g
/* copy error () from 'error.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on error
\p\g
create table errormessage(
	errormessageid integer not null,
	messagetext varchar(255) not null,
	sourcetype integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify errormessage to btree unique on
	errormessageid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy errormessage () from 'errormessage.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on errormessage
\p\g
create integrity  ON ErrorMessage IS ErrorMessageID >= 1
\p\g
create integrity  ON ErrorMessage IS SourceType >= 1
\p\g
create table errorsolution(
	errormessageid integer not null,
	solutiondescriptionid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify errorsolution to btree unique on
	errormessageid,
	solutiondescriptionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy errorsolution () from 'errorsolution.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on errorsolution
\p\g
create integrity  ON ErrorSolution IS ErrorMessageID >= 1
\p\g
create integrity  ON ErrorSolution IS SolutionDescriptionID >= 1
\p\g
create table es_constants(
	id integer not null,
	propertyid integer,
	name varchar(50),
	propvalue integer,
	comments varchar(255),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify es_constants to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy es_constants () from 'es_constants.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on es_constants
\p\g
create table es_nodes(
	id integer not null,
	node_id integer,
	tree_id integer,
	parent_node_id integer,
	root_id integer,
	link_id integer,
	node_type integer,
	node_short_desc varchar(150),
	query_resp_type varchar(50),
	query_resp_number integer,
	resplinkid1 integer,
	resplinkid2 integer,
	resplinkid3 integer,
	resplinkid4 integer,
	resplinkid5 integer,
	resplinkid6 integer,
	resplinkid7 integer,
	response1 varchar(100),
	response2 varchar(100),
	response3 varchar(100),
	response4 varchar(100),
	response5 varchar(100),
	response6 varchar(100),
	response7 varchar(100),
	displayed_text long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify es_nodes to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy es_nodes () from 'es_nodes.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on es_nodes
\p\g
create table es_responses(
	id integer not null,
	parent_node_id integer,
	response_link_id integer,
	response_link_text varchar(100),
	response_link_order integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify es_responses to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy es_responses () from 'es_responses.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on es_responses
\p\g
create table es_sessions(
	id integer not null,
	session_id integer,
	tree_id integer,
	external_id varchar(50),
	path_ids varchar(50),
	evaluation integer,
	comment_text varchar(50),
	path_qas long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify es_sessions to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy es_sessions () from 'es_sessions.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on es_sessions
\p\g
create table estimating_method(
	estimating_method_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	formula_id decimal(31,0),
	metric_id decimal(31,0),
	reference_id varchar(120),
	alt_ref_id varchar(120),
	estimating_method_name varchar(1200) not null,
	estimating_method_description varchar(4000),
	generic integer,
	ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify estimating_method to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy estimating_method () from 'estimating_method.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on estimating_method
\p\g
create table event0(
	eoid varchar(32),
	priority integer,
	event_time_gmt integer,
	evt_num integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify event0 to btree unique on
	priority,
	event_time_gmt
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy event0 () from 'event0.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on event0
\p\g
create table event2(
	eoid varchar(32),
	joid integer,
	job_name varchar(64),
	box_name varchar(64),
	autoserv varchar(30),
	priority integer,
	event integer,
	status integer,
	alarm integer,
	event_time_gmt integer,
	exit_code integer,
	machine varchar(80),
	pid integer,
	jc_pid integer,
	run_num integer,
	ntry integer,
	text varchar(255),
	que_priority integer,
	stamp date,
	evt_num integer,
	que_status integer,
	que_status_stamp date,
	counter varchar(7)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify event2 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy event2 () from 'event2.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on event2
\p\g
create table event_alert_log(
	time_stamp integer not null,
	neugent_instance varchar(50) not null,
	pattern_label varchar(255) not null,
	output_feature varchar(50),
	operator varchar(4),
	limit float,
	value float,
	description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify event_alert_log to heap
with extend = 16,
	allocation = 4
\p\g
/* copy event_alert_log () from 'event_alert_log.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on event_alert_log
\p\g
create table event_categories(
	event_category_oid varchar(20) not null,
	name varchar(50),
	description varchar(255),
	exporter_oid varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify event_categories to btree unique on
	event_category_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy event_categories () from 'event_categories.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on event_categories
\p\g
create table event_category_values(
	event_category_value_oid varchar(20) not null,
	event_category_oid varchar(20),
	description varchar(255),
	value varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify event_category_values to btree unique on
	event_category_value_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy event_category_values () from 'event_category_values.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on event_category_values
\p\g
create table event_log(
	id integer not null,
	log_time integer,
	millitime integer,
	event integer,
	"session" integer,
	kd_id integer,
	sd_obj_type varchar(30),
	sd_obj_id integer,
	numdata1 integer,
	numdata2 integer,
	textdata1 varchar(500),
	textdata2 varchar(500)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify event_log to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy event_log () from 'event_log.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on event_log
\p\g
create table event_type(
	id integer not null,
	persid varchar(30),
	code varchar(12) not null,
	description varchar(500),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify event_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy event_type () from 'event_type.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on event_type
\p\g
create table event_type_performance(
	time_stamp integer,
	neugent_instance varchar(50),
	output_feature varchar(256),
	total_percent_correct decimal(5,2),
	event_percent_correct decimal(5,2),
	no_event_percent_correct decimal(5,2)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify event_type_performance to heap
with extend = 16,
	allocation = 4
\p\g
/* copy event_type_performance () from 'event_type_performance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on event_type_performance
\p\g
create table eventlog(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strhost varchar(255) not null,
	strviewer varchar(255) not null,
	strremoteuser varchar(255) not null,
	strdescription varchar(255) not null,
	datetimestamp date not null,
	iduration integer not null,
	ieventid integer not null,
	iseverity integer not null,
	iencryption integer not null,
	strprotocol varchar(32) not null,
	ireasonsessionwasclosed integer not null,
	icategory integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify eventlog to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy eventlog () from 'eventlog.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on eventlog
\p\g
create table eventseverity(
	eventseverityid integer not null,
	eventseverityname varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify eventseverity to btree unique on
	eventseverityid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy eventseverity () from 'eventseverity.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on eventseverity
\p\g
create integrity  ON EventSeverity IS EventSeverityID >= 1
\p\g
create table eventtype(
	eventtypeid integer not null,
	eventtypename varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify eventtype to btree unique on
	eventtypeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy eventtype () from 'eventtype.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on eventtype
\p\g
create integrity  ON EventType IS EventTypeID IN (1, 2, 3, 4)
\p\g
create table evm_appliance_configuration(
	unit_id byte(16) not null,
	auto_create_discovered_assets i1,
	uses_auto_inventory i1,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify evm_appliance_configuration to btree unique on
	unit_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy evm_appliance_configuration () from 'evm_appliance_configuration.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on evm_appliance_configuration
\p\g
create table evm_company(
	company_uuid byte(16) not null,
	authentication_user_name nvarchar(64),
	authentication_password nvarchar(20),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify evm_company to btree unique on
	company_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy evm_company () from 'evm_company.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on evm_company
\p\g
create table evm_discovered_hardware(
	dis_hw_uuid byte(16) not null,
	name nvarchar(255) not null,
	ip_address nvarchar(15) not null,
	primary_subnet_mask nvarchar(15),
	description long nvarchar,
	location long nvarchar,
	is_inventory_managed i1,
	asset_group_id byte(16) not null,
	vm_service_version_number nvarchar(20),
	last_inventory_report_date integer,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify evm_discovered_hardware to btree unique on
	dis_hw_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy evm_discovered_hardware () from 'evm_discovered_hardware.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on evm_discovered_hardware
\p\g
create table evm_discovered_software(
	dis_sw_uuid byte(16) not null,
	is_evm_managed i1,
	is_ignored_by_impact_analysis i1,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify evm_discovered_software to btree unique on
	dis_sw_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy evm_discovered_software () from 'evm_discovered_software.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on evm_discovered_software
\p\g
create table evm_message_center_message(
	"message" nvarchar(64),
	type nvarchar(20),
	source nvarchar(20),
	keyword_classification nvarchar(50),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify evm_message_center_message to heap
with extend = 16,
	allocation = 4
\p\g
/* copy evm_message_center_message () from 'evm_message_center_message.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on evm_message_center_message
\p\g
create table evt(
	id integer not null,
	persid varchar(30),
	del integer not null,
	last_mod_dt integer,
	sym varchar(30) not null,
	description varchar(80),
	obj_type varchar(30),
	condition varchar(30),
	urgency integer,
	work_shift varchar(30),
	delay_time integer not null,
	modulo_time integer not null,
	user_settime integer not null,
	on_done_flag integer not null,
	user_smag varchar(200),
	violate_on_true integer,
	violate_on_false integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify evt to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy evt () from 'evt.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on evt
\p\g
create table evt_dly(
	id integer not null,
	persid varchar(30),
	last_mod_dt integer,
	obj_id varchar(30) not null,
	status_flag integer,
	delay_type integer,
	group_name varchar(30),
	support_lev varchar(30),
	start_userid byte varying(16),
	stop_userid byte varying(16),
	create_time integer,
	start_time integer,
	stop_time integer,
	cancel_time integer,
	eff_delay integer,
	act_delay integer,
	description varchar(80)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify evt_dly to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy evt_dly () from 'evt_dly.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on evt_dly
\p\g
create table evtdlytp(
	id integer not null,
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify evtdlytp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy evtdlytp () from 'evtdlytp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on evtdlytp
\p\g
create table exception_table(
	exception_id decimal(31,0) not null,
	errtext_msg varchar(4000) not null,
	procedure_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify exception_table to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy exception_table () from 'exception_table.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on exception_table
\p\g
create table execution(
	requestid integer not null,
	executionid integer not null,
	serverid integer,
	userid integer not null,
	executionstarttime date not null,
	executionendtime date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify execution to heap
with extend = 16,
	allocation = 4
\p\g
/* copy execution () from 'execution.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on execution
\p\g
create table export_reports(
	job_id integer not null,
	name varchar(50) not null,
	value varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify export_reports to btree unique on
	job_id,
	name,
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy export_reports () from 'export_reports.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on export_reports
\p\g
create table exporters(
	exporter_oid varchar(20) not null,
	bundle_key varchar(50),
	exporter_class varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify exporters to btree unique on
	exporter_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy exporters () from 'exporters.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on exporters
\p\g
create table ext_appl(
	id integer not null,
	persid varchar(30),
	code varchar(12) not null,
	sym varchar(30) not null,
	description varchar(500),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ext_appl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ext_appl () from 'ext_appl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ext_appl
\p\g
create table ext_command(
	ext_command_id integer not null,
	type integer,
	value varchar(255),
	creation_date date not null,
	modification_date date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ext_command to btree unique on
	ext_command_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ext_command () from 'ext_command.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ext_command
\p\g
create table ext_job(
	ext_job_name varchar(64) not null,
	ext_autoserv varchar(4) not null,
	status i1 not null,
	status_time integer not null,
	run_num integer,
	ntry integer,
	exit_code integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ext_job to btree unique on
	ext_job_name,
	ext_autoserv
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy ext_job () from 'ext_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ext_job
\p\g
create table extended_user_attribute_def(
	extended_attribute_def_id byte(16) not null,
	name varchar(255),
	data_type_attribute varchar(255),
	product_instance_name varchar(50),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify extended_user_attribute_def to heap
with extend = 16,
	allocation = 4
\p\g
/* copy extended_user_attribute_def () from 'extended_user_attribute_def.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on extended_user_attribute_def
\p\g
create table externalaction(
	actionid integer not null,
	acceptingactorcountry varchar(50),
	acceptingactororganisation varchar(50),
	acceptingactororgunit varchar(50),
	acceptingactorname varchar(50),
	actortype integer,
	actorname varchar(50),
	actioncomment varchar(300),
	acceptingactorcomment varchar(300)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify externalaction to btree unique on
	actionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy externalaction () from 'externalaction.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on externalaction
\p\g
create table filectl(
	job_id integer not null,
	origin integer not null,
	recovery_file integer not null,
	object_database varchar(128),
	object_owner varchar(128),
	object_name varchar(128) not null,
	file_name varchar(256) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify filectl to heap
with extend = 16,
	allocation = 4
\p\g
/* copy filectl () from 'filectl.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on filectl
\p\g
create table filemgr(
	domainid integer not null,
	unitid integer not null,
	filepart integer not null,
	fdate integer,
	contain text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify filemgr to btree unique on
	unitid,
	domainid,
	filepart
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy filemgr () from 'filemgr.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on filemgr
\p\g
create table filter(
	filterid integer not null,
	name varchar(255),
	owner varchar(255),
	expression text(1),
	matchestype integer,
	casesensitive integer,
	checkoutsid varchar(100),
	checkoutname varchar(100),
	psname varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify filter to btree unique on
	filterid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy filter () from 'filter.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on filter
\p\g
create table filter_collect(
	filter_collect_id decimal(5,0) not null,
	filter_head_id decimal(5,0),
	metric_id decimal(5,0),
	pattern_match varchar(60),
	min_val decimal(5,0),
	max_val decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify filter_collect to heap
with extend = 16,
	allocation = 4
\p\g
/* copy filter_collect () from 'filter_collect.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on filter_collect
\p\g
create table filter_compare(
	filter_compare_id decimal(5,0) not null,
	filter_head_id decimal(5,0),
	metric_id decimal(5,0),
	pct_change_min decimal(5,0),
	pct_change_max decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify filter_compare to btree unique on
	filter_compare_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy filter_compare () from 'filter_compare.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on filter_compare
\p\g
create table filter_head(
	filter_head_id decimal(5,0) not null,
	filter_name varchar(30),
	filter_version decimal(5,0),
	created_by varchar(30),
	created_date date,
	filter_ora_version decimal(1,0),
	filter_and_or decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify filter_head to btree unique on
	filter_head_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy filter_head () from 'filter_head.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on filter_head
\p\g
create table filter_value_set(
	filter_value_set_id decimal(31,0) not null,
	rsrc_id decimal(31,0),
	filter_value_set_name varchar(80),
	public_flag integer,
	filter_value_description varchar(80),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify filter_value_set to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy filter_value_set () from 'filter_value_set.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on filter_value_set
\p\g
create table filter_value_set_value(
	filter_value_set_id decimal(31,0) not null,
	filter_object_type decimal(31,0),
	start_value varchar(80),
	range_flag integer,
	end_value varchar(80),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify filter_value_set_value to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy filter_value_set_value () from 'filter_value_set_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on filter_value_set_value
\p\g
create table formula(
	formula_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	formula varchar(4000) not null,
	advice varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify formula to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy formula () from 'formula.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on formula
\p\g
create table formula_token(
	formula_token_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	formula_id decimal(31,0),
	token_metric_id decimal(31,0),
	token_variable_id decimal(31,0),
	owner_variable_id decimal(31,0),
	question varchar(4000),
	sibling_rank integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify formula_token to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy formula_token () from 'formula_token.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on formula_token
\p\g
create table frcircuitid(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	frcircuitifindex integer,
	frcircuitdlci integer,
	frcircuitcreationtime integer,
	frcircuitlasttimechange integer,
	frcircuitcommittedburst integer,
	frcircuitexcessburst integer,
	frcircuitthroughput integer,
	frcommittedinformationrate integer,
	collreq i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frcircuitid to btree on
	probe_addr,
	frcircuitifindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy frcircuitid () from 'frcircuitid.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on frcircuitid
\p\g
create table frcircuitstats(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	frcircuitifindex integer,
	frcircuitdlci integer,
	frcircuitstate i1,
	frcircuitreceivedfecns float,
	frcircuitreceivedbecns float,
	frcircuitsentframes float,
	frcircuitsentoctets float,
	frcircuitreceivedframes float,
	frcircuitreceivedoctets float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frcircuitstats to btree on
	probe_addr,
	frcircuitifindex,
	frcircuitdlci,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 32
\p\g
/* copy frcircuitstats () from 'frcircuitstats.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on frcircuitstats
\p\g
create table frdlcmiid(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	frdlcmiifindex integer,
	frdlcmistate i1,
	frdlcmiaddress i1,
	frdlcmiaddresslen i1,
	frdlcmipollinginterval i1,
	frdlcmifullenquiryinterval smallint,
	frdlcmierrorthreshold i1,
	frdlcmimonitoredevents i1,
	frdlcmimaxsupportedvcs integer,
	frdlcmimulticast i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frdlcmiid to btree on
	probe_addr,
	frdlcmiifindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy frdlcmiid () from 'frdlcmiid.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on frdlcmiid
\p\g
create table frmgrp(
	id integer not null,
	del integer not null,
	sym varchar(30) not null,
	description varchar(100),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify frmgrp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy frmgrp () from 'frmgrp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on frmgrp
\p\g
create table frs_circuit_line(
	l_net_name varchar(25) not null,
	l_node_name varchar(25) not null,
	l_line integer not null,
	l_port integer not null,
	card_type integer,
	interface integer,
	active integer,
	status integer,
	discovery integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_circuit_line to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_circuit_line () from 'frs_circuit_line.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_circuit_line
\p\g
create table frs_connection(
	l_net_name varchar(25),
	l_node_name varchar(25) not null,
	l_node_id integer,
	l_shelf varchar(25),
	l_line integer not null,
	l_slot integer not null,
	l_port integer not null,
	l_dlci integer not null,
	op_status integer,
	row_status integer,
	mir integer,
	cir integer,
	bc integer,
	be integer,
	vc_q_size integer,
	pir integer,
	cmax integer,
	ecn_q_size integer,
	qir integer,
	per_util integer,
	priority integer,
	ibs integer,
	detagging integer,
	ig_de_threshold integer,
	eg_q_depth integer,
	eg_de_threshold integer,
	eg_ecn_threshold integer,
	eg_q_select integer,
	loopback_state integer,
	card_type integer,
	channel_type integer,
	fecn integer,
	de_to_clp_map integer,
	clp_to_de_map integer,
	stats integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_connection to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_connection () from 'frs_connection.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_connection
\p\g
create table frs_frp(
	l_node_name varchar(25) not null,
	l_node_id integer,
	l_shelf varchar(25),
	l_line integer,
	l_slot integer not null,
	l_port integer not null,
	state integer,
	card_type integer,
	port_type integer,
	port_speed integer,
	port_line integer,
	stats integer,
	discovery integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_frp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_frp () from 'frs_frp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_frp
\p\g
create table frs_ip(
	lastip integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_ip to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_ip () from 'frs_ip.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_ip
\p\g
create table frs_node_id(
	node_id integer,
	netw_name varchar(25) not null,
	node_name varchar(25) not null,
	alarm_state integer,
	gateway integer,
	active integer,
	platform integer,
	fs_inc_rate integer,
	fs_dec_rate integer,
	fs_fdec_rate integer,
	rst_timeout integer,
	stats integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_node_id to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_node_id () from 'frs_node_id.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_node_id
\p\g
create table frs_packet_line(
	l_net_name varchar(25) not null,
	l_node_name varchar(25) not null,
	l_node_id integer,
	l_shelf varchar(25),
	l_line integer not null,
	l_slot integer not null,
	l_port integer not null,
	l_vtrk integer not null,
	card_type integer,
	interface integer,
	line_load integer,
	r_network_id integer,
	r_network_name varchar(20),
	r_node_id integer,
	r_line integer,
	r_slot integer,
	r_port integer,
	r_vtrk integer,
	alarm_state integer,
	active integer,
	status integer,
	stat_reserve integer,
	b_bq_depth integer,
	b_bq_efcn integer,
	clp_h_thresh integer,
	clp_l_thresh integer,
	stats integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_packet_line to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_packet_line () from 'frs_packet_line.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_packet_line
\p\g
create table frs_stat(
	strnodename varchar(25) not null,
	nslot integer not null,
	nport integer not null,
	ndlci integer not null,
	nobjecttype integer not null,
	nobjectsubtype integer,
	nstattype integer not null,
	nkey1 integer,
	nkey2 integer,
	nkey3 integer,
	nkey4 integer,
	nkey5 integer,
	fthresholdhigh float,
	fthresholdhighwater float,
	fthresholdlow float,
	fthresholdlowwater float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_stat to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_stat () from 'frs_stat.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_stat
\p\g
create table frs_stat_threshold(
	strnodename varchar(25) not null,
	slot integer,
	line integer,
	port integer,
	objecttype integer not null,
	subtype integer not null,
	stattype integer not null,
	numsamp integer,
	sv1 integer,
	sv2 integer,
	sv3 integer,
	sv4 integer,
	sv5 integer,
	sv6 integer,
	sv7 integer,
	sv8 integer,
	sv9 integer,
	sv10 integer,
	sv11 integer,
	sv12 integer,
	sv13 integer,
	sv14 integer,
	sv15 integer,
	sv16 integer,
	sv17 integer,
	sv18 integer,
	sv19 integer,
	sv20 integer,
	sv21 integer,
	sv22 integer,
	sv23 integer,
	sv24 integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_stat_threshold to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_stat_threshold () from 'frs_stat_threshold.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_stat_threshold
\p\g
create table frs_svp(
	svpid integer,
	address varchar(60) not null,
	retry integer,
	ntype integer,
	stats integer,
	state integer,
	benabled integer,
	ndpi integer,
	nppi integer,
	strcopycommand varchar(16),
	strhostname varchar(25),
	strusername varchar(16),
	strpassword varchar(16),
	strfilepath varchar(60),
	strtraphostaddress varchar(25),
	strcommunityname varchar(25),
	strcommunitynamewrite varchar(25)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_svp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_svp () from 'frs_svp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_svp
\p\g
create table frs_trap(
	timeofevent date,
	type varchar(12),
	node_name varchar(25) not null,
	l_slot integer,
	l_port integer,
	l_dlci integer,
	l_line integer,
	severity varchar(25),
	reason varchar(60)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify frs_trap to heap
with extend = 16,
	allocation = 4
\p\g
/* copy frs_trap () from 'frs_trap.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on frs_trap
\p\g
create table fun_identifier(
	value integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_identifier to btree unique on
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_identifier () from 'fun_identifier.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_identifier
\p\g
create table fun_ixfcols(
	fun_id integer not null,
	ixfcols varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_ixfcols to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_ixfcols () from 'fun_ixfcols.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_ixfcols
\p\g
create table fun_jas(
	fun_id integer not null,
	group_id integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_jas to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_jas () from 'fun_jas.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_jas
\p\g
create table fun_lobpaths(
	fun_id integer not null,
	path varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_lobpaths to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_lobpaths () from 'fun_lobpaths.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_lobpaths
\p\g
create table fun_nesttblpaths(
	fun_id integer not null,
	path varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_nesttblpaths to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_nesttblpaths () from 'fun_nesttblpaths.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_nesttblpaths
\p\g
create table fun_nesttblsto(
	fun_id integer not null,
	sto_tbl_name varchar(255),
	sto_tbl_name_ovr varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_nesttblsto to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_nesttblsto () from 'fun_nesttblsto.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_nesttblsto
\p\g
create table fun_ora(
	fun_id integer not null,
	multi_out integer not null,
	output_file varchar(255),
	write_scheme integer not null,
	rrobin_count integer not null,
	rrobin_output integer not null,
	filename_pattern varchar(255),
	listing_filename varchar(255),
	lob_file varchar(255),
	varray_file varchar(255),
	nested_file varchar(255),
	directory_scheme integer not null,
	use_nfs integer not null,
	max_output_size integer not null,
	max_output_units varchar(1) not null,
	format_type integer not null,
	column_delimiter varchar(3),
	row_delimiter varchar(3),
	enclosure_char varchar(3),
	enclosure_check integer not null,
	decimal_point varchar(3),
	fixed_decimal integer not null,
	float_format varchar(6) not null,
	sql_loader_type integer not null,
	direct_path integer not null,
	ins_rep_app integer not null,
	byte_count_length integer not null,
	date_format integer not null,
	format_file varchar(255),
	fixed_null_date varchar(255),
	unrecoverable integer not null,
	parallel integer not null,
	version varchar(10),
	binary_mode integer not null,
	col_byte_count integer not null,
	row_byte_count integer not null,
	sample integer not null,
	num_rows integer not null,
	max_varray_elem integer not null,
	max_open_files integer not null,
	max_sort_mem integer not null,
	odometer integer not null,
	log_file varchar(255) not null,
	dest_table_name varchar(255),
	loader_ctl_file varchar(255),
	loader_sql_file varchar(255),
	sql_file varchar(255),
	sql_query varchar(255),
	sql_type integer not null,
	delimiter_check integer not null,
	all_rows integer not null,
	quiesce_retry integer not null,
	maxlong_lobsize integer not null,
	all_elements integer not null,
	fixed_null_num varchar(25),
	max_num_threads integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_ora to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy fun_ora () from 'fun_ora.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_ora
\p\g
create table fun_outpaths(
	fun_id integer not null,
	path varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_outpaths to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_outpaths () from 'fun_outpaths.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_outpaths
\p\g
create table fun_packedcols(
	fun_id integer not null,
	packedcol varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_packedcols to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_packedcols () from 'fun_packedcols.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_packedcols
\p\g
create table fun_partitions(
	fun_id integer not null,
	partition_name varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_partitions to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_partitions () from 'fun_partitions.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_partitions
\p\g
create table fun_sortpaths(
	fun_id integer not null,
	path varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_sortpaths to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_sortpaths () from 'fun_sortpaths.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_sortpaths
\p\g
create table fun_sqlserver(
	fun_id integer not null,
	multi_out integer not null,
	output_file varchar(255),
	write_scheme integer not null,
	rrobin_count integer not null,
	rrobin_output integer not null,
	filename_pattern varchar(255),
	listing_filename varchar(255),
	directory_scheme integer not null,
	use_nfs integer not null,
	max_output_size integer not null,
	max_output_units varchar(1) not null,
	format_type integer not null,
	column_delimiter varchar(3),
	row_delimiter varchar(3),
	enclosure_char varchar(3),
	decimal_point varchar(3),
	fixed_decimal integer not null,
	date_format integer not null,
	long_limit integer not null,
	format_file varchar(255),
	fixed_null_date varchar(255),
	log_file varchar(255),
	master_device_file varchar(255),
	odometer integer not null,
	sample integer not null,
	num_rows integer not null,
	max_sort_mem integer not null,
	sql_file varchar(255),
	sql_query varchar(255),
	sql_type integer not null,
	max_open_files integer not null,
	character_set integer not null,
	all_rows integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_sqlserver to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy fun_sqlserver () from 'fun_sqlserver.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_sqlserver
\p\g
create table fun_template(
	fun_id integer not null,
	server_id integer not null,
	ident varchar(255) not null,
	object varchar(255) not null,
	name varchar(255) not null,
	description varchar(100),
	dbms_type varchar(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_template to btree unique on
	fun_id,
	server_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_template () from 'fun_template.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_template
\p\g
create table fun_udb(
	fun_id integer not null,
	multi_out integer not null,
	output_file varchar(255),
	partition_data integer not null,
	write_scheme integer not null,
	rrobin_count integer not null,
	rrobin_output integer not null,
	filename_pattern varchar(255),
	listing_filename varchar(255),
	lob_file varchar(255),
	directory_scheme integer not null,
	use_nfs integer not null,
	max_output_size integer not null,
	max_output_units varchar(1) not null,
	format_type integer not null,
	column_delimiter varchar(3),
	row_delimiter varchar(3),
	enclosure_char varchar(3),
	decimal_point varchar(3),
	fixed_decimal integer not null,
	long_limit integer not null,
	date_format integer not null,
	format_file varchar(255),
	fixed_null_date varchar(255),
	fixed_null_time varchar(255),
	fixed_null_tstamp varchar(255),
	log_file varchar(255),
	odometer integer not null,
	sample integer not null,
	num_rows integer not null,
	max_sort_mem integer not null,
	quiesce_mode integer not null,
	quiesce_retry integer not null,
	sql_file varchar(255),
	sql_query varchar(255),
	sql_type integer not null,
	max_open_files integer not null,
	character_set integer not null,
	all_rows integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_udb to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy fun_udb () from 'fun_udb.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_udb
\p\g
create table fun_varraypaths(
	fun_id integer not null,
	path varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify fun_varraypaths to btree unique on
	fun_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy fun_varraypaths () from 'fun_varraypaths.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on fun_varraypaths
\p\g
create table g_chg_ext(
	id integer not null,
	remote_sys_id integer not null,
	remote_id integer not null,
	active_flag integer not null,
	last_mod_dt integer not null,
	global_queue_id integer,
	chg_ref_num varchar(30) not null,
	status varchar(30) not null,
	priority integer not null,
	impact integer,
	open_date integer not null,
	close_date integer,
	category varchar(30),
	summary varchar(240),
	group_id byte varying(16),
	assignee byte varying(16),
	requestor byte varying(16) not null,
	affected_contact byte varying(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_chg_ext to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_chg_ext () from 'g_chg_ext.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_chg_ext
\p\g
create table g_chg_queue(
	id integer not null,
	remote_sys_id integer not null,
	remote_id integer not null,
	active_flag integer not null,
	last_mod_dt integer not null,
	global_queue_id integer,
	chg_ref_num varchar(30) not null,
	status varchar(30) not null,
	priority integer not null,
	impact integer,
	open_date integer not null,
	close_date integer,
	category varchar(30),
	summary varchar(240),
	group_id byte varying(16),
	assignee byte varying(16),
	requestor byte varying(16) not null,
	affected_contact byte varying(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_chg_queue to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_chg_queue () from 'g_chg_queue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_chg_queue
\p\g
create table g_contact(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	remote_sys_id integer not null,
	remote_id byte varying(16) not null,
	last_name varchar(100),
	first_name varchar(100),
	middle_name varchar(100),
	userid varchar(100),
	pri_phone_number varchar(32),
	email_addr varchar(120),
	org_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_contact to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_contact () from 'g_contact.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_contact
\p\g
create table g_iss_ext(
	id integer not null,
	remote_sys_id integer not null,
	remote_id integer not null,
	active_flag integer not null,
	last_mod_dt integer not null,
	global_queue_id integer,
	ref_num varchar(30) not null,
	status varchar(30) not null,
	priority integer not null,
	open_date integer not null,
	close_date integer,
	category varchar(30),
	summary varchar(240),
	product integer,
	group_id byte varying(16),
	assignee byte varying(16),
	requestor byte varying(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_iss_ext to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_iss_ext () from 'g_iss_ext.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_iss_ext
\p\g
create table g_iss_queue(
	id integer not null,
	remote_sys_id integer not null,
	remote_id integer not null,
	active_flag integer not null,
	last_mod_dt integer not null,
	global_queue_id integer,
	ref_num varchar(30) not null,
	status varchar(30) not null,
	priority integer not null,
	open_date integer not null,
	close_date integer,
	category varchar(30),
	summary varchar(240),
	product integer,
	group_id byte varying(16),
	assignee byte varying(16),
	requestor byte varying(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_iss_queue to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_iss_queue () from 'g_iss_queue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_iss_queue
\p\g
create table g_org(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	remote_sys_id integer not null,
	remote_id byte varying(16) not null,
	org_name varchar(100)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_org to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_org () from 'g_org.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_org
\p\g
create table g_product(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	remote_sys_id integer not null,
	remote_id integer not null,
	sym varchar(60)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_product to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_product () from 'g_product.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_product
\p\g
create table g_queue_names(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	sym varchar(30) not null,
	description varchar(100)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_queue_names to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_queue_names () from 'g_queue_names.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_queue_names
\p\g
create table g_req_ext(
	id integer not null,
	remote_sys_id integer not null,
	remote_id integer not null,
	active_flag integer not null,
	last_mod_dt integer not null,
	global_queue_id integer,
	ref_num varchar(30) not null,
	status varchar(30) not null,
	priority integer not null,
	impact integer,
	open_date integer not null,
	close_date integer,
	category varchar(30),
	summary varchar(240),
	group_id byte varying(16),
	assignee byte varying(16),
	customer byte varying(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_req_ext to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_req_ext () from 'g_req_ext.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_req_ext
\p\g
create table g_req_queue(
	id integer not null,
	remote_sys_id integer not null,
	remote_id integer not null,
	active_flag integer not null,
	last_mod_dt integer not null,
	global_queue_id integer,
	ref_num varchar(30) not null,
	status varchar(30) not null,
	priority integer not null,
	impact integer,
	open_date integer not null,
	close_date integer,
	category varchar(30),
	summary varchar(240),
	group_id byte varying(16),
	assignee byte varying(16),
	customer byte varying(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_req_queue to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_req_queue () from 'g_req_queue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_req_queue
\p\g
create table g_srvr(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	remote_sys_id integer not null,
	sym varchar(30) not null,
	description varchar(100),
	cr_prefix varchar(5),
	chg_prefix varchar(5),
	iss_prefix varchar(5),
	is_master integer,
	global_name varchar(30) not null,
	slump_addr varchar(30),
	web_protocol varchar(10),
	web_server varchar(30),
	web_server_port varchar(10),
	web_url varchar(100)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_srvr to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_srvr () from 'g_srvr.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_srvr
\p\g
create table g_tbl_map(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	sym varchar(30) not null,
	map_definition varchar(64) not null,
	description varchar(100)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_tbl_map to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_tbl_map () from 'g_tbl_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_tbl_map
\p\g
create table g_tbl_rule(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	sym varchar(30) not null,
	description varchar(100),
	sched varchar(30),
	reoccur_interv integer,
	table_map integer,
	last_sync_dt integer,
	addl_query varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify g_tbl_rule to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy g_tbl_rule () from 'g_tbl_rule.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on g_tbl_rule
\p\g
create table gdcdiscovery(
	server_addr integer not null,
	probe_addr integer not null,
	mibidx integer not null,
	intervaldatetime date not null,
	discovered integer default 1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify gdcdiscovery to heap
with extend = 16,
	allocation = 4
\p\g
/* copy gdcdiscovery () from 'gdcdiscovery.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on gdcdiscovery
\p\g
create integrity  ON GDCDiscovery IS Discovered IN (0, 1)
\p\g
create table glob(
	glo_name varchar(64),
	value varchar(100),
	value_set_time integer,
	owner varchar(80),
	permission varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify glob to btree unique on
	glo_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy glob () from 'glob.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on glob
\p\g
create table global_status_event(
	global_status_rec_id byte(16) not null,
	intiated_by nvarchar(64),
	intiated_date date,
	new_status_id byte(16) not null,
	old_status_id byte(16) not null,
	revoked_by nvarchar(64),
	revoked_date date,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify global_status_event to btree unique on
	global_status_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy global_status_event () from 'global_status_event.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on global_status_event
\p\g
create table globalvariable(
	variableid integer not null,
	variableaccess integer,
	variablevalue byte(248)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify globalvariable to heap
with extend = 16,
	allocation = 4
\p\g
/* copy globalvariable () from 'globalvariable.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on globalvariable
\p\g
create table groupingtype(
	id integer,
	name varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify groupingtype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy groupingtype () from 'groupingtype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on groupingtype
\p\g
create table grp_loc(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify grp_loc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy grp_loc () from 'grp_loc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on grp_loc
\p\g
create table grpmem(
	id integer not null,
	group_id byte varying(16) not null,
	member byte varying(16) not null,
	manager_flag integer,
	notify_flag integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify grpmem to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy grpmem () from 'grpmem.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on grpmem
\p\g
create table harallchildrenpath(
	itemobjid integer not null,
	childitemid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harallchildrenpath to btree unique on
	itemobjid,
	childitemid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harallchildrenpath () from 'harallchildrenpath.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harallchildrenpath
\p\g
create table harallusers(
	usrobjid integer not null,
	username char(32) not null,
	logindate date,
	lastlogin date,
	loggedin char(1) not null,
	realname char(128),
	phonenumber char(32),
	extension char(8),
	faxnumber char(32),
	encryptpsswd char(32),
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	email varchar(128),
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harallusers to btree unique on
	usrobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harallusers () from 'harallusers.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harallusers
\p\g
create table harapprove(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harapprove to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harapprove () from 'harapprove.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harapprove
\p\g
create table harapprovehist(
	packageobjid integer not null,
	envobjid integer not null,
	stateobjid integer not null,
	usrobjid integer not null,
	execdtime date not null,
	action varchar(128) not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harapprovehist to btree unique on
	envobjid,
	stateobjid,
	packageobjid,
	usrobjid,
	execdtime,
	action
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harapprovehist () from 'harapprovehist.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harapprovehist
\p\g
create table harapprovelist(
	processobjid integer not null,
	stateobjid integer not null,
	isgroup char(1) not null,
	usrobjid integer,
	usrgrpobjid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harapprovelist to btree unique on
	processobjid,
	stateobjid,
	isgroup,
	usrobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harapprovelist () from 'harapprovelist.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harapprovelist
\p\g
create table harassocpkg(
	formobjid integer not null,
	assocpkgid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harassocpkg to btree unique on
	formobjid,
	assocpkgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harassocpkg () from 'harassocpkg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harassocpkg
\p\g
create table harbranch(
	branchobjid integer not null,
	packageobjid integer not null,
	itemobjid integer not null,
	ismerged integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harbranch to btree unique on
	branchobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harbranch () from 'harbranch.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harbranch
\p\g
create table harcheckinproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	itemoption integer not null,
	pathoption integer not null,
	itemnewer char(1) not null,
	modeoption integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	viewpath varchar(255),
	clientdir varchar(255),
	description varchar(2000),
	note varchar(2000),
	neworexistingitem char(1) not null,
	newitemonly char(1) not null,
	existingitemonly char(1) not null,
	deleteafterci char(1) not null,
	owneronly char(1) not null,
	forcecomment char(1) not null default 'N'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harcheckinproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harcheckinproc () from 'harcheckinproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harcheckinproc
\p\g
create table harcheckoutproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	pathoption integer not null,
	replacefile char(1) not null,
	itemnewer char(1) not null,
	updmode char(1) not null,
	concurupdmode char(1) not null,
	browsemode char(1) not null,
	reservemode char(1) not null,
	syncmode char(1) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	clientdir varchar(255),
	viewpath varchar(255),
	note varchar(2000),
	sharedworkingdir char(1) not null,
	usecheckintimestamp char(1)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harcheckoutproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harcheckoutproc () from 'harcheckoutproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harcheckoutproc
\p\g
create table harcomment(
	formobjid integer not null,
	commentdate date,
	commentedby char(44),
	commentkeyword varchar(66),
	comments varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harcomment to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harcomment () from 'harcomment.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harcomment
\p\g
create table harconmrgproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	mergerule char(1) not null default 'A'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harconmrgproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harconmrgproc () from 'harconmrgproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harconmrgproc
\p\g
create table harconversionlog(
	tablename varchar(64) not null,
	lastobjid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harconversionlog to btree unique on
	tablename
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harconversionlog () from 'harconversionlog.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harconversionlog
\p\g
create table harcrpkgproc(
	processobjid integer not null,
	processname char(128) not null,
	defaultpkgformname char(128),
	createassocform char(1) not null,
	stateobjid integer not null,
	initialstateid integer not null default 0,
	formtypeobjid integer,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	disablenamechange char(1) not null default 'N'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harcrpkgproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harcrpkgproc () from 'harcrpkgproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harcrpkgproc
\p\g
create table harcrsenvmrgproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	placement char(1) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	mergerule char(1) not null default 'A'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harcrsenvmrgproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harcrsenvmrgproc () from 'harcrsenvmrgproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harcrsenvmrgproc
\p\g
create table hardefect(
	formobjid integer not null,
	dtapplication varchar(66),
	dtcategory char(12),
	dtcomponent varchar(66),
	dtconfirmedby varchar(66),
	dtconfirmedos char(32),
	dtconfirmedversion char(32),
	dtdateclosed date,
	dtdateconfirmed date,
	dtdatereported date,
	dtdefectkey char(19),
	dtdescription varchar(2000),
	dtdeveloper char(32),
	dtdocimpact char(12),
	dtdocument varchar(130),
	dtfixby date,
	dtimpact char(9),
	dtinvestigator char(32),
	dtinvestnotes varchar(2000),
	dtkeyword varchar(66),
	dtlikelihood char(9),
	dtmilestone char(12),
	dtorigin char(8),
	dtothercategory char(30),
	dtpriority char(10),
	dtrecommend varchar(77),
	dtreleasenum char(32),
	dtreportedby varchar(66),
	dtreportedos char(32),
	dtresolution varchar(2000),
	dtrevisionnum char(32),
	dtseverity char(21),
	dttestcases varchar(2000),
	dttester char(32),
	dttestresults varchar(2000),
	dtunittest varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify hardefect to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy hardefect () from 'hardefect.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on hardefect
\p\g
create table hardelversproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify hardelversproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy hardelversproc () from 'hardelversproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on hardelversproc
\p\g
create table hardemoteproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	tostateid integer not null,
	demotechgs char(1) not null,
	carrychgs char(1) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	enforcebind char(1) not null default 'N',
	checkdependencies char(1) not null default 'N'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify hardemoteproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy hardemoteproc () from 'hardemoteproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on hardemoteproc
\p\g
create table harenvironment(
	envobjid integer not null,
	environmentname char(128) not null,
	envisactive char(1) not null,
	baselineviewid integer not null default 0,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	isarchive char(1) not null default 'N',
	archiveby integer not null default 1,
	archivemachine char(256),
	archivefile char(256),
	archivetime date
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harenvironment to btree unique on
	envobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harenvironment () from 'harenvironment.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harenvironment
\p\g
create table harenvironmentaccess(
	envobjid integer not null,
	usrgrpobjid integer not null,
	secureaccess char(1) not null default 'N',
	updateaccess char(1) not null default 'N',
	viewaccess char(1) not null default 'N',
	executeaccess char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harenvironmentaccess to btree unique on
	envobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harenvironmentaccess () from 'harenvironmentaccess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harenvironmentaccess
\p\g
create table haresd(
	formobjid integer not null,
	esdbackoutplan varchar(2000),
	esdcertificationresults varchar(2000),
	esddeploymentplan varchar(2000),
	esddescription varchar(2000),
	esdhwdependencynotes varchar(2000),
	esdid char(40),
	esdimpactnotes varchar(2000),
	esdimplementationdate date,
	esdinitiator char(30),
	esdinvestigator char(30),
	esdplannedby char(30),
	esdpriority char(10),
	esdrejectedby char(30),
	esdrejectnotes varchar(2000),
	esdrequestdate date,
	esdrequiredspace char(40),
	esdreviewedby char(30),
	esdreviewnotes varchar(2000),
	esdrisklevel char(10),
	esdscope varchar(2000),
	esdscriptnotes varchar(2000),
	esdswdependencynotes varchar(2000),
	esdtestedby char(30),
	esdtestplan varchar(2000),
	esdtrainingplan varchar(2000),
	esdtype varchar(52)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify haresd to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 32768,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy haresd () from 'haresd.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on haresd
\p\g
create table harexternassoc(
	packageobjid integer not null,
	usrobjid integer not null,
	externalid integer not null,
	a_restrict integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harexternassoc to btree unique on
	externalid,
	usrobjid,
	packageobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harexternassoc () from 'harexternassoc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harexternassoc
\p\g
create table harfileextension(
	repositobjid integer not null,
	fileextension char(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harfileextension to btree unique on
	repositobjid,
	fileextension
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harfileextension () from 'harfileextension.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harfileextension
\p\g
create table harform(
	formobjid integer not null,
	formtypeobjid integer not null,
	formname varchar(128) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harform to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harform () from 'harform.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harform
\p\g
create table harformattachment(
	attachmentobjid integer,
	attachmentname varchar(512) not null,
	attachmenttype integer not null,
	formobjid integer not null,
	creatorid integer not null,
	creationtime date not null,
	filesize integer not null,
	filedata long byte,
	filecompressed char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harformattachment to btree on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy harformattachment () from 'harformattachment.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harformattachment
\p\g
create table harformhistory(
	formobjid integer not null,
	usrobjid integer not null,
	execdtime date not null,
	action varchar(128) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harformhistory to btree on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy harformhistory () from 'harformhistory.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harformhistory
\p\g
create table harformtype(
	formtypeobjid integer not null,
	formtablename char(32) not null,
	formtypename varchar(128) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harformtype to btree unique on
	formtypeobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harformtype () from 'harformtype.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harformtype
\p\g
create table harformtypeaccess(
	formtypeobjid integer not null,
	usrgrpobjid integer not null,
	secureaccess char(1) not null default 'N',
	updateaccess char(1) not null default 'N',
	viewaccess char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harformtypeaccess to btree unique on
	formtypeobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harformtypeaccess () from 'harformtypeaccess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harformtypeaccess
\p\g
create table harformtypedefs(
	attrid integer not null,
	formtypeobjid integer not null,
	columnname char(32) not null,
	columntype char(8) not null,
	columnsize integer not null,
	defaultintvalue integer,
	defaultcharvalue varchar(255),
	label varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harformtypedefs to btree unique on
	attrid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harformtypedefs () from 'harformtypedefs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harformtypedefs
\p\g
create table harharvest(
	usrgrpobjid integer not null,
	secureharvest char(1) not null default 'N',
	adminuser char(1) not null default 'N',
	viewuser char(1) not null default 'N',
	adminenvironment char(1) not null default 'N',
	viewenvironment char(1) not null default 'N',
	adminrepository char(1) not null default 'N',
	viewrepository char(1) not null default 'N',
	adminformtype char(1) not null default 'N',
	viewformtype char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harharvest to btree unique on
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harharvest () from 'harharvest.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harharvest
\p\g
create table harintmrgproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	mergeway integer not null default 0
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harintmrgproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harintmrgproc () from 'harintmrgproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harintmrgproc
\p\g
create table haritemaccess(
	itemobjid integer not null,
	usrgrpobjid integer not null,
	viewaccess char(1) not null default 'Y'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify haritemaccess to btree unique on
	itemobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy haritemaccess () from 'haritemaccess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on haritemaccess
\p\g
create table haritemrelationship(
	itemobjid integer not null,
	refitemid integer not null,
	relationship char(10) not null,
	versionobjid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify haritemrelationship to btree unique on
	itemobjid,
	refitemid,
	versionobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy haritemrelationship () from 'haritemrelationship.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on haritemrelationship
\p\g
create table haritems(
	itemobjid integer not null,
	itemname varchar(256) not null,
	itemtype integer not null,
	parentobjid integer not null,
	repositobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	itemnameupper varchar(256)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify haritems to btree unique on
	itemobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy haritems () from 'haritems.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on haritems
\p\g
create table harlinkedprocess(
	stateobjid integer not null,
	parentprocobjid integer not null,
	processobjid integer not null,
	processorder integer not null,
	processname char(128) not null,
	processtype char(32) not null,
	processprelink char(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harlinkedprocess to btree unique on
	parentprocobjid,
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harlinkedprocess () from 'harlinkedprocess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harlinkedprocess
\p\g
create table harlistdiffproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harlistdiffproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harlistdiffproc () from 'harlistdiffproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harlistdiffproc
\p\g
create table harlistversproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	changedescription char(1),
	actualchanges char(1),
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	toviewpath varchar(255),
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harlistversproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harlistversproc () from 'harlistversproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harlistversproc
\p\g
create table harmovepkgproc(
	processobjid integer not null,
	processname char(128) not null,
	includepkghistory char(1) not null,
	stateobjid integer not null,
	toenvironmentid integer not null,
	tostateid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harmovepkgproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harmovepkgproc () from 'harmovepkgproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harmovepkgproc
\p\g
create table harmr(
	formobjid integer not null,
	mrdatereported date,
	mrreportedby char(44),
	mrcategory char(12),
	mrothercategory char(30),
	mrapplication varchar(66),
	mrreleasenum char(32),
	mrhardware varchar(66),
	mroperatingsys char(32),
	mrdocument varchar(130),
	mrrevisionnum char(32),
	mrdescript varchar(2000),
	mrkeyword varchar(66),
	mrseverity char(32),
	mrinvestnotes varchar(2000),
	mrinvestigator char(32),
	mrrecommend varchar(76),
	mrresolution varchar(2000),
	mrunittest varchar(2000),
	mrdeveloper char(32),
	mrtestresults varchar(2000),
	mrtester char(32)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harmr to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harmr () from 'harmr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harmr
\p\g
create table harnotify(
	processobjid integer not null,
	processname char(128) not null,
	parentprocobjid integer,
	stateobjid integer,
	outputtarget char(8) not null,
	onerroraction char(8) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	mailfacility varchar(255) not null,
	"message" varchar(2000),
	note varchar(2000),
	subject varchar(1000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harnotify to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harnotify () from 'harnotify.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harnotify
\p\g
create table harnotifylist(
	processobjid integer not null,
	parentprocobjid integer,
	stateobjid integer,
	isgroup char(1) not null,
	usrobjid integer,
	usrgrpobjid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harnotifylist to btree unique on
	processobjid,
	stateobjid,
	parentprocobjid,
	isgroup,
	usrobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harnotifylist () from 'harnotifylist.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harnotifylist
\p\g
create table harobjectsequenceid(
	hartablename varchar(64) not null,
	harsequenceid varchar(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harobjectsequenceid to btree unique on
	hartablename
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harobjectsequenceid () from 'harobjectsequenceid.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harobjectsequenceid
\p\g
create table harpac(
	formobjid integer not null,
	pacbackoutplan varchar(2000),
	pacdatereported date,
	pacdescription varchar(2000),
	pacid char(40),
	pacimpactnotes varchar(2000),
	pacimplementationdate date,
	pacimplementationplan varchar(2000),
	pacinitiator char(30),
	pacinvestigator char(30),
	pacowner char(30),
	pacplannedby char(30),
	pacpriority char(10),
	pacrejectedby char(30),
	pacrejectnotes varchar(2000),
	pacreviewedby char(30),
	pacreviewnotes varchar(2000),
	pacrisklevel char(10),
	pacscope varchar(2000),
	pactestedby char(30),
	pactestplan varchar(2000),
	pactestresults varchar(2000),
	pactrainingplan varchar(2000),
	pactype varchar(52)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify harpac to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 32768,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harpac () from 'harpac.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpac
\p\g
create table harpackage(
	packageobjid integer not null,
	packagename varchar(128) not null,
	envobjid integer not null,
	stateobjid integer not null default 0,
	viewobjid integer not null default -1,
	approved char(1) not null,
	status char(32) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	packagedes varchar(255),
	note varchar(2000),
	priority integer not null default 0,
	assigneeid integer not null default -1,
	stateentrytime date not null default 'now',
	clientname varchar(128),
	servername varchar(128)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harpackage to btree unique on
	packageobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harpackage () from 'harpackage.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpackage
\p\g
create table harpackagegroup(
	pkggrpobjid integer not null,
	pkggrpname char(128) not null,
	envobjid integer not null,
	bind char(1) not null default 'N',
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harpackagegroup to btree unique on
	pkggrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harpackagegroup () from 'harpackagegroup.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpackagegroup
\p\g
create table harpackagenamegen(
	nameformat varchar(128) not null,
	namecounter integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harpackagenamegen to btree unique on
	nameformat
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harpackagenamegen () from 'harpackagenamegen.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpackagenamegen
\p\g
create table harpasswordhistory(
	usrobjid integer not null,
	prevpsswds long byte not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harpasswordhistory to heap
with extend = 16,
	allocation = 4
\p\g
/* copy harpasswordhistory () from 'harpasswordhistory.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on harpasswordhistory
\p\g
create table harpasswordpolicy(
	maxage integer not null default -1,
	minage integer not null default 0,
	minlen integer not null default 6,
	reuserule integer not null default 0,
	maxfailures integer not null default -1,
	allowusrchgexp char(1) not null default 'Y',
	warningage integer not null default -1,
	chrepetition integer not null default -1,
	minnumeric integer not null default 0,
	lowercase integer not null default 0,
	uppercase integer not null default 0,
	nonalphanum integer not null default 0,
	allowusername char(1) not null default 'Y',
	modifiedtime date not null,
	modifierid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harpasswordpolicy to heap
with extend = 16,
	allocation = 4
\p\g
/* copy harpasswordpolicy () from 'harpasswordpolicy.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on harpasswordpolicy
\p\g
create table harpathfullname(
	itemobjid integer not null,
	pathfullname varchar(1024),
	pathfullnameupper varchar(1024)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify harpathfullname to btree unique on
	itemobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy harpathfullname () from 'harpathfullname.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpathfullname
\p\g
create table harpkghistory(
	packageobjid integer not null,
	statename varchar(128) not null,
	environmentname varchar(128) not null,
	execdtime date not null,
	usrobjid integer not null,
	action varchar(128) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harpkghistory to btree on
	packageobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy harpkghistory () from 'harpkghistory.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpkghistory
\p\g
create table harpkgsinpkggrp(
	packageobjid integer not null,
	pkggrpobjid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harpkgsinpkggrp to btree unique on
	packageobjid,
	pkggrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harpkgsinpkggrp () from 'harpkgsinpkggrp.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpkgsinpkggrp
\p\g
create table harpmstatus(
	pmstatusindex integer not null,
	pmstatusname char(128) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harpmstatus to btree unique on
	pmstatusindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harpmstatus () from 'harpmstatus.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpmstatus
\p\g
create table harproblemreport(
	formobjid integer not null,
	datereported date,
	operatingsystem char(32),
	releasenum char(32),
	revisionnum char(32),
	severity char(32),
	application varchar(66),
	category varchar(66),
	hardware varchar(66),
	keyword varchar(66),
	reportedby varchar(66),
	document varchar(130),
	problemdescr varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harproblemreport to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harproblemreport () from 'harproblemreport.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harproblemreport
\p\g
create table harpromoteproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	tostateid integer not null,
	updpriorstates char(1) not null,
	mergedpkgsonly char(1) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	checkdependencies char(1) not null default 'N',
	fromstateid integer not null default 0,
	enforcebind char(1) not null default 'N'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harpromoteproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harpromoteproc () from 'harpromoteproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harpromoteproc
\p\g
create table harqanda(
	formobjid integer not null,
	answeredby char(44),
	submittedby char(44),
	quesdate date,
	ansdate date,
	queskeyword varchar(66),
	answer varchar(2000),
	question varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harqanda to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harqanda () from 'harqanda.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harqanda
\p\g
create table harreceiveupdates(
	syncobjid integer,
	configobjid integer,
	versionobjid integer,
	orig_versionobjid integer,
	itemfullname varchar(512),
	checkintime date,
	versionstatus char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harreceiveupdates to btree on
	configobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy harreceiveupdates () from 'harreceiveupdates.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harreceiveupdates
\p\g
create table harremitemproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harremitemproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harremitemproc () from 'harremitemproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harremitemproc
\p\g
create table harrenameitemproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harrenameitemproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harrenameitemproc () from 'harrenameitemproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harrenameitemproc
\p\g
create table harrepinview(
	viewobjid integer not null,
	repositobjid integer not null,
	readonly integer not null,
	repfromviewid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harrepinview to btree unique on
	viewobjid,
	repositobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harrepinview () from 'harrepinview.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harrepinview
\p\g
create table harrepository(
	repositobjid integer not null,
	repositname char(128) not null,
	rootpathid integer not null,
	reponline char(8),
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	initialviewid integer not null,
	hostnode varchar(32),
	hostinstance varchar(32) not null,
	note varchar(2000),
	extensionoption integer not null default 1,
	compfile char(1) not null default 'Y',
	notcompext varchar(1000) default '.zip.jpg.gif.asf.ram.mp3.wav.cab',
	mvsmapping char(1) not null default 'M'
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harrepository to btree unique on
	repositobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harrepository () from 'harrepository.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harrepository
\p\g
create table harrepositoryaccess(
	repositobjid integer not null,
	usrgrpobjid integer not null,
	secureaccess char(1) not null default 'N',
	updateaccess char(1) not null default 'N',
	viewaccess char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harrepositoryaccess to btree unique on
	repositobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harrepositoryaccess () from 'harrepositoryaccess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harrepositoryaccess
\p\g
create table harsendupdates(
	configobjid integer,
	versionobjid integer,
	syncdate date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harsendupdates to btree on
	configobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy harsendupdates () from 'harsendupdates.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harsendupdates
\p\g
create table harsite(
	siteobjid integer not null,
	sitename char(24) not null default 'N/A',
	a_local char(1),
	hostname char(30),
	importdir varchar(256),
	ftpdir varchar(256)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harsite to btree unique on
	siteobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harsite () from 'harsite.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harsite
\p\g
create table harsnapviewproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harsnapviewproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harsnapviewproc () from 'harsnapviewproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harsnapviewproc
\p\g
create table harstate(
	stateobjid integer not null,
	statename char(128) not null,
	envobjid integer not null,
	stateorder integer not null,
	viewobjid integer not null,
	snapshot char(1) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000),
	locationx integer not null default 0,
	locationy integer not null default 0,
	pmstatusindex integer not null default 0
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harstate to btree unique on
	stateobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harstate () from 'harstate.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harstate
\p\g
create table harstateaccess(
	stateobjid integer not null,
	usrgrpobjid integer not null,
	updateaccess char(1) not null default 'N',
	updatepkgaccess char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harstateaccess to btree unique on
	stateobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harstateaccess () from 'harstateaccess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harstateaccess
\p\g
create table harstateprocess(
	stateobjid integer not null,
	processobjid integer not null,
	processname char(128) not null,
	processtype char(32) not null,
	processorder integer not null,
	postcount integer not null default 0,
	precount integer not null default 0
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harstateprocess to btree unique on
	stateobjid,
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harstateprocess () from 'harstateprocess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harstateprocess
\p\g
create table harstateprocessaccess(
	stateobjid integer not null,
	processobjid integer not null,
	usrgrpobjid integer not null,
	executeaccess char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harstateprocessaccess to btree unique on
	stateobjid,
	processobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harstateprocessaccess () from 'harstateprocessaccess.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harstateprocessaccess
\p\g
create table harswitchpkgproc(
	processobjid integer not null,
	processname char(128) not null,
	stateobjid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harswitchpkgproc to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harswitchpkgproc () from 'harswitchpkgproc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harswitchpkgproc
\p\g
create table harsync(
	syncobjid integer not null,
	packageobjid integer not null default 0,
	configobjid integer,
	synctime date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harsync to btree unique on
	syncobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harsync () from 'harsync.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harsync
\p\g
create table harsyncconfig(
	configobjid integer not null,
	siteobjid integer not null default 0,
	envobjid integer not null default 0,
	stateobjid integer not null default 0,
	viewpathobjid integer not null default 0,
	remoteenv char(44) not null default 'N/A',
	remotestate char(44) not null default 'N/A',
	remoteviewpath varchar(300) not null default 'N/A',
	checkout_br_id integer,
	checkout_up_id integer,
	checkin_id integer,
	crpkg_id integer,
	remitem_id integer,
	pkgname char(25)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harsyncconfig to btree unique on
	configobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harsyncconfig () from 'harsyncconfig.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harsyncconfig
\p\g
create table harsyncfullpath(
	pathobjid integer not null,
	hostpath varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harsyncfullpath to btree unique on
	pathobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harsyncfullpath () from 'harsyncfullpath.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harsyncfullpath
\p\g
create table hartableinfo(
	versionindicator integer not null,
	casesenslogin char(1) not null default 'Y',
	databaseid integer not null default 0,
	authenticateuser char(1) not null default 'Y',
	sysvarpw char(1) not null default 'N'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify hartableinfo to heap
with extend = 16,
	allocation = 4
\p\g
/* copy hartableinfo () from 'hartableinfo.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on hartableinfo
\p\g
create table hartestinginfo(
	formobjid integer not null,
	devdate date,
	testdate date,
	developer char(44),
	tester char(44),
	devcomments varchar(2000),
	testcomments varchar(2000),
	testcases varchar(2000),
	testresults varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify hartestinginfo to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy hartestinginfo () from 'hartestinginfo.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on hartestinginfo
\p\g
create table harudp(
	processobjid integer not null,
	processname char(128) not null,
	parentprocobjid integer,
	stateobjid integer,
	outputtarget char(8) not null,
	onerroraction char(8) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	description varchar(255),
	programname varchar(255),
	inputparm varchar(2000),
	note varchar(2000),
	secureudpinput char(1) not null,
	udptype char(8) not null
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harudp to btree unique on
	processobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harudp () from 'harudp.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harudp
\p\g
create table haruser(
	usrobjid integer not null,
	username char(32) not null,
	logindate date,
	lastlogin date,
	loggedin char(1) not null,
	realname char(128),
	phonenumber char(32),
	extension char(8),
	faxnumber char(32),
	encryptpsswd char(32),
	passwdattrs integer not null default 0,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	email varchar(128),
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify haruser to btree unique on
	usrobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy haruser () from 'haruser.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on haruser
\p\g
create table harusercontact(
	formobjid integer not null,
	contactextension char(12),
	zip char(12),
	contactphone char(32),
	state char(32),
	city varchar(66),
	contactfax varchar(66),
	contactname varchar(66),
	contacttitle varchar(66),
	country varchar(66),
	position varchar(66),
	mailstop varchar(130),
	organization varchar(130),
	address varchar(257)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harusercontact to btree unique on
	formobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harusercontact () from 'harusercontact.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harusercontact
\p\g
create table haruserdata(
	usrobjid integer not null,
	encryptpsswd long byte,
	failures integer not null default 0,
	psswdtime date,
	maxage integer default -2
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify haruserdata to btree on
	usrobjid
with nonleaffill = 70,
	leaffill = 80,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy haruserdata () from 'haruserdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on haruserdata
\p\g
create table harusergroup(
	usrgrpobjid integer not null,
	usergroupname char(128) not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harusergroup to btree unique on
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harusergroup () from 'harusergroup.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harusergroup
\p\g
create table harusersingroup(
	usrobjid integer not null,
	usrgrpobjid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harusersingroup to btree unique on
	usrobjid,
	usrgrpobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harusersingroup () from 'harusersingroup.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harusersingroup
\p\g
create table harversiondata(
	versiondataobjid integer not null,
	refcounter integer not null default 0,
	datasize integer not null,
	compressed char(1) not null,
	compdatasize integer not null default 0,
	fileaccess char(9),
	modifytime date,
	createtime date,
	dcb varchar(256),
	textfile integer not null,
	itemobjid integer not null default 0,
	versiondata long byte
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harversiondata to btree unique on
	versiondataobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy harversiondata () from 'harversiondata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harversiondata
\p\g
create table harversiondelta(
	childversiondataid integer not null,
	parentversiondataid integer not null,
	deltasize integer not null,
	versiondelta long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify harversiondelta to btree unique on
	childversiondataid,
	parentversiondataid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy harversiondelta () from 'harversiondelta.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harversiondelta
\p\g
create table harversioninview(
	viewobjid integer not null,
	versionobjid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify harversioninview to btree unique on
	viewobjid,
	versionobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy harversioninview () from 'harversioninview.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harversioninview
\p\g
create table harversions(
	versionobjid integer not null,
	itemobjid integer not null,
	packageobjid integer not null,
	parentversionid integer not null,
	mergedversionid integer not null,
	inbranch integer not null,
	mappedversion char(16),
	versionstatus char(1),
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	description varchar(2000),
	versiondataobjid integer not null,
	clientmachine varchar(50),
	clientpath varchar(1024),
	ancestorversionid integer not null default 0
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harversions to btree unique on
	versionobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harversions () from 'harversions.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harversions
\p\g
create table harvest_subpackage_actions(
	sp_id integer not null,
	ep_id integer not null,
	harvest_state integer not null,
	promote_processid integer not null,
	promote_processname char(60),
	demote_processid integer not null,
	demote_processname char(60),
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify harvest_subpackage_actions to btree unique on
	sp_id,
	ep_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy harvest_subpackage_actions () from 'harvest_subpackage_actions.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harvest_subpackage_actions
\p\g
create table harview(
	viewobjid integer not null,
	viewname char(128) not null,
	viewtype char(16) not null,
	envobjid integer not null,
	canviewexternally char(1) not null,
	baselineviewid integer not null,
	creationtime date not null,
	creatorid integer not null,
	modifiedtime date not null,
	modifierid integer not null,
	snapshottime date,
	note varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify harview to btree unique on
	viewobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	compression = (nokey, data),
	unique_scope = statement
\p\g
/* copy harview () from 'harview.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on harview
\p\g
create table hex2decimal(
	hexvalue varchar(3),
	intvalue varchar(4)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify hex2decimal to heap
with extend = 16,
	allocation = 4
\p\g
/* copy hex2decimal () from 'hex2decimal.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on hex2decimal
\p\g
create table hier(
	id integer not null,
	persid varchar(30),
	hier_parent byte varying(16) not null,
	hier_child byte varying(16) not null,
	hier_log_date integer not null,
	hier_license_num varchar(40),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify hier to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy hier () from 'hier.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on hier
\p\g
create table hist_det(
	hist_det_id decimal(5,0) not null,
	hist_head_id decimal(5,0),
	row_nbr decimal(5,0),
	bucket decimal(5,0),
	endpoint decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify hist_det to btree unique on
	hist_det_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy hist_det () from 'hist_det.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on hist_det
\p\g
create table hist_head(
	hist_head_id decimal(5,0) not null,
	collect_id decimal(5,0),
	table_id decimal(5,0),
	column_name varchar(30),
	bucket_cnt decimal(5,0),
	row_cnt decimal(5,0),
	cache_cnt decimal(5,0),
	null_cnt decimal(5,0),
	sample_size decimal(5,0),
	minimum decimal(5,0),
	maximum decimal(5,0),
	dist_cnt decimal(5,0),
	low_val byte(32),
	high_val byte(32),
	density decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify hist_head to btree unique on
	hist_head_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy hist_head () from 'hist_head.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on hist_head
\p\g
create table holiday(
	holiday_date date not null,
	holiday_name varchar(1200),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify holiday to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy holiday () from 'holiday.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on holiday
\p\g
create table iam_attribute(
	object_guid varchar(128) not null,
	attribute_name varchar(255) not null,
	attribute_value long varchar,
	attribute_shortvalue varchar(255),
	attribute_order integer not null,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify iam_attribute to heap
with extend = 16,
	allocation = 4
\p\g
/* copy iam_attribute () from 'iam_attribute.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on iam_attribute
\p\g
create table iam_object(
	object_guid varchar(128) not null,
	object_name varchar(50) not null,
	location_name varchar(255) not null,
	object_class varchar(16) not null,
	object_link varchar(255),
	product_instance_name varchar(50),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify iam_object to heap
with extend = 16,
	allocation = 4
\p\g
/* copy iam_object () from 'iam_object.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on iam_object
\p\g
create table icat_grp(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify icat_grp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy icat_grp () from 'icat_grp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on icat_grp
\p\g
create table icat_loc(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify icat_loc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy icat_loc () from 'icat_loc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on icat_loc
\p\g
create table icat_wrkshft(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify icat_wrkshft to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy icat_wrkshft () from 'icat_wrkshft.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on icat_wrkshft
\p\g
create table identifier(
	id_type char(1) not null,
	id integer not null,
	filler1 char(255) not null,
	filler2 char(255) not null,
	filler3 char(255) not null,
	filler4 char(255) not null,
	filler5 char(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify identifier to btree unique on
	id_type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy identifier () from 'identifier.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on identifier
\p\g
create table idmanager(
	idname varchar(15) not null,
	lastvalue integer not null,
	checkouttime integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify idmanager to btree unique on
	idname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy idmanager () from 'idmanager.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on idmanager
\p\g
create table impact(
	id integer not null,
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	value integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify impact to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy impact () from 'impact.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on impact
\p\g
create table import_rules(
	rule_name varchar(100) not null,
	import_rule long varchar not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify import_rules to btree unique on
	rule_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy import_rules () from 'import_rules.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on import_rules
\p\g
create table increment_highval(
	entryid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify increment_highval to heap
with extend = 16,
	allocation = 4
\p\g
/* copy increment_highval () from 'increment_highval.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on increment_highval
\p\g
create table increment_id(
	owner_name varchar(1200) not null,
	last_used_id decimal(31,0),
	next_avail_id decimal(31,0),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify increment_id to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy increment_id () from 'increment_id.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on increment_id
\p\g
create table index_doc_links(
	id integer not null,
	doc_id integer,
	index_id integer,
	relational_id varchar(255),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify index_doc_links to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy index_doc_links () from 'index_doc_links.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on index_doc_links
\p\g
create table indextable(
	componentmibindexidx integer not null,
	typeofindexretrieval c1 not null,
	indexbaseoid varchar(128) not null,
	indexstartloc integer not null,
	indexlength float not null,
	coloidid varchar(32) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify indextable to heap
with extend = 16,
	allocation = 4
\p\g
/* copy indextable () from 'indextable.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on indextable
\p\g
create integrity  ON IndexTable IS TypeOfIndexRetrieval IN ('V', 'E')
\p\g
create table info(
	maxeid integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify info to btree unique on
	maxeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy info () from 'info.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on info
\p\g
create table infohis(
	adomid integer not null,
	apid integer not null,
	sttotal integer not null,
	acid integer,
	stdate integer,
	sttime integer,
	enddate integer,
	endtime integer,
	endtotal integer,
	apflag integer,
	domainid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify infohis to btree unique on
	apid,
	sttotal,
	adomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy infohis () from 'infohis.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on infohis
\p\g
create table infolng(
	domainid integer not null,
	unitid integer not null,
	itnameid integer not null,
	itprid integer not null,
	itrootid integer,
	itrtnmid integer,
	itprnmid integer,
	itidx integer,
	ittype integer,
	itval integer,
	itpval integer,
	itdate integer,
	itlock integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify infolng to btree unique on
	unitid,
	domainid,
	itprid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy infolng () from 'infolng.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on infolng
\p\g
create table infoqlt(
	domainid integer,
	itrtnmid integer,
	itrtname varchar(127),
	itprnmid integer,
	itprname varchar(127),
	itgrnmid integer,
	itgrname varchar(127),
	itgrrwnm varchar(127),
	itident integer,
	itflag integer,
	itnameid integer,
	itname varchar(127),
	ittbl integer,
	ittype integer,
	utype integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify infoqlt to btree on
	itident
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy infoqlt () from 'infoqlt.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on infoqlt
\p\g
create table infotrid(
	domainid integer not null,
	unitid integer not null,
	itid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify infotrid to btree unique on
	unitid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy infotrid () from 'infotrid.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on infotrid
\p\g
create table input(
	product_instance_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	tool_id decimal(31,0),
	product_path varchar(4000),
	is_mandatory smallint,
	is_external smallint,
	logical_delete_flag smallint,
	deleted_for_link integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify input to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy input () from 'input.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on input
\p\g
create table instance_history(
	processid varchar(20) not null default '',
	nodeid varchar(20) not null default '',
	type integer not null default -1,
	timestamp float not null,
	workitemid varchar(30) default NULL,
	actorname varchar(50) default NULL,
	info varchar(50) default NULL
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify instance_history to heap
with extend = 16,
	allocation = 4
\p\g
/* copy instance_history () from 'instance_history.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on instance_history
\p\g
create table instances(
	id varchar(20) not null,
	definitionid varchar(20) not null,
	content long byte,
	externals long byte,
	started float,
	completed float,
	status integer,
	name varchar(50),
	description varchar(200)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify instances to heap
with extend = 16,
	allocation = 4
\p\g
/* copy instances () from 'instances.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on instances
\p\g
create table intcodes(
	fld varchar(30),
	code integer,
	text varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify intcodes to btree unique on
	fld,
	code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy intcodes () from 'intcodes.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on intcodes
\p\g
create table interface(
	id integer not null,
	sym varchar(30) not null,
	code varchar(10) not null,
	persid varchar(30),
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	nx_desc varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify interface to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy interface () from 'interface.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on interface
\p\g
create table interfacechange(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	ifindex integer not null,
	ifdescr varchar(255),
	ifname varchar(255),
	oldifindex integer,
	oldifdescr varchar(255),
	oldifname varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify interfacechange to heap
with extend = 16,
	allocation = 4
\p\g
/* copy interfacechange () from 'interfacechange.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on interfacechange
\p\g
create table inv_default_item(
	object_uuid byte(16) not null,
	item_parent_id integer not null,
	item_name_id integer not null,
	item_root_id integer,
	item_root_name_id integer,
	item_parent_name_id integer,
	item_index integer,
	item_type integer,
	item_format integer,
	item_value_text varchar(384),
	item_previous_value_text varchar(384),
	item_value_long integer,
	item_previous_value_long integer,
	item_value_double f4,
	item_previous_value_double f4,
	item_date integer,
	item_lock integer,
	rep_count byte(8),
	domain_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_default_item to btree unique on
	object_uuid,
	item_name_id,
	item_parent_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_default_item () from 'inv_default_item.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_default_item
\p\g
create table inv_default_tree(
	object_uuid byte(16) not null,
	item_id integer not null,
	item_root_id integer,
	item_root_name_id integer,
	item_parent_id integer,
	item_parent_name_id integer,
	item_indent integer,
	item_index integer,
	item_flag integer,
	domain_uuid byte(16),
	item_name_id integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_default_tree to btree unique on
	object_uuid,
	item_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_default_tree () from 'inv_default_tree.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_default_tree
\p\g
create table inv_generalinventory_item(
	object_uuid byte(16) not null,
	item_parent_id integer not null,
	item_name_id integer not null,
	item_root_id integer,
	item_root_name_id integer,
	item_parent_name_id integer,
	item_index integer,
	item_type integer,
	item_format integer,
	item_value_text varchar(384),
	item_previous_value_text varchar(384),
	item_value_long integer,
	item_previous_value_long integer,
	item_value_double f4,
	item_previous_value_double f4,
	item_date integer,
	item_lock integer,
	domain_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_generalinventory_item to btree unique on
	object_uuid,
	item_name_id,
	item_parent_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_generalinventory_item () from 'inv_generalinventory_item.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_generalinventory_item
\p\g
create table inv_generalinventory_tree(
	object_uuid byte(16) not null,
	item_id integer not null,
	item_root_id integer,
	item_parent_id integer,
	item_parent_name_id integer,
	item_indent integer,
	item_index integer,
	item_flag integer,
	item_root_name_id integer,
	domain_uuid byte(16),
	item_name_id integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_generalinventory_tree to btree unique on
	object_uuid,
	item_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_generalinventory_tree () from 'inv_generalinventory_tree.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_generalinventory_tree
\p\g
create table inv_item_name_id(
	domain_uuid byte(16) not null,
	item_name_id integer not null,
	item_name varchar(384) not null,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_item_name_id to btree unique on
	domain_uuid,
	item_name_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_item_name_id () from 'inv_item_name_id.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_item_name_id
\p\g
create table inv_object_tree_id(
	object_uuid byte(16) not null,
	tree_id integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_object_tree_id to btree unique on
	object_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_object_tree_id () from 'inv_object_tree_id.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_object_tree_id
\p\g
create table inv_reconcile_item(
	object_uuid byte(16) not null,
	item_parent_id integer not null,
	item_name_id integer not null,
	item_root_id integer,
	item_root_name_id integer,
	item_parent_name_id integer,
	item_index integer,
	item_type integer,
	item_format integer,
	item_value_text nvarchar(384),
	item_previous_value_text nvarchar(384),
	item_value_long integer,
	item_previous_value_long integer,
	item_value_double f4,
	item_previous_value_double f4,
	item_date integer,
	item_lock integer,
	domain_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_reconcile_item to btree unique on
	object_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_reconcile_item () from 'inv_reconcile_item.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_reconcile_item
\p\g
create table inv_reconcile_tree(
	object_uuid byte(16) not null,
	item_id integer not null,
	item_root_id integer,
	item_parent_id integer,
	item_parent_name_id integer,
	item_indent integer,
	item_index integer,
	item_flag integer,
	item_root_name_id integer,
	domain_uuid byte(16),
	item_name_id integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_reconcile_tree to btree unique on
	object_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_reconcile_tree () from 'inv_reconcile_tree.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_reconcile_tree
\p\g
create table inv_root_map(
	item_root_name_id integer not null,
	object_uuid byte(16) not null,
	domain_uuid byte(16),
	item_id integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_root_map to btree unique on
	object_uuid,
	item_root_name_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_root_map () from 'inv_root_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_root_map
\p\g
create table inv_table_map(
	domain_uuid byte(16) not null,
	component_name varchar(384) not null,
	component_name_id integer not null,
	table_name_tree varchar(32) not null,
	table_name_item varchar(32) not null,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_table_map to btree unique on
	domain_uuid,
	component_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_table_map () from 'inv_table_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_table_map
\p\g
create table inv_tree_name_id(
	domain_uuid byte(16) not null,
	tree_name_id integer not null,
	tree_name varchar(384) not null,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify inv_tree_name_id to btree unique on
	domain_uuid,
	tree_name_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy inv_tree_name_id () from 'inv_tree_name_id.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inv_tree_name_id
\p\g
create table inventory_profile(
	inventory_profile_id byte(16) not null,
	profile_type nvarchar(2),
	name nvarchar(255),
	description long nvarchar,
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify inventory_profile to btree unique on
	inventory_profile_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy inventory_profile () from 'inventory_profile.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on inventory_profile
\p\g
create table investigation(
	name varchar(32) not null,
	status i1,
	event_scope varchar(768),
	anomaly_scope varchar(768)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify investigation to heap
with extend = 16,
	allocation = 4
\p\g
/* copy investigation () from 'investigation.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on investigation
\p\g
create table investigation_history(
	investigation_name varchar(32),
	timestamp date,
	administrator varchar(32),
	note_text varchar(1536)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify investigation_history to heap
with extend = 16,
	allocation = 4
\p\g
/* copy investigation_history () from 'investigation_history.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on investigation_history
\p\g
create table investigation_person(
	investigation_name varchar(32),
	person_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify investigation_person to heap
with extend = 16,
	allocation = 4
\p\g
/* copy investigation_person () from 'investigation_person.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on investigation_person
\p\g
create table invgene(
	domainid integer not null,
	unittype integer not null,
	gindex integer not null,
	gid varchar(127),
	dname varchar(127) not null,
	iconkey varchar(20)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify invgene to btree unique on
	gindex,
	unittype,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy invgene () from 'invgene.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on invgene
\p\g
create table invsetup(
	domainid integer not null,
	invid integer not null,
	invname varchar(127),
	invfname varchar(50),
	invmemo text(1),
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify invsetup to btree unique on
	invid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy invsetup () from 'invsetup.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on invsetup
\p\g
create table ipobject(
	objectid integer not null,
	userid integer not null,
	objectname varchar(32) not null,
	objecttype i1 not null,
	objectnote varchar(255),
	objectfolderid integer not null,
	objectcreatedtime date not null,
	objectlastmodifytime date not null,
	objectmodifierid integer not null,
	objectmodifierinstance integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ipobject to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ipobject () from 'ipobject.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ipobject
\p\g
create table ipprovider(
	providerid integer not null,
	deviceid integer,
	providertype smallint not null,
	oneconnperreq i1,
	onereqatatime i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ipprovider to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ipprovider () from 'ipprovider.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ipprovider
\p\g
create table iprequest(
	requestid integer not null,
	calcserverid integer,
	compilestatus i1 not null,
	lastupdatetime date,
	calctype i1 not null,
	calcminute i1,
	calchour i1,
	calcdow i1,
	calcday i1,
	calcmonth i1,
	calccount smallint,
	calcstarttime date,
	calcendtime date,
	requestscript long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify iprequest to heap
with extend = 16,
	allocation = 4
\p\g
/* copy iprequest () from 'iprequest.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on iprequest
\p\g
create table iprequestcode(
	requestid integer not null,
	compiledscript long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify iprequestcode to heap
with extend = 16,
	allocation = 4
\p\g
/* copy iprequestcode () from 'iprequestcode.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on iprequestcode
\p\g
create table ipuser(
	userid integer not null,
	username varchar(32) not null,
	usertype i1 not null,
	usergroupid integer,
	lastlogintime date,
	capabilities integer,
	usernote varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ipuser to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ipuser () from 'ipuser.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ipuser
\p\g
create table iss_template(
	id integer not null,
	persid varchar(30),
	del integer not null,
	template_name varchar(30) not null,
	description varchar(1000),
	template varchar(30),
	template_class varchar(12),
	quick_tmpl_type integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify iss_template to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy iss_template () from 'iss_template.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on iss_template
\p\g
create table issalg(
	id integer not null,
	persid varchar(30),
	issue_id varchar(30),
	last_mod_dt integer,
	time_spent integer,
	time_stamp integer,
	system_time integer,
	analyst byte varying(16),
	description long varchar,
	action_desc long varchar,
	type varchar(12),
	internal integer,
	knowledge_session varchar(80),
	knowledge_tool varchar(12)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify issalg to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy issalg () from 'issalg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on issalg
\p\g
create table isscat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	code varchar(12) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	organization byte varying(16),
	assignee byte varying(16),
	group_id byte varying(16),
	children_ok integer not null,
	service_type varchar(30),
	survey integer,
	schedule integer,
	auto_assign integer,
	owning_contract integer,
	cawf_defid integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify isscat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy isscat () from 'isscat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on isscat
\p\g
create table issprp(
	id integer not null,
	persid varchar(30),
	sequence integer not null,
	label varchar(80),
	description varchar(240),
	value varchar(240),
	required integer,
	sample varchar(240),
	owning_iss varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify issprp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy issprp () from 'issprp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on issprp
\p\g
create table issstat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	code varchar(12) not null,
	active integer,
	hold integer,
	resolved integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify issstat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy issstat () from 'issstat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on issstat
\p\g
create table issue(
	id integer not null,
	persid varchar(30),
	ref_num varchar(30) not null,
	summary varchar(240),
	description long varchar,
	status varchar(12),
	active_flag integer not null,
	start_date integer,
	open_date integer,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	close_date integer,
	resolve_date integer,
	rootcause integer,
	est_total_time integer,
	actual_total_time integer,
	log_agent byte varying(16) not null,
	assignee byte varying(16),
	organization byte varying(16),
	group_id byte varying(16),
	affected_contact byte varying(16),
	requestor byte varying(16) not null,
	category varchar(12),
	priority integer not null,
	need_by integer,
	est_comp_date integer,
	actual_comp_date integer,
	est_cost integer,
	actual_cost integer,
	justification varchar(240),
	backout_plan varchar(240),
	impact integer,
	parent varchar(30),
	effort varchar(240),
	support_lev varchar(30),
	template_name varchar(30),
	sla_violation integer,
	predicted_sla_viol integer,
	macro_predict_viol integer,
	created_via integer,
	call_back_date integer,
	call_back_flag integer,
	string1 varchar(40),
	string2 varchar(40),
	string3 varchar(40),
	string4 varchar(40),
	string5 varchar(40),
	string6 varchar(40),
	service_date integer,
	service_num varchar(30),
	product integer,
	actions varchar(750),
	type_of_contact integer,
	reporting_method integer,
	person_contacting integer,
	flag1 integer,
	flag2 integer,
	flag3 integer,
	flag4 integer,
	flag5 integer,
	flag6 integer,
	user1 varchar(100),
	user2 varchar(100),
	user3 varchar(100),
	cawf_procid integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify issue to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy issue () from 'issue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on issue
\p\g
create table isswf(
	id integer not null,
	persid varchar(30),
	del integer not null,
	object_type varchar(30) not null,
	object_id varchar(30) not null,
	task varchar(12) not null,
	wf_template integer,
	sequence integer not null,
	status varchar(12),
	group_task integer not null,
	asset byte varying(16),
	creator byte varying(16),
	date_created integer,
	assignee byte varying(16),
	group_id byte varying(16),
	support_lev varchar(30),
	done_by byte varying(16),
	start_date integer,
	est_comp_date integer,
	completion_date integer,
	est_duration integer,
	actual_duration integer,
	est_cost integer,
	cost integer,
	description varchar(1000),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify isswf to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy isswf () from 'isswf.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on isswf
\p\g
create table itfcconfig(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	itfcindex integer,
	itfcsubindex integer,
	itfctype i1,
	itfcspeed float,
	itfcdescr varchar(255),
	itfcgroupid smallint,
	collreq i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify itfcconfig to hash unique on
	probe_addr,
	itfcindex
with fillfactor = 50,
	extend = 4
\p\g
/* copy itfcconfig () from 'itfcconfig.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on itfcconfig
\p\g
create table itfcconfighist(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	itfcindex integer,
	itfcspeed float,
	itfcname varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify itfcconfighist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy itfcconfighist () from 'itfcconfighist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on itfcconfighist
\p\g
create table itrm_history(
	deletflag integer,
	phyuuid byte(16)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify itrm_history to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy itrm_history () from 'itrm_history.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on itrm_history
\p\g
create table jmo_gbl(
	gbl_name char(8) not null,
	gbl_adate integer,
	gbl_atime integer,
	gbl_ldate integer,
	gbl_ltime integer,
	gbl_ndate integer,
	gbl_ntime integer,
	gbl_fdate integer,
	gbl_ftime integer,
	next_rpt char(3),
	gbl_ltype byte(1),
	gbl_flag1 byte(1),
	act_trkset char(1) not null default 'P',
	prescan_min integer,
	prescan_max integer,
	prescan_total integer,
	prescan_cnt integer
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_gbl to btree unique on
	gbl_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy jmo_gbl () from 'jmo_gbl.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_gbl
\p\g
create table jmo_gbls(
	gbl_name char(8) not null,
	gbl_adate integer,
	gbl_atime integer,
	gbl_ldate integer,
	gbl_ltime integer,
	gbl_ndate integer,
	gbl_ntime integer,
	gbl_fdate integer,
	gbl_ftime integer,
	next_rpt char(3),
	gbl_ltype byte(1),
	gbl_flag1 byte(1),
	act_trkset char(1) not null default 'P',
	prescan_min integer,
	prescan_max integer,
	prescan_total integer,
	prescan_cnt integer
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_gbls to btree unique on
	gbl_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy jmo_gbls () from 'jmo_gbls.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_gbls
\p\g
create table jmo_gen(
	scp_key char(8) not null,
	scj_prty char(2),
	scg_en1 byte(1),
	scg_en2 byte(1),
	scg_en6 char(1),
	sca_utotm integer,
	sca_utoit smallint,
	scw_s varchar(21),
	scd_tab varchar(8),
	sch_istc smallint,
	scm_xaudt smallint,
	scq_name varchar(32),
	scm_axpsr smallint,
	scm_axinp smallint,
	scm_axres smallint
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_gen to btree unique on
	scp_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy jmo_gen () from 'jmo_gen.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_gen
\p\g
create table jmo_gens(
	sim_key char(4),
	scp_key char(8) not null,
	scj_prty char(2),
	scg_en1 byte(1),
	scg_en2 byte(1),
	scg_en6 char(1),
	sca_utotm integer,
	sca_utoit smallint,
	scw_s varchar(21),
	scd_tab varchar(8),
	sch_istc smallint,
	scm_xaudt smallint,
	scq_name varchar(32),
	scm_axpsr smallint,
	scm_axinp smallint,
	scm_axres smallint
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_gens to btree unique on
	scp_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy jmo_gens () from 'jmo_gens.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_gens
\p\g
create table jmo_hstu(
	hst_scdn char(65) not null,
	hst_name char(65) not null,
	hst_jno char(5) not null
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_hstu to btree unique on
	hst_scdn,
	hst_name,
	hst_jno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_hstu () from 'jmo_hstu.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_hstu
\p\g
create table jmo_jbr(
	jbr_scdn char(65) not null,
	jbr_name char(65) not null,
	jbr_jno char(5) not null,
	jbr_ws char(21),
	jbr_jobtyp char(1),
	jbr_any byte(1),
	jbr_subu varchar(33),
	jbr_abscd varchar(65),
	jbr_jprty char(2),
	jbr_abct integer,
	jbr_cal varchar(9),
	jbr_erly integer,
	jbr_must integer,
	jbr_dedln integer,
	jbr_mxtim integer,
	jbr_avg integer,
	jbr_effdt integer,
	jbr_expdt integer,
	jbr_histc smallint,
	jbr_flg1 byte(1),
	jbr_bklog byte(1),
	jbr_recs1 char(1),
	jbr_desc varchar(255),
	jbr_subfile varchar(255),
	jbr_creus varchar(33),
	jbr_credt integer,
	jbr_cretm integer,
	jbr_lusdt integer,
	jbr_lustm integer,
	jbr_user varchar(33),
	jbr_skip integer,
	jbr_faill integer,
	jbr_failh integer,
	jbr_subp varchar(15),
	jbr_domain varchar(16),
	jbr_cycle char(1),
	jbr_freq integer,
	jbr_count integer,
	jbr_ccal varchar(9),
	jbr_cri varchar(255),
	jbr_hact char(2),
	jbr_nwact char(2),
	jbr_cadj varchar(5),
	jbr_sutyp char(1),
	jbr_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_jbr to btree unique on
	jbr_scdn,
	jbr_name,
	jbr_jno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_jbr () from 'jmo_jbr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_jbr
\p\g
create table jmo_jhr(
	jhr_jschd char(65) not null,
	jhr_name char(65) not null,
	jhr_jno char(5) not null,
	jhr_key char(12),
	jhr_ws varchar(21),
	jhr_avcpu integer,
	jhr_hcnt smallint,
	jhr_erdt integer,
	jhr_msdt integer,
	jhr_deddt integer,
	jhr_adate integer,
	jhr_vdate integer,
	jhr_sdate integer,
	jhr_edate integer,
	jhr_ertm integer,
	jhr_mstm integer,
	jhr_dedtm integer,
	jhr_atime integer,
	jhr_vtime integer,
	jhr_stime integer,
	jhr_etime integer,
	jhr_relpt integer,
	jhr_rcput integer,
	jhr_code integer,
	jhr_qual char(4),
	jhr_stat byte(1),
	jhr_late char(1),
	jhr_cmrun varchar(33),
	jhr_cmhld varchar(33),
	jhr_cmrls varchar(33),
	jhr_cmcnc varchar(33),
	jhr_cmfrc varchar(33),
	jhr_cmstr varchar(33),
	jhr_cmcmp varchar(33),
	jhr_pid integer,
	jhr_jes integer,
	jhr_sysid varchar(65),
	jhr_avelp integer,
	jhr_subjno varchar(15),
	jhr_qname char(2)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_jhr to btree unique on
	jhr_jschd,
	jhr_name,
	jhr_jno,
	jhr_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_jhr () from 'jmo_jhr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_jhr
\p\g
create table jmo_jtr(
	jtr_scdn char(65) not null,
	jtr_name char(65) not null,
	jtr_jno char(5) not null,
	jtr_qual char(5) not null,
	jtr_ows varchar(21),
	jtr_ws varchar(21),
	jtr_subu varchar(33),
	jtr_subfile varchar(255),
	jtr_abscd varchar(65),
	jtr_avgtb integer,
	jtr_any byte(1),
	jtr_uxjno integer,
	jtr_erly integer,
	jtr_must integer,
	jtr_dedln integer,
	jtr_mxtim integer,
	jtr_avgt integer,
	jtr_flg1 byte(1),
	jtr_bklog byte(1),
	jtr_sutyp byte(1),
	jtr_wstyp char(1),
	jtr_desc varchar(255),
	jtr_newpr char(2),
	jtr_histc smallint,
	jtr_fordate integer,
	jtr_erdt integer,
	jtr_mudt integer,
	jtr_dedt integer,
	jtr_mxdt integer,
	jtr_adate integer,
	jtr_vdate integer,
	jtr_sdate integer,
	jtr_edate integer,
	jtr_pdate integer,
	jtr_atime integer,
	jtr_vtime integer,
	jtr_stime integer,
	jtr_etime integer,
	jtr_ptime integer,
	jtr_dprty integer,
	jtr_comp integer,
	jtr_cput integer,
	jtr_pid integer,
	jtr_cc varchar(9),
	jtr_hstat byte(1),
	jtr_rstat byte(1),
	jtr_flg3 byte(1),
	jtr_flg4 byte(1),
	jtr_flg5 byte(1),
	jtr_cmrun varchar(33),
	jtr_cmhld varchar(33),
	jtr_cmrls varchar(33),
	jtr_cmcnc varchar(33),
	jtr_cmfrc varchar(33),
	jtr_cmstr varchar(33),
	jtr_cmcmp varchar(33),
	jtr_luser varchar(33),
	jtr_cal varchar(9),
	jtr_cmsub varchar(33),
	jtr_abcnt integer,
	jtr_alias varchar(65),
	jtr_nodea varchar(65),
	jtr_emsg char(4),
	jtr_faill integer,
	jtr_failh integer,
	jtr_subp varchar(15),
	jtr_domain varchar(16),
	jtr_cycle char(1),
	jtr_freq integer,
	jtr_count integer,
	jtr_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_jtr to btree unique on
	jtr_scdn,
	jtr_name,
	jtr_jno,
	jtr_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_jtr () from 'jmo_jtr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_jtr
\p\g
create table jmo_jtr1(
	jtr_scdn char(65) not null,
	jtr_name char(65) not null,
	jtr_jno char(5) not null,
	jtr_qual char(5) not null,
	jtr_ows varchar(21),
	jtr_ws varchar(21),
	jtr_subu varchar(33),
	jtr_subfile varchar(255),
	jtr_abscd varchar(65),
	jtr_avgtb integer,
	jtr_any byte(1),
	jtr_uxjno integer,
	jtr_erly integer,
	jtr_must integer,
	jtr_dedln integer,
	jtr_mxtim integer,
	jtr_avgt integer,
	jtr_flg1 byte(1),
	jtr_bklog byte(1),
	jtr_sutyp byte(1),
	jtr_wstyp char(1),
	jtr_desc varchar(255),
	jtr_newpr char(2),
	jtr_histc smallint,
	jtr_fordate integer,
	jtr_erdt integer,
	jtr_mudt integer,
	jtr_dedt integer,
	jtr_mxdt integer,
	jtr_adate integer,
	jtr_vdate integer,
	jtr_sdate integer,
	jtr_edate integer,
	jtr_pdate integer,
	jtr_atime integer,
	jtr_vtime integer,
	jtr_stime integer,
	jtr_etime integer,
	jtr_ptime integer,
	jtr_dprty integer,
	jtr_comp integer,
	jtr_cput integer,
	jtr_pid integer,
	jtr_cc varchar(9),
	jtr_hstat byte(1),
	jtr_rstat byte(1),
	jtr_flg3 byte(1),
	jtr_flg4 byte(1),
	jtr_flg5 byte(1),
	jtr_cmrun varchar(33),
	jtr_cmhld varchar(33),
	jtr_cmrls varchar(33),
	jtr_cmcnc varchar(33),
	jtr_cmfrc varchar(33),
	jtr_cmstr varchar(33),
	jtr_cmcmp varchar(33),
	jtr_luser varchar(33),
	jtr_cal varchar(9),
	jtr_cmsub varchar(33),
	jtr_abcnt integer,
	jtr_alias varchar(65),
	jtr_nodea varchar(65),
	jtr_emsg char(4),
	jtr_faill integer,
	jtr_failh integer,
	jtr_subp varchar(15),
	jtr_domain varchar(16),
	jtr_cycle char(1),
	jtr_freq integer,
	jtr_count integer,
	jtr_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_jtr1 to btree unique on
	jtr_scdn,
	jtr_name,
	jtr_jno,
	jtr_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_jtr1 () from 'jmo_jtr1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_jtr1
\p\g
create table jmo_jtrs(
	sim_key char(4) not null,
	jtr_scdn char(65) not null,
	jtr_name char(65) not null,
	jtr_jno char(5) not null,
	jtr_qual char(5) not null,
	jtr_ows varchar(21),
	jtr_ws varchar(21),
	jtr_subu varchar(33),
	jtr_subfile varchar(255),
	jtr_abscd varchar(65),
	jtr_avgtb integer,
	jtr_any byte(1),
	jtr_uxjno integer,
	jtr_erly integer,
	jtr_must integer,
	jtr_dedln integer,
	jtr_mxtim integer,
	jtr_avgt integer,
	jtr_flg1 byte(1),
	jtr_bklog byte(1),
	jtr_sutyp byte(1),
	jtr_wstyp char(1),
	jtr_desc varchar(255),
	jtr_newpr char(2),
	jtr_histc smallint,
	jtr_fordate integer,
	jtr_erdt integer,
	jtr_mudt integer,
	jtr_dedt integer,
	jtr_mxdt integer,
	jtr_adate integer,
	jtr_vdate integer,
	jtr_sdate integer,
	jtr_edate integer,
	jtr_pdate integer,
	jtr_atime integer,
	jtr_vtime integer,
	jtr_stime integer,
	jtr_etime integer,
	jtr_ptime integer,
	jtr_dprty integer,
	jtr_comp integer,
	jtr_cput integer,
	jtr_pid integer,
	jtr_cc varchar(9),
	jtr_hstat byte(1),
	jtr_rstat byte(1),
	jtr_flg3 byte(1),
	jtr_flg4 byte(1),
	jtr_flg5 byte(1),
	jtr_cmrun varchar(33),
	jtr_cmhld varchar(33),
	jtr_cmrls varchar(33),
	jtr_cmcnc varchar(33),
	jtr_cmfrc varchar(33),
	jtr_cmstr varchar(33),
	jtr_cmcmp varchar(33),
	jtr_luser varchar(33),
	jtr_cal varchar(9),
	jtr_cmsub varchar(33),
	jtr_abcnt integer,
	jtr_alias varchar(65),
	jtr_nodea varchar(65),
	jtr_emsg char(4),
	jtr_faill integer,
	jtr_failh integer,
	jtr_subp varchar(15),
	jtr_domain varchar(16),
	jtr_cycle char(1),
	jtr_freq integer,
	jtr_count integer,
	jtr_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_jtrs to btree unique on
	sim_key,
	jtr_scdn,
	jtr_name,
	jtr_jno,
	jtr_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_jtrs () from 'jmo_jtrs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_jtrs
\p\g
create table jmo_jwb(
	jwb_scdn char(65) not null,
	jwb_name char(65) not null,
	jwb_jno char(5) not null,
	jwb_resn char(17) not null,
	jwb_srt integer,
	jwb_srv smallint,
	jwb_flag byte(1),
	jwb_desc varchar(255)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_jwb to btree unique on
	jwb_scdn,
	jwb_name,
	jwb_jno,
	jwb_resn
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_jwb () from 'jmo_jwb.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_jwb
\p\g
create table jmo_modeltemp(
	reportid char(11) not null,
	year integer not null,
	month smallint not null,
	day smallint not null,
	hour smallint not null,
	minute smallint not null,
	second smallint not null,
	objecttype char(2) not null,
	objectname varchar(137) not null,
	causingobjecttype char(2),
	causingobjectname varchar(137),
	newstatus char(2),
	units char(5)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_modeltemp to btree unique on
	reportid,
	year,
	month,
	day,
	hour,
	minute,
	second,
	objecttype,
	objectname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_modeltemp () from 'jmo_modeltemp.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_modeltemp
\p\g
create table jmo_mwc(
	mwc_clus char(21) not null,
	mwc_name char(17) not null,
	mwc_brt integer,
	mwc_brv smallint,
	mwc_desc varchar(255)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_mwc to btree unique on
	mwc_clus,
	mwc_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy jmo_mwc () from 'jmo_mwc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_mwc
\p\g
create table jmo_mwg(
	mwg_name char(17) not null,
	mwg_brt integer,
	mwg_brv smallint,
	mwg_desc varchar(255)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_mwg to btree unique on
	mwg_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy jmo_mwg () from 'jmo_mwg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_mwg
\p\g
create table jmo_nod(
	nod_name char(65) not null,
	nod_ckpt char(16),
	nod_boot char(16)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_nod to btree unique on
	nod_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy jmo_nod () from 'jmo_nod.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_nod
\p\g
create table jmo_prb(
	prb_scdn char(65) not null,
	prb_name char(65) not null,
	prb_jno char(5) not null,
	prb_seq char(5) not null,
	prb_parm1 varchar(255),
	prb_parm2 varchar(255),
	prb_parm3 varchar(255),
	prb_parm4 varchar(255)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_prb to btree unique on
	prb_scdn,
	prb_name,
	prb_jno,
	prb_seq
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_prb () from 'jmo_prb.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_prb
\p\g
create table jmo_prt(
	prt_scdn char(65) not null,
	prt_name char(65) not null,
	prt_jno char(5) not null,
	prt_qual char(5) not null,
	prt_seq char(5) not null,
	prt_parm1 varchar(255),
	prt_parm2 varchar(255),
	prt_parm3 varchar(255),
	prt_parm4 varchar(255)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_prt to btree unique on
	prt_scdn,
	prt_name,
	prt_jno,
	prt_qual,
	prt_seq
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_prt () from 'jmo_prt.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_prt
\p\g
create table jmo_prt1(
	prt_scdn char(65) not null,
	prt_name char(65) not null,
	prt_jno char(5) not null,
	prt_qual char(5) not null,
	prt_seq char(5) not null,
	prt_parm1 varchar(255),
	prt_parm2 varchar(255),
	prt_parm3 varchar(255),
	prt_parm4 varchar(255)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_prt1 to btree unique on
	prt_scdn,
	prt_name,
	prt_jno,
	prt_qual,
	prt_seq
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_prt1 () from 'jmo_prt1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_prt1
\p\g
create table jmo_psr1(
	psr_scdn char(65) not null,
	psr_name char(65) not null,
	psr_jno char(5) not null,
	psr_qual char(5) not null,
	psr_pscd char(65) not null,
	psr_pjob char(65) not null,
	psr_pjno char(5) not null,
	psr_pqua char(5) not null,
	psr_flag byte(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_psr1 to btree unique on
	psr_scdn,
	psr_name,
	psr_jno,
	psr_qual,
	psr_pscd,
	psr_pjob,
	psr_pjno,
	psr_pqua
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_psr1 () from 'jmo_psr1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_psr1
\p\g
create table jmo_psrm(
	psr_scdn char(65) not null,
	psr_name char(65) not null,
	psr_jno char(5) not null,
	psr_pscd char(65) not null,
	psr_pjob char(65) not null,
	psr_pjno char(5) not null,
	psr_flag byte(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_psrm to btree unique on
	psr_scdn,
	psr_name,
	psr_jno,
	psr_pscd,
	psr_pjob,
	psr_pjno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_psrm () from 'jmo_psrm.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_psrm
\p\g
create table jmo_psrs(
	sim_key char(4) not null,
	psr_scdn char(65) not null,
	psr_name char(65) not null,
	psr_jno char(5) not null,
	psr_qual char(5) not null,
	psr_pscd char(65) not null,
	psr_pjob char(65) not null,
	psr_pjno char(5) not null,
	psr_pqua char(5) not null,
	psr_flag byte(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_psrs to btree unique on
	sim_key,
	psr_scdn,
	psr_name,
	psr_jno,
	psr_qual,
	psr_pscd,
	psr_pjob,
	psr_pjno,
	psr_pqua
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_psrs () from 'jmo_psrs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_psrs
\p\g
create table jmo_psrt(
	psr_scdn char(65) not null,
	psr_name char(65) not null,
	psr_jno char(5) not null,
	psr_qual char(5) not null,
	psr_pscd char(65) not null,
	psr_pjob char(65) not null,
	psr_pjno char(5) not null,
	psr_pqua char(5) not null,
	psr_flag byte(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_psrt to btree unique on
	psr_scdn,
	psr_name,
	psr_jno,
	psr_qual,
	psr_pscd,
	psr_pjob,
	psr_pjno,
	psr_pqua
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_psrt () from 'jmo_psrt.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_psrt
\p\g
create table jmo_sbr(
	sbr_name char(65) not null,
	sbr_effdt integer,
	sbr_expdt integer,
	sbr_sprty char(2),
	sbr_stype char(1),
	sbr_any byte(1),
	sbr_ws varchar(21),
	sbr_cal varchar(9),
	sbr_erly integer,
	sbr_must integer,
	sbr_dedln integer,
	sbr_mxtim integer,
	sbr_avg integer,
	sbr_flg1 byte(1),
	sbr_bklog byte(1),
	sbr_recs1 char(1),
	sbr_histc smallint,
	sbr_creus varchar(33),
	sbr_credt integer,
	sbr_cretm integer,
	sbr_lusdt integer,
	sbr_lustm integer,
	sbr_skip integer,
	sbr_user varchar(33),
	sbr_desc varchar(255),
	sbr_faill integer,
	sbr_failh integer,
	sbr_subu varchar(65),
	sbr_subp varchar(15),
	sbr_domain varchar(16),
	sbr_ccal varchar(9),
	sbr_cri varchar(255),
	sbr_hact char(1),
	sbr_nwact char(1),
	sbr_cadj varchar(5),
	sbr_sutyp char(1),
	sbr_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_sbr to btree unique on
	sbr_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_sbr () from 'jmo_sbr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_sbr
\p\g
create table jmo_shr(
	shr_name char(65) not null,
	shr_key char(12),
	shr_avelp integer,
	shr_avcpu integer,
	shr_hcnt smallint,
	shr_erdt integer,
	shr_msdt integer,
	shr_deddt integer,
	shr_adate integer,
	shr_vdate integer,
	shr_sdate integer,
	shr_edate integer,
	shr_ertm integer,
	shr_mstm integer,
	shr_dedtm integer,
	shr_atime integer,
	shr_vtime integer,
	shr_stime integer,
	shr_etime integer,
	shr_relpt integer,
	shr_rcput integer,
	shr_qual char(4),
	shr_cc varchar(9),
	shr_ws varchar(21),
	shr_stat byte(1),
	shr_late char(1),
	shr_cmrun varchar(33),
	shr_cmhld varchar(33),
	shr_cmrls varchar(33),
	shr_cmcnc varchar(33),
	shr_cmfrc varchar(33),
	shr_avgtb integer,
	shr_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_shr to btree unique on
	shr_name,
	shr_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_shr () from 'jmo_shr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_shr
\p\g
create table jmo_simtsystemdeps(
	sim_key char(4) not null,
	reportid char(4) not null,
	jobsetname varchar(65) not null,
	jobname varchar(65) not null,
	jobnumber char(5) not null,
	qualifier char(5) not null,
	type varchar(11) not null,
	seqno char(5) not null,
	name varchar(255),
	station varchar(21),
	value integer,
	"count" integer,
	status char(14),
	avail integer,
	used integer,
	rstatus char(2)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_simtsystemdeps to btree unique on
	reportid,
	jobsetname,
	jobname,
	jobnumber,
	qualifier,
	type,
	seqno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_simtsystemdeps () from 'jmo_simtsystemdeps.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_simtsystemdeps
\p\g
create table jmo_srq(
	srq_stck char(8) not null,
	srq_func char(1),
	srq_user varchar(33),
	srq_scdn varchar(65),
	srq_jobn varchar(65),
	srq_jno char(4),
	srq_qual char(4),
	uflgc char(1),
	job_pid char(8),
	unix_jno varchar(15),
	node_name varchar(65),
	file_name varchar(255),
	actcmd varchar(65)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_srq to btree unique on
	srq_stck
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_srq () from 'jmo_srq.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_srq
\p\g
create table jmo_str(
	str_name char(65) not null,
	str_qual char(5) not null,
	str_avgtb integer,
	str_ows varchar(21),
	str_ws varchar(21),
	str_wstyp char(1),
	str_any byte(1),
	str_erly integer,
	str_must integer,
	str_dedln integer,
	str_mxtim integer,
	str_avgt integer,
	str_jcont integer,
	str_flg1 byte(1),
	str_flg3 byte(1),
	str_bklog byte(1),
	str_histc smallint,
	str_desc varchar(255),
	str_newpr char(2),
	str_fordate integer,
	str_erdt integer,
	str_mudt integer,
	str_dedt integer,
	str_adate integer,
	str_vdate integer,
	str_sdate integer,
	str_edate integer,
	str_pdate integer,
	str_atime integer,
	str_vtime integer,
	str_stime integer,
	str_etime integer,
	str_dprty integer,
	str_cc varchar(9),
	str_hstat byte(1),
	str_rstat byte(1),
	str_flg5 byte(1),
	str_cmrun varchar(33),
	str_cmhld varchar(33),
	str_cmrls varchar(33),
	str_cmcnc varchar(33),
	str_cmfrc varchar(33),
	str_cal varchar(9),
	str_faill integer,
	str_failh integer,
	str_subu varchar(33),
	str_subp varchar(15),
	str_domain varchar(16),
	str_flg4 byte(1),
	str_sutyp char(1),
	str_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_str to btree unique on
	str_name,
	str_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_str () from 'jmo_str.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_str
\p\g
create table jmo_str1(
	str_name char(65) not null,
	str_qual char(5) not null,
	str_avgtb integer,
	str_ows varchar(21),
	str_ws varchar(21),
	str_wstyp char(1),
	str_any byte(1),
	str_erly integer,
	str_must integer,
	str_dedln integer,
	str_mxtim integer,
	str_avgt integer,
	str_jcont integer,
	str_flg1 byte(1),
	str_flg3 byte(1),
	str_bklog byte(1),
	str_histc smallint,
	str_desc varchar(255),
	str_newpr char(2),
	str_fordate integer,
	str_erdt integer,
	str_mudt integer,
	str_dedt integer,
	str_adate integer,
	str_vdate integer,
	str_sdate integer,
	str_edate integer,
	str_pdate integer,
	str_atime integer,
	str_vtime integer,
	str_stime integer,
	str_etime integer,
	str_dprty integer,
	str_cc varchar(9),
	str_hstat byte(1),
	str_rstat byte(1),
	str_flg5 byte(1),
	str_cmrun varchar(33),
	str_cmhld varchar(33),
	str_cmrls varchar(33),
	str_cmcnc varchar(33),
	str_cmfrc varchar(33),
	str_cal varchar(9),
	str_faill integer,
	str_failh integer,
	str_subu varchar(33),
	str_subp varchar(15),
	str_domain varchar(16),
	str_flg4 byte(1),
	str_sutyp char(1),
	str_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_str1 to btree unique on
	str_name,
	str_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_str1 () from 'jmo_str1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_str1
\p\g
create table jmo_strs(
	sim_key char(4) not null,
	str_name char(65) not null,
	str_qual char(5) not null,
	str_avgtb integer,
	str_ows varchar(21),
	str_ws varchar(21),
	str_wstyp char(1),
	str_any byte(1),
	str_erly integer,
	str_must integer,
	str_dedln integer,
	str_mxtim integer,
	str_avgt integer,
	str_jcont integer,
	str_flg1 byte(1),
	str_flg3 byte(1),
	str_bklog byte(1),
	str_histc smallint,
	str_desc varchar(255),
	str_newpr char(2),
	str_fordate integer,
	str_erdt integer,
	str_mudt integer,
	str_dedt integer,
	str_adate integer,
	str_vdate integer,
	str_sdate integer,
	str_edate integer,
	str_pdate integer,
	str_atime integer,
	str_vtime integer,
	str_stime integer,
	str_etime integer,
	str_dprty integer,
	str_cc varchar(9),
	str_hstat byte(1),
	str_rstat byte(1),
	str_flg5 byte(1),
	str_cmrun varchar(33),
	str_cmhld varchar(33),
	str_cmrls varchar(33),
	str_cmcnc varchar(33),
	str_cmfrc varchar(33),
	str_cal varchar(9),
	str_faill integer,
	str_failh integer,
	str_subu varchar(33),
	str_subp varchar(15),
	str_domain varchar(16),
	str_flg4 byte(1),
	str_sutyp char(1),
	str_qname char(1)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_strs to btree unique on
	sim_key,
	str_name,
	str_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_strs () from 'jmo_strs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_strs
\p\g
create table jmo_swb(
	swb_name char(65) not null,
	swb_resn char(17) not null,
	swb_srt integer,
	swb_srv smallint,
	swb_flag byte(1),
	swb_desc varchar(255)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_swb to btree unique on
	swb_name,
	swb_resn
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 8192
\p\g
/* copy jmo_swb () from 'jmo_swb.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_swb
\p\g
create table jmo_systemdeps(
	jobsetname varchar(65) not null,
	jobname varchar(65) not null,
	jobnumber char(5) not null,
	type varchar(11) not null,
	seqno char(5) not null,
	name varchar(255),
	station varchar(21),
	value integer,
	"count" integer,
	status char(14),
	avail integer,
	used integer,
	rstatus char(2)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_systemdeps to btree unique on
	jobsetname,
	jobname,
	jobnumber,
	type,
	seqno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_systemdeps () from 'jmo_systemdeps.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_systemdeps
\p\g
create table jmo_trg(
	trg_trev char(9) not null,
	trg_trid char(65) not null,
	trg_apc7 varchar(9),
	trg_desc varchar(255),
	trg_jnam varchar(65),
	trg_usid varchar(33),
	trg_stan varchar(21),
	trg_faill integer,
	trg_failh integer,
	trg_file varchar(255),
	trg_ustat char(2),
	trg_skip varchar(5),
	trg_jobn varchar(5),
	trg_scdn varchar(65),
	trg_estar varchar(8),
	trg_efend varchar(8),
	trg_qnam char(2),
	trg_bklog char(2),
	trg_cal varchar(9),
	trg_auto char(2),
	trg_recs1 char(2),
	trg_ccal varchar(9),
	trg_cri varchar(255),
	trg_hact char(2),
	trg_nwact char(2),
	trg_cadj varchar(5)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_trg to btree unique on
	trg_trev,
	trg_trid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_trg () from 'jmo_trg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_trg
\p\g
create table jmo_trt(
	trt_trev char(9) not null,
	trt_trid char(65) not null,
	trt_qual char(5) not null,
	trt_apc7 varchar(9),
	trt_desc varchar(255),
	trt_jnam varchar(65),
	trt_usid varchar(33),
	trt_stan varchar(21),
	trt_faill integer,
	trt_failh integer,
	trt_file varchar(255),
	trt_ustat char(2),
	trt_jobn varchar(5),
	trt_scdn varchar(65),
	trt_bklog char(2),
	trt_cal varchar(9),
	trt_fdate integer,
	trt_tstat char(2)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_trt to btree unique on
	trt_trev,
	trt_trid,
	trt_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_trt () from 'jmo_trt.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_trt
\p\g
create table jmo_trt1(
	trt_trev char(9) not null,
	trt_trid char(65) not null,
	trt_qual char(5) not null,
	trt_apc7 varchar(9),
	trt_desc varchar(255),
	trt_jnam varchar(65),
	trt_usid varchar(33),
	trt_stan varchar(21),
	trt_faill integer,
	trt_failh integer,
	trt_file varchar(255),
	trt_ustat char(2),
	trt_jobn varchar(5),
	trt_scdn varchar(65),
	trt_bklog char(2),
	trt_cal varchar(9),
	trt_fdate integer,
	trt_tstat char(2)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_trt1 to btree unique on
	trt_trev,
	trt_trid,
	trt_qual
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_trt1 () from 'jmo_trt1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_trt1
\p\g
create table jmo_tsystemdeps(
	jobsetname varchar(65) not null,
	jobname varchar(65) not null,
	jobnumber char(5) not null,
	qualifier char(5) not null,
	type varchar(11) not null,
	seqno char(5) not null,
	name varchar(255) not null,
	station varchar(21) not null,
	value integer not null,
	"count" integer not null,
	status char(14) not null,
	avail integer not null,
	used integer not null,
	rstatus char(2) not null
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_tsystemdeps to btree unique on
	jobsetname,
	jobname,
	jobnumber,
	qualifier,
	type,
	seqno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_tsystemdeps () from 'jmo_tsystemdeps.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_tsystemdeps
\p\g
create table jmo_tsystemdeps1(
	jobsetname varchar(65) not null,
	jobname varchar(65) not null,
	jobnumber char(5) not null,
	qualifier char(5) not null,
	type varchar(11) not null,
	seqno char(5) not null,
	name varchar(255),
	station varchar(21),
	value integer,
	"count" integer,
	status char(14),
	avail integer,
	used integer,
	rstatus char(2)
)
with noduplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,row)
;
modify jmo_tsystemdeps1 to btree unique on
	jobsetname,
	jobname,
	jobnumber,
	qualifier,
	type,
	seqno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 25,
	page_size = 8192
\p\g
/* copy jmo_tsystemdeps1 () from 'jmo_tsystemdeps1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jmo_tsystemdeps1
\p\g
create table job2(
	joid integer not null,
	command2 varchar(255),
	condition2 varchar(255),
	external_app varchar(40),
	timezone varchar(50),
	condition3 varchar(255),
	create_user varchar(80),
	create_stamp date,
	modify_user varchar(80),
	modify_stamp date,
	as_applic varchar(16),
	as_group varchar(16),
	as_work char(7),
	as_holcal varchar(30),
	as_cyccal varchar(30),
	as_hact char(1),
	as_nwact char(1),
	as_adj integer,
	as_datecon varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job2 to btree unique on
	joid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job2 () from 'job2.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job2
\p\g
create table job_calendar(
	name varchar(30),
	day date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_calendar to btree unique on
	name,
	day
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_calendar () from 'job_calendar.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_calendar
\p\g
create table job_cond(
	cond_mode integer,
	joid integer,
	indx integer,
	type char(1),
	cond_job_name varchar(64),
	cond_job_autoserv varchar(30),
	operator char(2),
	value integer,
	indx_ptr integer,
	test_glovalue char(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_cond to btree unique on
	cond_mode,
	joid,
	indx
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_cond () from 'job_cond.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_cond
\p\g
create table job_config(
	fld varchar(30),
	code char(1),
	text varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_config to btree unique on
	fld,
	code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_config () from 'job_config.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_config
\p\g
create table job_delete(
	joid integer,
	job_name varchar(64),
	stamp integer,
	owner varchar(80)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_delete to btree unique on
	joid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_delete () from 'job_delete.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_delete
\p\g
create table job_event(
	eoid varchar(32),
	joid integer,
	job_name varchar(64),
	box_name varchar(64),
	autoserv varchar(30),
	priority integer,
	event integer,
	status integer,
	alarm integer,
	event_time_gmt integer,
	exit_code integer,
	machine varchar(80),
	pid integer,
	jc_pid integer,
	run_num integer,
	ntry integer,
	text varchar(255),
	que_priority integer,
	stamp date,
	evt_num integer,
	que_status integer,
	que_status_stamp date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_event to btree unique on
	eoid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_event () from 'job_event.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_event
\p\g
create table job_history(
	id integer,
	job_id integer,
	job_name varchar(32),
	engine_name varchar(32),
	engine_type varchar(8),
	state i1,
	starttime date,
	endtime date,
	datarange_starttime date,
	datarange_endtime date,
	records_processed integer,
	text varchar(1024)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_history to heap
with extend = 16,
	allocation = 4
\p\g
/* copy job_history () from 'job_history.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on job_history
\p\g
create table job_job(
	joid integer not null,
	job_name varchar(64),
	job_type char(1) not null,
	box_joid integer,
	owner varchar(80),
	permission varchar(30),
	machine varchar(80),
	n_retrys integer,
	auto_hold i1,
	command varchar(255),
	condition varchar(255),
	date_conditions i1,
	days_of_week varchar(80),
	run_calendar varchar(30),
	exclude_calendar varchar(30),
	start_times varchar(255),
	start_mins varchar(255),
	run_window varchar(20),
	description varchar(255),
	term_run_time integer,
	box_terminator i1,
	job_terminator i1,
	std_in_file varchar(80),
	std_out_file varchar(80),
	std_err_file varchar(80),
	watch_file varchar(80),
	watch_file_min_size integer,
	watch_interval integer,
	min_run_alarm integer,
	max_run_alarm integer,
	alarm_if_fail i1,
	chk_files varchar(255),
	free_procs integer,
	profile varchar(80),
	heartbeat_interval integer,
	job_load integer,
	priority integer,
	auto_delete integer,
	numero integer,
	max_exit_success integer,
	box_success varchar(255),
	box_failure varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify job_job to btree unique on
	joid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy job_job () from 'job_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_job
\p\g
create table job_machine(
	name varchar(80),
	parent_name varchar(80),
	que_name varchar(160),
	type char(1),
	factor float,
	max_load integer,
	mstatus char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_machine to btree unique on
	name,
	parent_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_machine () from 'job_machine.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_machine
\p\g
create table job_object(
	objectid integer not null,
	objectname varchar(255) not null,
	description varchar(255),
	objecttype smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_object to btree unique on
	objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_object () from 'job_object.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_object
\p\g
create table job_runs(
	joid integer,
	run_num integer,
	ntry integer,
	startime integer,
	endtime integer,
	status integer,
	exit_code integer,
	runtime integer,
	evt_num integer,
	machine varchar(80)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_runs to btree on
	joid,
	run_num,
	ntry
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_runs () from 'job_runs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_runs
\p\g
create table job_status(
	joid integer not null,
	status i1 not null,
	status_time integer not null,
	run_num integer,
	last_start integer,
	last_end integer,
	next_start integer,
	run_window_end integer,
	ntry integer,
	appl_ntry integer,
	time_ok i1,
	exit_code integer,
	run_machine varchar(80),
	que_name varchar(62),
	run_priority integer,
	next_priority integer,
	pid integer,
	jc_pid integer,
	last_heartbeat integer,
	evt_num integer,
	over_num integer,
	mvsflag integer,
	mvsnode varchar(30),
	jobset varchar(65),
	mvsjobname varchar(65),
	qual varchar(5),
	jno integer,
	entryno varchar(15),
	mvsautoserv varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_status to btree unique on
	joid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_status () from 'job_status.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_status
\p\g
create table job_template(
	templateid integer not null,
	name varchar(255),
	owner varchar(255),
	description varchar(255),
	templateleft integer,
	templateright integer,
	templatetop integer,
	templatebottom integer,
	clonename text(1),
	clonedescription text(1),
	clonebox text(1),
	cloneinstance text(1),
	checkoutsid varchar(100),
	checkoutname varchar(100),
	psname varchar(255),
	clonepsname varchar(255),
	autosystemplate smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify job_template to btree unique on
	templateid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy job_template () from 'job_template.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on job_template
\p\g
create table joborder(
	udomid integer not null,
	unitid integer not null,
	jdomid integer not null,
	jobid integer not null,
	joorder integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify joborder to btree unique on
	unitid,
	jobid,
	udomid,
	jdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy joborder () from 'joborder.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on joborder
\p\g
create table jobs(
	id integer not null,
	owner varchar(128) not null,
	name varchar(128) not null,
	description varchar(256),
	shareable integer not null,
	locked integer not null,
	locked_by varchar(128),
	lock_datetime date,
	upd_user varchar(128) not null,
	upd_datetime date not null,
	type integer not null,
	product_code varchar(3) not null,
	stage_string varchar(80),
	status_string varchar(80),
	status integer not null,
	exec_machine varchar(256),
	sched_time integer not null,
	sched_window integer not null,
	resched_time integer not null,
	start_time integer not null,
	end_time integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify jobs to btree unique on
	owner,
	name,
	product_code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy jobs () from 'jobs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jobs
\p\g
create table jobvisionpassword(
	password varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify jobvisionpassword to btree unique on
	password
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy jobvisionpassword () from 'jobvisionpassword.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jobvisionpassword
\p\g
create table jobvisionvalues(
	jv_name varchar(255) not null,
	jv_value varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify jobvisionvalues to btree unique on
	jv_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy jobvisionvalues () from 'jobvisionvalues.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jobvisionvalues
\p\g
create table jv_box_job(
	jobid integer not null,
	as_boxfailure varchar(255),
	as_boxsuccess varchar(255),
	cloneid integer,
	templatejobid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify jv_box_job to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy jv_box_job () from 'jv_box_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jv_box_job
\p\g
create table jv_command_job(
	jobid integer not null,
	as_chkfiles varchar(255),
	as_command text(1),
	as_heartbeatinterval smallint,
	as_maxexitsuccess varchar(255),
	as_machine varchar(255),
	as_profile varchar(255),
	as_stderrfile varchar(255),
	as_stdinfile varchar(255),
	as_stdoutfile varchar(255),
	target_mode varchar(32),
	cloneid integer,
	templatejobid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify jv_command_job to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy jv_command_job () from 'jv_command_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jv_command_job
\p\g
create table jv_fw_job(
	jobid integer not null,
	cloneid integer,
	templatejobid integer,
	as_watchfile varchar(255),
	as_watchfileminsize integer,
	as_watchinterval smallint,
	as_machine varchar(255),
	as_profile varchar(255),
	as_chkfiles varchar(255),
	target_mode varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify jv_fw_job to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy jv_fw_job () from 'jv_fw_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jv_fw_job
\p\g
create table jv_job(
	jobid integer not null,
	instancename varchar(12) not null,
	as_alarmiffail smallint,
	as_autodelete smallint,
	jobname varchar(84) not null,
	as_autohold smallint,
	regionid integer,
	sched_name varchar(50),
	as_condition text(1),
	job_variable varchar(50),
	kill_signal varchar(255),
	jobowner varchar(80),
	as_boxterminator smallint,
	boxjobid integer,
	jobtype varchar(32) not null,
	as_daysofweek varchar(80),
	jobleft integer,
	as_excludecalendar varchar(50),
	jobright integer,
	jobtop integer,
	as_jobload smallint,
	as_jobterminator smallint,
	as_description text(1),
	jobbottom integer,
	as_dateconditions smallint,
	as_maxrunalarm smallint,
	as_minrunalarm smallint,
	as_nretrys smallint,
	as_startmins varchar(255),
	as_starttimes varchar(255),
	as_permission varchar(50),
	as_priority smallint,
	as_runcalendar varchar(50),
	checkoutsid varchar(100),
	checkoutname varchar(100),
	lastsynctime integer,
	lastmodtime integer,
	cloneid integer,
	as_termruntime smallint,
	boxname varchar(64),
	as_timezone varchar(50),
	templatejobid integer,
	bagname varchar(50),
	job_mode varchar(32),
	application varchar(8),
	as_group varchar(3),
	max_concur_runs integer,
	save_cycles integer,
	restart_wait integer,
	run_as_ptid varchar(32),
	not_after_start_time integer,
	pre_load_mins integer,
	alarm_start_late varchar(6),
	avg_duration integer,
	operator_ok integer,
	app_status_var varchar(32),
	as_runwindow varchar(30)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify jv_job to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy jv_job () from 'jv_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jv_job
\p\g
create table jv_keymaster(
	hostid varchar(255) not null,
	expires varchar(255),
	dakey varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify jv_keymaster to btree unique on
	hostid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy jv_keymaster () from 'jv_keymaster.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on jv_keymaster
\p\g
create table kc(
	id integer not null,
	key_name varchar(20),
	key_value integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify kc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy kc () from 'kc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on kc
\p\g
create table kd_attmnt(
	id integer not null,
	doc_id integer,
	attmnt_id integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify kd_attmnt to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy kd_attmnt () from 'kd_attmnt.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on kd_attmnt
\p\g
create table kdlinks(
	id integer not null,
	kd integer,
	sd_obj_type varchar(5),
	sd_obj_id integer,
	link_type integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify kdlinks to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy kdlinks () from 'kdlinks.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on kdlinks
\p\g
create table kernel(
	kernel_id decimal(31,0) not null,
	owning_library_id decimal(31,0) not null,
	kernel_class_id decimal(31,0),
	reference_id varchar(120),
	opruid decimal(31,0),
	kernel_name varchar(1200) not null,
	kernel_description varchar(4000),
	license_key varchar(4000),
	display_level integer,
	last_instance_index integer,
	logical_delete_flag smallint,
	ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify kernel to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy kernel () from 'kernel.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on kernel
\p\g
create table kernel_class(
	kernel_class_id decimal(31,0) not null,
	kernel_class_description varchar(4000) not null,
	copy_placehoder integer,
	copy_primary_object integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify kernel_class to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy kernel_class () from 'kernel_class.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on kernel_class
\p\g
create table kernel_class_keyword(
	kernel_class_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify kernel_class_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy kernel_class_keyword () from 'kernel_class_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on kernel_class_keyword
\p\g
create table kernel_keyword(
	kernel_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify kernel_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy kernel_keyword () from 'kernel_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on kernel_keyword
\p\g
create table kernel_uses_product(
	product_instance_id decimal(31,0) not null,
	kernel_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify kernel_uses_product to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy kernel_uses_product () from 'kernel_uses_product.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on kernel_uses_product
\p\g
create table keymaster(
	hostid varchar(32),
	hostname varchar(64),
	product varchar(31),
	type char(1),
	server char(12),
	dakey varchar(255),
	not_used varchar(16)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify keymaster to btree unique on
	hostid,
	hostname,
	product,
	type,
	server,
	dakey,
	not_used
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy keymaster () from 'keymaster.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on keymaster
\p\g
create table keys(
	keyid integer not null,
	newkey integer not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify keys to btree unique on
	keyid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy keys () from 'keys.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on keys
\p\g
create table keyword(
	keyword_id decimal(31,0) not null,
	keyword_group_id decimal(31,0),
	reference_id varchar(120),
	alt_ref_id varchar(120),
	keyword_name varchar(1200) not null,
	keyword_description varchar(4000),
	logical_delete_flag smallint,
	ref_name varchar(4000),
	alt_ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy keyword () from 'keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on keyword
\p\g
create table keyword_group(
	keyword_group_id decimal(31,0) not null,
	keyword_group_name varchar(4000) not null,
	ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify keyword_group to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy keyword_group () from 'keyword_group.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on keyword_group
\p\g
create table km_kword(
	id integer not null,
	persid varchar(30),
	sym varchar(30) not null,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify km_kword to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy km_kword () from 'km_kword.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on km_kword
\p\g
create table km_lrel(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify km_lrel to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy km_lrel () from 'km_lrel.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on km_lrel
\p\g
create table lac_filenames(
	strid decimal(31,0) not null,
	serverid decimal(31,0) not null,
	database_name varchar(64),
	file_name varchar(255) not null,
	file_type decimal(31,0) not null,
	file_location char(1),
	filenm_manualentry char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lac_filenames to btree on
	strid,
	serverid,
	database_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lac_filenames () from 'lac_filenames.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lac_filenames
\p\g
create table lac_filter_names(
	filter_name varchar(64) not null,
	date_created date not null,
	user_created varchar(64) not null,
	dbms char(1) not null,
	strategy_count decimal(31,0) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lac_filter_names to btree unique on
	filter_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy lac_filter_names () from 'lac_filter_names.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lac_filter_names
\p\g
create table lac_filter_objects(
	filter_name varchar(64) not null,
	serverid decimal(31,0) not null,
	database_name varchar(64),
	owner_name varchar(255),
	object_name varchar(255) not null,
	object_type char(1) not null,
	wild_card char(1),
	inc_ex char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lac_filter_objects to btree on
	filter_name,
	serverid,
	database_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lac_filter_objects () from 'lac_filter_objects.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lac_filter_objects
\p\g
create table lac_job_output(
	strid decimal(31,0) not null,
	serverid decimal(31,0) not null,
	groupid decimal(31,0) not null,
	jobid decimal(31,0) not null,
	run_num decimal(3,0) not null,
	file_name varchar(255) not null,
	file_type decimal(31,0) not null,
	file_location char(1),
	filesize decimal(31,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lac_job_output to btree on
	strid,
	serverid,
	groupid,
	jobid,
	run_num
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lac_job_output () from 'lac_job_output.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lac_job_output
\p\g
create table lac_job_parms(
	strid decimal(31,0) not null,
	serverid decimal(31,0) not null,
	database_name varchar(64),
	name varchar(64) not null,
	valuestring varchar(255),
	valuenum decimal(31,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lac_job_parms to btree unique on
	strid,
	serverid,
	database_name,
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy lac_job_parms () from 'lac_job_parms.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lac_job_parms
\p\g
create table lac_strategy_parms(
	strid decimal(31,0) not null,
	name varchar(64) not null,
	valuestring varchar(255),
	valuenum decimal(31,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lac_strategy_parms to btree unique on
	strid,
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy lac_strategy_parms () from 'lac_strategy_parms.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lac_strategy_parms
\p\g
create table lac_transactions(
	strid decimal(31,0) not null,
	serverid decimal(31,0) not null,
	database_name varchar(64),
	xact_high decimal(31,0),
	xact_low decimal(31,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lac_transactions to btree on
	strid,
	serverid,
	database_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lac_transactions () from 'lac_transactions.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lac_transactions
\p\g
create table language(
	language_id byte(16) not null,
	name nvarchar(50) not null,
	english_title nvarchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify language to btree unique on
	language_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy language () from 'language.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on language
\p\g
create table last_eoid_counter(
	counter char(7) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify last_eoid_counter to heap
with extend = 16,
	allocation = 4
\p\g
/* copy last_eoid_counter () from 'last_eoid_counter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on last_eoid_counter
\p\g
create table ldapactors_worklist(
	workitemid varchar(30) not null,
	ldapactor varchar(50) not null,
	qualifier varchar(50) not null,
	users varchar(100) not null default ''
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ldapactors_worklist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ldapactors_worklist () from 'ldapactors_worklist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ldapactors_worklist
\p\g
create table ldapconfiguration(
	ldaphost varchar(50) not null,
	ldapport varchar(5) not null,
	rootdn varchar(255) not null default '',
	rootpass varchar(15) not null default '',
	rootcontext varchar(50) not null,
	contextdn varchar(255) not null,
	filter varchar(100) not null,
	pwattribute varchar(50) not null default ''
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ldapconfiguration to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ldapconfiguration () from 'ldapconfiguration.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ldapconfiguration
\p\g
create table library(
	library_id decimal(31,0) not null,
	opruid decimal(31,0),
	library_description varchar(4000),
	library_name varchar(1200) not null,
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify library to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy library () from 'library.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on library
\p\g
create table lic_machine(
	machine varchar(80) not null,
	first_stamp date,
	first_joid integer,
	recent_stamp date,
	recent_joid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lic_machine to btree unique on
	machine
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lic_machine () from 'lic_machine.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lic_machine
\p\g
create table linkbck(
	unitid integer not null,
	bckid integer not null,
	udomid integer not null,
	bdomid integer not null,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify linkbck to btree unique on
	udomid,
	unitid,
	bckid,
	bdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy linkbck () from 'linkbck.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on linkbck
\p\g
create table linkjob(
	udomid integer not null,
	unitid integer not null,
	jdomid integer not null,
	jobid integer not null,
	jostatus integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify linkjob to btree unique on
	unitid,
	jobid,
	udomid,
	jdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy linkjob () from 'linkjob.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on linkjob
\p\g
create table linkmod(
	udomid integer not null,
	unitid integer not null,
	mdomid integer not null,
	moid integer not null,
	modtype integer not null,
	mostatus integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify linkmod to btree unique on
	unitid,
	moid,
	modtype,
	udomid,
	mdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy linkmod () from 'linkmod.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on linkmod
\p\g
create table linkunit(
	domainid integer not null,
	type integer not null,
	ver integer not null,
	link integer,
	viewitem integer,
	viewtabl integer,
	viewtype integer,
	linkitem integer,
	linktabl integer,
	linktype integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify linkunit to btree unique on
	type,
	ver,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy linkunit () from 'linkunit.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on linkunit
\p\g
create table list(
	listid integer not null,
	name varchar(255) not null,
	filterid integer,
	owner varchar(255),
	description varchar(255),
	checkoutsid varchar(100),
	checkoutname varchar(100),
	psname varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify list to btree unique on
	listid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy list () from 'list.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on list
\p\g
create table listnodes(
	listid integer not null,
	instanceid integer,
	objectid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify listnodes to btree unique on
	instanceid,
	listid,
	objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy listnodes () from 'listnodes.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on listnodes
\p\g
create table listproperties(
	listid integer not null,
	propertytype integer not null,
	propertyid integer not null,
	colno integer not null,
	altpropid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify listproperties to btree unique on
	listid,
	propertyid,
	propertytype,
	altpropid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy listproperties () from 'listproperties.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on listproperties
\p\g
create table lnkitrmwv(
	wvclass varchar(20) not null,
	wvuuid varchar(20) not null,
	domainid integer not null,
	unitid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify lnkitrmwv to btree unique on
	domainid,
	wvuuid,
	unitid,
	wvclass
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy lnkitrmwv () from 'lnkitrmwv.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lnkitrmwv
\p\g
create table lob(
	lob_id decimal(5,0) not null,
	collect_id decimal(5,0),
	table_id decimal(5,0),
	column_name varchar(2000),
	data_tablespace_id decimal(5,0),
	index_tablespace_id decimal(5,0),
	chunk_bytes decimal(5,0),
	pctversion decimal(3,0),
	cache decimal(1,0),
	logging decimal(1,0),
	in_row decimal(1,0)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify lob to btree unique on
	lob_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy lob () from 'lob.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lob
\p\g
create table lob_fast(
	lob_id decimal(5,0) not null,
	min_len decimal(5,0),
	max_len decimal(5,0),
	avg_len decimal(5,0),
	std_len decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lob_fast to btree unique on
	lob_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy lob_fast () from 'lob_fast.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lob_fast
\p\g
create table localserver(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname varchar(64) not null,
	strpath varchar(255) not null,
	straddress varchar(255) not null,
	iisroot integer not null,
	uidconfigpolicy byte(16) not null,
	strdescription varchar(255) not null,
	dateconfigpolicy date not null,
	iinheritconfiguration integer not null,
	ipropagatechanges integer not null,
	ageofeventstopurge integer not null,
	datetopurgeevents date not null,
	ageofsessionstopurge integer not null,
	datetopurgesessions date not null,
	nexteventpurge date not null,
	nextsessionpurge date not null,
	periodtopurgeevents integer not null,
	periodtopurgesessions integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify localserver to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy localserver () from 'localserver.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on localserver
\p\g
create table lockunit(
	domainid integer not null,
	sectorid integer not null,
	unitid integer not null,
	status integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify lockunit to btree unique on
	unitid,
	domainid,
	sectorid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy lockunit () from 'lockunit.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lockunit
\p\g
create table logicalrelations(
	primluuid varchar(255) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify logicalrelations to btree unique on
	primluuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy logicalrelations () from 'logicalrelations.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on logicalrelations
\p\g
create table long_texts(
	id integer not null,
	ref_persid varchar(30),
	cnt_order integer,
	actual_text long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify long_texts to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy long_texts () from 'long_texts.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on long_texts
\p\g
create table lookoutcontrol(
	controlentryid integer not null,
	serverid integer not null,
	startuptime date not null,
	shutdowntime date,
	schedulerpulse date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lookoutcontrol to heap
with extend = 16,
	allocation = 4
\p\g
/* copy lookoutcontrol () from 'lookoutcontrol.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on lookoutcontrol
\p\g
create table lookoutidcontrol(
	lookoutversion varchar(80) not null,
	idlock integer not null,
	locktime date,
	nextobjectid integer not null,
	nextgroupid integer not null,
	nextexecutionid integer not null,
	nextddtableid integer not null,
	nextcontrolid integer not null,
	nextserverid integer not null,
	handlerkeys long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lookoutidcontrol to heap
with extend = 16,
	allocation = 4
\p\g
/* copy lookoutidcontrol () from 'lookoutidcontrol.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on lookoutidcontrol
\p\g
create table lookoutserver(
	serverid integer not null,
	servername varchar(32) not null,
	serverinstalled i1 not null,
	servernote varchar(255),
	serverlicenseinfo varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lookoutserver to heap
with extend = 16,
	allocation = 4
\p\g
/* copy lookoutserver () from 'lookoutserver.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on lookoutserver
\p\g
create table lrel(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify lrel to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy lrel () from 'lrel.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lrel
\p\g
create table lsyfileserverclients(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	addrtype i1 not null,
	servicetype integer not null,
	servernetaddr varchar(20) not null,
	clientnetaddr varchar(20) not null,
	pktstoclient float,
	bytestoclient float,
	pktstoserver float,
	bytestoserver float,
	linkerrors float,
	fserrors float,
	siorspcount float,
	siorspsum float,
	siorspcrossings float,
	clientname varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsyfileserverclients to btree on
	probe_addr,
	probeindex,
	servernetaddr,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 32
\p\g
/* copy lsyfileserverclients () from 'lsyfileserverclients.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsyfileserverclients
\p\g
create table lsyfileserverid(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	probeindex integer not null,
	fileserverkeyid integer not null,
	fileserveraddrtype i1 not null,
	fileserverservicetype smallint not null,
	fileservernetaddr varchar(20) not null,
	fileservername varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsyfileserverid to btree unique on
	probe_addr,
	probeindex,
	fileserverkeyid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 8
\p\g
/* copy lsyfileserverid () from 'lsyfileserverid.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsyfileserverid
\p\g
create table lsyfileserverstats(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	fileserverkeyid integer not null,
	pktstoclient float,
	bytestoclient float,
	pktstoserver float,
	bytestoserver float,
	readsvccount float,
	readsvcsum float,
	readsvcsos float,
	readbytes float,
	writesvccount float,
	writesvcsum float,
	writesvcsos float,
	writebytes float,
	othersvccount float,
	othersvcsum float,
	othersvcsos float,
	siocount float,
	siosum float,
	siosos float,
	linkerrcount float,
	fserrcount float,
	fileopen float,
	fileclose float,
	filesearch float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsyfileserverstats to btree on
	probe_addr,
	probeindex,
	fileserverkeyid,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsyfileserverstats () from 'lsyfileserverstats.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsyfileserverstats
\p\g
create table lsyhopdelay(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	lsyprobeindex integer not null,
	hopdelayindex integer not null,
	hopdelayintsrcaddr integer not null,
	hopdelayintdestaddr integer not null,
	hopdelaytos integer,
	hopdelaysequence i1 not null,
	hopdelaytotal float,
	hopdelayrel float,
	hopdelaymsgct float,
	hopdelaytimeoutct float,
	hopdelaylowhostaddr integer not null,
	hopdelayhighhostaddr integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsyhopdelay to btree on
	probe_addr,
	lsyprobeindex,
	hopdelayindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy lsyhopdelay () from 'lsyhopdelay.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
create table lsyhopdelayid(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	lsyprobeindex integer not null,
	hopdelayindex integer not null,
	hopdelayintsrcaddr integer not null,
	hopdelayintdestaddr integer not null,
	hopdelaytos integer not null,
	hopdelayintcsrcaddr varchar(20) not null,
	hopdelayintcdestaddr varchar(20) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsyhopdelayid to btree on
	probe_addr,
	lsyprobeindex,
	hopdelayindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy lsyhopdelayid () from 'lsyhopdelayid.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
create table lsylanprotocols(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	protocoltypecategory integer not null,
	protocoltypesubcategory integer not null,
	protocolframes float,
	protocolbytes float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsylanprotocols to btree on
	probe_addr,
	probeindex,
	protocoltypecategory,
	protocoltypesubcategory,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsylanprotocols () from 'lsylanprotocols.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsylanprotocols
\p\g
create table lsylanutilization(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	utilcount float,
	utilsum float,
	utilsos float,
	utilhist1 float,
	utilhist2 float,
	utilhist3 float,
	utilhist4 float,
	utilhistover float,
	utilhist1ctl smallint,
	utilhist2ctl smallint,
	utilhist3ctl smallint,
	utilhist4ctl smallint,
	utilthreshold i1,
	utilsamplesize smallint,
	utilavgeobs smallint,
	utilburstobs smallint,
	utilcrossingsctr float,
	utilpeakrate float,
	utilburstmax float,
	sizehist1 float,
	sizehist2 float,
	sizehist3 float,
	sizehist4 float,
	sizehistover float,
	sizehist1ctl smallint,
	sizehist2ctl smallint,
	sizehist3ctl smallint,
	sizehist4ctl smallint,
	totalframes float,
	totalbytes float,
	broadcastframes float,
	broadcastbytes float,
	multicastframes float,
	multicastbytes float,
	frameslostprobe float,
	frameslostbuf float,
	frameslosthard float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsylanutilization to btree on
	probe_addr,
	probeindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsylanutilization () from 'lsylanutilization.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsylanutilization
\p\g
create table lsynetnames(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	probeindex integer not null,
	addrtype i1 not null,
	servicetype integer not null,
	netaddr varchar(20) not null,
	macaddr varchar(12) not null,
	name varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsynetnames to btree on
	probe_addr,
	probeindex,
	servicetype
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsynetnames () from 'lsynetnames.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsynetnames
\p\g
create table lsyprobeid(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	probeindex integer,
	probemediumtype smallint,
	probenetworkspeed integer,
	probeinterfacename varchar(32),
	probereleaseid varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsyprobeid to hash unique on
	probe_addr,
	probeindex
with fillfactor = 50,
	extend = 2
\p\g
/* copy lsyprobeid () from 'lsyprobeid.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsyprobeid
\p\g
create table lsyprotocoltypes(
	protocoltype smallint not null,
	protocoltypecategory integer not null,
	protocoltypesubcategory integer not null,
	protocoltypesummaryflag i1 not null,
	protocoltypename varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsyprotocoltypes to btree on
	protocoltype
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy lsyprotocoltypes () from 'lsyprotocoltypes.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsyprotocoltypes
\p\g
create table lsytermserverclients(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	addrtype i1 not null,
	servicetype integer not null,
	servernetaddr varchar(20) not null,
	clientnetaddr varchar(20) not null,
	pktstoclient float,
	bytestoclient float,
	pktstoserver float,
	bytestoserver float,
	userrspcount float,
	userrspsum float,
	userrspcrossings float,
	netrsptype i1,
	netrspcount float,
	netrspsum float,
	netrspcrossings float,
	linkerrors float,
	clientname varchar(32),
	serverport integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytermserverclients to btree on
	probe_addr,
	probeindex,
	servernetaddr,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy lsytermserverclients () from 'lsytermserverclients.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytermserverclients
\p\g
create table lsytermserverid(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	probeindex integer not null,
	termserverkeyid integer not null,
	termserveraddrtype i1 not null,
	termserverservicetype integer not null,
	termservernetaddr varchar(20) not null,
	termservername varchar(32),
	termserverport integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytermserverid to btree unique on
	probe_addr,
	probeindex,
	termserverkeyid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsytermserverid () from 'lsytermserverid.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytermserverid
\p\g
create table lsytermserverstats(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	termserverkeyid integer not null,
	pktstoclient float,
	bytestoclient float,
	pktstoserver float,
	bytestoserver float,
	rttermcount float,
	rttermsum float,
	rttermsos float,
	netresponsetype i1 not null,
	nrtermcount float,
	nrtermsum float,
	nrtermsos float,
	linkerrcount float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytermserverstats to btree on
	probe_addr,
	probeindex,
	termserverkeyid,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 32
\p\g
/* copy lsytermserverstats () from 'lsytermserverstats.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytermserverstats
\p\g
create table lsytopncast(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	srcmacaddr varchar(12) not null,
	ratebase i1 not null,
	frames float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytopncast to btree on
	probe_addr,
	probeindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy lsytopncast () from 'lsytopncast.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytopncast
\p\g
create table lsytopnlinkerr(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	addrtype i1 not null,
	servicetype integer not null,
	netaddr1 varchar(20) not null,
	netaddr2 varchar(20) not null,
	linkerrors float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytopnlinkerr to btree on
	probe_addr,
	probeindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy lsytopnlinkerr () from 'lsytopnlinkerr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytopnlinkerr
\p\g
create table lsytopnmatrix(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	protocolcategory integer,
	protocoltype integer not null,
	srcaddr varchar(20) not null,
	destaddr varchar(20) not null,
	pktstodest float,
	bytestodest float,
	pktstosrc float,
	bytestosrc float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytopnmatrix to btree on
	probe_addr,
	probeindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsytopnmatrix () from 'lsytopnmatrix.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytopnmatrix
\p\g
create table lsytopnnetrsp(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	addrtype i1 not null,
	servicetype integer not null,
	netaddr1 varchar(20) not null,
	netaddr2 varchar(20) not null,
	netrspsum float,
	netrspcount float not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytopnnetrsp to btree on
	probe_addr,
	probeindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsytopnnetrsp () from 'lsytopnnetrsp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytopnnetrsp
\p\g
create table lsytopnroute(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	addrtype i1,
	losubnet varchar(20) not null,
	hisubnet varchar(20) not null,
	servicetype integer,
	pktstohi float,
	bytestohi float,
	pktstolo float,
	bytestolo float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytopnroute to btree on
	probe_addr,
	probeindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy lsytopnroute () from 'lsytopnroute.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytopnroute
\p\g
create table lsytopnroutedelay(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	probeindex integer not null,
	losubnet varchar(20) not null,
	hisubnet varchar(20) not null,
	servicetype integer,
	hopcount integer,
	msgcount integer,
	timeout integer,
	rtt integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify lsytopnroutedelay to btree on
	probe_addr,
	probeindex,
	losubnet,
	hisubnet,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy lsytopnroutedelay () from 'lsytopnroutedelay.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on lsytopnroutedelay
\p\g
create table m2if(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	ifindex integer,
	ifdescr varchar(255),
	iftype integer,
	ifmtu integer,
	ifspeed float,
	ifphysaddress varchar(50),
	ifspecific varchar(50),
	ip_addr varchar(16),
	dbindex integer,
	ifname varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify m2if to btree unique on
	probe_addr,
	ifindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy m2if () from 'm2if.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on m2if
\p\g
create table m2ifstats(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	ifindex integer,
	ifadminstatus i1,
	ifoperstatus i1,
	iflastchange integer,
	ifinoctets float,
	ifinucastpkts float,
	ifinnucastpkts float,
	ifindiscards float,
	ifinerrors float,
	ifinunknownprotos float,
	ifoutoctets float,
	ifoutucastpkts float,
	ifoutnucastpkts float,
	ifoutdiscards float,
	ifouterrors float,
	ifoutqlen integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify m2ifstats to btree on
	probe_addr,
	ifindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024
\p\g
/* copy m2ifstats () from 'm2ifstats.mdbadmin' */
/* with allocation = 128, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on m2ifstats
\p\g
create table m2ipstats(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	ipforwarding integer,
	ipdefaultttl integer,
	ipinreceives float,
	ipinhdrerrors float,
	ipinaddrerrors float,
	ipforwdatagrams float,
	ipinunknownprotos float,
	ipindiscards float,
	ipindelivers float,
	ipoutrequests float,
	ipoutdiscards float,
	ipoutnoroutes float,
	ipreasmtimeout float,
	ipreasmreqds float,
	ipreasmoks float,
	ipreasmfails float,
	ipfragoks float,
	ipfragfails float,
	ipfragcreates float,
	iproutingdiscards float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify m2ipstats to btree on
	probe_addr,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy m2ipstats () from 'm2ipstats.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on m2ipstats
\p\g
create table machine_group(
	group_name varchar(30),
	machine_name varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify machine_group to btree unique on
	group_name,
	machine_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy machine_group () from 'machine_group.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on machine_group
\p\g
create table machinealias(
	id integer,
	machineid integer,
	name varchar(32),
	domain varchar(32),
	starttime date,
	endtime date,
	createdby integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify machinealias to heap
with extend = 16,
	allocation = 4
\p\g
/* copy machinealias () from 'machinealias.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on machinealias
\p\g
create table mactoip(
	macaddress varchar(12),
	ipaddress varchar(15)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mactoip to hash unique on
	macaddress
with fillfactor = 50,
	extend = 32
\p\g
/* copy mactoip () from 'mactoip.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mactoip
\p\g
create table mailconnector(
	mailconnectorid integer not null,
	sourceid integer not null,
	mailconnectorname char(254) not null,
	description varchar(255),
	connectortypeid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mailconnector to btree unique on
	sourceid,
	mailconnectorid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mailconnector () from 'mailconnector.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mailconnector
\p\g
create integrity  ON MailConnector IS SourceID >= 1
\p\g
create integrity  ON MailConnector IS MailConnectorID >= 1
\p\g
create integrity  ON MailConnector IS ConnectorTypeID IN (0, 1, 2, 3, 
4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)
\p\g
create table maildb(
	maildbid integer not null,
	sourceid integer not null,
	dbtitle char(254),
	dbfilename varchar(255),
	maildbname char(254) not null,
	description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify maildb to btree unique on
	sourceid,
	maildbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy maildb () from 'maildb.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on maildb
\p\g
create integrity  ON MailDB IS SourceID >= 1
\p\g
create integrity  ON MailDB IS MailDBID >= 1
\p\g
create table maildisk(
	maildiskid integer not null,
	sourceid integer not null,
	disksize float not null default 0,
	maildiskname char(254) not null,
	description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify maildisk to btree unique on
	sourceid,
	maildiskid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy maildisk () from 'maildisk.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on maildisk
\p\g
create integrity  ON MailDisk IS SourceID >= 1
\p\g
create integrity  ON MailDisk IS MailDiskID >= 1
\p\g
create integrity  ON MailDisk IS DiskSize >= 0
\p\g
create table maildomain(
	maildomainid integer not null,
	maildomainname char(254) not null,
	sourceid integer not null,
	description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify maildomain to btree unique on
	sourceid,
	maildomainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy maildomain () from 'maildomain.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on maildomain
\p\g
create integrity  ON MailDomain IS SourceID >= 1
\p\g
create integrity  ON MailDomain IS MailDomainID >= 1
\p\g
create table mailevent(
	eventtypeid integer not null,
	eventseverityid integer not null,
	sourceid integer not null,
	maileventid integer not null,
	eventid integer,
	maileventname char(254) not null,
	description varchar(255),
	dominologeventtypeid integer not null,
	dominoeventtypeid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mailevent to btree unique on
	sourceid,
	maileventid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mailevent () from 'mailevent.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mailevent
\p\g
create integrity  ON MailEvent IS SourceID >= 1
\p\g
create integrity  ON MailEvent IS MailEventID >= 1
\p\g
create integrity  ON MailEvent IS EventTypeID IN (1, 2, 3, 4)
\p\g
create integrity  ON MailEvent IS EventSeverityID >= 1
\p\g
create integrity  ON MailEvent IS DominoLogEventTypeID IN (1, 2, 3, 4)
\p\g
create integrity  ON MailEvent IS DominoEventTypeID IN (0, 1, 2, 3, 4,
5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23)
\p\g
create table mailobject(
	mailobjectid integer not null,
	mailobjectname char(254) not null,
	mailobjecttype smallint not null,
	description varchar(255),
	sourceid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mailobject to btree unique on
	sourceid,
	mailobjectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mailobject () from 'mailobject.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mailobject
\p\g
create integrity  ON MailObject IS SourceID >= 1
\p\g
create integrity  ON MailObject IS MailObjectID >= 1
\p\g
create integrity  ON MailObject IS MailObjectType IN (1, 2, 3, 4, 5, 
6, 7, 8, 9)
\p\g
create table mailorganisation(
	mailorgid integer not null,
	organisationname char(254) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mailorganisation to btree unique on
	mailorgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mailorganisation () from 'mailorganisation.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mailorganisation
\p\g
create integrity  ON MailOrganisation IS MailOrgID >= 1
\p\g
create table mailqueue(
	mailqueueid integer not null,
	sourceid integer not null,
	queuetype smallint not null,
	mailqueuename char(254) not null,
	description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mailqueue to btree unique on
	sourceid,
	mailqueueid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mailqueue () from 'mailqueue.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mailqueue
\p\g
create integrity  ON MailQueue IS SourceID >= 1
\p\g
create integrity  ON MailQueue IS MailQueueID >= 1
\p\g
create integrity  ON MailQueue IS QueueType IN (1, 2)
\p\g
create table mailservice(
	mailserviceid integer not null,
	sourceid integer not null,
	mailservicename char(254) not null,
	description varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mailservice to btree unique on
	sourceid,
	mailserviceid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mailservice () from 'mailservice.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mailservice
\p\g
create integrity  ON MailService IS SourceID >= 1
\p\g
create integrity  ON MailService IS MailServiceID >= 1
\p\g
create table man_mod(
	id integer not null,
	persid varchar(30),
	del integer not null,
	alias integer,
	last_mod integer,
	mdl_sym varchar(80) not null,
	mdl_mfr_id byte varying(16),
	mdl_name varchar(80),
	mdl_grc byte varying(16),
	mdl_sla integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify man_mod to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy man_mod () from 'man_mod.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on man_mod
\p\g
create table managed_survey(
	id integer not null,
	persid varchar(30),
	del integer not null,
	description varchar(400),
	sym varchar(12) not null,
	owner byte varying(16),
	group_id byte varying(16),
	tplid integer,
	status varchar(12),
	initial_msgbody varchar(1000),
	initial_msgtitle varchar(80),
	initial_method integer,
	reminder_msgbody varchar(1000),
	reminder_msgtitle varchar(80),
	reminder_method integer,
	start_date integer,
	end_date integer,
	create_date integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify managed_survey to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy managed_survey () from 'managed_survey.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on managed_survey
\p\g
create table management_alert(
	counterid integer not null,
	personsourceid integer,
	tstamp date not null,
	source char(254) not null,
	objectid integer,
	status smallint not null,
	description varchar(255) not null,
	countervalue float,
	threshold float,
	prevstatus smallint not null,
	stringvalue varchar(255),
	issent smallint not null,
	datevalue date,
	sourceid integer not null,
	personid integer,
	alertid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_alert to btree unique on
	counterid,
	sourceid,
	alertid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy management_alert () from 'management_alert.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on management_alert
\p\g
create integrity  ON Management_Alert IS CounterID >= 1
\p\g
create integrity  ON Management_Alert IS SourceID >= 1
\p\g
create integrity  ON Management_Alert IS AlertID >= 1
\p\g
create integrity  ON Management_Alert IS ObjectID >= 1
\p\g
create integrity  ON Management_Alert IS PersonSourceID >= 1
\p\g
create integrity  ON Management_Alert IS PersonID >= 1
\p\g
create integrity  ON Management_Alert IS Status IN (1, 2, 3)
\p\g
create integrity  ON Management_Alert IS PrevStatus IN (1, 2, 3)
\p\g
create table management_asset_group(
	assetnode varchar(64) not null,
	id varchar(20) not null,
	name varchar(255) not null,
	asset varchar(255) not null,
	type varchar(24) not null,
	createdate integer,
	createtime integer,
	createsource varchar(64),
	createnode varchar(64),
	createuser varchar(32),
	createpid char(5),
	updatedate integer,
	updatetime integer,
	updatesource varchar(64),
	updatenode varchar(64),
	updateuser varchar(32),
	updatepid char(5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_asset_group to hash unique on
	assetnode,
	id,
	name,
	asset,
	type
with fillfactor = 50,
	extend = 16
\p\g
/* copy management_asset_group () from 'management_asset_group.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on management_asset_group
\p\g
create table management_collector(
	collectorid integer not null,
	collectorname char(15) not null,
	hostname char(254) not null,
	servername varchar(255) not null,
	dbname varchar(255) not null,
	username varchar(255),
	userpsw varchar(255),
	logfilelocation varchar(255),
	needrefresh i1 not null,
	collectortype smallint not null,
	rawdatakeepinterval integer,
	rawdatatimefactor smallint,
	hourlydatakeepinterval integer,
	hourlytimefactor smallint,
	dailydatakeepinterval integer,
	dailytimefactor smallint,
	weeklydatakeepinterval integer,
	weeklytimefactor smallint,
	monthlydatakeepinterval integer,
	monthlytimefactor smallint,
	yearlydatakeepinterval integer,
	yearlytimefactor smallint,
	parentcollectorid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_collector to heap
with extend = 16,
	allocation = 4
\p\g
/* copy management_collector () from 'management_collector.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on management_collector
\p\g
create table management_collectoraction(
	actionid integer not null,
	actionname char(254) not null,
	actiontype smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_collectoraction to heap
with extend = 16,
	allocation = 4
\p\g
/* copy management_collectoraction () from 'management_collectoraction.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on management_collectoraction
\p\g
create table management_config(
	oid integer not null,
	label varchar(64) not null,
	descr varchar(254),
	owner varchar(60) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_config to heap
with extend = 16,
	allocation = 4
\p\g
/* copy management_config () from 'management_config.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on management_config
\p\g
create table management_groupid(
	id char(20),
	createdate integer,
	createtime integer,
	createuser varchar(32),
	updatedate integer,
	updatetime integer,
	updateuser varchar(32),
	descr varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_groupid to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy management_groupid () from 'management_groupid.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on management_groupid
\p\g
create table management_groups(
	id char(20),
	stationid char(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_groups to btree unique on
	id,
	stationid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy management_groups () from 'management_groups.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on management_groups
\p\g
create table management_hub(
	oid integer not null,
	vrsn_oid integer not null,
	descr varchar(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_hub to heap
with extend = 16,
	allocation = 4
\p\g
/* copy management_hub () from 'management_hub.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on management_hub
\p\g
create table management_product(
	prodname char(254) not null,
	majorver smallint not null,
	minorver smallint not null,
	patchbetaver smallint,
	build smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_product to btree unique on
	prodname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy management_product () from 'management_product.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on management_product
\p\g
create table management_report(
	reportid integer not null,
	title char(254) not null,
	tablename varchar(255) not null,
	allcolumns i1 not null,
	isdistinct i1,
	reporttype smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_report to btree unique on
	reportid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy management_report () from 'management_report.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on management_report
\p\g
create integrity  ON Management_Report IS ReportID >= 1
\p\g
create integrity  ON Management_Report IS ReportType IN (1, 2, 3, 4)
\p\g
create table management_schedule(
	actionid integer not null,
	collectorid integer not null,
	scheduletype smallint not null,
	startdatetime date not null,
	occurs smallint,
	dailyfrequency smallint,
	every integer,
	enddatetime date,
	sun i1 not null,
	mon i1 not null,
	tue i1 not null,
	wen i1 not null,
	thur i1 not null,
	fri i1 not null,
	sat i1 not null,
	daytype smallint,
	intervalunit smallint,
	dayofmonth integer,
	weeknumber smallint,
	weekday smallint,
	lastrundate date,
	timeevery integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify management_schedule to heap
with extend = 16,
	allocation = 4
\p\g
/* copy management_schedule () from 'management_schedule.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on management_schedule
\p\g
create table maxid(
	id integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify maxid to heap
with extend = 16,
	allocation = 4
\p\g
/* copy maxid () from 'maxid.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on maxid
\p\g
create table metric_field_values(
	metric_name varchar(100) not null,
	field_name varchar(50) not null,
	value varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify metric_field_values to btree unique on
	metric_name,
	field_name,
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy metric_field_values () from 'metric_field_values.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on metric_field_values
\p\g
create table metric_fields(
	field_name varchar(50) not null,
	metric_name varchar(100) not null,
	label varchar(100),
	tooltip varchar(50),
	description varchar(255),
	tab_order integer,
	type varchar(20) not null,
	property varchar(20),
	required integer,
	editable integer,
	hidden integer,
	defaultval varchar(255),
	minval varchar(255),
	maxval varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify metric_fields to btree unique on
	field_name,
	metric_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy metric_fields () from 'metric_fields.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on metric_fields
\p\g
create table metric_keyword(
	keyword_id decimal(31,0) not null,
	metric_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify metric_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy metric_keyword () from 'metric_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on metric_keyword
\p\g
create table metric_menues(
	metric_name varchar(100) not null,
	menu_id varchar(100) not null,
	menu_label varchar(100) not null,
	taborder varchar(10),
	trig varchar(50) not null,
	type varchar(50) not null,
	action varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify metric_menues to btree unique on
	metric_name,
	menu_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy metric_menues () from 'metric_menues.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on metric_menues
\p\g
create table metric_reports(
	report_name varchar(255) not null,
	metric_name varchar(100) not null,
	report_function varchar(50) not null,
	goal_name varchar(100),
	unit varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify metric_reports to btree unique on
	report_name,
	metric_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy metric_reports () from 'metric_reports.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on metric_reports
\p\g
create table metric_value_set(
	metric_value_set_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	metric_id decimal(31,0),
	metric_value_set_name varchar(1200) not null,
	metric_value_set_description varchar(4000),
	column_label varchar(4000),
	is_display_method smallint,
	is_scheduler_effort smallint,
	default_value_access integer,
	is_scheduler_property_mapped smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify metric_value_set to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy metric_value_set () from 'metric_value_set.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on metric_value_set
\p\g
create table metric_weight(
	metric_weight_id decimal(31,0) not null,
	weight integer not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify metric_weight to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy metric_weight () from 'metric_weight.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on metric_weight
\p\g
create table metrics(
	metric_name varchar(100) not null,
	parent varchar(100),
	class varchar(50),
	alias varchar(50),
	agent varchar(30),
	label varchar(100),
	description varchar(255),
	class_scope varchar(50),
	metric_scope varchar(100),
	metric_help varchar(1023),
	created integer,
	created_by varchar(50),
	last_modified integer,
	last_modified_by varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify metrics to btree unique on
	metric_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy metrics () from 'metrics.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on metrics
\p\g
create table mgmt_acctg_summ_post(
	period_length varchar(120) not null,
	management_period_id decimal(31,0),
	project_size_id decimal(31,0) not null,
	client_object_code varchar(4000),
	client_object_name varchar(1200),
	decimal_projects decimal(31,0),
	projects_finished decimal(31,0),
	days_receipt_estimated integer,
	days_estimated_approved integer,
	days_approved_complete integer,
	projects_finished_on_time decimal(31,0),
	projects_received decimal(31,0),
	projects_withdrawn decimal(31,0),
	backlogged_projects decimal(31,0),
	backlogged_hrs decimal(31,0),
	tot_turnaround_days integer,
	projects_on_hold decimal(31,0),
	net_changes decimal(31,0),
	project_size_name varchar(1200),
	project_size_code varchar(4000),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify mgmt_acctg_summ_post to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy mgmt_acctg_summ_post () from 'mgmt_acctg_summ_post.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mgmt_acctg_summ_post
\p\g
create table mgmt_accting_period(
	management_period_id decimal(31,0),
	period_code varchar(4000),
	period_name varchar(1200),
	period_start_date date,
	period_end_date date,
	final_post_flag smallint,
	ytd_end_flag smallint,
	posted_by_user_name varchar(1200),
	post_datetime date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify mgmt_accting_period to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy mgmt_accting_period () from 'mgmt_accting_period.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mgmt_accting_period
\p\g
create table mgmt_detail_project_post(
	management_period_id decimal(31,0),
	period_length varchar(120) not null,
	client_object_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	project_code varchar(40),
	project_name varchar(120),
	project_manager_code varchar(40),
	project_manager_name varchar(120),
	project_size_code varchar(40),
	project_size_name varchar(120),
	client_object_code varchar(40),
	client_object_name varchar(120),
	client_group_flag smallint,
	client_group_name varchar(120),
	allocation_percentage float,
	year_indicator_code integer,
	task_wbs varchar(40),
	proj_tot_var_cost decimal(31,2),
	proj_tot_fix_cost decimal(31,2),
	proj_tot_ovt_cost decimal(31,2),
	proj_tot_ovhead_cost decimal(31,2),
	proj_tot_act_var_cost decimal(31,2),
	proj_tot_act_fix_cost decimal(31,2),
	proj_tot_act_ovt_cost decimal(31,2),
	proj_tot_act_ovhead_cost decimal(31,2),
	proj_tot_base_var_cost decimal(31,2),
	proj_tot_base_fix_cost decimal(31,2),
	proj_tot_bcwp decimal(31,2),
	proj_tot_asgn_hrs decimal(31,0),
	proj_tot_ovt_hrs decimal(31,0),
	proj_tot_oversch_hrs decimal(31,0),
	proj_tot_act_hrs decimal(31,0),
	proj_tot_act_ovt_hrs decimal(31,0),
	proj_tot_base_hrs decimal(31,0),
	proj_tot_mat_hrs decimal(31,0),
	proj_tot_act_mat_hrs decimal(31,0),
	proj_tot_upd_var_hrs decimal(31,0),
	proj_tot_upd_fix_cost decimal(31,2),
	proj_tot_upd_ovt_cost decimal(31,2),
	proj_tot_upd_hrs decimal(31,0),
	proj_tot_upd_ovt_hrs decimal(31,0),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify mgmt_detail_project_post to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy mgmt_detail_project_post () from 'mgmt_detail_project_post.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mgmt_detail_project_post
\p\g
create table mgmt_dtl_proj_1_lvl_post(
	management_period_id decimal(31,0) not null,
	period_length varchar(120) not null,
	client_object_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	project_code varchar(40),
	project_name varchar(120),
	project_manager_code varchar(40),
	project_manager_name varchar(120),
	project_size_code varchar(40),
	project_size_name varchar(120),
	client_object_code varchar(400),
	client_object_name varchar(120),
	client_group_flag smallint,
	client_group_name varchar(120),
	allocation_percent float,
	year_indicator_code integer,
	task_name varchar(120),
	task_wbs varchar(400),
	task_tot_var_cost decimal(31,2),
	task_tot_fix_cost decimal(31,2),
	task_tot_ovt_cost decimal(31,2),
	task_tot_ovhead_cost decimal(31,2),
	task_tot_act_var_cost decimal(31,2),
	task_tot_act_fix_cost decimal(31,2),
	task_tot_act_ovt_cost decimal(31,2),
	task_tot_act_ovhead_cost decimal(31,2),
	task_tot_base_var_cost decimal(31,2),
	task_tot_base_fix_cost decimal(31,2),
	task_tot_bcwp decimal(31,2),
	task_tot_asgn_hrs decimal(31,0),
	task_tot_ovt_hrs decimal(31,0),
	task_tot_oversch_hrs decimal(31,0),
	task_tot_act_hrs decimal(31,0),
	task_tot_act_ovt_hrs decimal(31,0),
	task_tot_base_hrs decimal(31,0),
	task_tot_mat_hrs decimal(31,0),
	task_tot_act_mat_hrs decimal(31,0),
	task_tot_upd_var_hrs decimal(31,0),
	task_tot_upd_fix_cost decimal(31,2),
	task_tot_upd_ovt_cost decimal(31,2),
	task_tot_upd_hrs decimal(31,0),
	task_tot_upd_ovt_hrs decimal(31,0),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(120),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify mgmt_dtl_proj_1_lvl_post to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy mgmt_dtl_proj_1_lvl_post () from 'mgmt_dtl_proj_1_lvl_post.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mgmt_dtl_proj_1_lvl_post
\p\g
create table mgsalg(
	id integer not null,
	persid varchar(30),
	mgs_id integer,
	last_mod_dt integer,
	time_spent integer,
	time_stamp integer,
	system_time integer,
	analyst byte varying(16),
	description varchar(1000),
	action_desc varchar(700),
	type varchar(12),
	internal integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify mgsalg to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy mgsalg () from 'mgsalg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mgsalg
\p\g
create table mgsstat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	code varchar(12) not null,
	active integer,
	hold integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify mgsstat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy mgsstat () from 'mgsstat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mgsstat
\p\g
create table mibdefinition(
	mibidx integer not null,
	mibtype integer not null default 0,
	description varchar(128) not null,
	collection c1 not null,
	mib_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mibdefinition to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mibdefinition () from 'mibdefinition.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mibdefinition
\p\g
create integrity  ON MIBDefinition IS MibType IN (0, 1)
\p\g
create integrity  ON MIBDefinition IS Collection IN ('1', '0')
\p\g
create table mibstructure(
	mibidx integer not null,
	oididxformib integer not null,
	oid varchar(128) not null,
	type integer not null,
	discoverykey c1 not null,
	isifindex c1 not null,
	isstatus c1 not null,
	componentmibindexidx integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mibstructure to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mibstructure () from 'mibstructure.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mibstructure
\p\g
create integrity  ON MibStructure IS DiscoveryKey IN ('Y', 'N')
\p\g
create integrity  ON MibStructure IS IsIfIndex IN ('Y', 'N')
\p\g
create table mibvariabletype(
	typeid integer not null,
	category c32,
	subcategory c32,
	description varchar(128),
	basetypeidx integer,
	collectable c1 not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mibvariabletype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mibvariabletype () from 'mibvariabletype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mibvariabletype
\p\g
create integrity  ON MibVariableType IS Collectable IN ('Y', 'N')
\p\g
create table miftypes(
	domainid integer not null,
	typeid integer not null,
	mtypeid varchar(120),
	mareaid varchar(120),
	mnameid varchar(120)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify miftypes to btree unique on
	typeid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy miftypes () from 'miftypes.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on miftypes
\p\g
create table mit_host(
	host_id integer not null,
	host_name varchar(255) not null,
	host_domain varchar(255),
	os_type varchar(255),
	os_version varchar(255),
	manageit_home varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_host to btree unique on
	host_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_host () from 'mit_host.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_host
\p\g
create table mit_host_parm(
	host_id integer not null,
	keyword varchar(250) not null,
	value varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_host_parm to btree unique on
	host_id,
	keyword
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_host_parm () from 'mit_host_parm.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_host_parm
\p\g
create table mit_identifier(
	id_type varchar(255) not null,
	id_value integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_identifier to btree unique on
	id_type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_identifier () from 'mit_identifier.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_identifier
\p\g
create table mit_product(
	host_id integer not null,
	component_code varchar(250) not null,
	version varchar(255) not null,
	name varchar(255) not null,
	short_name varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_product to btree unique on
	host_id,
	component_code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_product () from 'mit_product.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_product
\p\g
create table mit_repository(
	keynum integer not null,
	version varchar(255) not null,
	lastupdated varchar(255) not null,
	enabled i1 not null,
	manager_node varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_repository to btree unique on
	keynum
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_repository () from 'mit_repository.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_repository
\p\g
create table mit_server(
	server_id integer not null,
	server_name varchar(255) not null,
	server_type char(1) not null,
	server_version varchar(255),
	host_id integer,
	port integer,
	connect_name varchar(255),
	oracle_sid varchar(255),
	database_path varchar(255),
	community varchar(255),
	udb_instance varchar(255),
	connect_database varchar(255),
	service_name varchar(255),
	extended_info varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_server to btree unique on
	server_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy mit_server () from 'mit_server.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_server
\p\g
create table mit_server_parm(
	server_id integer not null,
	keyword varchar(250) not null,
	value varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_server_parm to btree unique on
	server_id,
	keyword
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_server_parm () from 'mit_server_parm.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_server_parm
\p\g
create table mit_server_type(
	server_type char(1) not null,
	server_description varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_server_type to btree unique on
	server_type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_server_type () from 'mit_server_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_server_type
\p\g
create table mit_server_user(
	user_id varchar(250) not null,
	server_id integer not null,
	server_user varchar(255),
	server_password varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mit_server_user to btree unique on
	user_id,
	server_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mit_server_user () from 'mit_server_user.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mit_server_user
\p\g
create table mitjas_calen_date(
	calendarid char(30) not null,
	rundate decimal(15,0) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_calen_date to btree unique on
	calendarid,
	rundate
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mitjas_calen_date () from 'mitjas_calen_date.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mitjas_calen_date
\p\g
create table mitjas_calen_node(
	calendarid char(30) not null,
	node varchar(60) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_calen_node to btree unique on
	calendarid,
	node
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mitjas_calen_node () from 'mitjas_calen_node.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mitjas_calen_node
\p\g
create table mitjas_calendar(
	id char(30) not null,
	description varchar(60)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_calendar to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mitjas_calendar () from 'mitjas_calendar.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mitjas_calendar
\p\g
create table mitjas_group(
	strid decimal(15,0) not null,
	groupid decimal(15,0) not null,
	description varchar(255),
	productcode varchar(8),
	productversion varchar(8),
	jobs_per_run decimal(15,0),
	created decimal(15,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_group to btree unique on
	strid,
	groupid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mitjas_group () from 'mitjas_group.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mitjas_group
\p\g
create table mitjas_job(
	joid decimal(15,0) not null,
	groupid decimal(15,0),
	username varchar(50),
	userrole varchar(125),
	node varchar(60),
	deployed decimal(15,0),
	next_start decimal(15,0),
	command varchar(255),
	commandb varchar(255),
	runcount integer,
	timezone integer,
	wstimezone varchar(12),
	retryinterval integer,
	retrycount integer,
	n_retrys integer,
	recurfailcount integer,
	notificationemail varchar(185),
	completionscript varchar(185),
	failedscript varchar(185),
	productcode varchar(8),
	productversion varchar(8),
	description varchar(128),
	type varchar(30),
	instance varchar(60),
	owner varchar(50),
	cred_value varchar(60),
	connectstring varchar(60),
	jobowner varchar(50),
	accessmode char(1),
	can_be_resumed smallint,
	resume_requested smallint,
	run_to_resume integer,
	object varchar(60),
	runstate smallint,
	calendarid char(30),
	recurinterval integer,
	recurincrement integer,
	everyweekday smallint,
	days_of_week char(7),
	dayofmonthflags char(31),
	lastdayofmonth smallint,
	yearmonth smallint,
	timeofdayhour smallint,
	timeofdayminute smallint,
	start_times char(60),
	cookies integer,
	n_preemptretries integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_job to btree unique on
	joid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy mitjas_job () from 'mitjas_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mitjas_job
\p\g
create table mitjas_jobhist(
	joid decimal(15,0) not null,
	run_num integer not null,
	groupid decimal(15,0),
	scheduledstarttime decimal(15,0),
	timezone varchar(12),
	starttime decimal(15,0),
	endtime decimal(15,0),
	startstatus smallint,
	osstatus decimal(15,0),
	failed smallint,
	preempted smallint,
	stopped smallint,
	status integer,
	logfilename varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_jobhist to btree unique on
	joid,
	run_num
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy mitjas_jobhist () from 'mitjas_jobhist.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mitjas_jobhist
\p\g
create table mitjas_jobparms(
	joid decimal(15,0) not null,
	parmname varchar(60) not null,
	parmvalue varchar(1960),
	parmvalueb varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_jobparms to btree unique on
	joid,
	parmname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy mitjas_jobparms () from 'mitjas_jobparms.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on mitjas_jobparms
\p\g
create table mitjas_setup(
	joid decimal(15,0),
	groupid decimal(15,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mitjas_setup to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mitjas_setup () from 'mitjas_setup.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mitjas_setup
\p\g
create table mmaccess(
	accessid integer not null,
	sessionid integer not null,
	objectid integer not null,
	accessmode smallint not null,
	opened date,
	lastobjectid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmaccess to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmaccess () from 'mmaccess.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmaccess
\p\g
create table mmaction(
	actionid smallint not null,
	actionname varchar(130) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmaction to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmaction () from 'mmaction.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmaction
\p\g
create table mmactiongrouping(
	metaactionid smallint not null,
	actionid smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmactiongrouping to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmactiongrouping () from 'mmactiongrouping.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmactiongrouping
\p\g
create table mmapplication(
	clientid smallint not null,
	applicationname varchar(130) not null,
	abbreviation char(3) not null,
	buildnumber smallint,
	lowerlimit smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmapplication to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmapplication () from 'mmapplication.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmapplication
\p\g
create table mmclass(
	classid integer not null,
	classname varchar(130),
	containerclassid integer,
	iscontainer smallint,
	islockable smallint,
	isphysical smallint,
	classlabel varchar(255),
	ispersistenceunit smallint,
	orderid integer,
	iscountable smallint,
	isignoredefault smallint,
	clientid smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmclass to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmclass () from 'mmclass.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmclass
\p\g
create table mmcontrol(
	controlid smallint not null,
	controlname varchar(130) not null,
	controlvalue integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmcontrol to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmcontrol () from 'mmcontrol.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmcontrol
\p\g
create table mmcontrolcache(
	sessionid integer not null,
	nextobjectid integer not null,
	cachecounter integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmcontrolcache to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmcontrolcache () from 'mmcontrolcache.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmcontrolcache
\p\g
create table mmdbms(
	dbmsid smallint not null,
	dbmsname varchar(130)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmdbms to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmdbms () from 'mmdbms.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmdbms
\p\g
create table mmdeleted(
	deleteid smallint,
	recursionlevel smallint,
	objectid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmdeleted to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmdeleted () from 'mmdeleted.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmdeleted
\p\g
create table mmlibrary(
	objectid integer not null,
	objectname varchar(130),
	objectcount integer,
	specialobjectcount integer,
	propertycount integer,
	createdby varchar(130),
	created date,
	updatedby varchar(130),
	updated date,
	isarchive smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmlibrary to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmlibrary () from 'mmlibrary.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmlibrary
\p\g
create table mmlicense(
	serialnumber char(30),
	licensecode char(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmlicense to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmlicense () from 'mmlicense.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmlicense
\p\g
create table mmlock(
	objectid integer not null,
	sessionid integer not null,
	lockgroup integer not null,
	locktype char(1) not null,
	isolationlevel char(1) not null,
	isprimary char(1) not null,
	accessid integer,
	locktypeid smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmlock to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmlock () from 'mmlock.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmlock
\p\g
create table mmlocktype(
	locktypeid smallint not null,
	locktypename varchar(130) not null,
	isenforced smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmlocktype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmlocktype () from 'mmlocktype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmlocktype
\p\g
create table mmmaster(
	repositoryname varchar(30) not null,
	createdby varchar(30),
	creationdate date,
	version integer,
	buildnumber integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmmaster to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmmaster () from 'mmmaster.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmmaster
\p\g
create table mmobject(
	containerid integer not null,
	contextid integer not null,
	classid integer not null,
	startversion integer not null,
	endversion integer,
	objectid integer not null,
	masterid integer not null,
	originid byte(21)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmobject to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmobject () from 'mmobject.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmobject
\p\g
create table mmobjectproperty(
	objectid integer not null,
	propertyid integer not null,
	sequencenumber smallint not null,
	valuesequencecount smallint not null,
	valueobjectid integer,
	stringvalue varchar(255),
	intvalue integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmobjectproperty to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmobjectproperty () from 'mmobjectproperty.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmobjectproperty
\p\g
create table mmpermission(
	profileid integer not null,
	actionid smallint not null,
	contextclassid integer not null,
	targetclassid integer not null,
	granted smallint,
	clientid smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmpermission to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmpermission () from 'mmpermission.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmpermission
\p\g
create table mmpermissionprofile(
	profileid integer not null,
	profilename varchar(130) not null,
	profiledescription varchar(255),
	parentprofileid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmpermissionprofile to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmpermissionprofile () from 'mmpermissionprofile.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmpermissionprofile
\p\g
create table mmpermissiontype(
	actionid smallint not null,
	contextclassid integer not null,
	targetclassid integer not null,
	permissiontypename varchar(130) not null,
	clientid smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmpermissiontype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmpermissiontype () from 'mmpermissiontype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmpermissiontype
\p\g
create table mmprofileassignment(
	profileid integer not null,
	userid integer not null,
	objectid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmprofileassignment to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmprofileassignment () from 'mmprofileassignment.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmprofileassignment
\p\g
create table mmproperty(
	propertyid integer not null,
	clientid smallint not null,
	propertyname varchar(130),
	isstring smallint,
	isnumber smallint,
	isobject smallint,
	islist smallint,
	valueobjectclassid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmproperty to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmproperty () from 'mmproperty.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmproperty
\p\g
create table mmpropertyassociation(
	classid integer not null,
	propertyid integer not null,
	clientid smallint not null,
	isclientmaintained smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmpropertyassociation to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmpropertyassociation () from 'mmpropertyassociation.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmpropertyassociation
\p\g
create table mmquery(
	name varchar(130) not null,
	text long varchar not null,
	description varchar(255),
	classid integer,
	outputclassid integer,
	issystem smallint,
	author varchar(130) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmquery to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmquery () from 'mmquery.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmquery
\p\g
create table mmsession(
	sessionid integer not null,
	userid integer not null,
	serveruserid integer not null,
	sessionstart date,
	sessionend date,
	sessionconnect date,
	librariesopen integer,
	traceactive smallint,
	scriptinprogress smallint,
	applicationname varchar(130)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmsession to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmsession () from 'mmsession.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmsession
\p\g
create table mmtrace(
	sequence integer not null,
	eventid smallint not null,
	traceid integer not null,
	sessionid integer,
	objectid integer,
	userid integer,
	containerid integer,
	tag1 integer,
	tag2 integer,
	value varchar(255),
	tracetime date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmtrace to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmtrace () from 'mmtrace.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmtrace
\p\g
create table mmtraceevent(
	eventid smallint not null,
	eventname varchar(130) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmtraceevent to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmtraceevent () from 'mmtraceevent.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmtraceevent
\p\g
create table mmuser(
	userid integer not null,
	serveruserid integer,
	servername varchar(130),
	isgroup smallint not null,
	currentsessions integer,
	totalsessions integer,
	lastlogin date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify mmuser to heap
with extend = 16,
	allocation = 4
\p\g
/* copy mmuser () from 'mmuser.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on mmuser
\p\g
create table monbro(
	name varchar(30),
	mon_mode char(1),
	do_output char(1),
	sound i1,
	alarm_verif i1,
	alarm i1,
	all_events i1,
	all_status i1,
	running i1,
	success i1,
	failure i1,
	terminate i1,
	starting i1,
	restart i1,
	on_ice i1,
	on_hold i1,
	job_filter char(1),
	job_name varchar(64),
	currun i1,
	after_time varchar(20),
	autoserv varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify monbro to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy monbro () from 'monbro.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on monbro
\p\g
create table monitor(
	monitor_id integer not null,
	monitor_type integer,
	low_threshold integer,
	high_threshold integer,
	creation_date date not null,
	modification_date date not null,
	severity_id integer,
	operation_id integer,
	operation_group_id integer,
	ata_source_name varchar(255),
	percentage_threshold integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify monitor to btree unique on
	monitor_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy monitor () from 'monitor.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on monitor
\p\g
create table monitor_notification(
	monitor_notification_id integer not null,
	severity_id integer,
	notification_type integer,
	contact_list_id integer,
	contact_id integer,
	snmp_manager_id integer,
	ext_command_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify monitor_notification to btree unique on
	monitor_notification_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy monitor_notification () from 'monitor_notification.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on monitor_notification
\p\g
create table monitor_property(
	monitor_property_id integer not null,
	monitor_id integer,
	name varchar(255),
	value_data_type integer,
	value_int integer,
	value_char varchar(255),
	value_date date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify monitor_property to btree unique on
	monitor_property_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy monitor_property () from 'monitor_property.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on monitor_property
\p\g
create table monitorappl(
	servicetype integer not null,
	mode integer not null,
	method integer not null,
	category integer not null,
	subcategory integer,
	netaddrtype integer not null,
	netaddr varchar(20),
	name varchar(133),
	siotimeout integer,
	topn_ct integer,
	script varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify monitorappl to btree on
	servicetype
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy monitorappl () from 'monitorappl.mdbadmin' */
/* with allocation = 8, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on monitorappl
\p\g
create table msg_ack(
	eoid varchar(12),
	who varchar(30),
	timein integer,
	timeack integer,
	comm varchar(80)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify msg_ack to btree unique on
	eoid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy msg_ack () from 'msg_ack.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on msg_ack
\p\g
create table nahd_hist_settings(
	id integer not null,
	nahd_server_name varchar(512),
	ahd_web_mode integer,
	ahd_url varchar(512),
	ahd_web_username varchar(50),
	ahd_web_password varchar(50),
	ahd_default_id varchar(50),
	ahd_default_type varchar(50),
	enable_demo integer,
	nahd_demo_timestamp integer,
	graph_file_name varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify nahd_hist_settings to heap
with extend = 16,
	allocation = 4
\p\g
/* copy nahd_hist_settings () from 'nahd_hist_settings.mdbadmin' */
/* with row_estimate = 1 */
/* \p\g */
set journaling on nahd_hist_settings
\p\g
create table name(
	eid integer not null not default,
	raw varchar(129) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify name to btree unique on
	eid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy name () from 'name.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on name
\p\g
create table namelist(
	oid integer not null,
	qmgr_oid integer not null,
	namelist varchar(48) not null,
	descr varchar(64),
	namcount integer,
	names text(1),
	qsgdisp varchar(8),
	nltype varchar(10),
	altdate varchar(48),
	alttime varchar(48)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify namelist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy namelist () from 'namelist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on namelist
\p\g
create table namelistcfg(
	qmgrid integer not null,
	namelistid integer not null,
	namelistname varchar(20) not null,
	type char(10) not null,
	status integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify namelistcfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy namelistcfg () from 'namelistcfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on namelistcfg
\p\g
create table nbarprotocol_cfg(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	supportedprotocolsindex integer,
	supportedprotocolsname varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify nbarprotocol_cfg to btree on
	probe_addr,
	supportedprotocolsindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy nbarprotocol_cfg () from 'nbarprotocol_cfg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nbarprotocol_cfg
\p\g
create table nbarprotocol_stat(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	allstatsprotocolsindex integer,
	ifindex integer,
	allstatshcinpkts float,
	allstatshcoutpkts float,
	allstatshcinbytes float,
	allstatshcoutbytes float,
	allstatsinbitrate float,
	allstatsoutbitrate float,
	dbindex integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify nbarprotocol_stat to btree on
	probe_addr,
	allstatsprotocolsindex,
	ifindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy nbarprotocol_stat () from 'nbarprotocol_stat.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nbarprotocol_stat
\p\g
create table nbarprotocolstatus_cfg(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	statuspdenable integer,
	ifindex integer,
	dbindex integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify nbarprotocolstatus_cfg to btree on
	probe_addr,
	ifindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy nbarprotocolstatus_cfg () from 'nbarprotocolstatus_cfg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nbarprotocolstatus_cfg
\p\g
create table nbarprotocolstatus_stat(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	ifindex integer,
	statuslastupdatetime integer,
	dbindex integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify nbarprotocolstatus_stat to btree on
	probe_addr,
	ifindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy nbarprotocolstatus_stat () from 'nbarprotocolstatus_stat.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nbarprotocolstatus_stat
\p\g
create table ncipc(
	ipcid integer not null,
	ipctype integer,
	ipctypex integer,
	adomid integer,
	ipcacid integer,
	edomid integer,
	ipcextid integer,
	sdomid integer,
	ipcstype integer,
	ipcsid integer,
	udomid integer,
	unitid integer,
	ipcdate integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncipc to btree unique on
	ipcid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncipc () from 'ncipc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncipc
\p\g
create table ncjobbin(
	domainid integer not null,
	jobid integer not null,
	jobpart integer not null,
	contents text(1),
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncjobbin to btree unique on
	jobid,
	jobpart,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncjobbin () from 'ncjobbin.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncjobbin
\p\g
create table ncjobcfg(
	domainid integer not null,
	jobid integer not null,
	joname varchar(80),
	jotype integer,
	jocont text(1),
	jocmd varchar(127),
	joos integer,
	jocreate integer,
	jomodify integer,
	josdate integer,
	jostime integer,
	joedate integer,
	joetime integer,
	jofreq integer,
	josched varchar(7),
	joinst integer,
	joonceat integer,
	jooncenr integer,
	joflag integer,
	joexit integer,
	jddomid integer,
	jodepend integer,
	joquest varchar(127),
	joqforce integer,
	joqfdate integer,
	jologoff varchar(127),
	joremove integer,
	jodepfil varchar(127),
	jodevice varchar(5),
	joserv varchar(127),
	jodiscon integer,
	joiconid integer,
	jopartnr integer,
	revnr integer,
	userid integer,
	checksum integer,
	auto_server_version integer default 0,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncjobcfg to btree unique on
	jobid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncjobcfg () from 'ncjobcfg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncjobcfg
\p\g
create table nclog(
	domainid integer not null,
	logid integer not null,
	logtype integer,
	logsev integer,
	logname varchar(127),
	logrefnr integer,
	logdate integer,
	unitid integer,
	userid integer,
	logmemo varchar(127)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify nclog to btree unique on
	logid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy nclog () from 'nclog.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nclog
\p\g
create table ncmodbin(
	mopart integer not null,
	moid integer not null,
	contents text(1),
	domainid integer not null,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncmodbin to btree unique on
	mopart,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncmodbin () from 'ncmodbin.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncmodbin
\p\g
create table ncmodcfg(
	domainid integer not null,
	moid integer not null,
	moname varchar(127) not null,
	mocont text(1),
	mocmd varchar(127),
	moos integer,
	motype integer not null,
	mocreate integer,
	momodify integer,
	mosdate integer,
	mostime integer,
	moedate integer,
	moetime integer,
	mofreq integer,
	mosched varchar(7),
	moinst integer,
	moonceat integer,
	mooncenr integer,
	moflag integer,
	jdmodid integer,
	modepend integer,
	moquest varchar(127),
	moqforce integer,
	moqfdate integer,
	mologoff varchar(127),
	moremove integer,
	modepfil varchar(127),
	modevice varchar(5),
	moserv varchar(127),
	modiscon integer,
	mopartnr integer,
	revnr integer,
	userid integer,
	checksum integer,
	auto_server_version integer default 0,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncmodcfg to btree unique on
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncmodcfg () from 'ncmodcfg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncmodcfg
\p\g
create table ncovervw(
	domainid integer not null,
	unittype integer not null,
	type integer not null,
	prnmid integer not null,
	idomid integer not null,
	nameid integer not null,
	name varchar(50),
	idx integer,
	attrib integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncovervw to btree unique on
	nameid,
	prnmid,
	unittype,
	type,
	domainid,
	idomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncovervw () from 'ncovervw.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncovervw
\p\g
create table ncprofil(
	profilid integer not null,
	profilln integer,
	profiltx varchar(127)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncprofil to btree unique on
	profilid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncprofil () from 'ncprofil.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncprofil
\p\g
create table ncqryres(
	qdomid integer not null,
	qryid integer not null,
	qryver integer not null,
	udomid integer not null,
	unitid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncqryres to btree unique on
	qryid,
	qryver,
	unitid,
	qdomid,
	udomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncqryres () from 'ncqryres.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncqryres
\p\g
create table ncqryver(
	domainid integer not null,
	qryid integer not null,
	qryver integer not null,
	qryvname varchar(50) not null,
	flag integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncqryver to btree unique on
	qryid,
	qryver,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncqryver () from 'ncqryver.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncqryver
\p\g
create table ncrc(
	domainid integer not null,
	rid integer not null,
	typeid integer not null,
	itemid integer not null,
	rescont text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ncrc to btree unique on
	rid,
	typeid,
	itemid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ncrc () from 'ncrc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ncrc
\p\g
create table nctngref(
	domainid integer not null,
	unitid integer not null,
	unittype integer,
	search1 varchar(64),
	search2 varchar(64),
	search3 varchar(64),
	search4 integer,
	clsname varchar(64),
	uuid varchar(64)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify nctngref to btree unique on
	unitid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy nctngref () from 'nctngref.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nctngref
\p\g
create table nctpldef(
	domainid integer not null,
	tpid integer not null,
	tpname varchar(64),
	tpfname varchar(64),
	tpver integer,
	tpuserid integer,
	tpdesc text(1),
	auto_server_version integer default 0
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify nctpldef to btree unique on
	tpid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy nctpldef () from 'nctpldef.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nctpldef
\p\g
create table network_alert(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	rsrctype i1 not null,
	rsrcindex integer not null,
	rsrcotherindex integer not null,
	fieldindex integer not null,
	alerton i1 not null,
	value float not null,
	percentbase float not null,
	threshold float not null,
	severity i1 not null,
	endtime date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify network_alert to btree on
	probe_addr,
	rsrcindex,
	rsrcotherindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy network_alert () from 'network_alert.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on network_alert
\p\g
create table network_groupid(
	grpid smallint not null,
	grptype smallint not null,
	grpsubtype smallint,
	grpaccessid varchar(255),
	grpname varchar(255) not null,
	grpdescr varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify network_groupid to btree on
	grptype
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy network_groupid () from 'network_groupid.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on network_groupid
\p\g
create table network_groups(
	grpid smallint not null,
	server_addr integer not null,
	probe_addr integer not null,
	rsrcindex integer,
	rsrcotherindex integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify network_groups to btree on
	grpid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy network_groups () from 'network_groups.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on network_groups
\p\g
create table network_mib(
	id integer not null,
	name varchar(128) not null,
	body text(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify network_mib to heap
with extend = 16,
	allocation = 4
\p\g
/* copy network_mib () from 'network_mib.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on network_mib
\p\g
create table network_probe(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	ip_addr varchar(16),
	port integer,
	community varchar(30),
	get_timeout smallint,
	user_descr varchar(30),
	ifnumber smallint,
	topncount smallint,
	collect_flags integer,
	sysdescr varchar(255),
	sysobjectid varchar(100),
	syscontact varchar(255),
	sysname varchar(255),
	syslocation varchar(255),
	sysservices i1,
	group_name varchar(30),
	class_name varchar(30),
	writecommunity varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify network_probe to btree unique on
	server_addr,
	probe_addr
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy network_probe () from 'network_probe.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on network_probe
\p\g
create table neug_mo_list(
	id integer not null,
	neugent_instance varchar(50) not null,
	active_flag integer,
	use_historian integer,
	pattern_interval integer,
	input_list varchar(2000),
	output_list varchar(2000),
	save_pattern_table varchar(256),
	consult_table varchar(256),
	consultable_table varchar(256),
	train_table varchar(256),
	trainable_table varchar(256),
	pattern_label_field varchar(100),
	consult_aux_table varchar(256),
	historian_views varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify neug_mo_list to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy neug_mo_list () from 'neug_mo_list.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on neug_mo_list
\p\g
create table next_oid(
	oid integer,
	field varchar(31)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify next_oid to btree unique on
	field
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy next_oid () from 'next_oid.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on next_oid
\p\g
create table next_run_num(
	run_num integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify next_run_num to heap
with extend = 16,
	allocation = 4
\p\g
/* copy next_run_num () from 'next_run_num.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on next_run_num
\p\g
create table non_project_event(
	non_project_event_id decimal(31,0) not null,
	non_project_event_name varchar(1200) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify non_project_event to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy non_project_event () from 'non_project_event.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on non_project_event
\p\g
create table nonavail(
	server_addr integer,
	probe_addr integer,
	ifindex integer,
	start_down_time date,
	end_down_time date,
	state i1,
	sessionnumber integer,
	time_period integer,
	rsrctype i1,
	rsrcotherindex integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify nonavail to btree on
	probe_addr,
	ifindex,
	rsrcotherindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy nonavail () from 'nonavail.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nonavail
\p\g
create table nonhealth(
	server_addr integer,
	intervaldatetime date,
	intervallength integer,
	nprobesmonitoredperformance integer,
	ninterfacesmonitoredperformance integer,
	nprobesmonitoredavailability integer,
	ninterfacesmonitoredavailability integer,
	criticalduration integer,
	majorduration integer,
	minorduration integer,
	warningduration integer,
	criticalnumber integer,
	majornumber integer,
	minornumber integer,
	warningnumber integer,
	ntotalprobesnonavail integer,
	ntotalinterfacesnonavail integer,
	nsecondsprobesnonavail integer,
	nsecondsinterfacesnonavail integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify nonhealth to btree on
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy nonhealth () from 'nonhealth.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nonhealth
\p\g
create table not_log(
	id integer not null,
	del integer not null,
	last_mod integer,
	nlh_hdr varchar(40),
	nlh_msg varchar(1000),
	nlh_msg_html long varchar,
	nlh_c_alias byte varying(16),
	nlh_c_addressee byte varying(16) not null,
	nlh_email varchar(50),
	nlh_cm_method integer,
	nlh_transition integer,
	nlh_pri integer,
	nlh_type integer,
	nlh_ack_time integer,
	nlh_status integer,
	nlh_user_ack varchar(40),
	nlh_start integer not null,
	nlh_ack_by integer,
	nlh_end integer,
	cntxt_obj varchar(30),
	cmth_used integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify not_log to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy not_log () from 'not_log.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on not_log
\p\g
create table not_que(
	id integer not null,
	persid varchar(30),
	del integer not null,
	msg_title varchar(40),
	msg_body varchar(1000),
	msg_body_html long varchar,
	msg_ack varchar(40),
	notify_level integer,
	transition_pt integer,
	internal integer,
	cmth_override integer,
	context_persid varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify not_que to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy not_que () from 'not_que.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on not_que
\p\g
create table notification(
	id integer not null,
	doc_id integer,
	analyst_id byte varying(16),
	alt_email varchar(100),
	ntf_level integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify notification to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy notification () from 'notification.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on notification
\p\g
create table nottrn(
	id integer not null,
	enum integer not null,
	del integer not null,
	sym varchar(30) not null,
	nx_desc varchar(40),
	tp_use_pri integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify nottrn to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy nottrn () from 'nottrn.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nottrn
\p\g
create table noturg(
	id integer not null,
	enum integer not null,
	del integer not null,
	sym varchar(60) not null,
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify noturg to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy noturg () from 'noturg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on noturg
\p\g
create table nr_com(
	id integer not null,
	com_par_id byte varying(16) not null,
	com_dt integer not null,
	com_userid varchar(40) not null,
	com_comment varchar(1000),
	writer_id byte varying(16),
	attr_name varchar(60),
	old_value varchar(1000),
	new_value varchar(1000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify nr_com to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy nr_com () from 'nr_com.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on nr_com
\p\g
create table ntfl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	description varchar(240),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	object_attr varchar(250),
	object_type varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ntfl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ntfl () from 'ntfl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ntfl
\p\g
create table o_comments(
	id integer not null,
	doc_id integer,
	ver_count integer,
	user_name varchar(50),
	user_id byte varying(16),
	comment_text varchar(255),
	comment_timestamp integer,
	email_address varchar(75),
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify o_comments to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy o_comments () from 'o_comments.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on o_comments
\p\g
create table o_events(
	id integer not null,
	entity_id integer,
	ver_count integer,
	event_timestamp integer,
	event_name varchar(50),
	wf_user_id byte varying(16),
	wf_action_id integer,
	action long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify o_events to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy o_events () from 'o_events.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on o_events
\p\g
create table o_indexes(
	id integer not null,
	caption varchar(50),
	description varchar(255),
	author_id byte varying(16),
	owner_id byte varying(16),
	subject_expert_id byte varying(16),
	relational_id varchar(255),
	has_children integer,
	has_docs integer,
	keywords varchar(255),
	read_pgroup integer,
	write_pgroup integer,
	permission_index_id integer,
	parent_id integer,
	wf_template integer,
	doc_template integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify o_indexes to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy o_indexes () from 'o_indexes.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on o_indexes
\p\g
create table objclasses(
	adapter varchar(50) not null,
	objectclass varchar(50) not null,
	objectclassinfo long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify objclasses to heap
with extend = 16,
	allocation = 4
\p\g
/* copy objclasses () from 'objclasses.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on objclasses
\p\g
create table object_type(
	object_type_id decimal(31,0) not null,
	object_table_name varchar(1200) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify object_type to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy object_type () from 'object_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on object_type
\p\g
create table object_udf_association(
	user_defined_field_id decimal(31,0) not null,
	object_type_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify object_udf_association to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy object_udf_association () from 'object_udf_association.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on object_udf_association
\p\g
create table object_udf_value(
	object_udf_id decimal(31,0) not null,
	user_defined_field_id decimal(31,0) not null,
	object_type_id decimal(31,0) not null,
	double_value decimal(31,2),
	string_value varchar(4000),
	datetime_value date,
	long_value long byte,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify object_udf_value to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy object_udf_value () from 'object_udf_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on object_udf_value
\p\g
create table object_view(
	view_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	view_name varchar(1200),
	view_description varchar(4000),
	menu_slot_id decimal(31,0),
	view_type integer,
	decimal_of_components integer,
	is_default_view smallint,
	view_sort varchar(4000),
	view_filter varchar(4000),
	system_origin integer,
	display_duplicates smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify object_view to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy object_view () from 'object_view.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on object_view
\p\g
create table objects(
	objectid integer not null,
	objecttype smallint not null default 1,
	objectsourceid integer,
	description varchar(255),
	clusterid integer,
	mailobjectid integer,
	domainsourceid integer,
	servicesourceid integer,
	objectname varchar(255) not null,
	maildomainid integer,
	mailserviceid integer,
	connectorsourceid integer,
	mailconnectorid integer,
	dbsourceid integer,
	maildbid integer,
	eventsourceid integer,
	maileventid integer,
	queuesourceid integer,
	mailqueueid integer,
	disksourceid integer,
	maildiskid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify objects to btree unique on
	objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy objects () from 'objects.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on objects
\p\g
create integrity  ON Objects IS ObjectID >= 1
\p\g
create integrity  ON Objects IS ObjectType IN (1, 2, 3, 4, 5, 6, 7, 8,
9)
\p\g
create integrity  ON Objects IS ObjectSourceID >= 1
\p\g
create integrity  ON Objects IS ClusterID >= 1
\p\g
create integrity  ON Objects IS DomainSourceID >= 1
\p\g
create integrity  ON Objects IS MailObjectID >= 1
\p\g
create integrity  ON Objects IS ServiceSourceID >= 1
\p\g
create integrity  ON Objects IS MailDomainID >= 1
\p\g
create integrity  ON Objects IS MailServiceID >= 1
\p\g
create integrity  ON Objects IS ConnectorSourceID >= 1
\p\g
create integrity  ON Objects IS MailConnectorID >= 1
\p\g
create integrity  ON Objects IS DBSourceID >= 1
\p\g
create integrity  ON Objects IS MailDBID >= 1
\p\g
create integrity  ON Objects IS EventSourceID >= 1
\p\g
create integrity  ON Objects IS MailEventID >= 1
\p\g
create integrity  ON Objects IS QueueSourceID >= 1
\p\g
create integrity  ON Objects IS MailQueueID >= 1
\p\g
create integrity  ON Objects IS DiskSourceID >= 1
\p\g
create integrity  ON Objects IS MailDiskID >= 1
\p\g
create table objectudp(
	objectid integer not null,
	udpid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify objectudp to btree unique on
	objectid,
	udpid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy objectudp () from 'objectudp.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on objectudp
\p\g
create table objstore(
	id varchar(20) not null,
	obj long byte not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify objstore to heap
with extend = 16,
	allocation = 4
\p\g
/* copy objstore () from 'objstore.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on objstore
\p\g
create table oid_seq(
	oid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify oid_seq to heap
with extend = 16,
	allocation = 4
\p\g
/* copy oid_seq () from 'oid_seq.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on oid_seq
\p\g
create table onetime_events(
	onetime_event_oid varchar(20) not null,
	calendar_oid varchar(20) not null,
	event_category_oid varchar(20),
	recurring_event_oid varchar(20),
	start integer not null,
	duration integer,
	description varchar(255),
	status char(1),
	event_category_value_oid varchar(20),
	value varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify onetime_events to btree unique on
	onetime_event_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy onetime_events () from 'onetime_events.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on onetime_events
\p\g
create table openunit(
	domainid integer not null,
	unitid integer not null,
	opunit integer,
	changes integer,
	usdomid integer,
	userid integer,
	opendate integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify openunit to btree unique on
	unitid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy openunit () from 'openunit.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on openunit
\p\g
create table operation(
	operation_id integer not null,
	service_name varchar(255),
	port_address varchar(255),
	name varchar(255),
	wsdl_operation_id integer,
	operation_group_id integer,
	num_ata_transactions integer,
	last_ata_count_date date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify operation to btree unique on
	operation_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy operation () from 'operation.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on operation
\p\g
create table operation_group(
	operation_group_id integer not null,
	name varchar(255),
	status integer,
	description char(1),
	creation_date date,
	modification_date date,
	time_period_id integer,
	ata_analysis_enabled decimal(1,0),
	last_ata_analysis date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify operation_group to btree unique on
	operation_group_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy operation_group () from 'operation_group.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on operation_group
\p\g
create table operation_group_monitor_type(
	operation_group_monitor_type_id integer not null,
	interval_size integer,
	monitor_type integer,
	rolling_interval_count integer,
	operation_group_id integer,
	enabled decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify operation_group_monitor_type to btree unique on
	operation_group_monitor_type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy operation_group_monitor_type () from 'operation_group_monitor_type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on operation_group_monitor_type
\p\g
create table opr_conview(
	opr_conv_name varchar(16) not null,
	opr_conv_desc varchar(256) not null,
	opr_conv_cr_id varchar(32) not null,
	opr_conv_cr_dt integer not null,
	opr_conv_cr_tm integer not null,
	opr_conv_up_id varchar(32) not null,
	opr_conv_up_dt integer not null,
	opr_conv_up_tm integer not null,
	opr_conv_data long byte not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify opr_conview to btree unique on
	opr_conv_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy opr_conview () from 'opr_conview.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on opr_conview
\p\g
create table opr_convusr(
	opr_convusr_name varchar(16) not null,
	opr_convusr_user varchar(32) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify opr_convusr to btree unique on
	opr_convusr_name,
	opr_convusr_user
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy opr_convusr () from 'opr_convusr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on opr_convusr
\p\g
create table opra_act(
	opra_act_token integer not null,
	opra_act_seqno smallint not null,
	opra_act_keyword varchar(15) not null,
	opra_act_status char(1) not null,
	opra_act_dest_node varchar(64) not null,
	opra_act_workstn varchar(64) not null,
	opra_act_simul char(1) not null,
	opra_act_color integer not null,
	opra_act_attrib integer not null,
	opra_act_cr_id varchar(32) not null,
	opra_act_cr_dt integer not null,
	opra_act_cr_ti integer not null,
	opra_act_up_id varchar(32) not null,
	opra_act_up_dt integer not null,
	opra_act_up_ti integer not null,
	opra_act_text varchar(512) not null,
	opra_act_cond_op char(2) not null,
	opra_act_cond_rc integer not null,
	opra_act_quiet char(1) not null,
	opra_act_audit char(1) not null,
	opra_act_run_id varchar(32) not null,
	opra_act_run_pw varchar(14) not null,
	opra_act_evaluate char(1) not null,
	opra_act_category varchar(64) not null,
	opra_act_severity varchar(4) not null,
	opra_act_source varchar(128) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify opra_act to btree unique on
	opra_act_token,
	opra_act_seqno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy opra_act () from 'opra_act.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on opra_act
\p\g
create table opra_ctl(
	opra_ctl_last_tkn integer not null,
	opra_ctl_wcmany char(1) not null,
	opra_ctl_wcsngl char(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify opra_ctl to heap
with extend = 16,
	allocation = 4
\p\g
/* copy opra_ctl () from 'opra_ctl.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on opra_ctl
\p\g
create table opra_msg(
	opra_msg_tkn integer not null,
	opra_msg_id varchar(512) not null,
	opra_msg_type varchar(4) not null,
	opra_msg_enode varchar(64) not null,
	opra_msg_calendar varchar(12) not null,
	opra_msg_wc_many char(1) not null,
	opra_msg_wc_sngl char(1) not null,
	opra_msg_cr_id varchar(32) not null,
	opra_msg_cr_dt integer not null,
	opra_msg_cr_tm integer not null,
	opra_msg_up_id varchar(32) not null,
	opra_msg_up_dt integer not null,
	opra_msg_up_tm integer not null,
	opra_msg_actn_cnt smallint not null,
	opra_msg_desc varchar(256) not null,
	opra_msg_node varchar(64) not null,
	opra_msg_user varchar(32) not null,
	opra_msg_scan varchar(512) not null,
	opra_msg_scan_from integer not null,
	opra_msg_scan_to integer not null,
	opra_msg_freq_cnt integer not null,
	opra_msg_freq_int integer not null,
	opra_msg_crit_prof varchar(256) not null,
	opra_msg_cont_scan char(1) not null,
	opra_msg_active char(1) not null,
	opra_msg_device varchar(128) not null,
	opra_msg_jobset varchar(64) not null,
	opra_msg_jobname varchar(64) not null,
	opra_msg_jobno varchar(16) not null,
	opra_msg_jobqual varchar(16) not null,
	opra_msg_workstn varchar(64) not null,
	opra_msg_program varchar(128) not null,
	opra_msg_udata varchar(128) not null,
	opra_msg_category varchar(64) not null,
	opra_msg_late char(1) not null,
	opra_msg_msgnum integer not null,
	opra_msg_severity varchar(4) not null,
	opra_msg_source varchar(128) not null,
	opra_msg_tag varchar(256) not null,
	opra_msg_group varchar(256) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify opra_msg to btree unique on
	opra_msg_tkn
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy opra_msg () from 'opra_msg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on opra_msg
\p\g
create table options(
	id integer not null,
	persid varchar(30),
	del integer not null,
	option_name varchar(30),
	sym varchar(30) not null,
	sequence integer,
	description varchar(200),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	action integer,
	action_status varchar(20),
	app_name varchar(30),
	install_script varchar(200),
	deinstall_script varchar(200),
	readme varchar(200),
	value_active integer,
	value varchar(100),
	default_value varchar(100),
	validation varchar(100),
	error_msg varchar(100)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify options to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy options () from 'options.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on options
\p\g
create table output(
	product_instance_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	tool_id decimal(31,0),
	product_path varchar(4000),
	is_mandatory smallint,
	logical_delete_flag smallint,
	deleted_for_link integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify output to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy output () from 'output.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on output
\p\g
create table output_det(
	output_det_id decimal(5,0),
	output_head_id decimal(5,0),
	report_head_id decimal(5,0),
	filter_id decimal(5,0),
	det_sum decimal(1,0),
	event_id decimal(5,0),
	scope_id decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify output_det to heap
with extend = 16,
	allocation = 4
\p\g
/* copy output_det () from 'output_det.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on output_det
\p\g
create table output_head(
	output_head_id decimal(5,0) not null,
	print_dest decimal(1,0) not null,
	printer_name varchar(40),
	report_type char(1) not null,
	collect_id decimal(5,0),
	compare_id decimal(5,0),
	report_directory varchar(200),
	created_by varchar(30),
	job_id decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify output_head to btree unique on
	output_head_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy output_head () from 'output_head.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on output_head
\p\g
create table output_repository(
	output_repository_id decimal(5,0) not null,
	collect_id decimal(5,0),
	compare_id decimal(5,0),
	filter_head_id decimal(5,0),
	scope_head_id decimal(5,0),
	report_head_id decimal(5,0) not null,
	report_name varchar(80),
	report_type char(1) not null,
	finish_time date,
	format varchar(1),
	file_name varchar(400),
	file_size decimal(5,0),
	created_by varchar(30),
	output_head_id decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify output_repository to btree unique on
	output_repository_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy output_repository () from 'output_repository.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on output_repository
\p\g
create table overjob(
	joid integer not null,
	machine varchar(80),
	n_retrys integer,
	auto_hold i1,
	command varchar(255),
	condition varchar(255),
	date_conditions i1,
	days_of_week varchar(80),
	run_calendar varchar(30),
	exclude_calendar varchar(30),
	start_times varchar(255),
	start_mins varchar(255),
	run_window varchar(20),
	term_run_time integer,
	profile varchar(80),
	std_in_file varchar(80),
	std_out_file varchar(80),
	std_err_file varchar(80),
	watch_file varchar(80),
	watch_file_min_size integer,
	watch_interval integer,
	min_run_alarm integer,
	max_run_alarm integer,
	over_num integer not null,
	entity varchar(80),
	run_num integer,
	setup_time integer,
	start_time integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify overjob to btree unique on
	joid,
	over_num
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy overjob () from 'overjob.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on overjob
\p\g
create table ownership(
	is_owner_id decimal(31,0) not null,
	is_owned_id decimal(31,0) not null,
	table_name_of_owned varchar(4000) not null,
	table_name_of_owner varchar(4000) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify ownership to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy ownership () from 'ownership.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ownership
\p\g
create table p_groups(
	id integer not null,
	grp_list_key varchar(255),
	grp_list long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify p_groups to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy p_groups () from 'p_groups.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on p_groups
\p\g
create table password_history(
	password_id byte(16) not null,
	user_uuid byte(16) not null,
	set_date integer,
	encrypted_password varchar(255) not null,
	creation_user varchar(64),
	creation_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify password_history to heap
with extend = 16,
	allocation = 4
\p\g
/* copy password_history () from 'password_history.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on password_history
\p\g
create table pattern_types(
	pattern_type_oid varchar(20) not null,
	bundle_key varchar(255),
	scheduler_class varchar(255),
	create_action varchar(100),
	update_action varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pattern_types to btree unique on
	pattern_type_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy pattern_types () from 'pattern_types.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on pattern_types
\p\g
create table pcat_grp(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify pcat_grp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy pcat_grp () from 'pcat_grp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on pcat_grp
\p\g
create table pcat_loc(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify pcat_loc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy pcat_loc () from 'pcat_loc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on pcat_loc
\p\g
create table pcat_wrkshft(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify pcat_wrkshft to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy pcat_wrkshft () from 'pcat_wrkshft.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on pcat_wrkshft
\p\g
create table pd_bpv(
	bpv_id integer not null not default,
	bpv_name nvarchar(64) not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_bpv to hash unique on
	bpv_id
with fillfactor = 50,
	extend = 16
\p\g
/* copy pd_bpv () from 'pd_bpv.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_bpv_def(
	bpv_id integer not null not default,
	machine_id integer not null not default,
	res_id integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_bpv_def to btree unique on
	bpv_id,
	machine_id,
	res_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy pd_bpv_def () from 'pd_bpv_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_cluster_def(
	parent_id integer not null not default,
	child_id integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_cluster_def to btree on
	parent_id,
	child_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy pd_cluster_def () from 'pd_cluster_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_cluster_ext(
	machine_id integer not null not default,
	cluster_alias nvarchar(30) not null default ' ',
	cluster_type nvarchar(30) not null default ' '
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_cluster_ext to btree unique on
	machine_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy pd_cluster_ext () from 'pd_cluster_ext.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_day(
	day_id integer not null not default,
	day_of_week nvarchar(3) not null not default,
	day_of_month i1 not null not default,
	day_of_year smallint not null not default,
	week_of_year i1 not null not default,
	month_of_year i1 not null not default,
	quarter_of_year i1 not null not default,
	current_year smallint not null not default,
	current_date nvarchar(11) not null not default,
	current_date_int integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_day to hash unique on
	day_id
with fillfactor = 50,
	extend = 16
\p\g
/* copy pd_day () from 'pd_day.mdbadmin' */
/* with minpages = 512, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_global(
	major_version integer not null default 1,
	minor_version integer not null default 0,
	build_version integer not null default 0,
	revision_version integer not null default 0
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_global to heap
with extend = 16,
	allocation = 4
\p\g
/* copy pd_global () from 'pd_global.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table pd_machine(
	machine_id integer not null not default,
	machine_name nvarchar(64) not null not default,
	systype_name nvarchar(64) not null default ' ',
	is_this_cluster i1 not null default 0,
	asset_id byte(16) not null default ' '
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_machine to hash unique on
	machine_id
with fillfactor = 50,
	extend = 512
\p\g
/* copy pd_machine () from 'pd_machine.mdbadmin' */
/* with minpages = 512, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_machine_ext(
	machine_id integer not null not default,
	primary_pde_name nvarchar(64) not null default ' ',
	backup_pde_name nvarchar(64) not null default ' ',
	primary_pdg_name nvarchar(64) not null default ' ',
	pd_static_name nvarchar(64) not null default ' ',
	last_dns_name nvarchar(64) not null default ' ',
	last_dns_name_1 nvarchar(64) not null default ' ',
	last_dns_name_2 nvarchar(64) not null default ' ',
	last_dns_name_3 nvarchar(64) not null default ' ',
	last_dns_name_4 nvarchar(64) not null default ' ',
	last_dns_name_5 nvarchar(64) not null default ' ',
	profile_name nvarchar(50) not null default ' ',
	config_server nvarchar(64) not null default ' ',
	mac_address nvarchar(18) not null default ' ',
	agent_version integer not null default 0,
	neugent_version integer not null default 0,
	pp_version integer not null default 0,
	pd_protocol integer not null default 0,
	pd_date nvarchar(26) not null default ' ',
	pd_address nvarchar(64) not null default ' ',
	object_id_high integer not null default 0,
	object_id_low integer not null default 0
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_machine_ext to btree unique on
	machine_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy pd_machine_ext () from 'pd_machine_ext.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_max_bpv(
	max_bpv_id integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_max_bpv to heap
with extend = 16,
	allocation = 4
\p\g
/* copy pd_max_bpv () from 'pd_max_bpv.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table pd_max_day(
	max_day_id integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_max_day to heap
with extend = 16,
	allocation = 4
\p\g
/* copy pd_max_day () from 'pd_max_day.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table pd_max_machine(
	max_machine_id integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_max_machine to heap
with extend = 16,
	allocation = 4
\p\g
/* copy pd_max_machine () from 'pd_max_machine.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table pd_max_resource(
	max_res_id integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_max_resource to heap
with extend = 16,
	allocation = 4
\p\g
/* copy pd_max_resource () from 'pd_max_resource.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table pd_resource(
	res_id integer not null not default,
	res_type nvarchar(64) not null not default,
	res_subtype nvarchar(80) not null not default,
	res_instance nvarchar(64) not null default ' ',
	res_value_type nvarchar(15) not null default ' '
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_resource to hash unique on
	res_id
with fillfactor = 50,
	extend = 512
\p\g
/* copy pd_resource () from 'pd_resource.mdbadmin' */
/* with minpages = 8192, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_time(
	time_id integer not null not default,
	time_value nvarchar(5) not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_time to hash on
	time_id
with fillfactor = 50,
	extend = 16
\p\g
/* copy pd_time () from 'pd_time.mdbadmin' */
/* with minpages = 64, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_10min(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_10min to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_10min () from 'pd_val_10min.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_12hr(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_12hr to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_12hr () from 'pd_val_12hr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_15min(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_15min to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_15min () from 'pd_val_15min.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_1day(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_1day to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_1day () from 'pd_val_1day.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_1hr(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_1hr to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_1hr () from 'pd_val_1hr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_1min(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_1min to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_1min () from 'pd_val_1min.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_1month(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_1month to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_1month () from 'pd_val_1month.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_1week(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_1week to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_1week () from 'pd_val_1week.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_1year(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_1year to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_1year () from 'pd_val_1year.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_20min(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_20min to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_20min () from 'pd_val_20min.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_2hr(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_2hr to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_2hr () from 'pd_val_2hr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_30min(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_30min to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_30min () from 'pd_val_30min.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_3hr(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_3hr to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_3hr () from 'pd_val_3hr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_4hr(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_4hr to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_4hr () from 'pd_val_4hr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_5min(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_5min to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_5min () from 'pd_val_5min.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_6hr(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_6hr to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_6hr () from 'pd_val_6hr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pd_val_8hr(
	machine_id integer not null not default,
	res_id integer not null not default,
	day_id integer not null not default,
	time_id integer not null not default,
	cell_value f4
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pd_val_8hr to btree unique on
	machine_id,
	res_id,
	day_id,
	time_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024,
	page_size = 16384
\p\g
/* copy pd_val_8hr () from 'pd_val_8hr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table pe_udf_data(
	object_id decimal(31,0) not null,
	object_type_id decimal(31,0) not null,
	pe_udf_field_id decimal(31,0) not null,
	udf_field_value varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pe_udf_data to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy pe_udf_data () from 'pe_udf_data.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on pe_udf_data
\p\g
create table pe_udf_field(
	pe_udf_field_id decimal(31,0) not null,
	library_id decimal(31,0),
	project_id decimal(31,0),
	pe_udf_name varchar(1200) not null,
	code_type integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify pe_udf_field to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy pe_udf_field () from 'pe_udf_field.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on pe_udf_field
\p\g
create table period_length(
	period_length varchar(120) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify period_length to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy period_length () from 'period_length.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on period_length
\p\g
create table permission(
	uid byte(16) not null,
	uidparent byte(16) not null,
	uidaddressbook byte(16) not null,
	strobjectidentifier varchar(255) not null,
	iisinherited integer not null,
	iisdeleted integer not null,
	datetimestamp date not null,
	strpermissions varchar(11) not null,
	iislocaluser integer not null,
	strinheritedfrom varchar(64) not null,
	datetimestampsuperior date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify permission to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy permission () from 'permission.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on permission
\p\g
create table permissionglobal(
	uid byte(16) not null,
	uidparent byte(16) not null,
	uidaddressbook byte(16) not null,
	strobjectidentifier varchar(255) not null,
	iisinherited integer not null,
	iisdeleted integer not null,
	datetimestamp date not null,
	strpermissions varchar(11) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify permissionglobal to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy permissionglobal () from 'permissionglobal.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on permissionglobal
\p\g
create table permissions(
	objectid integer not null,
	granteeid integer not null,
	permissionmask integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify permissions to heap
with extend = 16,
	allocation = 4
\p\g
/* copy permissions () from 'permissions.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on permissions
\p\g
create table permissionserver(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strserver varchar(64) not null,
	datelastcontact date not null,
	iissuperior integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify permissionserver to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy permissionserver () from 'permissionserver.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on permissionserver
\p\g
create table permit_profile(
	usernode varchar(64) not null,
	userid varchar(32) not null,
	usertype varchar(8) not null,
	assetid varchar(255) not null,
	assetnode varchar(64) not null,
	assettype varchar(24) not null,
	accesstype varchar(8) not null,
	expires integer,
	calendar varchar(20),
	profile varchar(255),
	accessread char(1),
	accesswrite char(1),
	accessdelete char(1),
	accessupdate char(1),
	accessexecute char(1),
	accesssearch char(1),
	accesscreate char(1),
	accesscontrol char(1),
	definitionmode char(1),
	createdate integer,
	createtime integer,
	createsource varchar(32),
	createnode varchar(64),
	createuser varchar(32),
	createpid varchar(5),
	updatedate integer,
	updatetime integer,
	updatesource varchar(32),
	updatenode varchar(64),
	updateuser varchar(32),
	updatepid varchar(5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify permit_profile to btree on
	usernode
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy permit_profile () from 'permit_profile.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on permit_profile
\p\g
create table perscon(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify perscon to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy perscon () from 'perscon.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on perscon
\p\g
create table personalias(
	id integer,
	personid integer,
	type varchar(32),
	name varchar(32),
	domain varchar(32),
	starttime date,
	endtime date,
	createdby integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify personalias to heap
with extend = 16,
	allocation = 4
\p\g
/* copy personalias () from 'personalias.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on personalias
\p\g
create table platform(
	domainid integer not null,
	pltid integer not null,
	pltname varchar(64)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify platform to btree unique on
	pltid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy platform () from 'platform.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on platform
\p\g
create table pm_calendar(
	calendar_id decimal(31,0) not null,
	project_id decimal(31,0),
	owner_id decimal(31,0),
	calendar_name varchar(1200) not null,
	calendar_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify pm_calendar to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy pm_calendar () from 'pm_calendar.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on pm_calendar
\p\g
create table poc_security(
	rsrc_id decimal(31,0) not null,
	field_one decimal(31,0),
	field_two decimal(31,0),
	field_three decimal(31,0),
	field_four decimal(31,0),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify poc_security to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy poc_security () from 'poc_security.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on poc_security
\p\g
create table poc_security_defaults(
	security_default_id decimal(31,0) not null,
	field_one decimal(31,0),
	field_two decimal(31,0),
	field_three decimal(31,0),
	field_four decimal(31,0),
	name varchar(1200),
	description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify poc_security_defaults to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy poc_security_defaults () from 'poc_security_defaults.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on poc_security_defaults
\p\g
create table policonf(
	pdomid integer not null,
	polid integer not null,
	poltype integer not null,
	qdomid integer,
	polqid integer,
	polinter integer,
	edomid integer,
	polengid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify policonf to btree unique on
	polid,
	poltype,
	pdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy policonf () from 'policonf.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on policonf
\p\g
create table policy_resource_class_asc(
	access_policy_uuid byte(16) not null,
	resource_class_uuid byte(16) not null,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify policy_resource_class_asc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy policy_resource_class_asc () from 'policy_resource_class_asc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on policy_resource_class_asc
\p\g
create table policygroup(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname varchar(64) not null,
	strdescription varchar(128) not null,
	itype integer not null,
	ideleteflag integer not null,
	datetimestamp date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify policygroup to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy policygroup () from 'policygroup.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on policygroup
\p\g
create table policyproperty(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname varchar(64) not null,
	strdescription varchar(128) not null,
	itype integer not null,
	ideleteflag integer not null,
	datetimestamp date not null,
	imode integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify policyproperty to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy policyproperty () from 'policyproperty.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on policyproperty
\p\g
create table policytable(
	policyid integer not null,
	regionname varchar(255) not null,
	policyindex integer,
	instancename varchar(64) not null,
	regularexpr varchar(255) not null,
	propertyid integer,
	altpropid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify policytable to btree unique on
	policyid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy policytable () from 'policytable.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on policytable
\p\g
create table policyvalue(
	uidparent byte(16) not null,
	uidpolicy byte(16) not null,
	uidproperty byte(16) not null,
	itype integer not null,
	strvalue varchar(255) not null,
	ivalue integer not null,
	uidvalue byte(16) not null,
	iinherited integer not null,
	iagentwritable integer not null,
	ivisible integer not null,
	ideleteflag integer not null,
	iviewernegotiable integer not null,
	iadvanced integer not null,
	iprotected integer not null,
	uid byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify policyvalue to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy policyvalue () from 'policyvalue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on policyvalue
\p\g
create table polidef(
	domainid integer not null,
	polid integer not null,
	polsev integer,
	polname varchar(127),
	polmemo text(1),
	lrundate integer,
	query_uuid byte(16),
	eval_freq integer,
	evaluation_uuid byte(16)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify polidef to btree unique on
	polid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy polidef () from 'polidef.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on polidef
\p\g
create table polijob(
	domainid integer not null,
	polid integer not null,
	polorder integer not null,
	polact integer not null,
	actype integer,
	actypeid integer,
	acmemo text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify polijob to btree unique on
	polid,
	polorder,
	polact,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy polijob () from 'polijob.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on polijob
\p\g
create table polilog(
	pdomid integer not null,
	polid integer not null,
	udomid integer not null,
	unitid integer not null,
	poldate integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify polilog to btree unique on
	polid,
	unitid,
	udomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy polilog () from 'polilog.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on polilog
\p\g
create table pollrowdefinition(
	rowid integer not null,
	mibidx integer not null,
	oididxformib integer not null,
	oidorder integer not null,
	rowdesc varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify pollrowdefinition to heap
with extend = 16,
	allocation = 4
\p\g
/* copy pollrowdefinition () from 'pollrowdefinition.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on pollrowdefinition
\p\g
create table por_dftpage(
	group_objectkey integer not null,
	user_objectkey integer not null,
	sortorder integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_dftpage to btree on
	group_objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_dftpage () from 'por_dftpage.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_dftpage
\p\g
create table por_discussion(
	objectkey integer not null,
	pathid varchar(100) not null,
	childcounter integer not null,
	ownerid integer not null,
	subject varchar(100) not null,
	content text(1) not null,
	datemodified integer not null,
	depth integer not null,
	changed integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_discussion to btree on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_discussion () from 'por_discussion.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_discussion
\p\g
create table por_discussion_nfy(
	objectkey integer not null,
	pathid varchar(100) not null,
	userid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_discussion_nfy to btree on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_discussion_nfy () from 'por_discussion_nfy.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_discussion_nfy
\p\g
create table por_document(
	objectkey integer not null,
	locale varchar(10),
	filename varchar(1024),
	location integer,
	doctype varchar(100),
	mountptr integer,
	version integer,
	headline varchar(100),
	expires integer,
	docsize integer,
	serverkey integer,
	proxy integer,
	target varchar(40),
	shortcut integer,
	relativeuri varchar(1024),
	schedule integer,
	isrequired varchar(10),
	isconfigurable varchar(10),
	isminimizable varchar(10)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_document to btree unique on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_document () from 'por_document.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_document
\p\g
create table por_documentgroups(
	objectkey integer not null,
	groupowner integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_documentgroups to btree unique on
	objectkey,
	groupowner
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_documentgroups () from 'por_documentgroups.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_documentgroups
\p\g
create table por_global(
	zipremote integer not null,
	maintimezone varchar(100) not null,
	schemaversion varchar(10) not null,
	supportemail varchar(100),
	enablemessages integer not null,
	usersetpassword integer not null,
	usertimeout integer not null,
	postsessionkey integer not null,
	newfulllib integer not null,
	newfullchan integer not null,
	newfullmess integer not null,
	pluginurl varchar(1024),
	pluginclassid varchar(100),
	pluginhtmlcodebase varchar(1024),
	expirecontent integer not null,
	searchenginecs integer,
	searchengine varchar(40),
	searchenginemaint integer,
	sessioncookiename varchar(40),
	sessioncookiedom varchar(100)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_global to btree on
	zipremote
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_global () from 'por_global.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_global
\p\g
create table por_group(
	objectkey integer not null,
	templatekey integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_group to btree unique on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_group () from 'por_group.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_group
\p\g
create table por_obcounter(
	cnter integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_obcounter to heap
with extend = 50,
	allocation = 100,
	page_size = 4096
\p\g
/* copy por_obcounter () from 'por_obcounter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on por_obcounter
\p\g
create table por_objectrepos(
	objectkey integer not null,
	objecttypekey integer,
	objectname varchar(100),
	ownerid integer,
	groupowner integer,
	ownerreadpriv integer,
	ownerwritepriv integer,
	ownerexecutepriv integer,
	groupreadpriv integer,
	groupwritepriv integer,
	groupexecutepriv integer,
	entreadpriv integer,
	entwritepriv integer,
	entexecutepriv integer,
	creator integer,
	createdate integer,
	lastmodifiedby integer,
	validationcode integer,
	validationdatetime integer,
	validatedby integer,
	messagecount integer,
	description varchar(1024),
	lastmoddatetime integer,
	password varchar(254)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_objectrepos to btree unique on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_objectrepos () from 'por_objectrepos.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_objectrepos
\p\g
create table por_pagecols(
	component_column integer not null,
	portalpage_id_fk integer,
	col_width integer,
	col_index integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_pagecols to btree unique on
	component_column
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_pagecols () from 'por_pagecols.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_pagecols
\p\g
create table por_pagecomps(
	component_title varchar(1024),
	compcolumnid integer,
	document_id_fk integer,
	is_minimized varchar(10),
	height integer,
	row_index integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_pagecomps to hash on
	component_title
with fillfactor = 50,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_pagecomps () from 'por_pagecomps.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_pagecomps
\p\g
create table por_pagecounter(
	page_uid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_pagecounter to heap
with extend = 50,
	allocation = 100,
	page_size = 4096
\p\g
/* copy por_pagecounter () from 'por_pagecounter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on por_pagecounter
\p\g
create table por_pages(
	portalpage_id integer not null,
	user_objectkey_fk integer,
	portalpage_title varchar(1024),
	page_index integer,
	isrequired varchar(10)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_pages to btree unique on
	portalpage_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_pages () from 'por_pages.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_pages
\p\g
create table por_preferences(
	objectkey integer,
	userkey integer,
	name varchar(100) not null,
	avalue text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_preferences to btree on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_preferences () from 'por_preferences.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_preferences
\p\g
create table por_prefsconfig(
	group_objectkey integer,
	name varchar(100) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_prefsconfig to btree on
	group_objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_prefsconfig () from 'por_prefsconfig.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_prefsconfig
\p\g
create table por_pubcounter(
	cnter integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_pubcounter to heap
with extend = 50,
	allocation = 100,
	page_size = 4096
\p\g
/* copy por_pubcounter () from 'por_pubcounter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on por_pubcounter
\p\g
create table por_publisher(
	objectkey integer not null,
	objectname varchar(40),
	extension varchar(10),
	contenttype varchar(40),
	enterprise integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_publisher to btree unique on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_publisher () from 'por_publisher.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_publisher
\p\g
create table por_registration(
	property_name varchar(100),
	property_value varchar(254)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify por_registration to heap
with extend = 16,
	allocation = 4
\p\g
/* copy por_registration () from 'por_registration.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on por_registration
\p\g
create table por_relationships(
	parentkey integer not null,
	childkey integer not null,
	sortorder integer not null,
	relationshiptype integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_relationships to btree on
	parentkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_relationships () from 'por_relationships.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_relationships
\p\g
create table por_server(
	serverkey integer not null,
	name varchar(100) not null,
	scheme varchar(10),
	port integer,
	rpcport integer,
	timezone varchar(40),
	path varchar(100)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_server to btree unique on
	serverkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_server () from 'por_server.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_server
\p\g
create table por_session(
	sid varchar(100),
	enteredpw varchar(100),
	ipaddr varchar(40),
	locale varchar(40),
	useragent integer,
	templatekey integer,
	usermsg varchar(1024),
	username varchar(100),
	userkey integer,
	lastaccesstime integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_session to btree on
	sid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_session () from 'por_session.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_session
\p\g
create table por_sessobjpw(
	sid varchar(1024),
	authorizedobjkey integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_sessobjpw to hash on
	sid
with fillfactor = 50,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_sessobjpw () from 'por_sessobjpw.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_sessobjpw
\p\g
create table por_svrcounter(
	cnter integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_svrcounter to heap
with extend = 50,
	allocation = 100,
	page_size = 4096
\p\g
/* copy por_svrcounter () from 'por_svrcounter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on por_svrcounter
\p\g
create table por_task(
	taskkey integer not null,
	serverkey integer not null,
	command integer not null,
	param1 integer,
	param2 integer,
	param3 integer,
	param4 integer,
	param5 varchar(100),
	param6 varchar(100),
	param7 varchar(100),
	firedatetime integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_task to btree unique on
	taskkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_task () from 'por_task.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_task
\p\g
create table por_taskcounter(
	cnter integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_taskcounter to heap
with extend = 50,
	allocation = 100,
	page_size = 4096
\p\g
/* copy por_taskcounter () from 'por_taskcounter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on por_taskcounter
\p\g
create table por_template(
	objectkey integer not null,
	templatekey integer not null,
	name varchar(40) not null,
	frames integer not null,
	cache integer not null,
	locale varchar(10) not null,
	defptr integer not null,
	description varchar(1024)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_template to btree unique on
	templatekey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_template () from 'por_template.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_template
\p\g
create table por_templatelookup(
	templatekey integer not null,
	idx integer not null,
	content text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_templatelookup to btree on
	templatekey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_templatelookup () from 'por_templatelookup.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_templatelookup
\p\g
create table por_tplcounter(
	cnter integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_tplcounter to heap
with extend = 50,
	allocation = 100,
	page_size = 4096
\p\g
/* copy por_tplcounter () from 'por_tplcounter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on por_tplcounter
\p\g
create table por_translog(
	createdatetime integer,
	action integer,
	errata varchar(1024),
	userkey integer,
	objectkey integer,
	objectdesc varchar(1024)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_translog to btree on
	createdatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096
\p\g
/* copy por_translog () from 'por_translog.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_translog
\p\g
create table por_user(
	objectkey integer not null,
	fname varchar(40),
	lname varchar(40),
	defaultgroup integer,
	homefolderkey integer,
	email varchar(100),
	address1 varchar(100),
	address2 varchar(100),
	city varchar(40),
	state varchar(40),
	country varchar(40),
	zip varchar(40),
	homephone varchar(40),
	company varchar(100),
	title varchar(40),
	busphone varchar(40),
	fax varchar(40),
	department varchar(40),
	pager varchar(40),
	cellphone varchar(40),
	templateptr integer,
	templatekey integer,
	publicnews integer,
	groupnews integer,
	privatenews integer,
	resetwrkplc varchar(10)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify por_user to btree unique on
	objectkey
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 50,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy por_user () from 'por_user.mdbadmin' */
/* with allocation = 100, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on por_user
\p\g
create table predecessor_type(
	link_type_id decimal(31,0) not null,
	predecessor_type_name varchar(1200) not null,
	predecessor_type_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify predecessor_type to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy predecessor_type () from 'predecessor_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on predecessor_type
\p\g
create table pri(
	id integer not null,
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40),
	service_type varchar(30),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify pri to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy pri () from 'pri.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on pri
\p\g
create table printer(
	printer_id decimal(5,0) not null,
	printer_name varchar(30),
	server_name varchar(50),
	test_ok decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify printer to btree unique on
	printer_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy printer () from 'printer.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on printer
\p\g
create table prob_ctg(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	organization byte varying(16),
	assignee byte varying(16),
	group_id byte varying(16),
	tcode integer,
	service_type varchar(30),
	survey integer,
	schedule integer,
	auto_assign integer,
	owning_contract integer,
	cr_flag integer,
	in_flag integer,
	pr_flag integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify prob_ctg to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy prob_ctg () from 'prob_ctg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on prob_ctg
\p\g
create table probeaccesslist(
	userid integer not null,
	probe_addr integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify probeaccesslist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy probeaccesslist () from 'probeaccesslist.mdbadmin' */
/* with row_estimate = 1 */
/* \p\g */
set journaling on probeaccesslist
\p\g
create table proc_event(
	eoid varchar(12),
	joid integer,
	job_name varchar(64),
	box_name varchar(64),
	autoserv varchar(32),
	priority integer,
	event integer,
	status integer,
	alarm integer,
	event_time_gmt integer,
	exit_code integer,
	machine varchar(80),
	pid integer,
	jc_pid integer,
	run_num integer,
	ntry integer,
	text varchar(255),
	que_priority integer,
	stamp date,
	evt_num integer,
	que_status integer,
	que_status_stamp date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify proc_event to btree unique on
	eoid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy proc_event () from 'proc_event.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on proc_event
\p\g
create table process(
	oid integer not null,
	qmgr_oid integer not null,
	applicid varchar(254),
	appltype varchar(25),
	descr varchar(64),
	envrdata varchar(128),
	process varchar(80),
	userdata varchar(128),
	altdate varchar(48),
	alttime varchar(48),
	qsgdisp varchar(8)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify process to heap
with extend = 16,
	allocation = 4
\p\g
/* copy process () from 'process.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on process
\p\g
create table process_calendar(
	holi_owner_type decimal(31,0) not null,
	holi_owner_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	holi_date date not null,
	rsrc_id decimal(31,0),
	holi_description varchar(4000),
	holi_exception_hrs decimal(31,0),
	holi_is_project smallint,
	creation_datetime date,
	logical_delete_flag smallint,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify process_calendar to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy process_calendar () from 'process_calendar.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on process_calendar
\p\g
create table process_listeners(
	processtolisten varchar(20) not null,
	workitemid varchar(30) not null,
	processid varchar(20) not null,
	listenername varchar(100) not null,
	eventtypes varchar(100) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify process_listeners to heap
with extend = 16,
	allocation = 4
\p\g
/* copy process_listeners () from 'process_listeners.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on process_listeners
\p\g
create table process_metric(
	metric_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	alt_ref_id varchar(120),
	reference_id varchar(120),
	is_scheduler_property smallint,
	metric_data_type decimal(31,0),
	metric_question varchar(4000),
	metric_name varchar(1200) not null,
	metric_description varchar(4000),
	format_category integer,
	ref_name varchar(4000),
	alt_ref_name varchar(4000),
	expertise_modifier1 integer,
	expertise_modifier2 integer,
	expertise_modifier3 integer,
	expertise_modifier4 integer,
	expertise_modifier5 integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify process_metric to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy process_metric () from 'process_metric.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on process_metric
\p\g
create table process_product(
	product_id decimal(31,0) not null,
	library_id decimal(31,0),
	product_type_id decimal(31,0),
	process_source_id decimal(31,0),
	parent_product_id decimal(31,0),
	product_description varchar(4000),
	product_name varchar(4000) not null,
	default_path varchar(4000),
	logical_delete_flag smallint,
	alt_ref_name varchar(4000),
	ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify process_product to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy process_product () from 'process_product.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on process_product
\p\g
create table process_schedule(
	process_schedule_id byte(16) not null,
	interval nvarchar(1) not null,
	week_number decimal(2,0),
	week_day decimal(1,0),
	time date not null,
	process_type_id byte(16),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify process_schedule to btree unique on
	process_schedule_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy process_schedule () from 'process_schedule.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on process_schedule
\p\g
create table process_template(
	template_id decimal(31,0) not null,
	opruid decimal(31,0),
	owning_library_id decimal(31,0) not null,
	template_class_id decimal(31,0),
	template_name varchar(1200) not null,
	template_description varchar(4000),
	license_key varchar(4000),
	last_instance_index integer,
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify process_template to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy process_template () from 'process_template.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on process_template
\p\g
create table process_type(
	process_type_id byte(16) not null,
	name nvarchar(50) not null,
	last_run_status nvarchar(20),
	creation_user nvarchar(64),
	creation_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify process_type to btree unique on
	process_type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy process_type () from 'process_type.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on process_type
\p\g
create table processcfg(
	qmgrid char(18) not null,
	processid integer not null,
	processname varchar(20) not null,
	type char(10) not null,
	status integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify processcfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy processcfg () from 'processcfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on processcfg
\p\g
create table product(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify product to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy product () from 'product.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on product
\p\g
create table product_context(
	product_category_id decimal(31,0) not null,
	product_category_description varchar(4000) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify product_context to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy product_context () from 'product_context.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on product_context
\p\g
create table product_example(
	product_instance_id decimal(31,0) not null,
	product_id decimal(31,0) not null,
	product_example_description varchar(4000) not null,
	example_object long byte,
	example_object_type varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify product_example to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy product_example () from 'product_example.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on product_example
\p\g
create table product_instance(
	product_instance_id decimal(31,0) not null,
	product_type_id decimal(31,0),
	project_id decimal(31,0),
	source_product_id decimal(31,0),
	tool_id decimal(31,0),
	reference_id varchar(120),
	product_name varchar(1200) not null,
	product_description varchar(4000),
	default_path varchar(4000),
	active_deliverable long byte,
	alt_ref_name varchar(4000),
	ref_name varchar(4000),
	example varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify product_instance to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy product_instance () from 'product_instance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on product_instance
\p\g
create table product_instance_keyword(
	product_instance_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify product_instance_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy product_instance_keyword () from 'product_instance_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on product_instance_keyword
\p\g
create table product_state(
	product_state_id decimal(31,0) not null,
	product_state_name varchar(4000) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify product_state to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy product_state () from 'product_state.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on product_state
\p\g
create table product_type(
	product_type_id decimal(31,0) not null,
	product_type_name varchar(1200) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify product_type to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy product_type () from 'product_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on product_type
\p\g
create table profile_defs(
	profile_name varchar(50) not null,
	section varchar(50) not null,
	attr_name varchar(50) not null,
	taborder integer,
	type varchar(50) not null,
	value varchar(255) not null,
	label varchar(255) not null,
	help varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify profile_defs to btree unique on
	profile_name,
	section,
	attr_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy profile_defs () from 'profile_defs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on profile_defs
\p\g
create table profile_expression_step(
	profile_expression_step_id byte(16) not null,
	group_expression_step_id byte(16) not null,
	inventory_profile_id byte(16) not null,
	sequence_number integer not null,
	not_indicator i1 not null,
	following_boolean_operator nvarchar(20),
	expression_step_type nvarchar(1) not null,
	sw_def_uuid byte(16) not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify profile_expression_step to btree unique on
	profile_expression_step_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy profile_expression_step () from 'profile_expression_step.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on profile_expression_step
\p\g
create table profile_hosts(
	pid integer not null,
	hostname varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify profile_hosts to btree unique on
	pid,
	hostname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy profile_hosts () from 'profile_hosts.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on profile_hosts
\p\g
create table profile_pki(
	name varchar(50) not null,
	version varchar(50) not null,
	profile byte varying(2000) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify profile_pki to btree unique on
	name,
	version
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy profile_pki () from 'profile_pki.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on profile_pki
\p\g
create table profile_values(
	profile_name varchar(50) not null,
	section varchar(50) not null,
	attr_name varchar(50) not null,
	value varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify profile_values to btree unique on
	profile_name,
	section,
	attr_name,
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy profile_values () from 'profile_values.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on profile_values
\p\g
create table profiles(
	profile_name varchar(50) not null,
	section varchar(50) not null,
	attr_name varchar(50) not null,
	value varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify profiles to btree unique on
	profile_name,
	section,
	attr_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy profiles () from 'profiles.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on profiles
\p\g
create table proj_account(
	acct_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	acct_is_heading smallint,
	acct_is_child_id smallint,
	acct_is_selected smallint,
	acct_code varchar(4000),
	acct_name varchar(1200),
	acct_group integer,
	acct_rate float,
	acct_tot_var_cost float,
	acct_tot_fix_cost float,
	acct_tot_ovt_cost float,
	acct_tot_ovhead_cost float,
	acct_tot_act_var_cost float,
	acct_tot_act_fix_cost float,
	acct_tot_act_ovt_cost float,
	acct_tot_act_ovhead_cost float,
	acct_tot_base_var_cost float,
	acct_tot_base_fix_cost float,
	acct_tot_bcwp float,
	acct_tot_asgn_hrs decimal(31,0),
	acct_tot_ovt_hrs decimal(31,0),
	acct_tot_oversch_hrs decimal(31,0),
	acct_tot_act_hrs decimal(31,0),
	acct_tot_act_ovt_hrs decimal(31,0),
	acct_tot_base_hrs decimal(31,0),
	acct_tot_mat_hrs decimal(31,0),
	acct_tot_act_mat_hrs decimal(31,0),
	acct_tot_upd_var_cost float,
	acct_tot_upd_fix_cost float,
	acct_tot_upd_ovt_cost float,
	acct_tot_upd_hrs decimal(31,0),
	acct_tot_upd_ovt_hrs decimal(31,0),
	logical_delete_flag smallint,
	acct_asgn_root_id decimal(31,0),
	acct_outline_root decimal(31,0),
	acct_child_id decimal(31,0),
	acct_sibling_id decimal(31,0),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify proj_account to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy proj_account () from 'proj_account.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on proj_account
\p\g
create table proj_resource_rate(
	rsrc_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	rate_rsrc_start_date date not null,
	rate_id decimal(31,0),
	rate_rsrc_end_date date not null,
	rate_rsrc_rate float,
	rate_rsrc_is_ent smallint,
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify proj_resource_rate to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy proj_resource_rate () from 'proj_resource_rate.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on proj_resource_rate
\p\g
create table project(
	project_id decimal(31,0) not null,
	status_id decimal(31,0) default 0,
	template_id decimal(31,0),
	project_status_id decimal(31,0) default 0,
	project_account_id decimal(31,0),
	project_size_id decimal(31,0),
	client_object_id decimal(31,0),
	scheduler_id decimal(31,0) default 0,
	project_type_id decimal(31,0) default 1,
	scheduler_path varchar(400),
	scheduler_version float,
	scheduler_options varchar(400),
	scheduler_command_line varchar(400),
	scheduler_file varchar(400),
	opruid decimal(31,0),
	project_name varchar(120) not null,
	project_code varchar(40),
	project_requestor_name varchar(120),
	received_date date,
	estimated_on_date date,
	approved_date date,
	post_datetime date,
	manual_ytd_hrs decimal(31,0),
	project_version float default 1.0,
	manual_ytd_cost float,
	manual_ptd_hrs decimal(31,0),
	manual_ptd_cost float,
	manual_previous_ytd_hrs decimal(31,0),
	manual_previous_ytd_cost float,
	manual_previous_period_hrs decimal(31,0),
	manual_previous_period_cost float,
	manual_previous_week_hrs decimal(31,0),
	manual_previous_week_cost float,
	project_path varchar(400),
	path varchar(400),
	project_root_task_id decimal(31,0),
	help_path varchar(400),
	search_path varchar(400),
	scheduler_time_stamp date,
	scheduler_sync_stamp date,
	scheduled_by_start integer,
	project_account_code varchar(400),
	project_account_name varchar(120),
	logical_delete_flag smallint default 0,
	proj_is_frozen smallint default 0,
	proj_is_pool_project smallint default 0,
	proj_priority decimal(31,0) default 50,
	proj_pswd_for_restrict_1 byte(200),
	proj_pswd_for_restrict_2 byte(200),
	proj_pswd_for_restrict_3 byte(200),
	proj_pswd_master byte(200),
	proj_is_modified smallint default 0,
	proj_is_locked smallint default 0,
	proj_is_subproj smallint default 0,
	proj_is_superproj smallint default 0,
	proj_is_forwardcalc smallint default 1,
	proj_is_not_calculated smallint default 1,
	proj_is_tied_to_pool smallint default 0,
	proj_next_task_id decimal(31,0) default 0,
	proj_next_rsrc_id decimal(31,0) default 0,
	proj_next_asgn_id decimal(31,0) default 0,
	proj_decimal_tasks decimal(31,0),
	proj_decimal_rsrcs decimal(31,0),
	proj_decimal_asgns decimal(31,0),
	proj_revision_no float default 1.0,
	proj_shiftstart_sun decimal(31,0) default 700,
	proj_shiftstart_mon decimal(31,0) default 700,
	proj_shiftstart_tue decimal(31,0) default 700,
	proj_shiftstart_wed decimal(31,0) default 700,
	proj_shiftstart_thu decimal(31,0) default 700,
	proj_shiftstart_fri decimal(31,0) default 700,
	proj_shiftstart_sat decimal(31,0) default 700,
	proj_hrs_sun decimal(31,0) default 2100,
	proj_hrs_mon decimal(31,0) default 2100,
	proj_hrs_tue decimal(31,0) default 2100,
	proj_hrs_wed decimal(31,0) default 2100,
	proj_hrs_thu decimal(31,0) default 2100,
	proj_hrs_fri decimal(31,0) default 2100,
	proj_hrs_sat decimal(31,0) default 2100,
	proj_hrs_day decimal(31,0) default 8,
	proj_days_week decimal(31,0) default 5,
	proj_days_month decimal(31,0) default 2,
	proj_wbs_mask varchar(400) default '11.22.33.44.????',
	proj_account_mask varchar(400) default '11.22.33.44.5555',
	proj_wbs_level decimal(31,0),
	proj_directory varchar(400),
	proj_status_days_critical integer default 0,
	proj_status_days_warning integer default 0,
	proj_ovhead_rate float default 0,
	proj_autopool smallint default 0,
	proj_superproject_id decimal(31,0),
	proj_description varchar(400),
	project_manager_code varchar(400),
	project_manager_name varchar(120),
	alt_manager_code varchar(400),
	alt_manager_name varchar(120),
	proj_late_finish_datetime date,
	proj_type_dur_pref smallint default 0,
	proj_pref_duration decimal(31,0) default 0,
	proj_pref_priority decimal(31,0) default 50,
	proj_pref_over_priority decimal(31,0) default 0,
	proj_max_hrs decimal(31,0),
	proj_max_costs float,
	proj_max_units decimal(31,0),
	proj_max_percent decimal(31,0),
	proj_min_hrs decimal(31,0),
	proj_min_costs float,
	proj_min_units decimal(31,0),
	proj_min_percent decimal(31,0),
	proj_max_cum_work decimal(31,0),
	proj_max_cum_cost float,
	proj_max_cum_units decimal(31,0),
	proj_max_cum_percent decimal(31,0),
	proj_min_cum_work decimal(31,0),
	proj_min_cum_cost float,
	proj_min_cum_units decimal(31,0),
	proj_min_cum_percent decimal(31,0),
	proj_is_durhour smallint default 0,
	proj_is_percent decimal(5,2) default 1,
	proj_is_optholi smallint,
	proj_is_task_filter smallint,
	proj_is_rsrc_filter smallint,
	proj_is_asgn_filter smallint,
	proj_is_arrange smallint,
	proj_is_outline smallint,
	proj_is_not_del_actuals smallint default 0,
	proj_type_driven smallint default 0,
	proj_type_task smallint default 0,
	proj_has_selected_tasks smallint,
	proj_has_milestones smallint,
	proj_has_subprojects smallint,
	proj_is_moved_tasks smallint,
	proj_is_crit_used smallint,
	proj_is_smoothscale smallint,
	proj_is_do_dep_arr smallint,
	proj_is_dontpaint smallint,
	proj_type_accrue smallint,
	proj_is_chargeovr smallint,
	proj_use_base integer default 0,
	proj_is_updselbutton smallint,
	proj_is_curstatus smallint,
	proj_is_showstatuscolor smallint,
	proj_superproject_dir varchar(400),
	proj_superproject_name varchar(400),
	superproject_task_id decimal(31,0) default 0,
	proj_group varchar(400),
	proj_def_rsrc_rate float default 0,
	proj_def_ovt_rate float default 0,
	proj_def_rsrc_ovt_hrs_sun decimal(31,0) default 0,
	proj_def_rsrc_ovt_hrs_mon decimal(31,0) default 0,
	proj_def_rsrc_ovt_hrs_tue decimal(31,0) default 0,
	proj_def_rsrc_ovt_hrs_wed decimal(31,0) default 0,
	proj_def_rsrc_ovt_hrs_thu decimal(31,0) default 0,
	proj_def_rsrc_ovt_hrs_fri decimal(31,0) default 0,
	proj_def_rsrc_ovt_hrs_sat decimal(31,0) default 0,
	proj_pool_name varchar(400),
	proj_pool_proj_id decimal(31,0),
	proj_profile_name varchar(400),
	proj_is_inheritprofile smallint default 0,
	proj_is_linkallinpooldir smallint,
	proj_work_week_defn byte(200) default 'FCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFFFCFF',
	proj_tot_var_cost float,
	proj_tot_fix_cost float,
	proj_tot_ovt_cost float,
	proj_tot_ovhead_cost float,
	proj_tot_act_var_cost float,
	proj_tot_act_fix_cost float,
	proj_tot_act_ovt_cost float,
	proj_tot_act_ovhead_cost float,
	proj_tot_base_var_cost float,
	proj_tot_base_fix_cost float,
	proj_tot_bcwp float,
	proj_tot_asgn_hrs decimal(31,0),
	proj_tot_ovt_hrs decimal(31,0),
	proj_tot_oversch_hrs decimal(31,0),
	proj_tot_act_hrs decimal(31,0),
	proj_tot_act_ovt_hrs decimal(31,0),
	proj_tot_base_hrs decimal(31,0),
	proj_tot_mat_hrs decimal(31,0),
	proj_tot_act_mat_hrs decimal(31,0),
	proj_tot_upd_var_cost float,
	proj_tot_upd_fix_cost float,
	proj_tot_upd_ovt_cost float,
	proj_tot_upd_hrs decimal(31,0),
	proj_tot_upd_ovt_hrs decimal(31,0),
	proj_curr_asgn_id decimal(31,0),
	proj_curr_acct_id decimal(31,0),
	proj_curr_dout_id decimal(31,0),
	proj_locked_by_user_name varchar(120),
	proj_compression_state integer,
	proj_datetime_created date,
	proj_datetime_revised date,
	proj_1_restriction_flags byte(200),
	proj_2_restriction_flags byte(200),
	proj_3_restriction_flags byte(200),
	schedule_from_datetime date,
	schedule_to_datetime date,
	proj_contents long byte,
	user_field1 varchar(320),
	user_field2 varchar(320),
	user_field3 varchar(320),
	user_field4 varchar(320),
	user_field5 varchar(320),
	proj_is_private_acct_1 smallint,
	creation_datetime date,
	creation_user_name varchar(120),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify project to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy project () from 'project.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project
\p\g
create table project_account(
	project_account_id decimal(31,0) not null,
	parent_proj_acct_id decimal(31,0),
	project_account_code varchar(4000),
	project_account_name varchar(1200) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify project_account to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy project_account () from 'project_account.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_account
\p\g
create table project_group(
	project_group_id decimal(31,0) not null,
	project_group_name varchar(1200),
	project_group_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify project_group to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy project_group () from 'project_group.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_group
\p\g
create table project_grp_rel(
	project_id decimal(31,0) not null,
	project_group_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify project_grp_rel to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy project_grp_rel () from 'project_grp_rel.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_grp_rel
\p\g
create table project_keyword(
	keyword_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify project_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy project_keyword () from 'project_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_keyword
\p\g
create table project_message(
	project_id decimal(31,0) not null,
	project_message_id decimal(31,0) not null,
	reference_id varchar(120),
	project_message_description varchar(4000) not null,
	message_start_date date,
	message_end_date date,
	ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify project_message to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy project_message () from 'project_message.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_message
\p\g
create table project_public(
	project_id decimal(31,0) not null,
	publ_proj_name varchar(400) not null,
	publ_proj_id decimal(31,0),
	publ_reserved_flags decimal(31,0),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify project_public to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy project_public () from 'project_public.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_public
\p\g
create table project_rsrc_avail(
	project_id decimal(31,0) not null,
	rsrc_id decimal(31,0) not null,
	effective_start_date date,
	effective_end_date date,
	availability_percentage integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify project_rsrc_avail to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy project_rsrc_avail () from 'project_rsrc_avail.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_rsrc_avail
\p\g
create table project_size(
	project_size_id decimal(31,0) not null,
	project_size_code varchar(4000),
	project_size_name varchar(1200) not null,
	project_size_description varchar(4000),
	overdue_received_to_estimated integer,
	overdue_estimated_to_approved integer,
	overdue_approved_to_complete integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify project_size to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy project_size () from 'project_size.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_size
\p\g
create table project_state(
	project_status_id decimal(31,0) not null,
	project_status_code varchar(4000),
	project_status_name varchar(1200) not null,
	creation_datetime date,
	creation_username varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify project_state to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy project_state () from 'project_state.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_state
\p\g
create table project_type(
	project_type_id decimal(31,0) not null,
	project_type_code varchar(4000),
	project_type_name varchar(1200) not null,
	project_type_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify project_type to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy project_type () from 'project_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_type
\p\g
create table project_uses_product(
	product_instance_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify project_uses_product to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy project_uses_product () from 'project_uses_product.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on project_uses_product
\p\g
create table propertyvalue(
	uidparent byte(16) not null,
	strvalue varchar(255) not null,
	ivalue integer not null,
	ivalue2 integer not null,
	uidvalue byte(16) not null,
	uid byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify propertyvalue to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy propertyvalue () from 'propertyvalue.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on propertyvalue
\p\g
create table protection_level(
	protection_level_id byte(16) not null,
	name nvarchar(50),
	ranking_value smallint,
	creation_user nvarchar(64),
	creation_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify protection_level to btree unique on
	protection_level_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy protection_level () from 'protection_level.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on protection_level
\p\g
create table provider_user(
	userid integer not null,
	provider_name char(20) not null,
	product_code integer not null,
	username char(40) not null,
	password char(64),
	datetime_updated date not null,
	provider_number integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify provider_user to btree unique on
	userid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy provider_user () from 'provider_user.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on provider_user
\p\g
create table providerversion(
	providertype smallint not null,
	providersubtype smallint not null,
	providername varchar(32) not null,
	serverid integer not null,
	providerversion varchar(32) not null,
	providermodulename varchar(32) not null,
	providerkeys long byte,
	minrunversion integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify providerversion to heap
with extend = 16,
	allocation = 4
\p\g
/* copy providerversion () from 'providerversion.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on providerversion
\p\g
create table prp(
	id integer not null,
	persid varchar(30),
	object_type varchar(30) not null,
	object_id integer not null,
	sequence integer not null,
	property integer,
	value varchar(240),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	required integer,
	sample varchar(240),
	description varchar(240),
	label varchar(80)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify prp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy prp () from 'prp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on prp
\p\g
create table prptpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	object_type varchar(30) not null,
	object_attrname varchar(30) not null,
	object_attrval integer,
	sequence integer not null,
	label varchar(80) not null,
	description varchar(240),
	code varchar(12) not null,
	required integer not null,
	sample varchar(240),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify prptpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy prptpl () from 'prptpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on prptpl
\p\g
create table qmgr(
	oid integer not null,
	authorev varchar(25),
	ccsid varchar(25),
	chad char(10),
	chadev char(10),
	chadexit varchar(128),
	cmdlevel varchar(25),
	commandq varchar(48),
	cpilevel integer,
	deadq varchar(48),
	defxmitq varchar(48),
	descr varchar(64),
	distl char(10),
	inhibtev char(10),
	localev char(10),
	maxhands integer,
	maxmsgl integer,
	maxprty integer,
	maxumsgs integer,
	perfmev char(10),
	platform char(12),
	qmname varchar(48) not null,
	remoteev char(10),
	strstpev char(10),
	syncpt char(10),
	trigint varchar(15),
	altdate varchar(48),
	alttime varchar(48),
	clwldata varchar(48),
	clwlexit varchar(48),
	clwllen varchar(48),
	crdate varchar(48),
	crtime varchar(48),
	qmid varchar(48),
	repos varchar(48),
	reposnl varchar(48),
	xpos varchar(20),
	ypos varchar(20),
	trptype char(7),
	configev char(10),
	expryint varchar(9),
	sslcrlnl varchar(48),
	sslcryp varchar(256),
	sslkeyr varchar(256),
	ssltasks integer,
	qsgname char(4),
	igq char(10),
	igqaut varchar(10),
	igquser varchar(12)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify qmgr to heap
with extend = 16,
	allocation = 4
\p\g
/* copy qmgr () from 'qmgr.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on qmgr
\p\g
create table qmgr_connect(
	oid integer not null,
	qmname varchar(48) not null,
	descr varchar(254),
	cmdlevel varchar(25),
	platform char(12),
	error_code integer,
	error_xml text(1),
	marked_for_delete char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify qmgr_connect to heap
with extend = 16,
	allocation = 4
\p\g
/* copy qmgr_connect () from 'qmgr_connect.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on qmgr_connect
\p\g
create table qmgr_url(
	oid integer not null,
	qmgr_connect_oid integer not null,
	hostname varchar(128) not null,
	port varchar(20) not null,
	trptype char(7) not null,
	conname varchar(64) not null,
	defaultx char(10),
	expertmq char(10)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify qmgr_url to heap
with extend = 16,
	allocation = 4
\p\g
/* copy qmgr_url () from 'qmgr_url.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on qmgr_url
\p\g
create table qmgr_vrsn(
	vrsn_oid integer not null,
	qmgr_oid integer not null,
	hub_oid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify qmgr_vrsn to heap
with extend = 16,
	allocation = 4
\p\g
/* copy qmgr_vrsn () from 'qmgr_vrsn.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on qmgr_vrsn
\p\g
create table qmgr_wip(
	wip_oid integer not null,
	qmgr_oid integer not null,
	hub_oid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify qmgr_wip to heap
with extend = 16,
	allocation = 4
\p\g
/* copy qmgr_wip () from 'qmgr_wip.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on qmgr_wip
\p\g
create table qmgrcfg(
	qmgrid integer not null,
	qmgrname varchar(48) not null,
	collectorid integer,
	hostname varchar(256),
	ipaddress char(20),
	port integer not null,
	cmdlevel char(5) not null,
	platform char(12),
	agentname char(20),
	agenthost varchar(256),
	agentip char(20),
	agentversion char(20),
	status integer,
	conntrptype char(7),
	conndescription varchar(254),
	connuserid char(20),
	connpassword char(256),
	connchannel char(20),
	connexit char(256),
	ceerrorcode integer,
	ceerrorxml text(1),
	ceqmgroid integer,
	cesnaid varchar(48),
	ceplatformfamily char(12),
	cemarkedfordelete char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify qmgrcfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy qmgrcfg () from 'qmgrcfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on qmgrcfg
\p\g
create table qmset(
	oid integer not null,
	qmset_label varchar(64) not null,
	descr varchar(254),
	master_vrsn_oid integer,
	user_name varchar(60) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify qmset to heap
with extend = 16,
	allocation = 4
\p\g
/* copy qmset () from 'qmset.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on qmset
\p\g
create table query(
	query_id decimal(5,0) not null,
	created_by varchar(30),
	query_version decimal(5,0) not null,
	query_date date,
	query_name varchar(30) not null,
	query_text varchar(2000) not null,
	query_type decimal(2,0),
	query_scope decimal(2,0),
	query_internal decimal(1,0),
	query_use_db decimal(1,0)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify query to btree unique on
	query_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy query () from 'query.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on query
\p\g
create table queue(
	oid integer not null,
	qmgr_oid integer not null,
	defprty integer,
	defpsist char(3),
	descr varchar(64),
	put char(8),
	queue varchar(48) not null,
	type varchar(48),
	boqname varchar(48),
	bothresh integer,
	crdate char(10),
	crtime char(8),
	curdepth integer,
	defsopt char(6),
	deftype char(10),
	distl char(3),
	get char(8),
	hardenbo char(10),
	indxtype char(8),
	initq varchar(48),
	ipprocs integer,
	maxdepth integer,
	maxmsgl integer,
	msgdlvsq char(8),
	opprocs integer,
	process varchar(80),
	qdepthhi integer,
	qdepthlo integer,
	qdphiev char(8),
	qdploev char(8),
	qdpmaxev char(8),
	qsvciev char(4),
	qsvcint integer,
	retintvl integer,
	rname varchar(48),
	rqmname varchar(48),
	scope char(4),
	sharex varchar(80),
	stgclass varchar(40),
	targq varchar(48),
	trigdata varchar(64),
	trigdpth integer,
	triggerx char(9),
	trigmpri integer,
	trigtype char(5),
	usagex char(6),
	xmitq varchar(48),
	altdate varchar(48),
	alttime varchar(48),
	clusnl varchar(48),
	clusterx varchar(48),
	defbind varchar(48),
	psid integer,
	qsgdisp varchar(8),
	cfstruct varchar(12)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify queue to heap
with extend = 16,
	allocation = 4
\p\g
/* copy queue () from 'queue.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on queue
\p\g
create table queuecfg(
	qmgrid integer not null,
	queueid integer not null,
	queuename varchar(48) not null,
	type char(8) not null,
	status integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify queuecfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy queuecfg () from 'queuecfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on queuecfg
\p\g
create table queuedata(
	tstamp date not null,
	qmgrid integer not null,
	queueid integer not null,
	intvltype char(1) not null,
	intvlduration integer not null,
	depth integer not null,
	depthpercent integer not null,
	residency integer not null,
	highmsgres integer not null,
	gets integer not null,
	puts integer not null,
	getenabled smallint not null,
	putenabled smallint not null,
	issent smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify queuedata to heap
with extend = 16,
	allocation = 4
\p\g
/* copy queuedata () from 'queuedata.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on queuedata
\p\g
create table quick_tpl_types(
	id integer not null,
	persid varchar(30),
	del integer not null,
	enum integer not null,
	sym varchar(30),
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify quick_tpl_types to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy quick_tpl_types () from 'quick_tpl_types.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on quick_tpl_types
\p\g
create table racaction(
	actionid integer not null,
	keycertdata long byte,
	serialnumber varchar(50),
	errormessage varchar(300)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify racaction to btree unique on
	actionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy racaction () from 'racaction.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on racaction
\p\g
create table rbooltab(
	id integer not null,
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rbooltab to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy rbooltab () from 'rbooltab.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rbooltab
\p\g
create table rbs(
	rbs_id decimal(5,0) not null,
	collect_id decimal(5,0),
	segment_name varchar(30),
	user_code decimal(5,0),
	datafile_id decimal(5,0),
	blocks_alloc decimal(5,0),
	extents_alloc decimal(5,0),
	initial_extent decimal(5,0),
	next_extent decimal(5,0),
	min_extents decimal(5,0),
	max_extents decimal(5,0),
	pct_increase decimal(5,0),
	status decimal(5,0),
	optsize decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rbs to btree unique on
	rbs_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy rbs () from 'rbs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rbs
\p\g
create table rdbms_provider(
	providerid integer not null,
	loginname varchar(32),
	loginpassword byte(32),
	servername varchar(128),
	databasename varchar(128),
	databasetype smallint not null,
	other varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rdbms_provider to heap
with extend = 16,
	allocation = 4
\p\g
/* copy rdbms_provider () from 'rdbms_provider.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rdbms_provider
\p\g
create table recoverrequest(
	requestid integer not null,
	country varchar(50),
	organisation varchar(50),
	orgunit varchar(50),
	name varchar(50),
	emailaddress varchar(50),
	serialnumber varchar(50),
	passphrase varchar(50),
	phonenumber varchar(50),
	reqreason varchar(300)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify recoverrequest to btree unique on
	requestid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy recoverrequest () from 'recoverrequest.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on recoverrequest
\p\g
create table recurring_events(
	recurring_event_oid varchar(20) not null,
	calendar_oid varchar(20),
	pattern varchar(255) not null,
	pattern_type_oid varchar(20),
	duration integer,
	start integer,
	expire integer,
	description varchar(255),
	event_category_oid varchar(20),
	event_category_value_oid varchar(20),
	value varchar(255),
	timezone varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify recurring_events to btree unique on
	recurring_event_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy recurring_events () from 'recurring_events.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on recurring_events
\p\g
create table ref(
	ref_id decimal(5,0) not null,
	collect_id decimal(5,0),
	table_id decimal(5,0),
	column_name varchar(30),
	with_rowid decimal(5,0),
	is_scoped decimal(5,0),
	scope_user_id decimal(5,0),
	scope_table_id decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ref to btree unique on
	ref_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ref () from 'ref.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ref
\p\g
create table ref_ref_source_matrix(
	ref_ref_id byte(16) not null,
	reference_source_id_1 byte(16) not null,
	reference_source_id_2 byte(16) not null,
	creation_user nvarchar(64) not null,
	creation_date nvarchar(64) not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ref_ref_source_matrix to btree unique on
	ref_ref_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ref_ref_source_matrix () from 'ref_ref_source_matrix.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ref_ref_source_matrix
\p\g
create table reference(
	reference_id varchar(120) not null,
	ref_name varchar(4000) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify reference to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy reference () from 'reference.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on reference
\p\g
create table reference_group(
	reference_group_id byte(16) not null,
	name nvarchar(60) not null,
	url_name nvarchar(255),
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reference_group to btree unique on
	reference_group_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy reference_group () from 'reference_group.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reference_group
\p\g
create table reference_source(
	reference_source_id byte(16) not null,
	name nvarchar(255) not null,
	reference_group_id byte(16) not null,
	url_name nvarchar(255),
	reference_number nvarchar(20),
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reference_source to btree unique on
	reference_source_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy reference_source () from 'reference_source.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reference_source
\p\g
create table reference_source_vuln_matrix(
	reference_source_vuln_rec_id byte(16) not null,
	vuln_id byte(16) not null,
	reference_source_id byte(16) not null,
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reference_source_vuln_matrix to btree unique on
	reference_source_vuln_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy reference_source_vuln_matrix () from 'reference_source_vuln_matrix.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reference_source_vuln_matrix
\p\g
create table region(
	regionid integer not null,
	regionname varchar(255) not null,
	instancename varchar(64) not null,
	regionowner varchar(255),
	parentregionid integer,
	regiontype varchar(10) not null,
	parentboxid integer,
	namingstandard varchar(255),
	rgnleft integer not null,
	rgnright integer not null,
	rgntop integer not null,
	rgnbottom integer not null,
	lastsynctime integer,
	checkoutsid varchar(100),
	checkoutname varchar(100),
	cloneid integer,
	templateregionid integer,
	psname varchar(255),
	autosysregion integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify region to btree unique on
	regionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy region () from 'region.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on region
\p\g
create table registered_observer(
	observer_key varchar(40) not null,
	type integer,
	version varchar(40),
	creation_date date,
	ip_address varchar(255),
	auto_discover_status integer,
	last_heartbeat_date date,
	observer_status integer,
	logging_enabled decimal(1,0),
	observer_enabled decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify registered_observer to btree unique on
	observer_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy registered_observer () from 'registered_observer.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on registered_observer
\p\g
create table rel_map(
	oid integer not null,
	a_tab_schem varchar(18) not null,
	a_tab_name varchar(18) not null,
	a_oid_col varchar(18) not null,
	a_tag varchar(64) not null,
	a_arity char(1) not null,
	a_cascade char(1) not null,
	b_tab_schem varchar(18) not null,
	b_tab_name varchar(18) not null,
	b_oid_col varchar(18) not null,
	b_tag varchar(64) not null,
	b_arity char(1) not null,
	b_cascade char(1) not null,
	superclass char(1) not null,
	rel_tab_schem varchar(18) not null,
	rel_tab_name varchar(18) not null,
	rel_a_oid_col varchar(18) not null,
	rel_b_oid_col varchar(18) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rel_map to heap
with extend = 16,
	allocation = 4
\p\g
/* copy rel_map () from 'rel_map.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rel_map
\p\g
create table release(
	sw_def_uuid byte(16) not null,
	is_priority_technology i1,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify release to btree unique on
	sw_def_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy release () from 'release.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on release
\p\g
create table rem_ref(
	id integer not null,
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	code varchar(12) not null,
	exec_str varchar(500),
	pcexec_str varchar(500),
	function_group varchar(30),
	arch_type varchar(12)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rem_ref to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy rem_ref () from 'rem_ref.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rem_ref
\p\g
create table remed_prof_detect_prof_matrix(
	remed_detect_profile_rec_id byte(16) not null,
	detect_profile_id byte(16) not null,
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	remed_profile_id byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify remed_prof_detect_prof_matrix to btree unique on
	remed_detect_profile_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy remed_prof_detect_prof_matrix () from 'remed_prof_detect_prof_matrix.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on remed_prof_detect_prof_matrix
\p\g
create table remediation_profile(
	remed_profile_id byte(16) not null,
	installation_instructions long nvarchar,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify remediation_profile to btree unique on
	remed_profile_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy remediation_profile () from 'remediation_profile.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on remediation_profile
\p\g
create table renewalrequest(
	requestid integer not null,
	country varchar(50),
	organisation varchar(50),
	orgunit varchar(50),
	name varchar(50),
	emailaddress varchar(50),
	serialnumber varchar(50),
	newexpirydate date,
	passphrase varchar(50),
	phonenumber varchar(50),
	reqreason varchar(300)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify renewalrequest to btree unique on
	requestid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy renewalrequest () from 'renewalrequest.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on renewalrequest
\p\g
create table reorg_part_tab_files(
	part_key decimal(31,0) not null,
	mb_spread decimal(31,0) not null,
	file_id decimal(31,0) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reorg_part_tab_files to heap
with extend = 16,
	allocation = 4
\p\g
/* copy reorg_part_tab_files () from 'reorg_part_tab_files.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on reorg_part_tab_files
\p\g
create table reorg_part_tables(
	part_key decimal(31,0) not null,
	table_name varchar(30) not null,
	table_owner varchar(30) not null,
	type decimal(31,0) not null,
	extent_size decimal(31,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reorg_part_tables to btree unique on
	part_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy reorg_part_tables () from 'reorg_part_tables.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reorg_part_tables
\p\g
create table repmeth(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify repmeth to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy repmeth () from 'repmeth.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on repmeth
\p\g
create table report_category(
	report_category_id decimal(5,0) not null,
	category varchar(30) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_category to btree unique on
	report_category_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy report_category () from 'report_category.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_category
\p\g
create table report_commands(
	job_id integer not null,
	command varchar(50),
	report_title varchar(255) not null,
	class_scope varchar(5),
	metric_scope varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_commands to btree unique on
	job_id,
	report_title
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_commands () from 'report_commands.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_commands
\p\g
create table report_done(
	job_id integer not null,
	start_time integer,
	end_time integer,
	report_period varchar(30),
	error varchar(50),
	link varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_done to btree unique on
	job_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_done () from 'report_done.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_done
\p\g
create table report_group(
	group_id integer not null,
	group_name varchar(50) not null,
	description varchar(255),
	created integer,
	created_by varchar(50),
	last_modified integer,
	last_modified_by varchar(50),
	downtime_goal integer not null default -1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_group to btree unique on
	group_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_group () from 'report_group.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_group
\p\g
create table report_group_calendars(
	group_id integer not null,
	calendar_oid varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_group_calendars to btree unique on
	group_id,
	calendar_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_group_calendars () from 'report_group_calendars.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_group_calendars
\p\g
create table report_group_goals(
	group_id integer not null,
	goal_name varchar(100) not null,
	value varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_group_goals to btree unique on
	group_id,
	goal_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_group_goals () from 'report_group_goals.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_group_goals
\p\g
create table report_group_member_calendars(
	group_id integer not null,
	dcid integer not null,
	calendar_oid varchar(20) not null,
	status char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_group_member_calendars to btree unique on
	group_id,
	dcid,
	calendar_oid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_group_member_calendars () from 'report_group_member_calendars.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_group_member_calendars
\p\g
create table report_group_members(
	group_id integer not null,
	dcid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_group_members to btree unique on
	group_id,
	dcid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_group_members () from 'report_group_members.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_group_members
\p\g
create table report_group_parents(
	group_id integer not null,
	parent_id integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_group_parents to btree unique on
	group_id,
	parent_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_group_parents () from 'report_group_parents.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_group_parents
\p\g
create table report_head(
	report_head_id decimal(5,0) not null,
	report_name varchar(80) not null,
	view_id decimal(5,0),
	filter_id decimal(5,0),
	detail_rep_name varchar(300),
	summary_rep_name varchar(300),
	detail_sample_name varchar(300),
	summary_sample_name varchar(300),
	category_id decimal(5,0),
	report_context decimal(1,0),
	filter_code decimal(1,0),
	ora8_view_id decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_head to btree unique on
	report_head_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy report_head () from 'report_head.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_head
\p\g
create table report_history(
	report_history_id decimal(31,0),
	run_date date not null,
	report_object long byte,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify report_history to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy report_history () from 'report_history.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on report_history
\p\g
create table report_identifier(
	job_id integer not null,
	dcid integer not null default -1,
	group_id integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_identifier to btree unique on
	job_id,
	dcid,
	group_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_identifier () from 'report_identifier.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_identifier
\p\g
create table report_index(
	report_index integer not null,
	group_id integer not null,
	category varchar(255),
	access_group varchar(20),
	cmd_id varchar(50),
	report_period varchar(50),
	report_title varchar(255),
	job_id integer,
	period_type varchar(20),
	url varchar(20),
	created integer,
	last_modified integer,
	status varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_index to btree unique on
	report_index
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_index () from 'report_index.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_index
\p\g
create table report_interval(
	wsdl_operation_id integer not null,
	start_date date not null,
	duration integer not null,
	total_request_size integer not null,
	total_response_size integer not null,
	total_duration integer not null,
	total_requests integer not null,
	total_faults integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_interval to btree on
	start_date
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_interval () from 'report_interval.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_interval
\p\g
create table report_options(
	job_id integer not null,
	name varchar(50) not null,
	value varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_options to btree unique on
	job_id,
	name,
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_options () from 'report_options.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_options
\p\g
create table report_pki(
	buttontext varchar(100) not null,
	buttonimage varchar(100) not null,
	actioncommand varchar(500) not null,
	action varchar(500) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify report_pki to btree unique on
	buttontext
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy report_pki () from 'report_pki.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_pki
\p\g
create table report_result(
	group_id integer not null,
	report_function varchar(50) not null,
	metric_scope varchar(100) not null,
	class_scope varchar(50) not null,
	report_period integer not null,
	report_qualifier integer not null,
	dcid integer not null,
	goal_orientation integer not null,
	url varchar(255) not null,
	service_goal f4,
	value f4,
	sla_violate integer,
	last_modified integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_result to btree unique on
	group_id,
	report_function,
	metric_scope,
	class_scope,
	report_period,
	report_qualifier,
	dcid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_result () from 'report_result.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_result
\p\g
create table report_time(
	job_id integer not null,
	time varchar(20) not null,
	period varchar(10) not null,
	period_type varchar(6) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_time to btree unique on
	job_id,
	time
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy report_time () from 'report_time.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_time
\p\g
create table report_view(
	report_view_id decimal(5,0) not null,
	view_name varchar(30),
	text integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify report_view to btree unique on
	report_view_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy report_view () from 'report_view.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on report_view
\p\g
create table reportcolumn(
	columnid integer not null,
	thresholdreportid integer,
	thresholdcolumnid integer,
	columnname varchar(255) not null,
	isvisible smallint,
	sortby smallint,
	formula varchar(255),
	isdistinct i1,
	isgroup smallint,
	title varchar(255),
	presentation smallint,
	inworkspace i1,
	unitid integer,
	reportid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reportcolumn to btree unique on
	columnid,
	reportid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy reportcolumn () from 'reportcolumn.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reportcolumn
\p\g
create integrity  ON ReportColumn IS ColumnID >= 1
\p\g
create integrity  ON ReportColumn IS ReportID >= 1
\p\g
create integrity  ON ReportColumn IS ThresholdColumnID >= 1
\p\g
create integrity  ON ReportColumn IS ThresholdReportID >= 1
\p\g
create integrity  ON ReportColumn IS IsGroup >= 1
\p\g
create integrity  ON ReportColumn IS Presentation IN (0, 1, 2)
\p\g
create integrity  ON ReportColumn IS UnitID >= 1
\p\g
create table reportdescr(
	rptindex smallint not null,
	rptpart smallint not null,
	rptorder integer not null,
	rpttitle varchar(64),
	rptdescription varchar(255),
	rptoid varchar(255),
	rptaxistitle varchar(50),
	rpttitle2 varchar(64),
	rptresources varchar(32),
	rptargtype smallint,
	rptstrdprocname varchar(30),
	rptdrillto smallint,
	rptsql1 varchar(255),
	rptsql2 varchar(255),
	rptcolsortorder smallint,
	rptallowscaling varchar(1),
	rptscale smallint,
	rptcharttype smallint,
	rptchart3d varchar(1),
	rptchartstacked smallint,
	rptcharttype2 integer,
	rptchartgrid smallint,
	rptchartlegendtext varchar(64),
	rptallowdrilldown varchar(1),
	rptnumchartseries smallint,
	rptrsrcseltype varchar(4),
	rptserleg varchar(255),
	rptcolheader varchar(255),
	rptdrilltos varchar(48),
	rptnumofneededoid smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reportdescr to hash unique on
	rptindex,
	rptpart
with fillfactor = 50,
	extend = 16
\p\g
/* copy reportdescr () from 'reportdescr.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reportdescr
\p\g
create table reporttable(
	counterid integer not null,
	reporttableid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify reporttable to btree unique on
	counterid,
	reporttableid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy reporttable () from 'reporttable.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reporttable
\p\g
create integrity  ON ReportTable IS CounterID >= 1
\p\g
create integrity  ON ReportTable IS ReportTableID >= 1
\p\g
create table reporttabledefinition(
	reporttableid integer not null,
	reporttablename char(2543) not null,
	algotype smallint not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify reporttabledefinition to btree unique on
	reporttableid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy reporttabledefinition () from 'reporttabledefinition.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on reporttabledefinition
\p\g
create integrity  ON ReportTableDefinition IS ReportTableID >= 1
\p\g
create integrity  ON ReportTableDefinition IS AlgoType IN (1, 2, 3, 4,
5)
\p\g
create table repositorycredentials(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname varchar(1048) not null,
	struser varchar(256) not null,
	strpassword varchar(256) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify repositorycredentials to btree unique on
	uid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy repositorycredentials () from 'repositorycredentials.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on repositorycredentials
\p\g
create table req_job(
	job_name varchar(64) not null,
	req_autoserv varchar(4) not null,
	req_job_name varchar(64) not null,
	pending_delete char(1),
	schd0005 varchar(7),
	nsm_system_id varchar(64) not null,
	nsm_jobset_id varchar(64) not null,
	nsm_jobno_id varchar(4) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify req_job to btree unique on
	job_name,
	req_autoserv,
	req_job_name,
	nsm_system_id,
	nsm_jobset_id,
	nsm_jobno_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy req_job () from 'req_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on req_job
\p\g
create table request_log(
	request_time date not null,
	wsdl_operation_id integer not null,
	transaction_id varchar(255) not null,
	observer_ip varchar(15) not null,
	requestor_ip varchar(15) not null,
	request_size integer not null,
	response_size integer not null,
	request_duration integer not null,
	type integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify request_log to btree on
	request_time
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy request_log () from 'request_log.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on request_log
\p\g
create table request_pki(
	requestid integer not null,
	requesttype integer,
	requesttime date,
	resolutiontime date,
	requeststatus integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify request_pki to btree unique on
	requestid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy request_pki () from 'request_pki.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on request_pki
\p\g
create table requestprovider(
	providerid integer not null,
	requestid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify requestprovider to heap
with extend = 16,
	allocation = 4
\p\g
/* copy requestprovider () from 'requestprovider.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on requestprovider
\p\g
create table requestqueue(
	requestid integer not null,
	serverid integer not null,
	nextexecutiontime date not null,
	userid integer not null,
	reschedule i1 not null,
	locktime date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify requestqueue to heap
with extend = 16,
	allocation = 4
\p\g
/* copy requestqueue () from 'requestqueue.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on requestqueue
\p\g
create table requesttype(
	requesttype integer not null,
	description varchar(50),
	entityname varchar(50)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify requesttype to btree unique on
	requesttype
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy requesttype () from 'requesttype.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on requesttype
\p\g
create table resnonhealth(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	ifindex integer,
	downduration integer,
	criticalduration integer,
	majorduration integer,
	minorduration integer,
	warningduration integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify resnonhealth to btree on
	probe_addr,
	ifindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy resnonhealth () from 'resnonhealth.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table resource(
	id integer,
	type i1,
	filename varchar(255) not null,
	description varchar(32),
	data long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify resource to heap
with extend = 16,
	allocation = 4
\p\g
/* copy resource () from 'resource.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource
\p\g
create table resource_alias(
	primary_rsrc_id decimal(31,0) not null,
	alias_rsrc_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_alias to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_alias () from 'resource_alias.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_alias
\p\g
create table resource_calendar(
	rsrc_calendar_id decimal(31,0) not null,
	rsrc_id decimal(31,0) not null,
	non_project_event_id decimal(31,0) not null,
	tot_sched_hrs decimal(31,0),
	frequency_id decimal(31,0) not null,
	sched_start_date date,
	sched_finish_date date,
	description varchar(4000),
	start_date date,
	finish_date date,
	start_time date,
	end_time date,
	interval integer,
	hours decimal(31,0),
	percentage float,
	frequency varchar(4000),
	frequency_description varchar(4000),
	asgn_notes varchar(4000),
	required_time_capture_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_calendar to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy resource_calendar () from 'resource_calendar.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_calendar
\p\g
create table resource_class(
	resource_class_uuid byte(16) not null,
	name varchar(50),
	product_instance_name varchar(50),
	product_instance_id byte(16) not null,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_class to heap
with extend = 16,
	allocation = 4
\p\g
/* copy resource_class () from 'resource_class.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_class
\p\g
create table resource_detail(
	rsrc_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	calendar_id decimal(31,0),
	work_week_id decimal(31,0),
	department_id decimal(31,0),
	rsrc_type_id decimal(31,0) default 0,
	reference_id varchar(120),
	instantiation_source_id decimal(31,0),
	rsrc_manager_id decimal(31,0),
	opruid decimal(31,0),
	rsrc_code varchar(300) not null,
	rsrc_name varchar(120) not null,
	rsrc_password varchar(120),
	password_setting_flag smallint,
	rsrc_title varchar(120),
	availability_date date,
	termination_date date,
	is_manager smallint,
	is_alt_manager smallint,
	rsrc_manager_name varchar(120),
	rsrc_manager_code varchar(40),
	rsrc_billing_rate float,
	rsrc_ovt_percent float,
	availability_level float,
	time_sheet_required_flag smallint,
	rsrc_description varchar(400),
	headcount_flag smallint,
	email_address varchar(120),
	phone_decimal varchar(120),
	mpx_calendar varchar(400),
	scheduler_attribute varchar(400),
	pmw_res_key decimal(31,0),
	project_info_sent smallint,
	tsdate_to_ignore date,
	work_units integer,
	last_signon_datetime date,
	hide_rsrc_bill_rate smallint,
	hide_rsrc_cost smallint,
	hide_rsrc_ovt_percent float,
	decimal_of_signon_times integer,
	logical_dete_flag smallint,
	rsrc_is_heading smallint,
	rsrc_is_childhidden smallint,
	rsrc_is_selected smallint,
	rsrc_is_level smallint,
	rsrc_is_conflict smallint,
	rsrc_is_xdur smallint,
	rsrc_is_percent smallint,
	rsrc_is_hidden smallint,
	rsrc_is_marked_in_conflict smallint,
	rsrc_is_optimized_holi smallint,
	rsrc_type_accrue smallint,
	rsrc_asgn_root_id decimal(31,0),
	rsrc_def_alloc integer,
	rsrc_def_alloc_hrs decimal(31,0),
	rsrc_def_hrs decimal(31,0),
	rsrc_use_units integer,
	rsrc_expertise integer,
	rsrc_ovt_rate float,
	rsrc_standard_day_hrs decimal(31,0),
	rsrc_ovt_hrs decimal(31,0),
	rsrc_available_hrs decimal(31,0),
	rsrc_under_sched_hrs decimal(31,0),
	rsrc_maxhour integer,
	rsrc_maxunit integer,
	rsrc_is_last_heading smallint,
	rsrc_is_ovt_rate_ent smallint,
	rsrc_is_accrual_ent smallint,
	rsrc_is_member_of_pool smallint,
	rsrc_outline_row integer,
	rsrc_outline_col integer,
	rsrc_tot_var_cost float,
	rsrc_tot_fix_cost float,
	rsrc_tot_ovt_cost float,
	rsrc_tot_ovhead_cost float,
	rsrc_tot_act_var_cost float,
	rsrc_tot_act_fix_cost float,
	rsrc_tot_act_ovt_cost float,
	rsrc_tot_act_ovhead_cost float,
	rsrc_tot_base_var_cost float,
	rsrc_tot_base_fix_cost float,
	rsrc_tot_bcwp float,
	rsrc_tot_asgn_hrs decimal(31,0),
	rsrc_tot_ovt_hrs decimal(31,0),
	rsrc_tot_oversch_hrs decimal(31,0),
	rsrc_tot_act_hrs decimal(31,0),
	rsrc_tot_act_ovt_hrs decimal(31,0),
	rsrc_tot_base_hrs decimal(31,0),
	rsrc_tot_mat_hrs decimal(31,0),
	rsrc_tot_act_mat_hrs decimal(31,0),
	rsrc_tot_upd_var_cost float,
	rsrc_tot_upd_fix_cost float,
	rsrc_tot_upd_ovt_cost float,
	rsrc_tot_upd_hrs decimal(31,0),
	rsrc_tot_upd_ovt_hrs decimal(31,0),
	rsrc_def_rsrc_rate float,
	rsrc_def_start_date date,
	rsrc_def_end_date date,
	rsrc_sibling_id decimal(31,0),
	rsrc_child_id decimal(31,0),
	rsrc_outline_root decimal(31,0),
	rsrc_group varchar(120),
	rsrc_datetime_created date,
	rsrc_datetime_revised date,
	rsrc_restriction integer,
	alias varchar(120),
	ref_name varchar(400),
	alt_ref_name varchar(400),
	pe_scheduler_id varchar(120),
	creation_datetime date,
	creation_user_name varchar(120),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_detail to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_detail () from 'resource_detail.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_detail
\p\g
create table resource_detail_rate(
	rsrc_start_date date not null,
	rsrc_id decimal(31,0) not null,
	rsrc_end_date date not null,
	rsrc_billing_rate float,
	rsrc_ovt_billing_percent float,
	rsrc_cost_rate float,
	rsrc_ovt_cost_percent float,
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_detail_rate to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_detail_rate () from 'resource_detail_rate.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_detail_rate
\p\g
create table resource_detail_unit(
	rsrc_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	unit_rsrc_start_date date not null,
	unit_rsrc_units decimal(31,0),
	unit_rsrc_end_date date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_detail_unit to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_detail_unit () from 'resource_detail_unit.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_detail_unit
\p\g
create table resource_emc_security(
	rsrc_id decimal(31,0) not null,
	emc_menu_id decimal(31,0) not null,
	emc_menu_setting smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_emc_security to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_emc_security () from 'resource_emc_security.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_emc_security
\p\g
create table resource_keyword(
	rsrc_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_keyword () from 'resource_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_keyword
\p\g
create table resource_object_security(
	object_type varchar(120) not null,
	rsrc_id decimal(31,0) not null,
	object_creation_rights smallint,
	object_deletion_rights smallint,
	object_update_rights smallint,
	object_read_only_rights smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_object_security to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_object_security () from 'resource_object_security.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_object_security
\p\g
create table resource_role_assignment(
	rsrc_id decimal(31,0) not null,
	role_id decimal(31,0) not null,
	efficiency_id decimal(31,0),
	responsibility varchar(4000),
	logical_delete_flag smallint,
	role_expertise integer,
	role_is_expertise_ent smallint,
	role_is_rate_ent smallint,
	role_rate float,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_role_assignment to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy resource_role_assignment () from 'resource_role_assignment.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_role_assignment
\p\g
create table resource_team(
	rsrc_id decimal(31,0) not null,
	team_id decimal(31,0) not null,
	global_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_team to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy resource_team () from 'resource_team.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_team
\p\g
create table resource_type(
	rsrc_type_id decimal(31,0) not null,
	rsrc_type_name varchar(4000) not null,
	rsrc_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_type to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy resource_type () from 'resource_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_type
\p\g
create table resource_work_summary(
	rsrc_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	pjwk_rsrc_proj_name varchar(400) not null,
	pjwk_rsrc_proj_id decimal(31,0),
	revision_datetime date,
	pjwk_rsrc_rsrc_id decimal(31,0),
	pjwk_rsrc_proj_directory varchar(4000),
	pjwk_rsrc_index integer,
	pjwk_rsrc_last_index integer,
	pjwk_rsrc_last_date_processed date,
	pjwk_rsrc_project_priority decimal(31,0),
	pjwk_rsrc_compr_work_arr long byte,
	pjwk_tot_var_cost float,
	pjwk_tot_fix_cost float,
	pjwk_tot_ovt_cost float,
	pjwk_tot_ovhead_cost float,
	pjwk_tot_act_var_cost float,
	pjwk_tot_act_fix_cost float,
	pjwk_tot_act_ovt_cost float,
	pjwk_tot_act_ovhead_cost float,
	pjwk_tot_base_var_cost float,
	pjwk_tot_base_fix_cost float,
	pjwk_tot_bcwp float,
	pjwk_tot_asgn_hrs decimal(31,0),
	pjwk_tot_ovt_hrs decimal(31,0),
	pjwk_tot_oversch_hrs decimal(31,0),
	pjwk_tot_act_hrs decimal(31,0),
	pjwk_tot_act_ovt_hrs decimal(31,0),
	pjwk_tot_base_hrs decimal(31,0),
	pjwk_tot_mat_hrs decimal(31,0),
	pjwk_tot_act_mat_hrs decimal(31,0),
	pjwk_tot_upd_var_cost float,
	pjwk_tot_upd_fix_cost float,
	pjwk_tot_upd_ovt_cost float,
	pjwk_tot_upd_hrs decimal(31,0),
	pjwk_tot_upd_ovt_hrs decimal(31,0),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify resource_work_summary to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy resource_work_summary () from 'resource_work_summary.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resource_work_summary
\p\g
create table resourcemonitoring(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	mibidx integer not null,
	monitor c1 not null,
	index1 integer,
	index2 integer,
	index3 integer,
	index4 integer,
	index5 integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify resourcemonitoring to heap
with extend = 16,
	allocation = 4
\p\g
/* copy resourcemonitoring () from 'resourcemonitoring.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resourcemonitoring
\p\g
create integrity  ON ResourceMonitoring IS Monitor IN ('Y', 'N')
\p\g
create table resourcename(
	server_addr integer not null,
	probe_addr integer not null,
	rsrcindex integer,
	rsrcotherindex integer,
	rsrctype integer,
	collect_flags integer,
	rsrcname varchar(255),
	rsrcdescr varchar(255),
	ip_addr varchar(32),
	community varchar(32),
	ifspeed float,
	iftype integer,
	agentname varchar(255),
	ifname varchar(255),
	ifindex integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify resourcename to btree on
	rsrctype,
	probe_addr,
	rsrcindex,
	rsrcotherindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy resourcename () from 'resourcename.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on resourcename
\p\g
create table resourcetype(
	rsrctype integer not null,
	rsrcname varchar(64),
	rsrcviewname varchar(64)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify resourcetype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy resourcetype () from 'resourcetype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on resourcetype
\p\g
create table response(
	id integer not null,
	del integer not null,
	persid varchar(30),
	sym varchar(50) not null,
	response varchar(1000),
	response_owner byte varying(16),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	cr_flag integer,
	in_flag integer,
	pr_flag integer,
	chg_flag integer,
	iss_flag integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify response to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy response () from 'response.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on response
\p\g
create table restart(
	nstart integer,
	joid integer,
	status integer,
	run_machine varchar(80),
	pid integer,
	jc_pid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify restart to btree unique on
	nstart,
	joid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy restart () from 'restart.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on restart
\p\g
create table revocationrequest(
	requestid integer not null,
	country varchar(50),
	organisation varchar(50),
	orgunit varchar(50),
	name varchar(50),
	emailaddress varchar(50),
	serialnumber varchar(50),
	reason varchar(50),
	passphrase varchar(50),
	phonenumber varchar(50),
	reqreason varchar(300)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify revocationrequest to btree unique on
	requestid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy revocationrequest () from 'revocationrequest.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on revocationrequest
\p\g
create table rmconfiguration(
	optionname varchar(50) not null,
	optiontype i1 not null,
	optiondataint integer not null,
	optiondatastring varchar(100) not null,
	optiondatadatetime date not null,
	optiondatafloat float not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmconfiguration to hash unique on
	optionname
with fillfactor = 50,
	extend = 4
\p\g
/* copy rmconfiguration () from 'rmconfiguration.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 34, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmconfiguration
\p\g
create table rmoaddress(
	address char(255) not null,
	format char(30) not null default 'email',
	registered char(1) not null default 'N',
	uname char(255),
	inx integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmoaddress to btree unique on
	inx,
	address
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmoaddress () from 'rmoaddress.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmoaddress
\p\g
create table rmobacklog(
	uname char(255),
	address char(255) not null,
	date integer not null,
	accessliteral char(50) not null,
	problemid char(12),
	messageid char(12),
	timesent integer,
	dataout integer,
	datain integer,
	status char(2)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmobacklog to heap
with extend = 16,
	allocation = 4
\p\g
/* copy rmobacklog () from 'rmobacklog.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rmobacklog
\p\g
create table rmon2addressmap(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	protocoldirrmindex integer not null,
	addressmapdatasource integer not null,
	addressmapnetworkaddress varchar(255) not null,
	addressmapphysicaladdress varchar(255) not null,
	addressmaplastchange integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmon2addressmap to btree on
	probe_addr,
	protocoldirrmindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmon2addressmap () from 'rmon2addressmap.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmon2addressmap
\p\g
create table rmon2alhost(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	protocoldirrmindex integer not null,
	protocoldirrmappindex integer not null,
	alhostdatasource integer not null,
	alhostnetworkaddress varchar(255) not null,
	alhostinpkts float,
	alhostoutpkts float,
	alhostinoctets float,
	alhostoutoctets float,
	alhostoutmacnonunicastpkts float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmon2alhost to btree on
	probe_addr,
	protocoldirrmappindex,
	alhostdatasource,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 256
\p\g
/* copy rmon2alhost () from 'rmon2alhost.mdbadmin' */
/* with allocation = 256, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmon2alhost
\p\g
create table rmon2nlmatrix(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	protocoldirrmindex integer not null,
	protocoldirrmappindex integer not null,
	nlmatrixdatasource integer not null,
	almatrixsourceaddress varchar(255) not null,
	almatrixdestaddress varchar(255) not null,
	almatrixsdpkts float,
	almatrixdspkts float,
	almatrixsdoctets float,
	almatrixdsoctets float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmon2nlmatrix to btree on
	probe_addr,
	protocoldirrmappindex,
	nlmatrixdatasource,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1024
\p\g
/* copy rmon2nlmatrix () from 'rmon2nlmatrix.mdbadmin' */
/* with allocation = 64, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmon2nlmatrix
\p\g
create table rmon2protocoldist(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	protocoldirrmindex integer not null,
	protocoldistdatasource integer not null,
	protocoldiststatspkts float,
	protocoldiststatsoctets float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmon2protocoldist to btree on
	probe_addr,
	protocoldirrmindex,
	protocoldistdatasource,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy rmon2protocoldist () from 'rmon2protocoldist.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmon2protocoldist
\p\g
create table rmon2protocoldistcontrol(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	protocoldistcontrolindex integer not null,
	protocoldistcontroldatasource integer not null,
	protocoldistcontrolowner varchar(255) not null,
	protocoldistcontrolstatus i1 not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmon2protocoldistcontrol to btree on
	probe_addr,
	protocoldistcontrolindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmon2protocoldistcontrol () from 'rmon2protocoldistcontrol.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmon2protocoldistcontrol
\p\g
create table rmon2protocolid(
	intervaldatetime date not null,
	protocoldirid varchar(255) not null,
	protocoldirparameters varchar(255) not null,
	protocoldirrmindex integer not null,
	protocoldirdescr varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmon2protocolid to btree unique on
	protocoldirrmindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmon2protocolid () from 'rmon2protocolid.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmon2protocolid
\p\g
create table rmon2protocolproperties(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	protocoldirrmindex integer not null,
	protocoldirdescr varchar(255) not null,
	protocoldirtype smallint,
	protocoldiraddressmapconfig smallint,
	protocoldirhostconfig smallint,
	protocoldirmatrixconfig smallint,
	protocoldirowner varchar(255) not null,
	protocoldirstatus smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmon2protocolproperties to btree on
	probe_addr,
	protocoldirrmindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy rmon2protocolproperties () from 'rmon2protocolproperties.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmon2protocolproperties
\p\g
create table rmonetherstatsid(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	etherstatsindex integer,
	etherstatsdatasource integer,
	etherstatsowner varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmonetherstatsid to btree on
	probe_addr,
	etherstatsindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmonetherstatsid () from 'rmonetherstatsid.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmonetherstatsid
\p\g
create table rmonetherstatsstats(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	etherstatsindex integer,
	etherstatsdropevents float,
	etherstatsoctets float,
	etherstatspkts float,
	etherstatsbroadcastpkts float,
	etherstatsmulticastpkts float,
	etherstatscrcalignerrors float,
	etherstatsundersizepkts float,
	etherstatsoversizepkts float,
	etherstatsfragments float,
	etherstatsjabbers float,
	etherstatscollisions float,
	etherstatspkts64octets float,
	etherstatspkts65to127octets float,
	etherstatspkts128to255octets float,
	etherstatspkts256to511octets float,
	etherstatspkts512to1023octets float,
	etherstatspkts1024to1518octets float,
	etherstatsstatus i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmonetherstatsstats to btree on
	probe_addr,
	etherstatsindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 64
\p\g
/* copy rmonetherstatsstats () from 'rmonetherstatsstats.mdbadmin' */
/* with allocation = 512, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmonetherstatsstats
\p\g
create table rmonhostcontrol(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	hostcontrolindex integer,
	hostcontroldatasource integer,
	hostcontrolstatus i1,
	hosttopngrantedsize0 i1,
	hosttopngrantedsize1 i1,
	hosttopngrantedsize2 i1,
	hosttopngrantedsize3 i1,
	hosttopngrantedsize4 i1,
	hosttopngrantedsize5 i1,
	hosttopngrantedsize6 i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmonhostcontrol to btree on
	probe_addr,
	hostcontrolindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmonhostcontrol () from 'rmonhostcontrol.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmonhostcontrol
\p\g
create table rmonhosttopnstat(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	hostcontrolindex integer,
	hosttopnratebase i1,
	hosttopnaddress varchar(12),
	hosttopnrate float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmonhosttopnstat to btree on
	probe_addr,
	hostcontrolindex,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmonhosttopnstat () from 'rmonhosttopnstat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmonhosttopnstat
\p\g
create table rmonrptquerydata(
	spid float not null,
	rpid smallint not null,
	intervaltype i1 not null,
	server_addr integer not null,
	probe_addr integer not null,
	ifindex integer not null,
	intervaldatetime date not null,
	value1 float,
	value2 float,
	value3 float,
	value4 float,
	value5 float,
	value6 float,
	value7 float,
	value8 float,
	value9 float,
	value10 float,
	string1 varchar(128),
	string2 varchar(64),
	string3 varchar(64),
	string4 varchar(64),
	string5 varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmonrptquerydata to btree on
	spid,
	rpid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmonrptquerydata () from 'rmonrptquerydata.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rmonrptquerydata
\p\g
create table rmonrptquerytempdata(
	spid float not null,
	rpid smallint not null,
	intervaltype i1 not null,
	server_addr integer not null,
	probe_addr integer not null,
	ifindex integer not null,
	intervaldatetime date not null,
	value1 float,
	value2 float,
	value3 float,
	value4 float,
	value5 float,
	value6 float,
	value7 float,
	value8 float,
	value9 float,
	value10 float,
	string1 varchar(64),
	string2 varchar(64),
	string3 varchar(64),
	string4 varchar(64),
	string5 varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rmonrptquerytempdata to btree on
	spid,
	rpid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rmonrptquerytempdata () from 'rmonrptquerytempdata.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
create table role(
	role_id decimal(31,0) not null,
	opruid decimal(31,0),
	name varchar(1200) not null,
	description varchar(4000),
	role_billing_rate float,
	role_ovt_rate float,
	default_weekly_availability integer,
	logical_delete_flag smallint,
	ref_name varchar(1200),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify role to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy role () from 'role.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on role
\p\g
create table role_keyword(
	keyword_id decimal(31,0) not null,
	role_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify role_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy role_keyword () from 'role_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on role_keyword
\p\g
create table role_priv(
	role_priv_id decimal(5,0) not null,
	collect_id decimal(5,0),
	role_name varchar(30) not null,
	grantee varchar(30) not null,
	admin_option decimal(5,0),
	default_role decimal(5,0),
	password_required decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify role_priv to btree unique on
	role_priv_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy role_priv () from 'role_priv.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on role_priv
\p\g
create table rolluptimestamp(
	tablename varchar(32) not null,
	interval2hourly date,
	hourly2daily date,
	intervaldays integer,
	hourlydays integer,
	dailydays integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rolluptimestamp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy rolluptimestamp () from 'rolluptimestamp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rolluptimestamp
\p\g
create table rolluptypes(
	tablename varchar(32) not null,
	colidx integer not null,
	colname varchar(64) not null,
	rolluptype varchar(4)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rolluptypes to heap
with extend = 16,
	allocation = 4
\p\g
/* copy rolluptypes () from 'rolluptypes.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rolluptypes
\p\g
create table root_cause(
	root_cause_id byte(16) not null,
	name nvarchar(50) not null,
	creation_user nvarchar(64),
	creation_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify root_cause to btree unique on
	root_cause_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy root_cause () from 'root_cause.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on root_cause
\p\g
create table rootcause(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rootcause to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy rootcause () from 'rootcause.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rootcause
\p\g
create table routecfg(
	qmgrid integer not null,
	routeid integer not null,
	routename varchar(40) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify routecfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy routecfg () from 'routecfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on routecfg
\p\g
create table routedata(
	tstamp date not null,
	qmgrid integer not null,
	routeid integer not null,
	intvltype char(1) not null,
	intvlduration integer not null,
	responsetime integer not null,
	msgcount integer not null,
	msgsize integer not null,
	issent smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify routedata to heap
with extend = 16,
	allocation = 4
\p\g
/* copy routedata () from 'routedata.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on routedata
\p\g
create table routenodecfg(
	qmgrid integer not null,
	routeid integer not null,
	nodeqmgrid integer not null,
	nodeorder integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify routenodecfg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy routenodecfg () from 'routenodecfg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on routenodecfg
\p\g
create table routenodedata(
	tstamp date not null,
	qmgrid integer not null,
	routeid integer not null,
	nodeqmgrid integer not null,
	intvltype char(1) not null,
	intvlduration integer not null,
	outboundtime integer not null,
	inboundtime integer not null,
	totaltime integer not null,
	issent smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify routenodedata to heap
with extend = 16,
	allocation = 4
\p\g
/* copy routenodedata () from 'routenodedata.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on routenodedata
\p\g
create table rpauto(
	objid integer not null,
	objname varchar(64),
	descript text(1),
	tplobjid integer,
	schobjid integer,
	pubobjid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpauto to btree unique on
	objid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpauto () from 'rpauto.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpauto
\p\g
create table rpceng(
	domainid integer not null,
	rpcengid integer not null,
	name varchar(127),
	service varchar(127),
	rpcconf integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpceng to btree unique on
	rpcengid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpceng () from 'rpceng.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpceng
\p\g
create table rpfield(
	objid integer not null,
	fieldid integer,
	fldindex integer not null,
	status integer,
	tpltype integer,
	fldtype integer,
	fielddef text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpfield to btree unique on
	objid,
	fldindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpfield () from 'rpfield.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpfield
\p\g
create table rpfilter(
	tplid integer not null,
	resid integer not null,
	argid integer not null,
	name varchar(127),
	type integer,
	argspec text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpfilter to btree unique on
	tplid,
	resid,
	argid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpfilter () from 'rpfilter.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpfilter
\p\g
create table rpglobal(
	keyname varchar(64) not null,
	subname varchar(64) not null,
	value text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpglobal to btree unique on
	keyname,
	subname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpglobal () from 'rpglobal.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpglobal
\p\g
create table rpipc(
	ipcid integer not null,
	sid integer,
	objid integer,
	notify integer,
	lparam1 integer,
	lparam2 integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpipc to btree unique on
	ipcid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpipc () from 'rpipc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpipc
\p\g
create table rppub(
	objid integer not null,
	genset text(1),
	expset text(1),
	saveset text(1),
	expspec text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rppub to btree unique on
	objid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rppub () from 'rppub.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rppub
\p\g
create table rpqq(
	qqid integer not null,
	idx integer,
	title varchar(255),
	sqltxt varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpqq to btree unique on
	qqid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpqq () from 'rpqq.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpqq
\p\g
create table rpresult(
	tplid integer not null,
	tplsubid integer not null,
	resid integer not null,
	tblname varchar(64),
	dispname varchar(64),
	filter integer,
	status integer,
	resspec text(1),
	created integer,
	createby varchar(64)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpresult to btree unique on
	tplid,
	tplsubid,
	resid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpresult () from 'rpresult.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpresult
\p\g
create table rpstats(
	tplid integer not null,
	runcount integer,
	runtoday integer,
	lastrun integer,
	lasttime integer,
	lastuser varchar(64),
	avtime integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpstats to btree unique on
	tplid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpstats () from 'rpstats.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpstats
\p\g
create table rpt_list(
	rpt_id smallint not null,
	rpt_name varchar(255),
	rpt_access smallint not null,
	rpt_data_source smallint not null,
	rpt_template varchar(32) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rpt_list to heap
with extend = 16,
	allocation = 4
\p\g
/* copy rpt_list () from 'rpt_list.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table rpt_tags(
	rpt_id integer not null,
	tag_id integer not null,
	seq_id integer not null,
	query_type integer not null,
	query_stmt text(1) not null,
	temp1 integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rpt_tags to heap
with extend = 16,
	allocation = 4
\p\g
/* copy rpt_tags () from 'rpt_tags.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table rptables(
	tblname varchar(64) not null,
	type integer,
	tplid integer,
	subid integer,
	created integer,
	createby varchar(64),
	status integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rptables to btree unique on
	tblname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rptables () from 'rptables.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rptables
\p\g
create table rptmth(
	id integer not null,
	del integer not null,
	sym varchar(30) not null,
	description varchar(80),
	default_out varchar(80),
	def_pg_len varchar(80),
	script varchar(1000),
	is_default integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rptmth to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy rptmth () from 'rptmth.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rptmth
\p\g
create table rptpl(
	objid integer not null,
	objname varchar(64),
	descript text(1),
	status integer,
	tpltype integer,
	tplspec text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rptpl to btree unique on
	objid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rptpl () from 'rptpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rptpl
\p\g
create table rptree(
	root integer not null,
	ownerid integer not null,
	objid integer not null,
	objname varchar(64),
	descript text(1),
	status integer,
	created integer,
	createby varchar(64),
	modified integer,
	modifiby varchar(64),
	type integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rptree to btree unique on
	root,
	ownerid,
	objid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rptree () from 'rptree.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rptree
\p\g
create table rpview(
	tplid integer not null,
	viewid integer not null,
	field1 varchar(127),
	field2 varchar(127),
	field3 varchar(127),
	field4 varchar(127),
	settings text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify rpview to btree unique on
	tplid,
	viewid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy rpview () from 'rpview.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rpview
\p\g
create table rsrc_asgn_sched_prop_value(
	scheduler_property_id decimal(31,0) not null,
	asgn_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	value float,
	derivation_source decimal(31,0),
	project_manager_assumptions varchar(4000),
	value_last_update date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify rsrc_asgn_sched_prop_value to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy rsrc_asgn_sched_prop_value () from 'rsrc_asgn_sched_prop_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rsrc_asgn_sched_prop_value
\p\g
create table rsrc_enh_owner(
	enhanced_rsrc_id decimal(31,0) not null,
	parent_rsrc_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200) not null,
	comments varchar(4000) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rsrc_enh_owner to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy rsrc_enh_owner () from 'rsrc_enh_owner.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rsrc_enh_owner
\p\g
create table rsrc_inst_sec(
	object_id decimal(31,0) not null,
	password varchar(120) not null,
	object_owner decimal(31,0) not null,
	object_type varchar(4000),
	object_name varchar(1200),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify rsrc_inst_sec to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy rsrc_inst_sec () from 'rsrc_inst_sec.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rsrc_inst_sec
\p\g
create table rsrc_mvs_access(
	metric_value_set_id decimal(31,0) not null,
	rsrc_id decimal(31,0) not null,
	value_access integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rsrc_mvs_access to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy rsrc_mvs_access () from 'rsrc_mvs_access.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rsrc_mvs_access
\p\g
create table rsrc_non_proj_evt_summary(
	non_project_event_id decimal(31,0) not null,
	rsrc_id decimal(31,0) not null,
	ptd_hrs decimal(31,0),
	mtd_hrs decimal(31,0),
	ytd_hrs decimal(31,0),
	ltd_hrs decimal(31,0),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rsrc_non_proj_evt_summary to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy rsrc_non_proj_evt_summary () from 'rsrc_non_proj_evt_summary.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rsrc_non_proj_evt_summary
\p\g
create table rsrc_non_proj_evt_time_hist(
	rsrc_id decimal(31,0) not null,
	time_period_id decimal(31,0) not null,
	time_type_id decimal(31,0) not null,
	non_project_event_id decimal(31,0) not null,
	frequency_id decimal(31,0),
	time_type_name varchar(1200),
	rsrc_name varchar(1200),
	rsrc_manager_code varchar(4000),
	rsrc_manager_name varchar(1200),
	tot_sched_hrs decimal(31,0),
	sched_start_date date,
	sched_finish_date date,
	description varchar(4000),
	percentage float,
	frequency integer,
	frequency_description varchar(4000),
	asgn_notes varchar(4000),
	required_time_capture_flag smallint,
	billable_flag smallint,
	non_proj_billing_rate float,
	non_proj_ovt_percent float,
	non_proj_cost_rate float,
	last_week_hrs decimal(31,0),
	last_period_hrs decimal(31,0),
	posted_hrs decimal(31,0),
	approval_flag smallint,
	submit_flag smallint,
	post_rejected_flag smallint,
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify rsrc_non_proj_evt_time_hist to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy rsrc_non_proj_evt_time_hist () from 'rsrc_non_proj_evt_time_hist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rsrc_non_proj_evt_time_hist
\p\g
create table rsrc_security_grp_assoc(
	security_group_id decimal(31,0) not null,
	rsrc_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify rsrc_security_grp_assoc to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy rsrc_security_grp_assoc () from 'rsrc_security_grp_assoc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on rsrc_security_grp_assoc
\p\g
create table rttctrladmin_cfg(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	ctrladminindex integer,
	ctrladminowner varchar(32),
	ctrladmintag varchar(32),
	ctrladminrtttype integer,
	ctrladminthreshold integer,
	ctrladminfrequency integer,
	ctrladmintimeout integer,
	ctrladminstatus integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rttctrladmin_cfg to btree on
	probe_addr,
	ctrladminindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rttctrladmin_cfg () from 'rttctrladmin_cfg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rttctrladmin_cfg
\p\g
create table rttechoadmin_cfg(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	echoadminprotocol integer,
	ctrladminindex integer,
	echoadmintargetaddress varchar(32),
	echoadminpktdatarequestsize integer,
	echoadminpktdataresponsesize integer,
	echoadmintargetport integer,
	echoadminsourceaddress varchar(32),
	echoadminsourceport integer,
	echoadmincontrolenable integer,
	echoadmintos integer,
	echoadminlsrenable integer,
	echoadmintargetaddressstring varchar(32),
	echoadminnameserver varchar(32),
	echoadminoperation integer,
	echoadminhttpversion varchar(32),
	echoadminurl varchar(32),
	echoadmincache integer,
	echoadmininterval integer,
	echoadminnumpackets integer,
	echoadminproxy varchar(32),
	echoadminmode integer,
	echoadminvrfname varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rttechoadmin_cfg to btree on
	probe_addr,
	echoadminprotocol,
	ctrladminindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rttechoadmin_cfg () from 'rttechoadmin_cfg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rttechoadmin_cfg
\p\g
create table rttjitter_stat(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	jitterstatsstarttimeindex integer,
	ctrladminindex integer,
	jitterstatscompletions float,
	jitterstatsoverthresholds float,
	jitterstatsnumofrtt float,
	jitterstatsrttsum float,
	jitterstatsrttmin float,
	jitterstatsrttmax float,
	jitterstatsminofpositivessd float,
	jitterstatsmaxofpositivessd float,
	jitterstatsnumofpositivessd float,
	jitterstatssumofpositivessd float,
	jitterstatsminofnegativessd float,
	jitterstatsmaxofnegativessd float,
	jitterstatsnumofnegativessd float,
	jitterstatssumofnegativessd float,
	jitterstatsminofpositivesds float,
	jitterstatsmaxofpositivesds float,
	jitterstatsnumofpositivesds float,
	jitterstatssumofpositivesds float,
	jitterstatsminofnegativesds float,
	jitterstatsmaxofnegativesds float,
	jitterstatsnumofnegativesds float,
	jitterstatssumofnegativesds float,
	jitterstatspacketlosssd float,
	jitterstatspacketlossds float,
	jitterstatspacketoutofsequence float,
	jitterstatspacketmia float,
	jitterstatspacketlatearrival float,
	jitterstatserror float,
	jitterstatsbusies float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rttjitter_stat to btree on
	probe_addr,
	ctrladminindex,
	jitterstatsstarttimeindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rttjitter_stat () from 'rttjitter_stat.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rttjitter_stat
\p\g
create table rttstatscapture_stat(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	statscapturestarttimeindex integer,
	ctrladminindex integer,
	statscapturedistindex integer,
	statscapturehopindex integer,
	statscapturepathindex integer,
	statscapturecompletions float,
	statscaptureoverthresholds float,
	statscapturesumcompletiontime float,
	statscapturecompletiontimemax float,
	statscapturecompletiontimemin float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rttstatscapture_stat to btree on
	probe_addr,
	ctrladminindex,
	statscapturestarttimeindex,
	statscapturepathindex,
	statscapturehopindex,
	statscapturedistindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rttstatscapture_stat () from 'rttstatscapture_stat.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rttstatscapture_stat
\p\g
create table rttstatscoll_stat(
	server_addr integer not null,
	probe_addr integer not null,
	intervaldatetime date not null,
	intervalduration integer not null,
	statscollectnumdisconnects float,
	ctrladminindex integer,
	statscapturehopindex integer,
	statscapturepathindex integer,
	statscapturestarttimeindex integer,
	statscollecttimeouts float,
	statscollectbusies float,
	statscollectnoconnections float,
	statscollectdrops float,
	statscollectsequenceerrors float,
	statscollectverifyerrors float,
	statscollectaddress varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify rttstatscoll_stat to btree on
	probe_addr,
	ctrladminindex,
	statscapturestarttimeindex,
	statscapturepathindex,
	statscapturehopindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy rttstatscoll_stat () from 'rttstatscoll_stat.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on rttstatscoll_stat
\p\g
create table sapolicy(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(40) not null,
	code varchar(20) not null,
	pub_key varchar(2000),
	allow_impersonate integer not null,
	state integer,
	proxy_contact byte varying(16),
	is_default integer,
	description varchar(300),
	access_ticket_ins integer,
	access_object_ins integer,
	access_object_upd integer,
	access_atmnt integer,
	access_data integer,
	access_knowledge integer,
	ext_appl integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify sapolicy to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy sapolicy () from 'sapolicy.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sapolicy
\p\g
create table saprobtyp(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(40) not null,
	code varchar(20) not null,
	description varchar(300),
	owning_policy integer,
	ticket_tmpl_fac varchar(20),
	ticket_tmpl_id integer,
	ticket_tmpl_name varchar(40),
	is_default integer,
	ret_usr_1 varchar(500),
	ret_app_1 varchar(500),
	dup_action integer,
	dup_interval integer,
	is_internal integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify saprobtyp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy saprobtyp () from 'saprobtyp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on saprobtyp
\p\g
create table saved_57(
	date_and_time decimal(20,5),
	label_field char(50),
	calls_opened char(50),
	group_field char(50),
	pattern_date char(50),
	calls_resolved char(50),
	calls_esc char(50),
	calls_trans char(50),
	calls_reopened char(50),
	calls_closefirst char(50),
	avg_close_time char(50),
	calls_closed char(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify saved_57 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy saved_57 () from 'saved_57.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on saved_57
\p\g
create table saved_62(
	date_and_time decimal(20,5),
	id char(50),
	open_date char(50),
	start_date char(50),
	close_date char(50),
	priority char(50),
	assignee char(50),
	start_time char(50),
	sla_time char(50),
	fire_time char(50),
	impact char(50),
	group_id char(50),
	category char(50),
	workshift char(50),
	customer char(50),
	status_changes char(50),
	transfers char(50),
	assignee_name char(50),
	group_name char(50),
	sla_violation char(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify saved_62 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy saved_62 () from 'saved_62.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on saved_62
\p\g
create table sched_prop_value_detail(
	detail_id decimal(31,0) not null,
	asgn_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	detail_date date,
	detail_value decimal(31,0),
	detail_exported_flag integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify sched_prop_value_detail to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy sched_prop_value_detail () from 'sched_prop_value_detail.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on sched_prop_value_detail
\p\g
create table scheduler(
	scheduler_id decimal(31,0) not null,
	reference_id varchar(120),
	alt_ref_id varchar(120),
	opruid decimal(31,0),
	scheduler_name varchar(1200) not null,
	scheduler_library_name varchar(1200),
	scheduler_constraint_types varchar(4000),
	logical_delete_flag smallint,
	ref_name varchar(4000),
	alt_ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify scheduler to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy scheduler () from 'scheduler.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on scheduler
\p\g
create table scheduler_property(
	scheduler_property_id decimal(31,0) not null,
	scheduler_id decimal(31,0),
	datatype integer,
	name varchar(1200) not null,
	helpid decimal(31,0),
	mapping decimal(31,0),
	conversionfactor integer,
	projectimport_id varchar(320),
	projectexport_id varchar(320),
	activityimport_id varchar(320),
	activityexport_id varchar(320),
	rsrc_import_id varchar(320),
	rsrc_export_id varchar(320),
	rsrc_asgn_import_id decimal(31,0),
	rsrc_asgn_export_id decimal(31,0),
	activity_mpx_field_id decimal(31,0),
	project_mpx_field_id decimal(31,0),
	rsrc_mpx_field_id decimal(31,0),
	work_value_field_id decimal(31,0),
	validation_rule varchar(320),
	ref_name varchar(4000),
	is_scheduler_effort smallint,
	constraint_type_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify scheduler_property to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy scheduler_property () from 'scheduler_property.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on scheduler_property
\p\g
create table scheduler_table_entry(
	entry_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	opr_entry_id integer not null,
	data_type decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify scheduler_table_entry to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy scheduler_table_entry () from 'scheduler_table_entry.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on scheduler_table_entry
\p\g
create table scheduler_table_value(
	entry_id decimal(31,0) not null,
	scheduler_property_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	value float,
	description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify scheduler_table_value to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy scheduler_table_value () from 'scheduler_table_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on scheduler_table_value
\p\g
create table scope_det(
	scope_det_id decimal(5,0) not null,
	scope_head_id decimal(5,0),
	object_type decimal(1,0),
	object_name varchar(61),
	incl_excl decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify scope_det to btree unique on
	scope_det_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy scope_det () from 'scope_det.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on scope_det
\p\g
create table scope_head(
	scope_head_id decimal(5,0) not null,
	scope_name varchar(30),
	scope_version decimal(5,0),
	created_by varchar(30),
	created_date date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify scope_head to btree unique on
	scope_head_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy scope_head () from 'scope_head.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on scope_head
\p\g
create table scriptmessagelog(
	requestid integer not null,
	executionid integer not null,
	messageorder integer not null,
	messagetime date not null,
	messagetext varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify scriptmessagelog to heap
with extend = 16,
	allocation = 4
\p\g
/* copy scriptmessagelog () from 'scriptmessagelog.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on scriptmessagelog
\p\g
create table sdsc_map(
	id integer not null,
	persid varchar(30),
	map_contract integer not null,
	map_sdsc varchar(30),
	map_objid integer not null,
	map_objtype varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify sdsc_map to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy sdsc_map () from 'sdsc_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sdsc_map
\p\g
create table search(
	aid smallint not null not default,
	normkey varchar(8) not null not default,
	eid integer not null not default,
	vid smallint not null not default,
	norm varchar(106) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify search to btree unique on
	aid,
	normkey,
	eid,
	vid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy search () from 'search.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on search
\p\g
create table secure_event(
	id integer,
	timestamp date,
	personaliasid integer,
	categoryid integer,
	machinealiasid integer,
	srceventid integer,
	source varchar(32),
	createdby integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify secure_event to heap
with extend = 16,
	allocation = 4
\p\g
/* copy secure_event () from 'secure_event.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on secure_event
\p\g
create table secure_job(
	name varchar(32) not null,
	start_time date,
	run_frequency date,
	repeats integer,
	delay date,
	state i1,
	jobrun_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify secure_job to heap
with extend = 16,
	allocation = 4
\p\g
/* copy secure_job () from 'secure_job.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on secure_job
\p\g
create table secure_machine(
	id integer,
	screenname varchar(32),
	description varchar(32),
	buildingid integer,
	coord_x float,
	coord_y float,
	coord_z float,
	floor varchar(32),
	class varchar(32),
	rating integer,
	ratingtime date,
	starttime date,
	endtime date,
	createdby integer,
	lastupdated date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify secure_machine to heap
with extend = 16,
	allocation = 4
\p\g
/* copy secure_machine () from 'secure_machine.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on secure_machine
\p\g
create table secure_person(
	id integer,
	fullname varchar(32),
	rating integer,
	ratingtime date,
	starttime date,
	endtime date,
	createdby integer,
	lastupdated date,
	badgeresid integer,
	firstname varchar(32),
	lastname varchar(32),
	department varchar(32),
	address varchar(64),
	phone char(16),
	email char(32),
	title varchar(32),
	officeno varchar(32),
	dateofhire varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify secure_person to heap
with extend = 16,
	allocation = 4
\p\g
/* copy secure_person () from 'secure_person.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on secure_person
\p\g
create table security_cal_time_block(
	time_block_id byte(16) not null,
	calendar_id byte(16) not null,
	name varchar(50),
	effective_start_time integer,
	is_included i1,
	duration integer,
	effective_weekday_mask byte(4),
	effective_monthday_mask byte(8),
	effective_month_mask byte(8),
	description long varchar,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify security_cal_time_block to heap
with extend = 16,
	allocation = 4
\p\g
/* copy security_cal_time_block () from 'security_cal_time_block.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_cal_time_block
\p\g
create table security_calendar(
	calendar_id byte(16) not null,
	calendar_name varchar(50),
	effective_start_date_time integer,
	effective_stop_date_time integer,
	location_name varchar(255),
	generation integer,
	description long varchar,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify security_calendar to heap
with extend = 16,
	allocation = 4
\p\g
/* copy security_calendar () from 'security_calendar.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_calendar
\p\g
create table security_group(
	security_group_id decimal(31,0) not null,
	group_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify security_group to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy security_group () from 'security_group.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_group
\p\g
create table security_object_assoc(
	security_object_id decimal(31,0) not null,
	security_right_id decimal(31,0) not null,
	security_right_value integer,
	security_right_priority integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify security_object_assoc to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy security_object_assoc () from 'security_object_assoc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_object_assoc
\p\g
create table security_person(
	person_id byte(16) not null,
	is_inactive i1,
	job_title varchar(50),
	mailstop varchar(30),
	last_name varchar(50) not null,
	first_name varchar(50),
	middle_name varchar(50),
	alias varchar(50),
	department varchar(50),
	display_name varchar(50),
	work_phone_number varchar(32) not null,
	home_phone_number varchar(32),
	mobile_phone_number varchar(32),
	alt_phone_number varchar(32),
	email_address varchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify security_person to heap
with extend = 16,
	allocation = 4
\p\g
/* copy security_person () from 'security_person.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_person
\p\g
create table security_policy(
	policy_uuid byte(16) not null,
	policy_name varchar(50),
	text_policy long varchar,
	product_instance_name varchar(50),
	calendar_name varchar(50),
	location_name varchar(255),
	description long varchar,
	generation integer,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify security_policy to heap
with extend = 16,
	allocation = 4
\p\g
/* copy security_policy () from 'security_policy.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_policy
\p\g
create table security_policy_action_asc(
	policy_action_uuid byte(16) not null,
	access_policy_uuid byte(16) not null,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify security_policy_action_asc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy security_policy_action_asc () from 'security_policy_action_asc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_policy_action_asc
\p\g
create table security_policy_action_type(
	policy_action_uuid byte(16) not null,
	name varchar(50),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer,
	resource_class_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify security_policy_action_type to heap
with extend = 16,
	allocation = 4
\p\g
/* copy security_policy_action_type () from 'security_policy_action_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_policy_action_type
\p\g
create table security_right(
	security_right_id decimal(31,0) not null,
	security_right_description varchar(4000),
	security_right_value smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify security_right to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy security_right () from 'security_right.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_right
\p\g
create table security_user_group(
	security_group_id byte(16) not null,
	group_name varchar(255),
	membership_policy_text long varchar not null,
	product_instance_name varchar(50),
	description long varchar,
	location_name varchar(255),
	generation integer,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify security_user_group to heap
with extend = 16,
	allocation = 4
\p\g
/* copy security_user_group () from 'security_user_group.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on security_user_group
\p\g
create table securitypredicate(
	definitionid varchar(20) default '',
	securitypredicateinfo long byte not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify securitypredicate to heap
with extend = 16,
	allocation = 4
\p\g
/* copy securitypredicate () from 'securitypredicate.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on securitypredicate
\p\g
create table segment_dict(
	object_id decimal(5,0) not null,
	collect_id decimal(5,0) not null,
	owner_id decimal(5,0),
	owner varchar(30),
	segment_name varchar(30),
	type# decimal(5,0),
	create_date date,
	last_analyzed date,
	iot_name varchar(30),
	iot_type decimal(5,0),
	pct_free decimal(5,0),
	pct_used decimal(5,0),
	cache decimal(5,0),
	table_lock decimal(5,0),
	nested decimal(5,0),
	tablespace_id decimal(5,0),
	ini_trans decimal(5,0),
	max_trans decimal(5,0),
	initial_extent decimal(5,0),
	next_extent decimal(5,0),
	min_extents decimal(5,0),
	max_extents decimal(5,0),
	pct_increase decimal(5,0),
	smallest_ext decimal(5,0),
	largest_ext decimal(5,0),
	freelists decimal(5,0),
	freelist_groups decimal(5,0),
	nbr_extents decimal(5,0),
	logging decimal(5,0),
	backed_up decimal(5,0),
	degree decimal(5,0),
	instances decimal(5,0),
	"temporary" decimal(5,0),
	partitioned decimal(5,0),
	buffer_pool decimal(5,0),
	current_bytes decimal(5,0),
	table_id decimal(5,0),
	index_type decimal(5,0),
	uniqueness decimal(5,0),
	pct_threshold decimal(5,0),
	include_column decimal(5,0),
	blevel decimal(5,0),
	leaf_blocks decimal(5,0),
	distinct_keys decimal(5,0),
	avg_leaf_blocks_per_key decimal(5,0),
	avg_data_blocks_per_key decimal(5,0),
	clustering_factor decimal(5,0),
	status decimal(5,0),
	sample_size decimal(5,0),
	generated decimal(5,0),
	key_size decimal(5,0),
	avg_blocks_per_key decimal(5,0),
	cluster_type decimal(5,0),
	cluster_function decimal(5,0),
	hash_keys decimal(5,0),
	row_cnt decimal(5,0),
	ora_chained decimal(5,0),
	ora_avg_free_space decimal(5,0),
	avg_space_freelist_blocks decimal(5,0),
	avg_row_len decimal(5,0),
	min_row_len decimal(5,0),
	max_row_len decimal(5,0),
	normal_row_cnt decimal(5,0),
	migrate_row_cnt decimal(5,0),
	chain_row_cnt decimal(5,0),
	migrate_and_chain_row_cnt decimal(5,0),
	delete_row_cnt decimal(5,0),
	used_block_cnt decimal(5,0),
	empty_block_cnt decimal(5,0),
	free_block_cnt decimal(5,0),
	free_list_length decimal(5,0),
	emb_cnt decimal(5,0),
	avg_block_header_bytes decimal(5,0),
	avg_block_data_bytes decimal(5,0),
	avg_unused_free_space decimal(5,0),
	avg_released_free_space decimal(5,0),
	avg_normal_row_bytes decimal(5,0),
	avg_migrated_row_bytes decimal(5,0),
	avg_chained_row_bytes decimal(5,0),
	avg_mig_and_chained_row_bytes decimal(5,0),
	min_scn decimal(5,0),
	max_scn decimal(5,0),
	avg_row_dir_entries decimal(5,0),
	empty_row_dir_entries decimal(5,0),
	total_row_dir_entries decimal(5,0),
	min_chain_blockspan_offset decimal(5,0),
	avg_chain_blockspan_offset decimal(5,0),
	max_chain_blockspan_offset decimal(5,0),
	min_migrated_blockspan_offset decimal(5,0),
	avg_migrated_blockspan_offset decimal(5,0),
	max_migrated_blockspan_offset decimal(5,0),
	chained_rows_that_span_files decimal(5,0),
	migrated_rows_that_span_files decimal(5,0),
	used_block_fill_percentage decimal(5,0),
	home_row_reads decimal(5,0),
	migrated_row_reads decimal(5,0),
	chained_row_reads decimal(5,0),
	block_fill_more_pctfree decimal(5,0),
	block_fill_less_pctused decimal(5,0),
	freelist_block_cnt decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify segment_dict to btree unique on
	collect_id,
	object_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy segment_dict () from 'segment_dict.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on segment_dict
\p\g
create table send_buffer(
	eoid varchar(12),
	serverdb varchar(40),
	stamp date,
	send_status integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify send_buffer to btree unique on
	eoid,
	serverdb
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy send_buffer () from 'send_buffer.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on send_buffer
\p\g
create table seosdata(
	entryid integer,
	domainname nvarchar(255),
	username nvarchar(214),
	eventtype integer,
	logname nvarchar(255),
	timstamp date,
	source nvarchar(255),
	computername nvarchar(214),
	eventid integer,
	eventcategory nvarchar(255),
	searchstrings nvarchar(255),
	msgtext long nvarchar
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify seosdata to btree on
	entryid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 1000,
	page_size = 4096
\p\g
/* copy seosdata () from 'seosdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on seosdata
\p\g
create table seqctl(
	id integer not null,
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	code varchar(12) not null,
	prefix varchar(5),
	suffix varchar(5),
	description varchar(240),
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify seqctl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy seqctl () from 'seqctl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on seqctl
\p\g
create table sequence_values(
	name varchar(32) not null not default,
	sequence_value integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sequence_values to btree unique on
	sequence_value,
	name
with nonleaffill = 70,
	leaffill = 80,
	fillfactor = 80,
	extend = 16
\p\g
/* copy sequence_values () from 'sequence_values.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sequence_values
\p\g
create table server_collector(
	collectorid integer not null,
	collectorname char(15) not null,
	parentcollectorid integer,
	hostname char(64) not null,
	servername varchar(255) not null,
	dbname varchar(255) not null,
	username varchar(255),
	userpsw varchar(255),
	logfilelocation varchar(255),
	needrefresh smallint,
	collectortype smallint not null,
	rawdatakeepinterval integer,
	rawdatatimefactor smallint,
	hourlydatakeepinterval integer,
	hourlytimefactor smallint,
	dailydatakeepinterval integer,
	dailytimefactor smallint,
	weeklydatakeepinterval integer,
	weeklytimefactor smallint,
	monthlydatakeepinterval integer,
	monthlytimefactor smallint,
	yearlydatakeepinterval integer,
	yearlytimefactor smallint,
	inactive i1,
	topnservers integer,
	topnpersons integer,
	topnobjects integer,
	alertlimit integer,
	idfile1 varchar(8),
	idfile2 varchar(8),
	oneidfile i1,
	idfilepwd varchar(8)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify server_collector to btree unique on
	collectorid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy server_collector () from 'server_collector.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on server_collector
\p\g
create integrity  ON Server_Collector IS CollectorID >= 1
\p\g
create integrity  ON Server_Collector IS ParentCollectorID >= 1
\p\g
create integrity  ON Server_Collector IS NeedRefresh IN (0, 1, 2, 3)
\p\g
create integrity  ON Server_Collector IS CollectorType IN (1, 2)
\p\g
create integrity  ON Server_Collector IS RawDataTimeFactor IN (1, 2, 
3, 4, 5)
\p\g
create integrity  ON Server_Collector IS HourlyTimeFactor IN (1, 2, 3,
4, 5)
\p\g
create integrity  ON Server_Collector IS DailyTimeFactor IN (1, 2, 3, 
4, 5)
\p\g
create integrity  ON Server_Collector IS WeeklyTimeFactor IN (1, 2, 3,
4, 5)
\p\g
create integrity  ON Server_Collector IS MonthlyTimeFactor IN (1, 2, 
3, 4, 5)
\p\g
create integrity  ON Server_Collector IS YearlyTimeFactor IN (1, 2, 3,
4, 5)
\p\g
create integrity  ON Server_Collector IS TopNServers >= 1
\p\g
create integrity  ON Server_Collector IS TopNPersons >= 1
\p\g
create integrity  ON Server_Collector IS AlertLimit >= 1
\p\g
create table server_collectoraction(
	actionid integer not null,
	actionname char(254) not null,
	actiontype smallint not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify server_collectoraction to btree unique on
	actionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy server_collectoraction () from 'server_collectoraction.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on server_collectoraction
\p\g
create integrity  ON Server_CollectorAction IS ActionID IN (1, 2, 3, 
4)
\p\g
create integrity  ON Server_CollectorAction IS ActionType IN (1, 2, 4,
8, 16, 32, 64)
\p\g
create table server_person(
	personid integer not null,
	sourceid integer not null,
	personname char(254) not null,
	description varchar(255),
	displayname char(254),
	mailfile varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify server_person to btree unique on
	sourceid,
	personid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy server_person () from 'server_person.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on server_person
\p\g
create integrity  ON Server_Person IS SourceID >= 1
\p\g
create integrity  ON Server_Person IS PersonID >= 1
\p\g
create table server_schedule(
	collectorid integer not null,
	actionid integer not null,
	scheduletype smallint not null,
	startdatetime date not null,
	occurs smallint,
	dailyfrequency smallint,
	every integer,
	enddatetime date,
	sun i1,
	mon i1,
	tue i1,
	wen i1,
	thur i1,
	fri i1,
	sat i1,
	daytype smallint,
	intervalunit smallint,
	dayofmonth smallint,
	weeknumber smallint,
	weekday smallint,
	lastrundate date,
	timeevery integer,
	inscale i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify server_schedule to btree unique on
	collectorid,
	actionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy server_schedule () from 'server_schedule.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on server_schedule
\p\g
create integrity  ON Server_Schedule IS CollectorID >= 1
\p\g
create integrity  ON Server_Schedule IS ActionID IN (1, 2, 3, 4)
\p\g
create integrity  ON Server_Schedule IS ScheduleType IN (1, 2)
\p\g
create integrity  ON Server_Schedule IS Occurs IN (1, 2, 3)
\p\g
create integrity  ON Server_Schedule IS DailyFrequency IN (1, 2)
\p\g
create integrity  ON Server_Schedule IS DayType IN (1, 2)
\p\g
create integrity  ON Server_Schedule IS IntervalUnit IN (1, 2, 3)
\p\g
create integrity  ON Server_Schedule IS WeekNumber IN (1, 2, 3, 4, 5)
\p\g
create integrity  ON Server_Schedule IS WeekDay IN (1, 2, 3, 4, 5, 6, 
7)
\p\g
create integrity  ON Server_Schedule IS TimeEvery >= 1
\p\g
create table server_site(
	siteid integer not null,
	sitename char(254) not null,
	mailorgid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify server_site to btree unique on
	siteid,
	mailorgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy server_site () from 'server_site.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on server_site
\p\g
create integrity  ON Server_Site IS SiteID >= 1
\p\g
create integrity  ON Server_Site IS MailOrgID >= 1
\p\g
create table service_goals(
	goal_name varchar(100) not null,
	label varchar(100),
	tooltip varchar(50),
	description varchar(255),
	tab_order integer,
	type varchar(20) not null,
	required integer,
	editable integer,
	hidden integer,
	defaultval varchar(255),
	minval varchar(255),
	maxval varchar(255),
	orientation integer,
	report_function varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify service_goals to btree unique on
	goal_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy service_goals () from 'service_goals.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on service_goals
\p\g
create table service_goalvalues(
	goal_name varchar(100) not null,
	value varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify service_goalvalues to btree unique on
	goal_name,
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy service_goalvalues () from 'service_goalvalues.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on service_goalvalues
\p\g
create table service_incident_victims(
	siid integer not null,
	dcid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify service_incident_victims to btree unique on
	siid,
	dcid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy service_incident_victims () from 'service_incident_victims.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on service_incident_victims
\p\g
create table service_incidents(
	siid integer not null,
	description varchar(255) not null,
	start_time integer not null,
	stop_time integer not null,
	created integer,
	created_by varchar(50),
	last_modified integer,
	last_modified_by varchar(50),
	category varchar(10),
	event_category_oid varchar(20),
	recurring_event_oid varchar(20),
	onetime_event_oid varchar(20),
	calendar_oid varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify service_incidents to btree unique on
	siid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy service_incidents () from 'service_incidents.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on service_incidents
\p\g
create table serviceproviders(
	adapter varchar(50) not null,
	serviceprovider varchar(50) not null,
	actor varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify serviceproviders to heap
with extend = 16,
	allocation = 4
\p\g
/* copy serviceproviders () from 'serviceproviders.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on serviceproviders
\p\g
create table session_log(
	id integer not null,
	login_time integer,
	logout_time integer,
	session_id integer,
	contact byte varying(16),
	session_type integer,
	policy integer,
	status integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify session_log to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy session_log () from 'session_log.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on session_log
\p\g
create table session_type(
	id integer not null,
	persid varchar(30),
	sym varchar(30) not null,
	description varchar(500),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify session_type to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy session_type () from 'session_type.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on session_type
\p\g
create table sessionlength(
	start_time date,
	end_time date,
	sessionnumber integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sessionlength to heap
with extend = 16,
	allocation = 4
\p\g
/* copy sessionlength () from 'sessionlength.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on sessionlength
\p\g
create table sessionx(
	oid integer not null,
	name varchar(64),
	enabled char(1),
	intervalx integer not null,
	xml text(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sessionx to heap
with extend = 16,
	allocation = 4
\p\g
/* copy sessionx () from 'sessionx.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on sessionx
\p\g
create table setting(
	actor varchar(50) not null,
	setting long byte not null,
	user_name varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify setting to heap
with extend = 16,
	allocation = 4
\p\g
/* copy setting () from 'setting.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on setting
\p\g
create table settings(
	eccmuserid integer not null,
	context char(20) not null,
	value char(1900),
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify settings to btree unique on
	eccmuserid,
	context
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy settings () from 'settings.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on settings
\p\g
create table severity(
	severity_id integer not null,
	"level" integer,
	name varchar(255),
	max_alert_surpression_enabled decimal(1,0),
	max_alert_per_period integer,
	max_alert_measurement_period integer,
	min_time_between_alerts_enabled decimal(1,0),
	min_time_between_alerts integer,
	alert_complete_email decimal(1,0),
	alert_complete_email_period integer,
	operation_group_id integer,
	wmi_enabled decimal(1,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify severity to btree unique on
	severity_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy severity () from 'severity.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on severity
\p\g
create table sevrty(
	id integer not null,
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify sevrty to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy sevrty () from 'sevrty.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sevrty
\p\g
create table show_obj(
	id integer not null,
	obj_persid varchar(255),
	pwd varchar(255),
	expire_date integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify show_obj to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy show_obj () from 'show_obj.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on show_obj
\p\g
create table sid(
	sid_id decimal(5,0) not null,
	collect_id decimal(5,0) not null,
	created_by varchar(30),
	created_date date,
	oracle_sid varchar(30) not null,
	oracle_version varchar(64) not null,
	oracle_options varchar(300),
	oracle_home varchar(200),
	block_size decimal(5,0),
	tnsname varchar(30) not null,
	hostname varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sid to btree unique on
	sid_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy sid () from 'sid.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sid
\p\g
create table sid_param(
	sid_param_id decimal(5,0) not null,
	sid_id decimal(5,0),
	collect_id decimal(5,0),
	param_name varchar(64),
	param_type decimal(5,0),
	param_value varchar(512)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sid_param to btree unique on
	sid_param_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy sid_param () from 'sid_param.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sid_param
\p\g
create table simpleevent(
	processid varchar(20) not null,
	workitemid varchar(20) not null,
	operation varchar(100) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify simpleevent to heap
with extend = 16,
	allocation = 4
\p\g
/* copy simpleevent () from 'simpleevent.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on simpleevent
\p\g
create table simplerequest(
	requestid integer not null,
	sourceproviderid integer not null,
	sourceservername varchar(128),
	sourcedatabasename varchar(128),
	sourceloginname varchar(32),
	sourceloginpassword byte(32),
	sourceother varchar(128),
	destproviderid integer not null,
	destservername varchar(128),
	destdatabasename varchar(128),
	destloginname varchar(32),
	destloginpassword byte(32),
	destother varchar(128),
	desttablename varchar(128),
	desttableoverwrite i1 not null,
	bulktransfer i1,
	deletestring varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify simplerequest to heap
with extend = 16,
	allocation = 4
\p\g
/* copy simplerequest () from 'simplerequest.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on simplerequest
\p\g
create table skeletons(
	id integer not null,
	user_def_id varchar(40),
	active_state integer,
	active_state_date integer,
	hits integer,
	sd_accepted_hits integer,
	status_id integer,
	priority_id integer,
	doc_type_id integer,
	ext_doc_id integer,
	initiator_id byte varying(16),
	initiator varchar(100),
	owner_id byte varying(16),
	author_id byte varying(16),
	subject_expert_id byte varying(16),
	assignee_id byte varying(16),
	creation_date integer,
	modify_date integer,
	start_date integer,
	expiration_date integer,
	review_date integer,
	last_accepted_date integer,
	sd_product_id integer,
	sd_asset_id byte varying(16),
	sd_rootcause_id integer,
	sd_priority_id integer,
	sd_severity_id integer,
	sd_impact_id integer,
	sd_urgency_id integer,
	created_via integer,
	read_pgroup integer,
	write_pgroup integer,
	primary_index integer,
	kd_permission_index_id integer,
	inherit_permission integer,
	current_action_id integer,
	resolution_short varchar(255),
	resolution_length integer,
	doc_template_id integer,
	custom1 varchar(50),
	custom2 varchar(50),
	custom3 varchar(50),
	custom4 varchar(255),
	custom5 varchar(255),
	custom_num1 float,
	custom_num2 float,
	bu_result float,
	expire_notification_sent integer,
	published_date integer,
	wf_template integer,
	doc_version varchar(50),
	ver_count integer,
	ver_cross_ref_id integer,
	ver_comment varchar(1000),
	locked_by_id byte varying(16),
	word_count_total integer,
	wordcount integer,
	title varchar(255),
	summary varchar(255),
	problem long varchar,
	resolution long varchar,
	notes long varchar,
	fullwords long varchar,
	shortwords long varchar,
	wordcounts long varchar,
	wordspans long varchar,
	wordplaces long varchar,
	wordorders long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify skeletons to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy skeletons () from 'skeletons.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on skeletons
\p\g
create table slatpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	service_type varchar(30) not null,
	event varchar(30),
	elapsed integer not null,
	object_type varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify slatpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy slatpl () from 'slatpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on slatpl
\p\g
create table smm_module_defs(
	smm_module varchar(50) not null,
	attr_name varchar(50) not null,
	taborder integer,
	type varchar(50) not null,
	value varchar(255) not null,
	label varchar(255) not null,
	help varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify smm_module_defs to btree unique on
	smm_module,
	attr_name,
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy smm_module_defs () from 'smm_module_defs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on smm_module_defs
\p\g
create table smm_module_values(
	smm_module varchar(50) not null,
	attr_name varchar(50) not null,
	value varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify smm_module_values to btree unique on
	smm_module,
	attr_name,
	value
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy smm_module_values () from 'smm_module_values.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on smm_module_values
\p\g
create table smm_modules(
	system_name varchar(50) not null,
	smm_module varchar(50) not null,
	attr_name varchar(50) not null,
	value varchar(1023) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify smm_modules to btree unique on
	system_name,
	smm_module,
	attr_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy smm_modules () from 'smm_modules.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on smm_modules
\p\g
create table smm_sub_systems(
	sub_system_name varchar(100) not null,
	system_name varchar(100) not null,
	description varchar(255),
	status varchar(255),
	statuspage varchar(1023),
	created integer,
	created_by varchar(50),
	last_modified integer,
	last_modified_by varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify smm_sub_systems to btree unique on
	sub_system_name,
	system_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy smm_sub_systems () from 'smm_sub_systems.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on smm_sub_systems
\p\g
create table smm_systems(
	system_name varchar(100) not null,
	description varchar(255),
	created integer,
	created_by varchar(50),
	last_modified integer,
	last_modified_by varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify smm_systems to btree unique on
	system_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy smm_systems () from 'smm_systems.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on smm_systems
\p\g
create table snapmain(
	domainid integer not null,
	unitid integer not null,
	snapmain varchar(80) not null,
	snappart integer not null,
	snapmemo text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify snapmain to btree unique on
	unitid,
	snapmain,
	domainid,
	snappart
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy snapmain () from 'snapmain.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on snapmain
\p\g
create table snapmemo(
	domainid integer not null,
	unitid integer not null,
	snappart integer not null,
	snapmemo text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify snapmemo to btree unique on
	unitid,
	domainid,
	snappart
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy snapmemo () from 'snapmemo.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on snapmemo
\p\g
create table snmp_config(
	target varchar(50) not null,
	community varchar(50) not null,
	retries integer not null,
	timeout integer not null,
	netmask varchar(20),
	snmpversion varchar(50) not null,
	username varchar(100),
	password varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify snmp_config to btree unique on
	target
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy snmp_config () from 'snmp_config.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on snmp_config
\p\g
create table snmp_console(
	snmp_manager_id integer not null,
	name varchar(255),
	address varchar(255),
	community varchar(255),
	retries integer,
	timeout_millis integer,
	port integer,
	pref_version integer,
	creation_date date not null,
	modification_date date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify snmp_console to btree unique on
	snmp_manager_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy snmp_console () from 'snmp_console.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on snmp_console
\p\g
create table software_vulnerability(
	vuln_id byte(16) not null,
	is_remotely_exploitable i1 not null,
	is_locally_exploitable i1 not null,
	discovery_date integer not null,
	discovered_by nvarchar(100),
	impact_rating smallint not null,
	popularity_rating smallint not null,
	simplicity_rating smallint not null,
	root_cause_id byte(16),
	published_date integer,
	creation_user varchar(64) not null,
	creation_date integer not null,
	last_update_user varchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify software_vulnerability to btree unique on
	vuln_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy software_vulnerability () from 'software_vulnerability.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on software_vulnerability
\p\g
create table solutiondescription(
	solutiondescriptionid integer not null,
	solutiontext text(4096) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify solutiondescription to btree unique on
	solutiondescriptionid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy solutiondescription () from 'solutiondescription.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on solutiondescription
\p\g
create integrity  ON SolutionDescription IS SolutionDescriptionID >= 1
\p\g
create table sonarapplication(
	applicationuuid byte(16) not null not default,
	name varchar(96) not null not default,
	discoverystatus varchar(16) not default,
	discoverystarted date not default,
	discoverycompleted date not default,
	discoverystartedseconds integer not null default 0,
	discoverycompletedseconds integer not null default 0
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sonarapplication to btree unique on
	applicationuuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy sonarapplication () from 'sonarapplication.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sonarapplication
\p\g
create table sonarcomponentdef(
	sonarcomponentuuid byte(16) not null not default,
	applicationuuid byte(16) not null not default,
	assetuuid byte(16) not null not default,
	parentassetuuid byte(16) not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sonarcomponentdef to btree unique on
	sonarcomponentuuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy sonarcomponentdef () from 'sonarcomponentdef.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sonarcomponentdef
\p\g
create table sonarperformance(
	localcomponentuuid byte(1) not null not default,
	remotecomponentuuid byte(1) not null not default,
	sessionid smallint not null not default,
	intervalstart date not null not default,
	intervalstartseconds integer not null not default,
	intervallength integer not null not default,
	totalsessions integer not null default 0,
	responsetime integer not null default 0,
	totalpackets integer not null default 0,
	totalbytes integer not null default 0,
	outboundpackets integer default 0,
	inboundpackets integer not null default 0,
	outboundbytes integer not null default 0,
	inboundbytes integer not null default 0
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sonarperformance to btree unique on
	localcomponentuuid,
	remotecomponentuuid,
	intervalstart,
	intervalstartseconds
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy sonarperformance () from 'sonarperformance.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sonarperformance
\p\g
create table sonartransaction(
	transactionuuid byte(16) not null not default,
	applicationuuid byte(16) not null not default,
	name varchar(16) not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sonartransaction to btree unique on
	transactionuuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy sonartransaction () from 'sonartransaction.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sonartransaction
\p\g
create table sourcelocale(
	localeid integer not null,
	localename char(32) not null,
	langcode char(4) not null,
	sourcetype integer not null,
	javalocale char(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify sourcelocale to btree unique on
	localeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy sourcelocale () from 'sourcelocale.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sourcelocale
\p\g
create integrity  ON SourceLocale IS LocaleID >= 1
\p\g
create table splmac(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	description varchar(80),
	ob_type varchar(30) not null,
	type varchar(30) not null,
	fragment long varchar,
	usr_string2 varchar(250),
	usr_string3 varchar(125),
	usr_string4 varchar(25),
	usr_integer1 integer,
	usr_integer2 integer,
	usr_integer3 integer,
	msg_html long varchar,
	lock_object integer not null,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify splmac to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy splmac () from 'splmac.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on splmac
\p\g
create table splmactp(
	id integer not null,
	persid varchar(30),
	del integer not null,
	code varchar(30) not null,
	sym varchar(30) not null,
	description varchar(200),
	tech_desc varchar(300),
	arg_list varchar(80),
	execute_script varchar(800),
	validate_script varchar(400),
	lock_object_flag integer,
	last_mod_dt integer,
	display_name varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify splmactp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy splmactp () from 'splmactp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on splmactp
\p\g
create table sql_tab(
	id integer not null,
	del integer not null,
	sql_name varchar(30),
	sql_script varchar(500),
	sql_desc varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify sql_tab to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy sql_tab () from 'sql_tab.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on sql_tab
\p\g
create table srv_desc(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	code varchar(30) not null,
	rank integer,
	schedule varchar(30),
	owning_contract integer,
	violation_cost integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify srv_desc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy srv_desc () from 'srv_desc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on srv_desc
\p\g
create table srvr_aliases(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	alias_name varchar(30) not null,
	zone_id integer not null,
	host_addr varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify srvr_aliases to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy srvr_aliases () from 'srvr_aliases.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on srvr_aliases
\p\g
create table srvr_zones(
	id integer not null,
	del integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	zone_name varchar(30) not null,
	is_default integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify srvr_zones to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy srvr_zones () from 'srvr_zones.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on srvr_zones
\p\g
create table station(
	id char(20),
	type smallint,
	max_prn_pages integer,
	max_prn_time integer,
	time_zone smallint,
	cci_node varchar(64),
	crt_date integer,
	crt_time integer,
	crt_id varchar(32),
	upd_date integer,
	upd_time integer,
	upd_id varchar(32),
	descr varchar(255),
	node_type smallint
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify station to btree unique on
	id,
	type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy station () from 'station.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on station
\p\g
create table statistic(
	id integer,
	name varchar(32),
	statistictype varchar(32),
	frequency varchar(32),
	grouptype varchar(32),
	eventcategory varchar(32),
	period varchar(32),
	span varchar(32),
	timestamp date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify statistic to heap
with extend = 16,
	allocation = 4
\p\g
/* copy statistic () from 'statistic.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on statistic
\p\g
create table statisticaverages(
	statisticgroupingid integer,
	average float,
	stddeviation float,
	totalcount integer,
	dayorhour varchar(32),
	timelastupdated date,
	periodendts date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify statisticaverages to heap
with extend = 16,
	allocation = 4
\p\g
/* copy statisticaverages () from 'statisticaverages.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on statisticaverages
\p\g
create table statisticgrouping(
	id integer,
	statisticid integer,
	personid integer,
	machineid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify statisticgrouping to heap
with extend = 16,
	allocation = 4
\p\g
/* copy statisticgrouping () from 'statisticgrouping.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on statisticgrouping
\p\g
create table statjob(
	udomid integer not null,
	unitid integer not null,
	jdomid integer not null,
	jobid integer not null,
	status integer,
	stcount integer,
	stqcount integer,
	stdate integer,
	stelapse integer,
	sttext varchar(127),
	strev integer,
	stflag integer,
	auto_rep_version date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify statjob to btree unique on
	unitid,
	jobid,
	udomid,
	jdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy statjob () from 'statjob.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on statjob
\p\g
create table statjobm(
	udomid integer not null,
	unitid integer not null,
	jdomid integer not null,
	jobid integer not null,
	statpart integer not null,
	stattext text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify statjobm to btree unique on
	unitid,
	jobid,
	statpart,
	udomid,
	jdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy statjobm () from 'statjobm.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on statjobm
\p\g
create table statmod(
	udomid integer not null,
	unitid integer not null,
	mdomid integer not null,
	moid integer not null,
	status integer,
	stcount integer,
	stqcount integer,
	stdate integer,
	stelapse integer,
	sttext varchar(127),
	strev integer,
	stflag integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify statmod to btree unique on
	unitid,
	moid,
	udomid,
	mdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy statmod () from 'statmod.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on statmod
\p\g
create table statmodm(
	udomid integer not null,
	unitid integer not null,
	mdomid integer not null,
	moid integer not null,
	statpart integer not null,
	stattext text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify statmodm to btree unique on
	unitid,
	moid,
	statpart,
	udomid,
	mdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy statmodm () from 'statmodm.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on statmodm
\p\g
create table stats(
	processid varchar(20) not null,
	started float not null,
	workitemid varchar(20) not null,
	duedate float,
	completed float,
	actor varchar(50) not null,
	processname varchar(50) not null,
	nodeid varchar(20) not null,
	nodename varchar(50) not null,
	nodedesc varchar(200)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stats to btree unique on
	workitemid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy stats () from 'stats.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stats
\p\g
create table stattype(
	id integer,
	name varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stattype to heap
with extend = 16,
	allocation = 4
\p\g
/* copy stattype () from 'stattype.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on stattype
\p\g
create table status_type(
	status_id decimal(31,0) not null,
	status_name varchar(1200) not null,
	status_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify status_type to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy status_type () from 'status_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on status_type
\p\g
create table stg_backups(
	name char(17) not null,
	seqno smallint not null,
	stgid integer not null,
	devid integer not null,
	fileno smallint not null,
	blocks integer not null,
	last_blksize integer not null,
	machineid integer not null,
	backup_type char(1) not null,
	volid char(6) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_backups to btree unique on
	name,
	seqno
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_backups () from 'stg_backups.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_backups
\p\g
create table stg_device_alloc(
	devid integer not null,
	pid integer not null,
	alloc_time integer not null,
	machineid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_device_alloc to btree unique on
	machineid,
	devid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_device_alloc () from 'stg_device_alloc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_device_alloc
\p\g
create table stg_devices(
	devid integer not null,
	device_type char(1) not null,
	name varchar(200) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_devices to btree unique on
	devid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_devices () from 'stg_devices.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_devices
\p\g
create table stg_group(
	stgid integer not null,
	creator varchar(21) not null,
	name varchar(30) not null,
	share_option char(1) not null,
	stg_type char(1) not null,
	stg_flag char(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_group to btree unique on
	stgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_group () from 'stg_group.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_group
\p\g
create table stg_group_adsm(
	stgid integer not null,
	owner varchar(64) not null,
	server varchar(64) not null,
	filespace varchar(200) not null,
	high_level varchar(200) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_group_adsm to btree unique on
	stgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_group_adsm () from 'stg_group_adsm.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_group_adsm
\p\g
create table stg_group_arc(
	stgid integer not null,
	arc_user varchar(120) not null,
	password varchar(120) not null,
	media_group varchar(120) not null,
	arc_server varchar(120) not null,
	file_path varchar(200)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_group_arc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy stg_group_arc () from 'stg_group_arc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on stg_group_arc
\p\g
create table stg_group_devices(
	stgid integer not null,
	devid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_group_devices to btree unique on
	stgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_group_devices () from 'stg_group_devices.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_group_devices
\p\g
create table stg_group_openv(
	stgid integer not null,
	class varchar(120) not null,
	schedule varchar(120) not null,
	server varchar(128) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_group_openv to btree unique on
	stgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_group_openv () from 'stg_group_openv.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_group_openv
\p\g
create table stg_group_tape(
	stgid integer not null,
	blksize integer not null,
	tapelen integer not null,
	label_prefix char(8) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_group_tape to btree unique on
	stgid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_group_tape () from 'stg_group_tape.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_group_tape
\p\g
create table stg_volume_alloc(
	volid integer not null,
	pid integer not null,
	alloc_time integer not null,
	machineid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_volume_alloc to btree unique on
	volid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_volume_alloc () from 'stg_volume_alloc.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_volume_alloc
\p\g
create table stg_volumes(
	volid char(6) not null,
	stgid integer not null,
	devid integer not null,
	free_space integer not null,
	file_count smallint not null,
	max_fileno smallint not null,
	machineid integer not null,
	label_prefix char(8) not null,
	volume_type char(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stg_volumes to btree unique on
	volid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stg_volumes () from 'stg_volumes.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stg_volumes
\p\g
create table strategies(
	strategy_id integer not null,
	version integer not null,
	strategy_owner varchar(128) not null,
	strategy_name varchar(128) not null,
	strategy_type integer not null,
	shareable integer not null,
	locked integer not null,
	locked_by varchar(128),
	lock_datetime date,
	src_server varchar(256) not null,
	tgt_server varchar(256) not null,
	description varchar(256),
	upd_user varchar(128) not null,
	upd_datetime date not null,
	data_version integer not null,
	product_code char(3) not null,
	src_server_type varchar(30),
	tgt_server_type varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategies to btree unique on
	version,
	strategy_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategies () from 'strategies.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategies
\p\g
create table strategy(
	strid integer not null,
	str_name varchar(30) not null,
	str_creator varchar(21) not null,
	str_type char(2) not null,
	product_code char(4) not null,
	product_version smallint not null,
	retention smallint not null,
	share_option char(1) not null,
	update_user varchar(21) not null,
	update_time date not null,
	description varchar(255) not null,
	complete char(1) not null,
	select_mode char(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy to btree unique on
	strid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy () from 'strategy.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy
\p\g
create table strategy_db_server(
	serverid integer not null,
	server_name varchar(128) not null,
	dbms_type char(1) not null,
	hostid integer not null,
	instanceid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_db_server to btree unique on
	serverid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_db_server () from 'strategy_db_server.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_db_server
\p\g
create table strategy_db_store(
	storeid integer not null,
	store_name varchar(32) not null,
	create_time date not null,
	machineid integer not null,
	pgsize integer not null,
	dbid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_db_store to btree unique on
	storeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_db_store () from 'strategy_db_store.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_db_store
\p\g
create table strategy_group(
	strid integer not null,
	groupid integer not null,
	jobs_per_run integer not null,
	active_schedule char(1) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_group to btree unique on
	strid,
	groupid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_group () from 'strategy_group.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_group
\p\g
create table strategy_host_id(
	hostid integer not null,
	host_name varchar(128) not null,
	domain_name varchar(128) not null,
	machineid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_host_id to btree unique on
	hostid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_host_id () from 'strategy_host_id.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_host_id
\p\g
create table strategy_ins_store(
	instanceid integer not null,
	storeid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_ins_store to btree unique on
	instanceid,
	storeid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_ins_store () from 'strategy_ins_store.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_ins_store
\p\g
create table strategy_instance(
	instanceid integer not null,
	instance_name varchar(32) not null,
	machineid integer not null,
	dbms_version varchar(15) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_instance to btree unique on
	instanceid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_instance () from 'strategy_instance.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_instance
\p\g
create table strategy_job(
	strid integer not null,
	groupid integer not null,
	run_num integer not null,
	jobid integer not null,
	serverid integer not null,
	hostid integer not null,
	start_time date not null,
	end_time date not null,
	job_state char(1) not null,
	logfile_name varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_job to btree unique on
	strid,
	groupid,
	serverid,
	run_num
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_job () from 'strategy_job.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_job
\p\g
create table strategy_lock(
	creator varchar(21) not null,
	name varchar(30) not null,
	locked char(1) not null,
	requestor varchar(21) not null,
	component char(1) not null,
	filler1 char(255) not null,
	filler2 char(255) not null,
	filler3 char(255) not null,
	filler4 char(255) not null,
	filler5 char(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_lock to btree unique on
	creator,
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_lock () from 'strategy_lock.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_lock
\p\g
create table strategy_machine(
	machineid integer not null,
	platform varchar(31) not null,
	ident_string varchar(64) not null,
	name varchar(40) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_machine to btree unique on
	machineid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_machine () from 'strategy_machine.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_machine
\p\g
create table strategy_objs_slct(
	strid integer not null,
	object_type char(1) not null,
	inc_ex char(1) not null,
	source_storeid integer not null,
	source_instanceid integer not null,
	target_serverid integer not null,
	old_dbname varchar(30) not null,
	old_name varchar(30) not null,
	old_owner varchar(30) not null,
	old_filename varchar(255) not null,
	new_dbname varchar(30) not null,
	new_name varchar(30) not null,
	new_owner varchar(30) not null,
	new_filename varchar(255) not null,
	tocopy_time date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_objs_slct to btree on
	strid,
	target_serverid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_objs_slct () from 'strategy_objs_slct.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_objs_slct
\p\g
create table strategy_run(
	strid integer not null,
	groupid integer not null,
	run_num integer not null,
	start_time date not null,
	server_numstart integer not null,
	server_numcomp integer not null,
	server_numsucc integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_run to btree unique on
	strid,
	groupid,
	run_num
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_run () from 'strategy_run.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_run
\p\g
create table strategy_ver_info(
	client_min integer not null,
	client_max integer not null,
	backend_min integer not null,
	backend_max integer not null,
	owner_name varchar(30),
	table_name varchar(30),
	column_count integer,
	table_ext varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strategy_ver_info to btree unique on
	owner_name,
	table_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strategy_ver_info () from 'strategy_ver_info.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strategy_ver_info
\p\g
create table stratglblchg(
	id integer not null,
	owner varchar(128) not null,
	name varchar(128) not null,
	server_type integer not null,
	server_version integer not null,
	shareable integer not null,
	locked integer not null,
	locked_by varchar(128),
	lock_datetime date,
	description varchar(256),
	upd_user varchar(128) not null,
	upd_datetime date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify stratglblchg to btree unique on
	owner,
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy stratglblchg () from 'stratglblchg.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stratglblchg
\p\g
create table stratobjs(
	strategy_id integer not null,
	version integer not null,
	stratobj_id integer not null,
	serverlocation integer not null,
	object_type integer not null,
	object_database varchar(128),
	object_owner varchar(128),
	object_name varchar(128) not null,
	object_qualifier varchar(128),
	object_id integer not null,
	process integer not null,
	editedflag integer,
	old_database varchar(128),
	old_owner varchar(128),
	old_name varchar(128),
	old_qualifier varchar(128),
	new_database varchar(128),
	new_owner varchar(128),
	new_name varchar(128),
	new_qualifier varchar(128),
	optionsflag integer,
	description1 varchar(1960),
	description2 varchar(1960)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify stratobjs to isam unique on
	version,
	strategy_id,
	serverlocation,
	object_database,
	object_type,
	object_owner,
	object_name,
	object_qualifier
with fillfactor = 80,
	extend = 16,
	page_size = 8192
\p\g
/* copy stratobjs () from 'stratobjs.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on stratobjs
\p\g
create table strattext(
	column_id integer not null,
	unique_id integer not null,
	version_no integer not null,
	sequence_no integer not null,
	text_val byte(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify strattext to btree unique on
	unique_id,
	column_id,
	sequence_no,
	version_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy strattext () from 'strattext.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strattext
\p\g
create table strlst(
	_slid smallint,
	slentry smallint,
	slvalue1 varchar(60),
	slvalue2 varchar(60),
	slchgrst varchar(20),
	sldatest date,
	sltimest varchar(6),
	sltmestp byte(8)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify strlst to btree unique on
	_slid,
	slentry
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy strlst () from 'strlst.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on strlst
\p\g
create table style(
	style_id decimal(31,0) not null,
	style_name varchar(1200),
	font_size integer,
	font_color integer,
	font_weight integer,
	font_italic smallint,
	font_underscore smallint,
	font_strike_through smallint,
	pitch_and_family integer,
	depth float,
	font_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify style to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy style () from 'style.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on style
\p\g
create table subattr(
	cid smallint not null not default,
	syntax smallint not null not default,
	parent_syx smallint not null not default,
	description varchar(40) not null not default,
	objectid varchar(88) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify subattr to btree unique on
	cid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy subattr () from 'subattr.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on subattr
\p\g
create table subsearch(
	aid smallint not null not default,
	cid smallint not null not default,
	normkey varchar(8) not null not default,
	eid integer not null not default,
	vid smallint not null not default,
	cvid smallint not null default 0,
	norm varchar(1900) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify subsearch to btree unique on
	aid,
	cid,
	normkey,
	eid,
	vid,
	cvid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy subsearch () from 'subsearch.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on subsearch
\p\g
create table survey(
	id integer not null,
	persid varchar(30),
	del integer not null,
	description varchar(400),
	sym varchar(12),
	include_comment integer not null,
	comment_label varchar(80),
	nx_comment varchar(200),
	conclude_text varchar(400),
	object_type varchar(10),
	object_id integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey () from 'survey.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey
\p\g
create table survey_answer(
	id integer not null,
	persid varchar(30),
	del integer not null,
	txt varchar(400),
	sequence integer not null,
	own_srvy_question integer,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	selected integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey_answer to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey_answer () from 'survey_answer.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey_answer
\p\g
create table survey_atpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	txt varchar(400),
	sequence integer not null,
	own_srvy_question integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey_atpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey_atpl () from 'survey_atpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey_atpl
\p\g
create table survey_qtpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	txt varchar(400),
	sequence integer not null,
	owning_survey integer,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	resp_required integer,
	include_qcomment integer,
	mult_resp_flag integer,
	qcomment_label varchar(80)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey_qtpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey_qtpl () from 'survey_qtpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey_qtpl
\p\g
create table survey_question(
	id integer not null,
	persid varchar(30),
	del integer not null,
	txt varchar(400),
	sequence integer not null,
	owning_survey integer,
	response integer not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	resp_required integer,
	include_qcomment integer,
	mult_resp_flag integer,
	qcomment_label varchar(80),
	qcomment varchar(200)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey_question to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey_question () from 'survey_question.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey_question
\p\g
create table survey_statistics(
	id integer not null,
	persid varchar(30),
	del integer not null,
	tplid integer,
	cycle integer,
	cyc_counter integer,
	eval_counter integer,
	sub_counter integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey_statistics to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey_statistics () from 'survey_statistics.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey_statistics
\p\g
create table survey_tpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	description varchar(400),
	sym varchar(12) not null,
	include_comment integer not null,
	comment_label varchar(80),
	conclude_text varchar(400),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	submit_cycle integer,
	cycle_counter integer,
	tracking_flag integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey_tpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey_tpl () from 'survey_tpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey_tpl
\p\g
create table survey_tracking(
	id integer not null,
	persid varchar(30),
	del integer not null,
	tplid integer,
	cntid byte varying(16),
	object_type varchar(10),
	object_id integer,
	status integer,
	notif_dt integer,
	recv_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify survey_tracking to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy survey_tracking () from 'survey_tracking.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on survey_tracking
\p\g
create table svc_contract(
	id integer not null,
	persid varchar(30),
	del integer,
	sym varchar(80),
	nx_desc varchar(240),
	contract_num varchar(50),
	svc_owner byte varying(16),
	svc_advocate byte varying(16),
	active integer,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	expiration integer,
	org_svc_type varchar(30),
	dflt_pcat_st varchar(30),
	dflt_isscat_st varchar(30),
	dflt_chgcat_st varchar(30),
	dflt_pri_st varchar(30),
	dflt_nr_st varchar(30),
	dflt_cnt_st varchar(30)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify svc_contract to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy svc_contract () from 'svc_contract.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on svc_contract
\p\g
create table system_configuration(
	unit_id byte(16) not null,
	application_type_id byte(16),
	code_version_number nvarchar(20),
	password_expiration_day_count smallint,
	nonrepeating_password_count smallint,
	nonrepeating_password_day_count smallint,
	minimum_password_length smallint,
	minimum_user_name_length smallint,
	maximum_user_name_length smallint,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify system_configuration to btree unique on
	unit_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy system_configuration () from 'system_configuration.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on system_configuration
\p\g
create table system_parameters(
	system_parameter_id decimal(31,0) not null,
	adm_schema_version float not null,
	adm_last_db_reorg_datetime date,
	admin_data_conv_complete_flag smallint,
	proj_def_dept_id decimal(31,0),
	proj_def_project_account_id integer,
	proj_def_project_client_id integer,
	tm_create_weeks_ahead integer,
	in_progress_status_indicator smallint,
	rsrc_allow_def_rsrc_flag smallint,
	proj_def_project_mask varchar(4000),
	proj_lock_actuals_flag smallint,
	proj_lock_etc_flag smallint,
	tm_tot_etc_timesheet smallint,
	proj_acct_code_reqd_flag smallint,
	proj_client_code_reqd_flag smallint,
	rsrc_dept_code_reqd_flag smallint,
	timesheet_week_ends_on integer,
	proj_allow_base_org_mod_flag smallint,
	mgmt_first_mth_in_fiscal_year integer,
	mgmt_last_mth_in_fiscal_year integer,
	rsrc_def_rsrc_id decimal(31,0),
	proj_allow_proj_create_flag smallint,
	proj_allow_proj_header_upd_fla smallint,
	proj_allow_proj_notes_mod_flag smallint,
	proj_task_notes_mod_flag smallint,
	tm_def_rpt_time_vari_over integer,
	tm_def_rpt_time_var_under integer,
	proj_post_altr_proj_head_flag smallint default 0,
	proj_allow_actual_del_flag smallint,
	tm_enbl_timesheet_notes smallint,
	tm_allw_entr_to_comp_proj_flag smallint,
	proj_allw_mod_to_compl_evt_flg smallint,
	tm_allw_psting_act_to_compl_ta smallint,
	proj_any_owns_unmng_levels_flg smallint,
	tm_last_enp_tmpost_date date,
	proj_use_bill_rates_by_proj smallint,
	proj_use_cost_rates_by_proj smallint,
	proj_use_ovtime_rates_by_proj smallint,
	proj_availability_by_proj smallint,
	proj_allw_chg_of_rsrcs_with_ac smallint,
	tm_reqd_pm_appr_for_tmsheet smallint,
	tm_reqd_rm_appr_for_tmsheet smallint,
	tm_admin_ovrride_tmsheet_apprv smallint,
	tm_days_warning smallint,
	tm_days_critical integer,
	allw_psting_act_to_compl_proj smallint default 0,
	tm_entr_allw_on_compl_tasks smallint,
	proj_std_hours_day integer,
	proj_std_days_week integer,
	proj_std_days_month integer,
	mgmt_recv_to_est_threshold integer,
	mgmt_est_to_apprv_threshold integer,
	mgmt_appr_to_actv_threshold integer,
	post_to_lock_project_flag smallint,
	post_to_close_project_flag smallint,
	mgmt_use_bill_rates_by_rsrc smallint,
	mgmt_use_cost_rates_by_rsrc smallint,
	period_per_fy integer,
	proj_param_acct_mask varchar(4000),
	proj_param_wbs_mask varchar(4000),
	allw_usr_del_task_with_act smallint,
	allw_usr_del_asgn_with_act smallint,
	rsrc_param_req_rsrc_dept_id smallint,
	rsrc_param_std_wk_hrs_per_day decimal(31,0),
	rsrc_param_avail_for_proj decimal(31,0),
	auto_schedule_after_post smallint,
	default_currency_symbol varchar(20),
	currency_symbol_is_suffix smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify system_parameters to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy system_parameters () from 'system_parameters.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on system_parameters
\p\g
create table systemparameter(
	parametername varchar(32) not null,
	parametervalue varchar(255),
	parametertype i1 not null,
	serverid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify systemparameter to heap
with extend = 16,
	allocation = 4
\p\g
/* copy systemparameter () from 'systemparameter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on systemparameter
\p\g
create table systemvalues(
	predefined i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify systemvalues to heap
with extend = 16,
	allocation = 4
\p\g
/* copy systemvalues () from 'systemvalues.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on systemvalues
\p\g
create table t_accounts(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_accountindex integer not null,
	c_accounttype integer not null,
	c_accountname varchar(129) not null,
	c_accountcomment varchar(255) not null,
	c_flag integer not null,
	c_ownerid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_accounts to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_accounts () from 't_accounts.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_accounts
\p\g
create table t_acctempl(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_objectclassindex integer not null,
	c_templacl byte varying(65) not null,
	c_ownerid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_acctempl to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_acctempl () from 't_acctempl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_acctempl
\p\g
create table t_activity(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_ordernumb integer not null,
	c_state integer not null,
	c_startflag integer not null,
	c_activationtime date not null,
	c_creationtime date not null,
	c_giveuptime date not null,
	c_execmode integer not null,
	c_jobname varchar(255) not null,
	c_promptmsg varchar(255) not null,
	c_promptto integer not null,
	c_userparams varchar(255) not null,
	c_jobbanner varchar(65) not null,
	c_okcnt integer not null,
	c_activecnt integer not null,
	c_errorcnt integer not null,
	c_mask integer not null,
	c_opmask integer not null,
	c_bootbefore integer not null,
	c_bootafter integer not null,
	c_targetmask integer not null,
	c_dtsstate integer not null,
	c_deliverytime date not null,
	c_cause integer not null,
	c_renewstate integer not null,
	c_waitingcnt integer not null,
	c_waitingrenewcnt integer not null,
	c_activerenewcnt integer not null,
	c_okrenewcnt integer not null,
	c_errorrenewcnt integer not null,
	c_permmask integer not null,
	c_calendar varchar(33),
	c_errorcause varchar(1024),
	c_ownerid integer,
	c_actproc integer,
	c_instproc integer,
	c_compfold integer,
	c_container integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_activity to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_activity () from 't_activity.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_activity
\p\g
create table t_actproc(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_itemname varchar(129) not null,
	c_itemversion varchar(129) not null,
	c_apesos integer not null,
	c_subpathentered varchar(255) not null,
	c_filedby integer not null,
	c_activatedby integer not null,
	c_comment varchar(255) not null,
	c_creationdatetime date not null,
	c_changedatetime date not null,
	c_type integer not null,
	c_task integer not null,
	c_subpath varchar(255) not null,
	c_proctorun varchar(255) not null,
	c_includedproc integer not null,
	c_bootflags integer not null,
	c_mask integer not null,
	c_opmask integer not null,
	c_bootbefore integer not null,
	c_bootafter integer not null,
	c_mgmtmask integer not null,
	c_procparameter varchar(255),
	c_prereqquery varchar(1024),
	c_ownerid integer,
	c_rsw integer,
	c_volume integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_actproc to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_actproc () from 't_actproc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_actproc
\p\g
create table t_apdep(
	c_objectid integer not null,
	c_version integer not null,
	c_rswname varchar(129) not null,
	c_rswversion varchar(129) not null,
	c_apname varchar(129) not null,
	c_apversion varchar(129) not null,
	c_filedby integer not null,
	c_ordernumber integer not null,
	c_ap integer,
	c_depap integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_apdep to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_apdep () from 't_apdep.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_apdep
\p\g
create table t_applic(
	c_objectid integer not null,
	c_version integer not null,
	c_status integer not null,
	c_errorcause integer not null,
	c_errorparam varchar(255) not null,
	c_creationtime date not null,
	c_activationtime date not null,
	c_completiontime date not null,
	c_administrator varchar(129) not null,
	c_applicationid varchar(129) not null,
	c_comment varchar(255) not null,
	c_task integer not null,
	c_percentsent integer not null,
	c_retentiontime date not null,
	c_renewstatus integer not null,
	c_userparams varchar(255) not null,
	c_uuid char(37) not null,
	c_uninstallstate integer not null,
	c_permmask integer not null,
	c_actproc integer,
	c_activity integer,
	c_installation integer,
	c_firstrenew integer,
	c_nextrenew integer,
	c_racassoc integer,
	c_target integer,
	c_applicationgroup integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_applic to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_applic () from 't_applic.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_applic
\p\g
create table t_carrier(
	c_objectid integer not null,
	c_version integer not null,
	c_status integer not null,
	c_transferid varchar(33) not null,
	c_transferdir varchar(255) not null,
	c_destination varchar(255) not null,
	c_transfertime date not null,
	c_containername varchar(255) not null,
	c_boundto integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_carrier to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_carrier () from 't_carrier.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_carrier
\p\g
create table t_cc(
	c_objectid integer not null,
	c_version integer not null,
	c_diststatus integer not null,
	c_overalljobstatus integer not null,
	c_numberofparameters integer not null,
	c_failure byte varying(255) not null,
	c_creationdatetime date not null,
	c_boundto integer,
	c_cont integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_cc to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_cc () from 't_cc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_cc
\p\g
create table t_cmp_attr(
	c_objectid integer not null,
	c_version integer not null,
	c_id integer not null,
	c_value varchar(129) not null,
	c_creationtime date not null,
	c_changetime date not null,
	c_computer integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_cmp_attr to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_cmp_attr () from 't_cmp_attr.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_cmp_attr
\p\g
create table t_cmp_grp(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_type integer not null,
	c_attributes integer not null,
	c_name varchar(129) not null,
	c_comment varchar(255) not null,
	c_credatetime date not null,
	c_chdatetime date not null,
	c_propflag integer not null,
	c_qcalendar varchar(33) not null,
	c_qevalrate integer not null,
	c_qnextevaldatetime date not null,
	c_qevaldatetime date not null,
	c_qtype integer not null,
	c_state integer not null,
	c_seal integer not null,
	c_var integer not null,
	c_query varchar(1024),
	c_theactivity integer,
	c_mycmpgrp integer,
	c_ownerid integer,
	c_schedevaltask integer,
	c_qtemplfold integer,
	c_cataloggrp integer,
	c_mylocalsite integer,
	c_unschedevaltask integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_cmp_grp to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_cmp_grp () from 't_cmp_grp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_cmp_grp
\p\g
create table t_compos(
	c_objectid integer not null,
	c_version integer not null,
	c_id integer not null,
	c_os varchar(65) not null,
	c_architecture varchar(129) not null,
	c_machine varchar(129) not null,
	c_fullvalue varchar(255) not null,
	c_msgcodebase varchar(33) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_compos to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_compos () from 't_compos.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_compos
\p\g
create table t_computer(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_managementtype integer not null,
	c_ssname varchar(193) not null,
	c_tngname varchar(255) not null,
	c_lanname varchar(193) not null,
	c_lanaddress varchar(255) not null,
	c_owner varchar(65) not null,
	c_phonenumber varchar(65) not null,
	c_location varchar(129) not null,
	c_creationtime date not null,
	c_changetime date not null,
	c_regflag integer not null,
	c_type integer not null,
	c_state integer not null,
	c_curros integer not null,
	c_currosvers varchar(65) not null,
	c_comment varchar(255) not null,
	c_calendar varchar(33) not null,
	c_sdver varchar(33) not null,
	c_uuid char(37) not null,
	c_prevls varchar(255) not null,
	c_agrefcnt integer not null,
	c_locks integer not null,
	c_ssid integer,
	c_ownerid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_computer to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_computer () from 't_computer.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_computer
\p\g
create table t_cont(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_name varchar(129) not null,
	c_overallstatus integer not null,
	c_sendid integer not null,
	c_containerpath varchar(255) not null,
	c_distlistpath varchar(255) not null,
	c_distlisttype integer not null,
	c_distdatetime date not null,
	c_credatetime date not null,
	c_ahdclosesuccess integer,
	c_ahdappendlog integer,
	c_ahdpersid varchar(16),
	c_ahdtemplpersid varchar(16),
	c_ownerid integer,
	c_contfold integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_cont to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_cont () from 't_cont.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_cont
\p\g
create table t_contfold(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_type integer not null,
	c_attributes integer not null,
	c_name varchar(129) not null,
	c_comment varchar(255) not null,
	c_credatetime date not null,
	c_chdatetime date not null,
	c_propflag integer not null,
	c_qcalendar varchar(33) not null,
	c_qevalrate integer not null,
	c_qnextevaldatetime date not null,
	c_qevaldatetime date not null,
	c_qtype integer not null,
	c_state integer not null,
	c_seal integer not null,
	c_var integer not null,
	c_ownerid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_contfold to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_contfold () from 't_contfold.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_contfold
\p\g
create table t_csite(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_siteid varchar(129) not null,
	c_location varchar(129) not null,
	c_address varchar(255) not null,
	c_tngname varchar(255) not null,
	c_admname varchar(65) not null,
	c_admphone varchar(65) not null,
	c_asmversion varchar(65) not null,
	c_releasedate date not null,
	c_installationdate date not null,
	c_creationdatetime date not null,
	c_changedatetime date not null,
	c_archivepath varchar(255) not null,
	c_remoteaddress varchar(255) not null,
	c_networktype integer not null,
	c_accessname varchar(9) not null,
	c_password varchar(9) not null,
	c_usercomment varchar(255) not null,
	c_uuid char(37) not null,
	c_agcnt integer not null,
	c_ownerid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_csite to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_csite () from 't_csite.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_csite
\p\g
create table t_distap(
	c_objectid integer not null,
	c_version integer not null,
	c_distributiondatetime date not null,
	c_ape integer,
	c_distsw integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_distap to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_distap () from 't_distap.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_distap
\p\g
create table t_distsw(
	c_objectid integer not null,
	c_version integer not null,
	c_distributiondatetime date not null,
	c_numberofinstallations integer not null,
	c_numberofinstsfound integer not null,
	c_numberofinstslocally integer not null,
	c_filedby integer not null,
	c_rsw integer,
	c_localsite integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_distsw to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_distsw () from 't_distsw.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_distsw
\p\g
create table t_fio(
	c_objectid integer not null,
	c_version integer not null,
	c_finame varchar(255) not null,
	c_fienviron varchar(255) not null,
	c_creationdatetime date not null,
	c_comment varchar(255) not null,
	c_assoc integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_fio to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_fio () from 't_fio.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_fio
\p\g
create table t_fitem(
	c_objectid integer not null,
	c_version integer not null,
	c_fetchdatetime date not null,
	c_fipath varchar(255) not null,
	c_copied integer not null,
	c_fio integer,
	c_localsite integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_fitem to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_fitem () from 't_fitem.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_fitem
\p\g
create table t_iprocos(
	c_objectid integer not null,
	c_version integer not null,
	c_id integer not null,
	c_os varchar(65) not null,
	c_osversion varchar(65) not null,
	c_machine varchar(129) not null,
	c_fullvalue varchar(255) not null,
	c_swdextension varchar(33) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_iprocos to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_iprocos () from 't_iprocos.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_iprocos
\p\g
create table t_jcappgr(
	c_objectid integer not null,
	c_version integer not null,
	c_jobstatus integer not null,
	c_renewedjobstatus integer not null,
	c_okcnt integer not null,
	c_activecnt integer not null,
	c_errorcnt integer not null,
	c_waitingcnt integer not null,
	c_okrenewcnt integer not null,
	c_activerenewcnt integer not null,
	c_waitingrenewcnt integer not null,
	c_errorrenewcnt integer not null,
	c_permmask integer not null,
	c_jobtarget integer,
	c_jobcontview integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_jcappgr to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_jcappgr () from 't_jcappgr.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_jcappgr
\p\g
create table t_jcview(
	c_objectid integer not null,
	c_version integer not null,
	c_type integer not null,
	c_waitingcnt integer not null,
	c_activecnt integer not null,
	c_errorcnt integer not null,
	c_okcnt integer not null,
	c_waitingrenewcnt integer not null,
	c_activerenewcnt integer not null,
	c_errorrenewcnt integer not null,
	c_okrenewcnt integer not null,
	c_jobcont integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_jcview to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_jcview () from 't_jcview.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_jcview
\p\g
create table t_job_cont(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_type integer not null,
	c_attributes integer not null,
	c_name varchar(129) not null,
	c_comment varchar(255) not null,
	c_credatetime date not null,
	c_chdatetime date not null,
	c_propflag integer not null,
	c_texts integer not null,
	c_qcalendar varchar(33) not null,
	c_qevalrate integer not null,
	c_qnextevaldatetime date not null,
	c_qevaldatetime date not null,
	c_qtype integer not null,
	c_state integer not null,
	c_seal integer not null,
	c_var integer not null,
	c_ahdclosesuccess integer,
	c_ahdappendlog integer,
	c_ahdpersid varchar(16),
	c_ahdtemplpersid varchar(16),
	c_qtemplfold integer,
	c_exceptiongrp integer,
	c_ownerid integer,
	c_qtask integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_job_cont to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_job_cont () from 't_job_cont.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_job_cont
\p\g
create table t_ls(
	c_objectid integer not null,
	c_version integer not null,
	c_ownerid integer not null,
	c_acl byte varying(65) not null,
	c_siteid varchar(129) not null,
	c_location varchar(129) not null,
	c_address varchar(255) not null,
	c_tngname varchar(255) not null,
	c_admname varchar(65) not null,
	c_admphone varchar(65) not null,
	c_asmversion varchar(65) not null,
	c_releasedate date not null,
	c_installationdate date not null,
	c_creationdatetime date not null,
	c_changedatetime date not null,
	c_archivepath varchar(255) not null,
	c_remoteaddress varchar(255) not null,
	c_networktype integer not null,
	c_accessname varchar(9) not null,
	c_password varchar(9) not null,
	c_usercomment varchar(255) not null,
	c_uuid char(37) not null,
	c_agcnt integer not null,
	c_compgrp integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_ls to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_ls () from 't_ls.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_ls
\p\g
create table t_lsg(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_type integer not null,
	c_attributes integer not null,
	c_name varchar(129) not null,
	c_comment varchar(255) not null,
	c_credatetime date not null,
	c_chdatetime date not null,
	c_propflag integer not null,
	c_qcalendar varchar(33) not null,
	c_qevalrate integer not null,
	c_qnextevaldatetime date not null,
	c_qevaldatetime date not null,
	c_qtype integer not null,
	c_state integer not null,
	c_seal integer not null,
	c_var integer not null,
	c_ownerid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_lsg to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_lsg () from 't_lsg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_lsg
\p\g
create table t_objdict(
	c_table varchar(8) not null,
	c_name varchar(8) not null,
	c_objectid integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_objdict to btree unique on
	c_table,
	c_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_objdict () from 't_objdict.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_objdict
\p\g
create table t_order(
	c_objectid integer not null,
	c_version integer not null,
	c_type integer not null,
	c_orderctrl integer not null,
	c_sequenceno integer not null,
	c_activationdatetime date not null,
	c_creationdatetime date not null,
	c_actproc integer,
	c_fitemorder integer,
	c_cmpgrp integer,
	c_jobcont integer,
	c_cont integer,
	c_software integer,
	c_softwarebase integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_order to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_order () from 't_order.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_order
\p\g
create table t_ownsite(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_siteid varchar(129) not null,
	c_location varchar(129) not null,
	c_address varchar(255) not null,
	c_tngname varchar(255) not null,
	c_admname varchar(65) not null,
	c_admphone varchar(65) not null,
	c_asmversion varchar(65) not null,
	c_releasedatetime date not null,
	c_installationdatetime date not null,
	c_creationdatetime date not null,
	c_changedatetime date not null,
	c_archivepath varchar(255) not null,
	c_remoteaddress varchar(255) not null,
	c_networktype integer not null,
	c_accessname varchar(9) not null,
	c_password varchar(9) not null,
	c_usercomment varchar(255) not null,
	c_uuid char(37) not null,
	c_agcnt integer not null,
	c_ownerid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_ownsite to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_ownsite () from 't_ownsite.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_ownsite
\p\g
create table t_rsw(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_packagesize integer not null,
	c_packagetype integer not null,
	c_itemname varchar(129) not null,
	c_itemversion varchar(129) not null,
	c_itemtype integer not null,
	c_sourcemedium integer not null,
	c_productname varchar(129) not null,
	c_productversion varchar(129) not null,
	c_filedby integer not null,
	c_supplier varchar(255) not null,
	c_comment varchar(255) not null,
	c_creationdatetime date not null,
	c_changedatetime date not null,
	c_activationproc integer not null,
	c_recnotification integer not null,
	c_singlemediasourcepath varchar(255) not null,
	c_singlemediasourcepathentered varchar(255) not null,
	c_archpath varchar(255),
	c_archuser varchar(129),
	c_archcomment varchar(255),
	c_archtime integer not null,
	c_addsize integer not null,
	c_archflag integer not null,
	c_flags integer not null,
	c_crc32 integer not null,
	c_basedon integer,
	c_deliverproc integer,
	c_undeliverproc integer,
	c_ownerid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_rsw to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_rsw () from 't_rsw.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_rsw
\p\g
create table t_sdusers(
	c_objectid integer not null,
	c_version integer not null,
	c_username varchar(129) not null,
	c_domain varchar(129) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_sdusers to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_sdusers () from 't_sdusers.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_sdusers
\p\g
create table t_swfold(
	c_objectid integer not null,
	c_version integer not null,
	c_acl byte varying(65) not null,
	c_type integer not null,
	c_attributes integer not null,
	c_name varchar(129) not null,
	c_comment varchar(255) not null,
	c_credatetime date not null,
	c_chdatetime date not null,
	c_propflag integer not null,
	c_qcalendar varchar(33) not null,
	c_qevalrate integer not null,
	c_qnextevaldatetime date not null,
	c_qevaldatetime date not null,
	c_qtype integer not null,
	c_state integer not null,
	c_seal integer not null,
	c_var integer not null,
	c_ownerid integer,
	c_cmpgrp integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_swfold to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_swfold () from 't_swfold.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_swfold
\p\g
create table t_task(
	c_objectid integer not null,
	c_version integer not null,
	c_referredentity integer not null,
	c_tasktype integer not null,
	c_taskstate integer not null,
	c_creationtime date not null,
	c_activationtime date not null,
	c_transactiontime date not null,
	c_runningstate integer not null,
	c_runcounter integer not null,
	c_lasteventmsgtime date not null,
	c_noofmsgparameters integer not null,
	c_lasteventmsgid integer not null,
	c_eventmsgparams varchar(1024)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_task to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_task () from 't_task.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_task
\p\g
create table t_volume(
	c_objectid integer not null,
	c_version integer not null,
	c_name varchar(129) not null,
	c_comment varchar(255) not null,
	c_number integer not null,
	c_rsw integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify t_volume to btree unique on
	c_objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy t_volume () from 't_volume.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on t_volume
\p\g
create table tab_map(
	oid integer not null,
	tab_schem varchar(18),
	tab_name varchar(18),
	tag varchar(64),
	oid_col varchar(18)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tab_map to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tab_map () from 'tab_map.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tab_map
\p\g
create table tab_priv(
	tab_priv_id decimal(5,0) not null,
	grantee_id decimal(5,0),
	owner_id decimal(5,0),
	table_id decimal(5,0),
	grantor_id decimal(5,0),
	privilege varchar(40),
	grantable decimal(5,0),
	collect_id decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tab_priv to btree unique on
	tab_priv_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy tab_priv () from 'tab_priv.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tab_priv
\p\g
create table tabledefinition(
	tableidx integer not null,
	nameoftable varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tabledefinition to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tabledefinition () from 'tabledefinition.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tabledefinition
\p\g
create table tableindex(
	tablename varchar(32) not null,
	indexes varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tableindex to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tableindex () from 'tableindex.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tableindex
\p\g
create table tablejoins(
	srctable varchar(32),
	desttable varchar(32),
	joins varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tablejoins to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tablejoins () from 'tablejoins.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tablejoins
\p\g
create table tablesdescription(
	oididxformib integer not null,
	mibidx integer not null,
	tableidx integer not null,
	orderofcolumn integer not null,
	typeofsaving c1 not null,
	collectable c1 not null default 'Y'
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tablesdescription to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tablesdescription () from 'tablesdescription.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tablesdescription
\p\g
create integrity  ON TablesDescription IS TypeOfSaving IN ('F', 'L')
\p\g
create table tablespace(
	tablespace_id decimal(5,0) not null,
	ts# decimal(5,0),
	collect_id decimal(5,0),
	tablespace_name varchar(30) not null,
	initial_extent decimal(5,0),
	next_extent decimal(5,0),
	min_extents decimal(5,0),
	max_extents decimal(5,0),
	pct_increase decimal(5,0),
	min_extlen decimal(5,0),
	status decimal(1,0),
	"temporary" decimal(1,0),
	logging decimal(1,0),
	blocksize decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tablespace to btree unique on
	tablespace_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy tablespace () from 'tablespace.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tablespace
\p\g
create table task(
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	description_blob_id decimal(31,0),
	task_notes_blob_id decimal(31,0),
	parent_task_id decimal(31,0),
	template_id decimal(31,0),
	kernel_id decimal(31,0),
	task_type_id decimal(31,0),
	type_id decimal(31,0),
	status_id decimal(31,0),
	wbs_component varchar(400),
	sibling_rank integer,
	task_name varchar(120) not null,
	task_description varchar(400),
	task_notes varchar(400),
	scheduling_priority integer,
	fixed_duration integer,
	instantiation_rule varchar(400),
	scheduler_foreign_attribute varchar(400),
	logical_delete_flag smallint,
	task_is_mandatory_flag smallint,
	task_is_heading smallint,
	task_is_childhidden smallint,
	task_is_selected smallint,
	task_is_connected smallint,
	task_is_headend smallint,
	task_is_schedule_asgn smallint,
	task_is_children_task smallint,
	task_type_driven smallint,
	task_pert_row decimal(31,0),
	task_pert_col decimal(31,0),
	task_pert_head_row integer,
	task_pert_head_col integer,
	task_outline_row decimal(31,0),
	task_outline_col decimal(31,0),
	task_sq decimal(31,0),
	task_decimal_predecessors integer,
	task_decimal_successors integer,
	task_estimated_duration decimal(31,0),
	task_act_duration decimal(31,0),
	task_remain_duration decimal(31,0),
	task_is_subproject smallint,
	task_is_linked smallint,
	task_type_dur_estimated smallint,
	task_type_dur_act smallint,
	task_project_link smallint,
	task_sq2 decimal(31,0),
	task_proj_link_type smallint,
	task_is_readonly_sub smallint,
	task_is_not_splitable smallint,
	task_type_dur_upd smallint,
	task_upd_duration decimal(31,0),
	task_tot_var_cost float,
	task_tot_fix_cost float,
	task_tot_ovt_cost float,
	task_tot_ovhead_cost float,
	task_tot_act_var_cost float,
	task_tot_act_fix_cost float,
	task_tot_act_ovt_cost float,
	task_tot_act_ovhead_cost float,
	task_tot_base_var_cost float,
	task_tot_base_fix_cost float,
	task_tot_bcwp float,
	task_tot_asgn_hrs decimal(31,0),
	task_tot_ovt_hrs decimal(31,0),
	task_tot_oversch_hrs decimal(31,0),
	task_tot_act_hrs decimal(31,0),
	task_tot_act_ovt_hrs decimal(31,0),
	task_tot_base_hrs decimal(31,0),
	task_tot_mat_hrs decimal(31,0),
	task_tot_act_mat_hrs decimal(31,0),
	task_tot_upd_var_cost float,
	task_tot_upd_fix_cost float,
	task_tot_upd_ovt_cost float,
	task_tot_upd_hrs decimal(31,0),
	task_tot_upd_ovt_hrs decimal(31,0),
	task_tot_remain_hrs decimal(31,0),
	task_tot_remain_cost float,
	task_tot_base_cost float,
	task_tot_cost float,
	task_tot_act_cost float,
	task_wbs varchar(400),
	task_interlinked_proj_name varchar(120),
	task_interlinked_task_name varchar(120),
	task_interlinked_proj_id decimal(31,0),
	task_deviation float,
	task_optimistic_duration decimal(31,0),
	task_likely_duration decimal(31,0),
	task_pessimistic_duration decimal(31,0),
	task_sched_duration decimal(31,0),
	task_type_base_dur decimal(31,0),
	task_base_duration decimal(31,0),
	task_external_proj_task_id decimal(31,0),
	task_base_decimal_of decimal(31,0),
	task_sched_start_datetime date,
	task_sched_finish_datetime date,
	task_must_start_datetime date,
	task_must_finish_datetime date,
	task_priority decimal(31,0),
	task_type_dur_sched smallint,
	task_type_dur_start_delay smallint,
	task_type_must_start smallint,
	task_type_must_finish smallint,
	task_is_critical smallint,
	task_is_conflict smallint,
	task_is_negative_slack smallint,
	task_is_ent_act smallint,
	task_is_duplicate smallint,
	task_is_ent_start_delay smallint,
	task_is_ent_percent smallint,
	task_is_negative_delay smallint,
	task_is_node smallint,
	task_is_ent_act_start smallint,
	task_is_ent_act_finish smallint,
	task_early_start_datetime date,
	task_early_finish_datetime date,
	task_late_start_datetime date,
	task_late_finish_datetime date,
	task_act_start_datetime date,
	task_act_finish_datetime date,
	task_float_start_date date,
	task_base_start_datetime date,
	task_base_finish_datetime date,
	task_start_delay integer,
	task_percent_complete decimal(31,0),
	task_constraint_type varchar(120),
	task_constraint_date date,
	task_mgr_rsrc_code varchar(400),
	task_mgr_rsrc_name varchar(120),
	task_mgr_rsrc_id decimal(31,0),
	task_asgn_root_id decimal(31,0),
	task_child_id decimal(31,0),
	task_sibling_id decimal(31,0),
	msp_cost_variance decimal(31,2),
	msp_dur_variance decimal(31,0),
	msp_finish_variance decimal(31,0),
	msp_start_variance decimal(31,0),
	msp_work_variance decimal(31,2),
	pww_locked smallint,
	pww_short_name varchar(120),
	pww_task_category varchar(120),
	hyperguide_keyword varchar(400),
	pe_scheduler_id varchar(120),
	origin_flag integer,
	is_collapsed integer,
	pmw_task_key integer,
	is_blob smallint,
	total_cost float,
	creation_datetime date,
	creation_user_name varchar(120),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task () from 'task.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task
\p\g
create table task_kernel_link(
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	kernel_id decimal(31,0) not null,
	link_instance_index integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_kernel_link to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_kernel_link () from 'task_kernel_link.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_kernel_link
\p\g
create table task_keyword(
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_keyword () from 'task_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_keyword
\p\g
create table task_links(
	project_id decimal(31,0) not null,
	link_task_id_successor decimal(31,0) not null,
	link_task_id_predecessor decimal(31,0) not null,
	product_instance_id decimal(31,0),
	link_type_id decimal(31,0),
	link_leadlag decimal(31,0),
	link_column integer,
	link_is_selected smallint,
	link_is_critical smallint,
	link_is_checked smallint,
	link_is_hrs smallint,
	link_type_dur smallint,
	link_is_percent smallint,
	link_is_elapsed smallint,
	link_is_fliplink smallint,
	link_pert_column integer,
	deleted_for_link integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_links to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_links () from 'task_links.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_links
\p\g
create table task_metric_formula(
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	estimating_method_id decimal(31,0) not null,
	formula_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_metric_formula to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_metric_formula () from 'task_metric_formula.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_metric_formula
\p\g
create table task_metric_value(
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	metric_value_set_id decimal(31,0) not null,
	formula_id decimal(31,0),
	value float,
	value_last_update date,
	derivation_source decimal(31,0),
	project_manager_assumptions varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify task_metric_value to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy task_metric_value () from 'task_metric_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_metric_value
\p\g
create table task_metric_wt(
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	metric_id decimal(31,0) not null,
	weight integer,
	weight_last_updated integer,
	deleted_for_link integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_metric_wt to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_metric_wt () from 'task_metric_wt.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_metric_wt
\p\g
create table task_originals_archive(
	project_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	revision_decimal integer not null,
	manual_original_hours decimal(31,0),
	manual_original_cost float,
	manual_original_start_date date,
	manual_original_finish_date date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_originals_archive to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_originals_archive () from 'task_originals_archive.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_originals_archive
\p\g
create table task_resource_assignment(
	asgn_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	task_id decimal(31,0),
	rsrc_id decimal(31,0),
	status_id decimal(31,0),
	pe_scheduler_id varchar(120),
	task_name varchar(1200),
	status_name varchar(1200),
	wbs_component varchar(4000),
	task_wbs varchar(4000),
	asgn_notes varchar(4000),
	billable_flag smallint,
	asgn_billing_rate float,
	asgn_ovt_cost_percent float,
	asgn_ovt_billing_percent float,
	scheduler_load_factor integer,
	scheduler_attribute varchar(4000),
	responsibility varchar(4000),
	message_status integer,
	logical_delete_flag smallint,
	message_last_sent integer,
	ytd_hrs decimal(31,0),
	ytd_cost float,
	ptd_hrs decimal(31,0),
	ptd_cost float,
	previous_ytd_hrs decimal(31,0),
	previous_ytd_cost float,
	previous_ptd_hrs decimal(31,0),
	previous_ptd_cost float,
	previous_week_hrs decimal(31,0),
	previous_week_cost float,
	ptd_cost_regular float,
	ptd_cost_fixed float,
	ptd_cost_ovt float,
	ptd_cost_overhead float,
	ptd_hrs_regular decimal(31,0),
	ptd_hrs_ovt decimal(31,0),
	ptd_units integer,
	asgn_is_heading smallint,
	asgn_is_child_hidden smallint,
	asgn_is_selected smallint,
	asgn_is_xtype smallint,
	asgn_is_percent smallint,
	asgn_is_pjpublic smallint,
	asgn_is_lead smallint,
	asgn_is_level smallint,
	asgn_is_split smallint,
	asgn_is_duration smallint,
	asgn_is_first smallint,
	asgn_is_ent_act_fix smallint,
	asgn_is_ent_act_var smallint,
	asgn_units decimal(31,0),
	asgn_alloc_hrs decimal(31,0),
	asgn_act_units decimal(31,0),
	asgn_mat_alloc_units decimal(31,0),
	asgn_type_mat_alloc smallint,
	asgn_is_ent_act_hrs smallint,
	asgn_is_ent_rate smallint,
	asgn_is_ent_bcwp smallint,
	asgn_type_accrue smallint,
	asgn_is_use_max_hrs smallint,
	asgn_is_ent_act_ovt_cost smallint,
	asgn_is_ent_act_ovt_hrs smallint,
	asgn_is_mat_producer smallint,
	asgn_is_ent_units smallint,
	asgn_is_ent_act_units smallint,
	asgn_is_ent_act_reg_hrs smallint,
	asgn_is_ent_ovhead_cost smallint,
	asgn_hrs_firstday decimal(31,0),
	asgn_hrs_lastday decimal(31,0),
	asgn_hrs_firstday_latedate decimal(31,0),
	asgn_hrs_lastday_latedate decimal(31,0),
	asgn_hrs_level_delay decimal(31,0),
	asgn_has_costs decimal(31,0),
	asgn_sched_order decimal(31,0),
	asgn_is_ent_upd_reg_cost smallint,
	asgn_is_ent_upd_ovhead_cost smallint,
	asgn_is_ent_upd_fix_cost smallint,
	asgn_is_not_splitable smallint,
	asgn_is_ent_heading_act_hrs smallint,
	asgn_is_email_outstanding smallint,
	asgn_is_proj_summary smallint,
	asgn_split_alloc_hrs decimal(31,0),
	asgn_expertise decimal(31,0),
	asgn_is_expertise_ent smallint,
	asgn_tot_var_cost float,
	asgn_tot_fix_cost float,
	asgn_tot_ovt_cost float,
	asgn_tot_ovhead_cost float,
	asgn_tot_act_var_cost float,
	asgn_tot_act_fix_cost float,
	asgn_tot_act_ovt_cost float,
	asgn_tot_act_ovhead_cost float,
	asgn_tot_act_cost float,
	asgn_tot_base_var_cost float,
	asgn_tot_base_fix_cost float,
	asgn_tot_bcwp float,
	asgn_tot_asgn_hrs decimal(31,0),
	asgn_tot_ovt_hrs decimal(31,0),
	asgn_tot_cost float,
	asgn_tot_base_cost float,
	asgn_tot_oversch_hrs decimal(31,0),
	asgn_tot_act_hrs decimal(31,0),
	asgn_tot_act_ovt_hrs decimal(31,0),
	asgn_tot_base_hrs decimal(31,0),
	asgn_tot_mat_hrs decimal(31,0),
	asgn_tot_act_mat_hrs decimal(31,0),
	asgn_tot_upd_var_cost float,
	asgn_tot_upd_fix_cost float,
	asgn_tot_upd_ovt_cost float,
	asgn_tot_upd_hrs decimal(31,0),
	asgn_tot_upd_ovt_hrs decimal(31,0),
	asgn_tot_remain_hrs decimal(31,0),
	asgn_tot_remain_cost float,
	asgn_cost_fix float,
	asgn_cost_rate float,
	asgn_cost_act_var float,
	asgn_cost_act_fix float,
	asgn_cost_act_ovt float,
	asgn_cost_bcwp float,
	asgn_cost_upd_reg float,
	asgn_cost_upd_ovt float,
	asgn_cost_upd_fix float,
	asgn_base_decimal_of decimal(31,0),
	asgn_sched_start_datetime date,
	asgn_sched_finish_datetime date,
	asgn_must_start_datetime date,
	asgn_must_finish_datetime date,
	asgn_priority decimal(31,0),
	asgn_type_dur_sched smallint,
	asgn_type_dur_start_delay smallint,
	asgn_type_must_start smallint,
	asgn_type_must_finish smallint,
	asgn_is_critical smallint,
	asgn_is_conflict smallint,
	asgn_is_negative_slack smallint,
	asgn_is_ent_act smallint,
	asgn_is_duplicate smallint,
	asgn_is_ent_start_delay smallint,
	asgn_is_ent_percent smallint,
	asgn_is_negative_delay smallint,
	asgn_is_node smallint,
	asgn_type_task smallint,
	asgn_is_ent_act_start smallint,
	asgn_is_ent_act_finish smallint,
	asgn_is_subhook smallint default 0,
	asgn_early_start_datetime date,
	asgn_early_finish_datetime date,
	asgn_late_start_datetime date,
	asgn_late_finish_datetime date,
	asgn_act_start_datetime date,
	asgn_act_finish_datetime date,
	asgn_float_start_datetime date,
	asgn_base_start_datetime date,
	asgn_base_finish_datetime date,
	asgn_start_delay decimal(31,0),
	asgn_percent_complete decimal(31,0),
	asgn_acct_sibling_id_1 decimal(31,0),
	asgn_acct_sibling_id_2 decimal(31,0),
	asgn_acct_sibling_id_3 decimal(31,0),
	asgn_acct_sibling_id_4 decimal(31,0),
	asgn_acct_sibling_id_5 decimal(31,0),
	asgn_dl_sibling_id decimal(31,0),
	asgn_task_sibling_id decimal(31,0),
	asgn_rsrc_sibling_id decimal(31,0),
	asgn_acct_id_1 decimal(31,0),
	asgn_acct_id_2 decimal(31,0),
	asgn_acct_id_3 decimal(31,0),
	asgn_acct_id_4 decimal(31,0),
	asgn_acct_id_5 decimal(31,0),
	asgn_constraint_date date,
	asgn_constraint_type varchar(1200),
	pww_locked smallint,
	pww_pending_actuals smallint,
	p3_budgeted_quantity decimal(31,2),
	msp_start_variance decimal(31,0),
	msp_work_variance decimal(31,2),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify task_resource_assignment to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy task_resource_assignment () from 'task_resource_assignment.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_resource_assignment
\p\g
create table task_resource_time_history(
	time_period_id decimal(31,0) not null,
	rsrc_id decimal(31,0) not null,
	time_type_id decimal(31,0) not null,
	timesheet_entry_id decimal(31,0) not null,
	project_id decimal(31,0),
	non_project_event_id decimal(31,0),
	non_project_event_name varchar(120),
	task_id decimal(31,0),
	asgn_id decimal(31,0),
	task_name varchar(120),
	time_type_name varchar(120),
	project_code varchar(400),
	project_name varchar(120),
	rsrc_name varchar(120),
	project_manager_code varchar(400),
	project_manager_name varchar(120),
	rsrc_manager_code varchar(400),
	rsrc_manager_name varchar(120),
	task_wbs varchar(400),
	status_id decimal(31,0),
	status_name varchar(120),
	asgn_actual_start_datetime date,
	asgn_actual_finish_datetime date,
	asgn_sched_start_datetime date,
	asgn_sched_finish_datetime date,
	tot_sched_hrs decimal(31,0),
	tot_sched_cost float,
	tot_post_reg_hrs decimal(31,0),
	tot_post_ovt_hrs decimal(31,0),
	tot_post_hrs decimal(31,0),
	asgn_actual_tot_hrs decimal(31,0),
	asgn_actual_ovt_hrs decimal(31,0),
	asgn_actual_reg_hrs decimal(31,0),
	asgn_actual_ovt_cost float,
	asgn_actual_reg_cost float,
	asgn_actual_tot_cost float,
	asgn_tot_remain_hrs decimal(31,0),
	asgn_tot_remain_cost float,
	prev_asgn_actual_tot_cost float,
	prev_asgn_actual_ovt_cost float,
	prev_asgn_actual_reg_cost float,
	prev_asgn_actual_tot_hrs decimal(31,0),
	prev_asgn_actual_ovt_hrs decimal(31,0),
	prev_asgn_actual_reg_hrs decimal(31,0),
	previous_week_etc_hrs decimal(31,0),
	approval_flag smallint,
	expense_report_id decimal(31,0),
	expense_amount float,
	billable_flag smallint,
	project_account_code varchar(400),
	account_name varchar(120),
	department_code varchar(400),
	department_name varchar(120),
	asgn_notes varchar(400),
	asgn_notes_for_time_period varchar(400),
	sunday_hrs decimal(31,0),
	monday_hrs decimal(31,0),
	tuesday_hrs decimal(31,0),
	wednesday_hrs decimal(31,0),
	thursday_hrs decimal(31,0),
	friday_hrs decimal(31,0),
	saturday_hrs decimal(31,0),
	sunday_billing_rate float,
	monday_billing_rate float,
	tuesday_billing_rate float,
	wednesday_billing_rate float,
	thursday_billing_rate float,
	friday_billing_rate float,
	saturday_billing_rate float,
	sunday_ovt_billing_percent float,
	monday_ovt_billing_percent float,
	tuesday_ovt_billing_percent float,
	wednesday_ovt_billing_percent float,
	thursday_ovt_billing_percent float,
	friday_ovt_billing_percent float,
	saturday_ovt_billing_percent float,
	sunday_cost_rate float,
	monday_cost_rate float,
	tuesday_cost_rate float,
	wednesday_cost_rate float,
	thursday_cost_rate float,
	friday_cost_rate float,
	saturday_cost_rate float,
	sunday_ovt_cost_percent float,
	monday_ovt_cost_percent float,
	tuesday_ovt_cost_percent float,
	wednesday_ovt_cost_percent float,
	thursday_ovt_cost_percent float,
	friday_ovt_cost_percent float,
	saturday_ovt_cost_percent float,
	manual_etc_hrs_flag smallint,
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(120),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_resource_time_history to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_resource_time_history () from 'task_resource_time_history.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_resource_time_history
\p\g
create table task_role_assignment(
	project_id decimal(31,0) not null,
	role_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	responsibility varchar(4000),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify task_role_assignment to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy task_role_assignment () from 'task_role_assignment.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_role_assignment
\p\g
create table task_rsrc_asgn_metric_value(
	metric_value_set_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	asgn_id decimal(31,0) not null,
	value float,
	derivation_source decimal(31,0),
	project_manager_assumptions varchar(4000),
	value_last_update date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify task_rsrc_asgn_metric_value to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy task_rsrc_asgn_metric_value () from 'task_rsrc_asgn_metric_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_rsrc_asgn_metric_value
\p\g
create table task_rsrc_asgn_metric_wt(
	metric_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	asgn_id decimal(31,0) not null,
	weight integer,
	weight_last_updated integer,
	deleted_for_link integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify task_rsrc_asgn_metric_wt to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy task_rsrc_asgn_metric_wt () from 'task_rsrc_asgn_metric_wt.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_rsrc_asgn_metric_wt
\p\g
create table task_rsrc_role_assign(
	project_id decimal(31,0) not null,
	asgn_id decimal(31,0) not null,
	role_id decimal(31,0) not null,
	efficiency_id decimal(31,0),
	responsibility varchar(4000),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify task_rsrc_role_assign to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy task_rsrc_role_assign () from 'task_rsrc_role_assign.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_rsrc_role_assign
\p\g
create table task_sched_prop_value(
	task_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	scheduler_property_id decimal(31,0) not null,
	value float,
	description varchar(4000),
	derivation_source decimal(31,0),
	project_manager_assumptions varchar(4000),
	value_last_update date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify task_sched_prop_value to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy task_sched_prop_value () from 'task_sched_prop_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_sched_prop_value
\p\g
create table task_type(
	task_type_id decimal(31,0) not null,
	task_type_name varchar(1200) not null,
	task_type_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify task_type to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy task_type () from 'task_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on task_type
\p\g
create table tau_mdb(
	mdbmajorversion integer not null,
	mdbminorversion integer not null,
	releasedate date not null,
	installdate date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tau_mdb to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tau_mdb () from 'tau_mdb.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tau_mdb
\p\g
create table tau_mdb_product(
	mdbmajorversion integer not null,
	mdbminorversion integer not null,
	productname varchar(64) not null,
	productmajorversion integer not null,
	productminorversion integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tau_mdb_product to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tau_mdb_product () from 'tau_mdb_product.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tau_mdb_product
\p\g
create table tau_product(
	productname varchar(64) not null,
	productmajorversion integer not null,
	productminorversion integer not null,
	releasedate date not null,
	installcount integer not null default 0
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tau_product to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tau_product () from 'tau_product.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tau_product
\p\g
create table team(
	team_id decimal(31,0) not null,
	team_name varchar(1200),
	team_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify team to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy team () from 'team.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on team
\p\g
create table technique(
	technique_id decimal(31,0) not null,
	parent_technique_id decimal(31,0),
	technique_class_id decimal(31,0),
	instantiation_source_id decimal(31,0),
	product_instance_id decimal(31,0),
	reference_id varchar(120),
	alt_ref_id varchar(120),
	opruid decimal(31,0),
	technique_name varchar(4000),
	technique_description varchar(4000),
	command_line varchar(4000),
	dw_touched smallint,
	logical_delete_flag smallint,
	ref_name varchar(4000),
	alt_ref_name varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify technique to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy technique () from 'technique.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on technique
\p\g
create table technique_assignment(
	technique_id decimal(31,0) not null,
	task_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify technique_assignment to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy technique_assignment () from 'technique_assignment.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on technique_assignment
\p\g
create table technique_class(
	technique_class_id decimal(31,0) not null,
	technique_class_description varchar(4000) not null,
	creation_user_name varchar(1200),
	creation_datetime date,
	last_update_user_name varchar(1200),
	last_update_datetime date,
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify technique_class to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy technique_class () from 'technique_class.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on technique_class
\p\g
create table technique_keyword(
	technique_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify technique_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy technique_keyword () from 'technique_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on technique_keyword
\p\g
create table tempapprovehist(
	usrobjid integer not null,
	action varchar(100) not null,
	execdtime date not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tempapprovehist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tempapprovehist () from 'tempapprovehist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tempapprovehist
\p\g
create table tempapprovelist(
	isgroup char(1) not null,
	usrobjid integer,
	usrgrpobjid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tempapprovelist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tempapprovelist () from 'tempapprovelist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tempapprovelist
\p\g
create table tempbaselinefields(
	fieldvalue float not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tempbaselinefields to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tempbaselinefields () from 'tempbaselinefields.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table template_class(
	template_class_id decimal(31,0) not null,
	template_class_description varchar(4000) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify template_class to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy template_class () from 'template_class.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on template_class
\p\g
create table template_class_keyword(
	template_class_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify template_class_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy template_class_keyword () from 'template_class_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on template_class_keyword
\p\g
create table template_keyword(
	template_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify template_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy template_keyword () from 'template_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on template_keyword
\p\g
create table template_uses_product(
	product_instance_id decimal(31,0) not null,
	template_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify template_uses_product to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy template_uses_product () from 'template_uses_product.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on template_uses_product
\p\g
create table templatebob(
	templateid integer not null,
	templatejobid integer not null,
	jobname varchar(100),
	instancename varchar(100),
	regionid integer,
	jobowner varchar(255),
	boxjobid integer,
	jobtype varchar(32),
	jobleft integer,
	jobright integer,
	jobtop integer,
	jobbottom integer,
	as_condition text(1),
	as_dateconditions varchar(100),
	as_machine varchar(255),
	as_startmins text(1),
	as_starttimes text(1),
	as_command text(1),
	as_description text(1),
	as_watchfile text(1),
	as_watchfileminsize varchar(255),
	boxname varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify templatebob to btree unique on
	templateid,
	templatejobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy templatebob () from 'templatebob.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on templatebob
\p\g
create table templatebob1(
	templateid integer not null,
	templatejobid integer not null,
	as_alarmiffail varchar(50),
	as_autodelete varchar(50),
	as_autohold varchar(50),
	as_boxfailure text(1),
	as_boxsuccess text(1),
	as_boxterminator varchar(50),
	as_chkfiles text(1),
	as_daysofweek varchar(140),
	as_excludecalendar varchar(90),
	as_heartbeatinterval varchar(50),
	as_jobload varchar(50),
	as_jobterminator varchar(50),
	as_maxexitsuccess text(1),
	as_maxrunalarm varchar(50),
	as_minrunalarm varchar(50),
	as_nretrys varchar(50),
	as_permission varchar(90),
	as_priority varchar(50),
	as_profile text(1),
	as_runcalendar varchar(90),
	as_runwindow varchar(90),
	as_stderrfile text(1),
	as_stdinfile text(1),
	as_stdoutfile text(1),
	as_termruntime varchar(50),
	as_timezone varchar(90),
	as_watchinterval varchar(80)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify templatebob1 to btree unique on
	templateid,
	templatejobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy templatebob1 () from 'templatebob1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on templatebob1
\p\g
create table templatebob2(
	templateid integer not null,
	templatejobid integer not null,
	bagname varchar(100),
	job_mode varchar(100),
	application varchar(100),
	as_group varchar(100),
	max_concur_runs varchar(50),
	save_cycles varchar(50),
	restart_wait varchar(50),
	run_as_ptid varchar(100),
	not_after_start_time varchar(50),
	pre_load_mins varchar(50),
	alarm_start_late varchar(50),
	avg_duration varchar(50),
	operator_ok varchar(50),
	app_status_var varchar(100),
	sched_name varchar(100),
	job_variable varchar(100),
	kill_signal text(1),
	target_mode varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify templatebob2 to btree unique on
	templateid,
	templatejobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy templatebob2 () from 'templatebob2.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on templatebob2
\p\g
create table templateparameters(
	templateid integer not null,
	udpid integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify templateparameters to btree unique on
	templateid,
	udpid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy templateparameters () from 'templateparameters.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on templateparameters
\p\g
create table templateudpvalues(
	templateid integer not null,
	udpid integer not null,
	objectid integer not null,
	instanceid integer not null,
	strvalue text(1),
	textvalue text(1),
	intvalue text(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify templateudpvalues to btree unique on
	templateid,
	udpid,
	objectid,
	instanceid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy templateudpvalues () from 'templateudpvalues.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on templateudpvalues
\p\g
create table templateworkloadjob1(
	templateid integer not null,
	instancename varchar(100),
	jobtype varchar(50),
	regionid integer,
	boxjobid integer,
	jobleft integer,
	jobright integer,
	jobtop integer,
	jobbottom integer,
	templatejobid integer,
	jobname varchar(100),
	applicationid varchar(50),
	abendaction varchar(100),
	anycpu varchar(50),
	autosel varchar(50),
	autostart varchar(50),
	averagetime varchar(50),
	backlog varchar(50),
	calendar varchar(50),
	createdate varchar(50),
	createtime varchar(50),
	createuser varchar(100),
	adjustment varchar(50),
	critcal varchar(50),
	crithact varchar(50),
	critnwact varchar(50),
	critkeys text(1),
	cycfreq varchar(50),
	cyccount varchar(50),
	cyclic varchar(50),
	wk_condition text(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify templateworkloadjob1 to btree unique on
	templateid,
	templatejobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy templateworkloadjob1 () from 'templateworkloadjob1.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on templateworkloadjob1
\p\g
create table templateworkloadjob2(
	templateid integer not null,
	templatejobid integer not null,
	earlytime varchar(50),
	effectivedate varchar(50),
	expiresdate varchar(50),
	failcondl varchar(50),
	failcondh varchar(50),
	history varchar(50),
	hold varchar(50),
	jobnumber varchar(5),
	interruptible varchar(50),
	boxname varchar(100),
	maxtime varchar(50),
	mustcomptime varchar(50),
	muststarttime varchar(50),
	subuserid varchar(50),
	subdomain varchar(50),
	subpass varchar(100),
	subfile text(1),
	priority varchar(50),
	settype varchar(50),
	skip varchar(50),
	station varchar(50),
	updatedate varchar(50),
	updatetime varchar(50),
	updateuser varchar(50),
	userenv varchar(50),
	description text(1),
	type varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify templateworkloadjob2 to btree unique on
	templateid,
	templatejobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy templateworkloadjob2 () from 'templateworkloadjob2.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on templateworkloadjob2
\p\g
create table tempstats(
	server_addr integer,
	probe_addr integer,
	intervaldatetime date,
	intervalduration integer,
	stat1 float,
	stat2 float,
	stat3 float,
	stat4 float,
	stat5 float,
	stat6 float,
	stat7 float,
	stat8 float,
	stat9 float,
	stat10 float,
	stat11 float,
	stat12 float,
	stat13 float,
	stat14 float,
	stat15 float,
	stat16 float,
	stat17 float,
	stat18 float,
	stat19 float,
	stat20 float,
	stat21 float,
	stat22 float,
	stat23 float,
	stat24 float,
	stat25 float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tempstats to btree on
	probe_addr,
	intervaldatetime
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy tempstats () from 'tempstats.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table term_operator(
	term_operator_id decimal(31,0) not null,
	value integer,
	derivation_source varchar(4000),
	parent_formula_id decimal(31,0),
	sibling_rank integer,
	isterm smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify term_operator to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy term_operator () from 'term_operator.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on term_operator
\p\g
create table threadx(
	oid integer not null,
	qmgr_oid integer not null,
	name char(8) not null,
	st char(2),
	a char(1),
	req integer,
	thread_xref varchar(24),
	userid char(8),
	asid char(5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify threadx to heap
with extend = 16,
	allocation = 4
\p\g
/* copy threadx () from 'threadx.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on threadx
\p\g
create table thresholdconst(
	fieldindex integer not null,
	constant i1 not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify thresholdconst to hash unique on
	fieldindex
with fillfactor = 50,
	extend = 4
\p\g
/* copy thresholdconst () from 'thresholdconst.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 20, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on thresholdconst
\p\g
create table thresholddesc(
	fieldindex integer not null,
	mibidx integer,
	thresholdorfilter c1 not null,
	fieldname varchar(32),
	fielddescshort varchar(64),
	fielddesclong varchar(255) not null,
	unit varchar(32),
	weight float,
	lowerdefaultmode byte(1),
	lowerdefaultvalue float,
	lowerboundmin float,
	lowerboundmax float,
	operationandoperandbufferl long byte,
	lengthofbufferl integer,
	upperdefaultmode byte(1),
	upperdefaultvalue float,
	upperboundmin float,
	upperboundmax float,
	operationandoperandbufferu long byte,
	lengthofbufferu integer,
	criticalthreshold integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify thresholddesc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy thresholddesc () from 'thresholddesc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on thresholddesc
\p\g
create table thresholdformula(
	fieldindex integer not null,
	tablename varchar(32) not null,
	columnname varchar(64) not null,
	formula varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify thresholdformula to heap
with extend = 16,
	allocation = 4
\p\g
/* copy thresholdformula () from 'thresholdformula.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on thresholdformula
\p\g
create table thresholds(
	server_addr integer not null,
	probe_addr integer not null,
	mibidx integer,
	rsrcindex integer not null,
	rsrcotherindex integer not null,
	fieldindex integer not null,
	lowerthreshold float not null,
	lowermode i1 not null,
	upperthreshold float not null,
	uppermode i1 not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify thresholds to btree on
	probe_addr,
	rsrcindex,
	rsrcotherindex,
	fieldindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy thresholds () from 'thresholds.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on thresholds
\p\g
create table time_period(
	time_period_id integer not null,
	name varchar(255),
	creation_date date,
	modification_date date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify time_period to btree unique on
	time_period_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy time_period () from 'time_period.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on time_period
\p\g
create table time_period_attribute(
	time_period_attribute_id integer not null,
	type integer,
	all_day decimal(1,0),
	start_hour integer,
	end_hour integer,
	days_of_month varchar(32),
	time_period_id integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify time_period_attribute to btree unique on
	time_period_attribute_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy time_period_attribute () from 'time_period_attribute.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on time_period_attribute
\p\g
create table time_type(
	time_type_id decimal(31,0) not null,
	time_type_name varchar(1200) not null,
	post_to_time_type_id decimal(31,0),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify time_type to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy time_type () from 'time_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on time_type
\p\g
create table timedevent(
	eventtime float not null,
	processid varchar(20) not null,
	id varchar(20) not null,
	duedate float not null,
	parentid varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify timedevent to heap
with extend = 16,
	allocation = 4
\p\g
/* copy timedevent () from 'timedevent.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on timedevent
\p\g
create table timesheet(
	rsrc_id decimal(31,0) not null,
	time_period_id decimal(31,0) not null,
	posted_date date,
	all_posted_flag smallint,
	timesheet_notes varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify timesheet to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy timesheet () from 'timesheet.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on timesheet
\p\g
create table timesheet_entry(
	timesheet_entry_id decimal(31,0) not null,
	rsrc_id decimal(31,0),
	time_period_id decimal(31,0),
	project_id decimal(31,0),
	frequency_id decimal(31,0),
	task_id decimal(31,0),
	asgn_id decimal(31,0),
	non_project_event_id decimal(31,0),
	time_type_name varchar(120),
	project_code varchar(400),
	project_name varchar(120),
	rsrc_code varchar(400),
	rsrc_name varchar(120),
	project_manager_code varchar(400),
	project_manager_name varchar(120),
	rsrc_manager_code varchar(400),
	rsrc_manager_name varchar(120),
	task_wbs varchar(400),
	task_name varchar(120),
	status_id decimal(31,0),
	status_name varchar(120),
	department_code varchar(400),
	department_name varchar(120),
	project_account_code varchar(400),
	project_account_name varchar(120),
	tot_post_reg_hrs decimal(31,0),
	tot_post_ovt_hrs decimal(31,0),
	tot_post_hrs decimal(31,0),
	asgn_actual_reg_hrs decimal(31,0),
	asgn_actual_ovt_hrs decimal(31,0),
	asgn_actual_tot_hrs decimal(31,0),
	asgn_actual_start_datetime date,
	asgn_actual_finish_datetime date,
	asgn_actual_ovt_cost float,
	asgn_actual_reg_cost float,
	asgn_actual_tot_cost float,
	prev_asgn_actual_tot_cost float,
	prev_asgn_actual_ovt_cost float,
	prev_asgn_actual_reg_cost float,
	tot_post_cost float,
	tot_post_ovt_cost float,
	tot_post_reg_cost float,
	tot_sched_cost float,
	prev_asgn_actual_tot_hrs decimal(31,0),
	prev_asgn_actual_ovt_hrs decimal(31,0),
	prev_asgn_actual_reg_hrs decimal(31,0),
	prev_week_etc_hrs decimal(31,0),
	asgn_tot_remain_hrs decimal(31,0),
	asgn_tot_remain_cost decimal(31,2),
	tot_sched_hrs decimal(31,0),
	asgn_sched_start_datetime date,
	asgn_sched_finish_datetime date,
	asgn_notes varchar(400),
	asgn_notes_for_time_period varchar(400),
	expense_report_id decimal(31,0),
	expense_report_amount float,
	non_project_event_name varchar(120),
	sunday_billing_rate float,
	monday_billing_rate float,
	tuesday_billing_rate float,
	wednesday_billing_rate float,
	thursday_billing_rate float,
	friday_billing_rate float,
	saturday_billing_rate float,
	sunday_ovt_billing_percent float,
	monday_ovt_billing_percent float,
	tuesday_ovt_billing_percent float,
	wednesday_ovt_billing_percent float,
	thursday_ovt_billing_percent float,
	friday_ovt_billing_percent float,
	saturday_ovt_billing_percent float,
	sunday_cost_rate float,
	monday_cost_rate float,
	tuesday_cost_rate float,
	wednesday_cost_rate float,
	thursday_cost_rate float,
	friday_cost_rate float,
	saturday_cost_rate float,
	sunday_ovt_cost_percent float,
	monday_ovt_cost_percent float,
	tuesday_ovt_cost_percent float,
	wednesday_ovt_cost_percent float,
	thursday_ovt_cost_percent float,
	friday_ovt_cost_percent float,
	saturday_ovt_cost_percent float,
	ready_for_approval_flag smallint,
	post_flag smallint,
	approval_flag smallint,
	billable_flag smallint,
	manual_etc_hrs_flag smallint,
	creation_datetime date,
	creation_user_name varchar(120),
	last_update_datetime date,
	last_update_user_name varchar(120),
	comments varchar(400)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify timesheet_entry to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy timesheet_entry () from 'timesheet_entry.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on timesheet_entry
\p\g
create table timesheet_entry_time(
	timesheet_entry_id decimal(31,0) not null,
	time_type_id decimal(31,0) not null,
	rsrc_id decimal(31,0),
	time_period_id decimal(31,0),
	project_id decimal(31,0),
	frequency_id decimal(31,0),
	task_id decimal(31,0),
	asgn_id decimal(31,0),
	non_project_event_id decimal(31,0),
	non_project_event_name varchar(1200),
	sunday_hrs decimal(31,0),
	monday_hrs decimal(31,0),
	tuesday_hrs decimal(31,0),
	wednesday_hrs decimal(31,0),
	thursday_hrs decimal(31,0),
	friday_hrs decimal(31,0),
	saturday_hrs decimal(31,0),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify timesheet_entry_time to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy timesheet_entry_time () from 'timesheet_entry_time.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on timesheet_entry_time
\p\g
create table timesheet_period(
	time_period_id decimal(31,0) not null,
	period_end_date date not null,
	all_rsrc_posted_flag smallint,
	period_close_flag smallint,
	split_period_close_flag smallint,
	split_week_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify timesheet_period to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy timesheet_period () from 'timesheet_period.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on timesheet_period
\p\g
create table timezones(
	name varchar(50) not null,
	type char(1) not null,
	zone varchar(50) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify timezones to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy timezones () from 'timezones.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on timezones
\p\g
create table tl_act_inst(
	c_activity integer not null,
	c_installation integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_act_inst to btree unique on
	c_activity,
	c_installation
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_act_inst () from 'tl_act_inst.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_act_inst
\p\g
create table tl_cmpgrp(
	c_grpparent integer not null,
	c_grpchild integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_cmpgrp to btree unique on
	c_grpparent,
	c_grpchild
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_cmpgrp () from 'tl_cmpgrp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_cmpgrp
\p\g
create table tl_grp_cmp(
	c_comp integer not null,
	c_grp integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_grp_cmp to btree unique on
	c_comp,
	c_grp
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_grp_cmp () from 'tl_grp_cmp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_grp_cmp
\p\g
create table tl_grp_proc(
	c_procgrp integer not null,
	c_proc integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_grp_proc to btree unique on
	c_procgrp,
	c_proc
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_grp_proc () from 'tl_grp_proc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_grp_proc
\p\g
create table tl_jc(
	c_jcparent integer not null,
	c_jcchild integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_jc to btree unique on
	c_jcparent,
	c_jcchild
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_jc () from 'tl_jc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_jc
\p\g
create table tl_lsg(
	c_lsgparent integer not null,
	c_lsgchild integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_lsg to btree unique on
	c_lsgchild,
	c_lsgparent
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_lsg () from 'tl_lsg.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_lsg
\p\g
create table tl_lsg_ls(
	c_lsg integer not null,
	c_ls integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_lsg_ls to btree unique on
	c_lsg,
	c_ls
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_lsg_ls () from 'tl_lsg_ls.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_lsg_ls
\p\g
create table tl_swg_sw(
	c_swg integer not null,
	c_sw integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_swg_sw to btree unique on
	c_swg,
	c_sw
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_swg_sw () from 'tl_swg_sw.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_swg_sw
\p\g
create table tl_swgrp(
	c_grpparent integer not null,
	c_grpchild integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tl_swgrp to btree unique on
	c_grpparent,
	c_grpchild
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tl_swgrp () from 'tl_swgrp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tl_swgrp
\p\g
create table tn(
	id integer not null,
	del integer not null,
	tn_name varchar(30),
	tn_dflt varchar(30),
	tn_sys varchar(30),
	tn_desc varchar(240)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify tn to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy tn () from 'tn.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tn
\p\g
create table tng_address_type(
	address_type integer not null,
	address_description varchar(255) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_address_type to btree unique on
	address_type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_address_type () from 'tng_address_type.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_adminstatus(
	admin_status integer not null,
	admin_text varchar(255) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_adminstatus to btree unique on
	admin_status
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_adminstatus () from 'tng_adminstatus.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_agent_info(
	poller_server char(20),
	dscvr_server char(20),
	agent_server char(20),
	poller_running integer,
	dscvr_running integer,
	agent_running integer,
	elog_name char(20),
	elog_server char(20),
	total_object integer,
	polled_object integer,
	total_fault integer,
	active_clients integer,
	severity1 integer,
	severity2 integer,
	severity3 integer,
	severity4 integer,
	severity5 integer,
	hopcount1 integer,
	hopcount2 integer,
	hopcount3 integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_agent_info to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy tng_agent_info () from 'tng_agent_info.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table tng_alarmset(
	name varchar(40) not null,
	comment varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_alarmset to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_alarmset () from 'tng_alarmset.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_alarmset_entry(
	alarmset_name varchar(40) not null,
	status_no integer not null,
	severity integer not null,
	propagate_status i1
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_alarmset_entry to btree unique on
	alarmset_name,
	status_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_alarmset_entry () from 'tng_alarmset_entry.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_auth(
	name varchar(40),
	access char(1),
	mask varchar(30)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_auth to btree on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_auth () from 'tng_auth.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_browser_menu(
	name varchar(30) not null,
	sequence_no integer not null,
	label varchar(30),
	method_name varchar(30),
	sub_popup_menu varchar(30),
	bitmap_name varchar(64),
	flag integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_browser_menu to btree unique on
	name,
	label,
	sequence_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_browser_menu () from 'tng_browser_menu.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_browser_method(
	name varchar(40) not null,
	type integer,
	exe_name varchar(255),
	parameter varchar(255),
	standalone i1,
	persistent i1
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_browser_method to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_browser_method () from 'tng_browser_method.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_ca_claim_discovery_tmp(
	ret integer,
	computer_name varchar(25),
	instance_no integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_ca_claim_discovery_tmp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tng_ca_claim_discovery_tmp () from 'tng_ca_claim_discovery_tmp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table tng_change_history(
	sequence_no integer not null,
	operation char(1) not null,
	class_name varchar(30) not null,
	object_id1 byte(16) not null,
	portnum1 integer,
	object_id2 byte(16),
	timestamp date,
	portnum2 integer,
	object_id3 byte(16),
	source_seq integer,
	dest_seq integer,
	user_name varchar(30)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_change_history to btree unique on
	sequence_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_change_history () from 'tng_change_history.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_city(
	uuid byte(16) not null,
	latitude float,
	background varchar(64),
	geomap varchar(255),
	longitude float
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_city to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_city () from 'tng_city.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_class(
	class_id integer not null,
	name varchar(30) not null,
	super_class_id integer not null,
	super_class_name varchar(30) not null,
	virtual_class i1 not null,
	map_visible i1 not null default 1,
	vr_visible i1 not null default 1,
	system_class i1 not null default 1,
	hidden_class i1 not null default 0,
	instance_storage varchar(45)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_class to btree unique on
	class_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_class () from 'tng_class.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_class_addport(
	class_name varchar(30) not null,
	port integer not null,
	portstring varchar(128),
	override_decal varchar(64)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_class_addport to btree on
	class_name,
	portstring
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_class_addport () from 'tng_class_addport.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_class_ext(
	class_id integer not null,
	name varchar(30) not null,
	datatype varchar(20) not null,
	length integer not null,
	property_group varchar(10),
	string varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_class_ext to btree unique on
	class_id,
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_class_ext () from 'tng_class_ext.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_class_reclass(
	class_rule varchar(30) not null,
	orig_class varchar(30) not null,
	oid varchar(128),
	oid_value varchar(128),
	new_class varchar(30) not null,
	override_decal varchar(64),
	port integer not null,
	oid_wildcard integer default 0,
	wildcard_cnt_oid varchar(128),
	rule_off integer default 0,
	search_order integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_class_reclass to btree on
	orig_class,
	oid,
	new_class
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_class_reclass () from 'tng_class_reclass.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_class_special(
	sysobjid varchar(128) not null,
	class_name varchar(30) not null,
	sysdescription varchar(128)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_class_special to btree on
	sysobjid,
	class_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_class_special () from 'tng_class_special.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_conflict_object(
	uuid byte(16) not null,
	contact varchar(128),
	location varchar(128),
	sysobjid varchar(128),
	description varchar(255),
	comment varchar(255),
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_conflict_object to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_conflict_object () from 'tng_conflict_object.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_country(
	uuid byte(16) not null,
	lower_left_lat float,
	lower_left_long float,
	upper_right_lat float,
	upper_right_long float,
	background varchar(64),
	geomap varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_country to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_country () from 'tng_country.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_dbpv(
	uuid byte(16) not null,
	refresh_rate integer,
	date_gathered date,
	target_obj_class varchar(30),
	target_obj_name varchar(200),
	notify_em smallint default 0,
	em_msg varchar(255),
	em_server varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_dbpv to btree on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_dbpv () from 'tng_dbpv.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_dhcp_scope(
	starting_address varchar(16) not null,
	ending_address varchar(16) not null,
	comment varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_dhcp_scope to btree unique on
	starting_address
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_dhcp_scope () from 'tng_dhcp_scope.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_discovery_ipsubnet(
	discovery_ipsubnet_id integer not null,
	name varchar(20),
	subnet_addr byte(4),
	subnet_mask byte(4),
	gateway1 byte(4),
	gateway2 byte(4),
	managed integer,
	time_stamp date,
	subnet_addr_str char(15),
	subnet_mask_str char(15),
	gateway1_str char(15),
	gateway2_str char(15),
	managed_str varchar(6),
	computer_name varchar(25),
	instance_no integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_discovery_ipsubnet to btree unique on
	discovery_ipsubnet_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_discovery_ipsubnet () from 'tng_discovery_ipsubnet.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_discovery_ipsubnet_tmp(
	subnet_addr byte(4),
	subnet_mask byte(4),
	gateway1 byte(4),
	gateway2 byte(4),
	time_stamp date,
	computer_name varchar(25),
	instance_no integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_discovery_ipsubnet_tmp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tng_discovery_ipsubnet_tmp () from 'tng_discovery_ipsubnet_tmp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table tng_discovery_setup(
	usr_intrest_dev_mask integer,
	start_time date,
	frequency integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_discovery_setup to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy tng_discovery_setup () from 'tng_discovery_setup.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table tng_discovery_status(
	current_status smallint,
	start_time date,
	cycle_time integer,
	init_time date,
	curr_total_devices integer,
	new_managedobject integer,
	new_tcpip integer,
	new_subnet integer,
	curr_new_devices integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_discovery_status to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy tng_discovery_status () from 'tng_discovery_status.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table tng_dsm_class_scope(
	dsmserver varchar(60) not null,
	classname varchar(40) not null,
	managedstate i1 not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_dsm_class_scope to btree unique on
	dsmserver,
	classname
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_dsm_class_scope () from 'tng_dsm_class_scope.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tng_dsm_class_scope
\p\g
create table tng_dsm_comm_scope(
	dsmserver varchar(60) not null,
	ipmask varchar(24) not null,
	nodeclassname varchar(40) not null,
	agentclassname varchar(40) not null,
	getcommstring varchar(40) not null,
	setcommstring varchar(40) not null,
	portnumber integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_dsm_comm_scope to btree unique on
	dsmserver,
	ipmask,
	nodeclassname,
	agentclassname,
	getcommstring,
	setcommstring,
	portnumber
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_dsm_comm_scope () from 'tng_dsm_comm_scope.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tng_dsm_comm_scope
\p\g
create table tng_dsm_ip_scope(
	dsmserver varchar(60) not null,
	ipmask varchar(24) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_dsm_ip_scope to btree unique on
	dsmserver,
	ipmask
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_dsm_ip_scope () from 'tng_dsm_ip_scope.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tng_dsm_ip_scope
\p\g
create table tng_dsm_mo_scope(
	dsmserver varchar(60) not null,
	ipmask varchar(24) not null,
	agentclassname varchar(128) not null,
	agentinstancename varchar(128) not null,
	managedstate i1 not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_dsm_mo_scope to btree unique on
	dsmserver,
	ipmask,
	agentclassname,
	agentinstancename
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_dsm_mo_scope () from 'tng_dsm_mo_scope.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tng_dsm_mo_scope
\p\g
create table tng_dsm_poll_scope(
	dsmserver varchar(60) not null,
	ipmask varchar(24) not null,
	nodeclassname varchar(40) not null,
	agentclassname varchar(40) not null,
	interval integer not null,
	timeout integer not null,
	retries integer not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_dsm_poll_scope to btree unique on
	dsmserver,
	ipmask,
	nodeclassname,
	agentclassname,
	interval,
	timeout,
	retries
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_dsm_poll_scope () from 'tng_dsm_poll_scope.mdbadmin' */
/* with allocation = 32, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tng_dsm_poll_scope
\p\g
create table tng_field_definition(
	field_id integer default 0,
	field_type integer default 0,
	field_flags integer default 0,
	name varchar(32) default '',
	data_length integer default 0,
	instance_storage varchar(255) default '',
	storage_name varchar(255) default '',
	last_int integer default 0,
	last_char integer default 0
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_field_definition to btree on
	field_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_field_definition () from 'tng_field_definition.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_field_storage(
	uuid byte(16) not null,
	int1 integer default 0,
	int2 integer default 0,
	int3 integer default 0,
	int4 integer default 0,
	int5 integer default 0,
	int6 integer default 0,
	int7 integer default 0,
	int8 integer default 0,
	int9 integer default 0,
	int10 integer default 0,
	int11 integer default 0,
	int12 integer default 0,
	int13 integer default 0,
	int14 integer default 0,
	int15 integer default 0,
	int16 integer default 0,
	int17 integer default 0,
	int18 integer default 0,
	int19 integer default 0,
	int20 integer default 0,
	int21 integer default 0,
	int22 integer default 0,
	int23 integer default 0,
	int24 integer default 0,
	int25 integer default 0,
	int26 integer default 0,
	int27 integer default 0,
	int28 integer default 0,
	int29 integer default 0,
	int30 integer default 0,
	int31 integer default 0,
	int32 integer default 0,
	int33 integer default 0,
	int34 integer default 0,
	int35 integer default 0,
	int36 integer default 0,
	int37 integer default 0,
	int38 integer default 0,
	int39 integer default 0,
	int40 integer default 0,
	int41 integer default 0,
	int42 integer default 0,
	int43 integer default 0,
	int44 integer default 0,
	int45 integer default 0,
	int46 integer default 0,
	int47 integer default 0,
	int48 integer default 0,
	int49 integer default 0,
	int50 integer default 0,
	int51 integer default 0,
	int52 integer default 0,
	int53 integer default 0,
	int54 integer default 0,
	int55 integer default 0,
	int56 integer default 0,
	int57 integer default 0,
	int58 integer default 0,
	int59 integer default 0,
	int60 integer default 0,
	int61 integer default 0,
	int62 integer default 0,
	int63 integer default 0,
	int64 integer default 0,
	int65 integer default 0,
	int66 integer default 0,
	int67 integer default 0,
	int68 integer default 0,
	int69 integer default 0,
	int70 integer default 0,
	int71 integer default 0,
	int72 integer default 0,
	int73 integer default 0,
	int74 integer default 0,
	int75 integer default 0,
	int76 integer default 0,
	int77 integer default 0,
	int78 integer default 0,
	int79 integer default 0,
	int80 integer default 0,
	int81 integer default 0,
	int82 integer default 0,
	int83 integer default 0,
	int84 integer default 0,
	int85 integer default 0,
	int86 integer default 0,
	int87 integer default 0,
	int88 integer default 0,
	int89 integer default 0,
	int90 integer default 0,
	int91 integer default 0,
	int92 integer default 0,
	int93 integer default 0,
	int94 integer default 0,
	int95 integer default 0,
	int96 integer default 0,
	int97 integer default 0,
	int98 integer default 0,
	int99 integer default 0,
	int100 integer default 0,
	str1 varchar(128) default '',
	str2 varchar(128) default '',
	str3 varchar(128) default '',
	str4 varchar(128) default '',
	str5 varchar(128) default '',
	str6 varchar(128) default '',
	str7 varchar(128) default '',
	str8 varchar(128) default '',
	str9 varchar(128) default '',
	str10 varchar(128) default '',
	str11 varchar(128) default '',
	str12 varchar(128) default '',
	str13 varchar(128) default ''
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_field_storage to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_field_storage () from 'tng_field_storage.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_geomap(
	name varchar(255) not null,
	height integer not null,
	width integer not null,
	altitude integer not null default 1,
	map_file_name varchar(64),
	background varchar(64),
	map_id integer,
	upper_left_longitude float,
	upper_left_latitude float,
	lower_right_longitude float,
	lower_right_latitude float,
	mapfunction varchar(64)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_geomap to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_geomap () from 'tng_geomap.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_icon_2d(
	name varchar(30) not null,
	normal_icon varchar(64),
	unknown_icon varchar(64),
	warning_icon varchar(64),
	minor_icon varchar(64),
	major_icon varchar(64),
	critical_icon varchar(64),
	down_icon varchar(64),
	inservice_icon varchar(64),
	remove_icon varchar(64),
	future_icon varchar(64)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_icon_2d to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_icon_2d () from 'tng_icon_2d.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_icon_3d(
	name varchar(40) not null,
	nff_file1 varchar(64),
	nff_file2 varchar(64),
	nff_file3 varchar(64),
	nff_file4 varchar(64),
	distance1 float,
	distance2 float,
	distance3 float,
	distance4 float,
	expand_distance float,
	nff_inside varchar(64),
	status integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_icon_3d to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_icon_3d () from 'tng_icon_3d.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_inclusion(
	uuid byte(16) not null,
	parent_class varchar(30) not null,
	parent_uuid byte(16) not null,
	parent_repository varchar(64),
	child_class varchar(30) not null,
	child_uuid byte(16) not null,
	child_repository varchar(64),
	parent_sequence_no integer,
	child_sequence_no integer,
	hidden i1 default 0,
	coord_type integer,
	position_x float,
	position_y float,
	position_z float,
	size_cx float,
	size_cy float,
	size_cz float
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_inclusion to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_inclusion () from 'tng_inclusion.mdbadmin' */
/* with allocation = 1600, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_interface_type(
	interface_type integer not null,
	description varchar(35)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_interface_type to btree unique on
	interface_type
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_interface_type () from 'tng_interface_type.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_ip_discovery_history(
	class_name varchar(30),
	date_ins date default 'now',
	operation varchar(32),
	address varchar(16),
	name varchar(255),
	auth varchar(30),
	object_uuid byte(16) not null,
	status integer,
	description varchar(255),
	dscvr_id varchar(24),
	comment varchar(255),
	sequence_no integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_ip_discovery_history to btree on
	object_uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_ip_discovery_history () from 'tng_ip_discovery_history.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_ip_interface(
	uuid byte(16) not null,
	interface_no integer not null,
	segment_uuid byte(16) not null default 0,
	pollset_name varchar(30),
	comment varchar(255),
	if_description varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_ip_interface to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_ip_interface () from 'tng_ip_interface.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_ip_subnet(
	uuid byte(16) not null,
	ip_sbnt_ref i1 default 0
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_ip_subnet to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_ip_subnet () from 'tng_ip_subnet.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_jasmine_menu_action(
	name varchar(80) not null,
	description varchar(80),
	confirmit i1 not null default 0,
	show_result i1 not null default 1,
	method varchar(255) not null,
	p1_name varchar(80),
	p1_value varchar(255),
	p2_name varchar(80),
	p2_value varchar(255),
	p3_name varchar(80),
	p3_value varchar(255),
	p4_name varchar(80),
	p4_value varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_jasmine_menu_action to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_jasmine_menu_action () from 'tng_jasmine_menu_action.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_jasmine_menu_object(
	menu_name varchar(80) not null,
	name varchar(80) not null,
	sequence_no integer not null default 0,
	label varchar(80),
	shortcut_character integer default -1,
	type varchar(80),
	action varchar(80),
	enabled i1 not null default 1,
	visible i1 not null default 1,
	platform_type varchar(80),
	platform_minimum_version varchar(80),
	time_travel_capable i1 not null default 1,
	filter varchar(255),
	icon varchar(256)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_jasmine_menu_object to btree unique on
	name,
	menu_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_jasmine_menu_object () from 'tng_jasmine_menu_object.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_jii_inclusion(
	uuid byte(16) not null,
	parent_class varchar(30) not null,
	parent_uuid byte(16) not null,
	parent_sequence_no integer,
	parent_repository varchar(64),
	child_jii_server varchar(255),
	child_jii_provider varchar(255) not null,
	child_jii_class varchar(255) not null,
	child_jii_objid varchar(255) not null,
	child_sequence_no integer,
	hidden i1,
	coord_type integer,
	position_x float,
	position_y float,
	position_z float,
	size_cx float,
	size_cy float,
	size_cz float
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_jii_inclusion to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 100,
	page_size = 4096
\p\g
/* copy tng_jii_inclusion () from 'tng_jii_inclusion.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_key_change_hist(
	sequence_no_key integer,
	min_seq_no integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_key_change_hist to btree on
	sequence_no_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy tng_key_change_hist () from 'tng_key_change_hist.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 1 */
/* \p\g */
create table tng_key_class_id(
	class_id_key integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_key_class_id to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tng_key_class_id () from 'tng_key_class_id.mdbadmin' */
/* with row_estimate = 1 */
/* \p\g */
create table tng_key_discovery_ipsubnet_id(
	discovery_ipsubnet_id_key integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_key_discovery_ipsubnet_id to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tng_key_discovery_ipsubnet_id () from 'tng_key_discovery_ipsubnet_id.mdbadmin' */
/* with row_estimate = 1 */
/* \p\g */
create table tng_key_id(
	id_key integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_key_id to heap
with extend = 16,
	allocation = 4
\p\g
/* copy tng_key_id () from 'tng_key_id.mdbadmin' */
/* with row_estimate = 1 */
/* \p\g */
create table tng_key_prop_status_hist(
	sequence_no_key integer,
	min_seq_no integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_key_prop_status_hist to btree on
	sequence_no_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy tng_key_prop_status_hist () from 'tng_key_prop_status_hist.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 1 */
/* \p\g */
create table tng_key_status_hist(
	sequence_no_key integer,
	min_seq_no integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_key_status_hist to btree on
	sequence_no_key
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy tng_key_status_hist () from 'tng_key_status_hist.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 1 */
/* \p\g */
create table tng_link(
	uuid byte(16) not null,
	name varchar(255),
	label varchar(255),
	class_name varchar(30) not null,
	source_class varchar(30) not null,
	source_uuid byte(16) not null,
	source_repository varchar(64),
	source_port integer,
	dest_class varchar(30) not null,
	dest_uuid byte(16) not null,
	dest_repository varchar(64),
	dest_port integer,
	date_ins date,
	status_no integer,
	severity integer,
	tng_delete_flag integer,
	hidden i1 default 0,
	alarmset_name varchar(30),
	direction integer,
	source_seq integer,
	dest_seq integer,
	parent_link byte(16) default 0,
	implied i1 default 0,
	link_flag integer default 0,
	reserved varchar(32),
	unimplied i1 default 0,
	common_ancestor_class varchar(30),
	common_ancestor_uuid byte(16)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_link to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_link () from 'tng_link.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_locale_info(
	property_name char(30),
	key_name varchar(128),
	locale_name nvarchar(512),
	locale char(10)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_locale_info to btree unique on
	key_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 100,
	page_size = 4096
\p\g
/* copy tng_locale_info () from 'tng_locale_info.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_mac_address(
	mac_address varchar(12) not null,
	class_name varchar(30) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_mac_address to btree unique on
	mac_address
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_mac_address () from 'tng_mac_address.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_managedobject(
	uuid byte(16) not null,
	name varchar(200) not null,
	label varchar(255),
	address varchar(255),
	address_type integer,
	class_name varchar(30) not null,
	interface_type integer,
	autoarrange_type integer,
	hidden i1,
	propagate_status i1,
	status_no integer,
	severity integer,
	tng_delete_flag integer,
	posted i1,
	acknowledge i1,
	ip_address_hex byte(4),
	mac_address varchar(12),
	subnet_mask byte(4),
	date_ins date default 'now',
	date_modify date default 'now',
	alarmset_name varchar(40),
	code_page integer,
	admin_status integer,
	dsm_server varchar(60),
	propagated_status_no integer,
	propagated_sev integer,
	dsm_address varchar(16),
	license_machine_type varchar(64),
	create_bpv i1,
	override_imagelarge varchar(64),
	override_imagesmall varchar(64),
	override_imagedecal varchar(64),
	override_imagetintbool i1,
	override_model varchar(64),
	background_image varchar(64),
	weight integer,
	reserved varchar(32),
	weighted_severity integer,
	max_sev integer,
	user_reclass integer,
	asset_uuid byte(16),
	source_repository varchar(60),
	dnsname varchar(255),
	last_seen_time date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_managedobject to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_managedobject () from 'tng_managedobject.mdbadmin' */
/* with allocation = 1600, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_map_authority(
	name varchar(30) not null,
	time_stamp date
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_map_authority to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_map_authority () from 'tng_map_authority.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_method(
	name varchar(40) not null,
	type integer,
	exe_name varchar(255),
	parameter varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_method to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_method () from 'tng_method.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_netpc_history(
	class_name varchar(30),
	mac_addr varchar(255),
	inst_timestamp date,
	ip_addr varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_netpc_history to btree on
	class_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_netpc_history () from 'tng_netpc_history.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_ov_enum(
	field_id integer,
	enum_name varchar(30),
	enum_ordinal integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_ov_enum to btree on
	field_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_ov_enum () from 'tng_ov_enum.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_ov_field_def(
	class_name varchar(30),
	field_name varchar(30),
	field_id integer,
	field_flags integer,
	field_type integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_ov_field_def to btree on
	class_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_ov_field_def () from 'tng_ov_field_def.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_overlapinterface(
	uuid byte(16) not null,
	interface_no integer not null,
	comment varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_overlapinterface to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_overlapinterface () from 'tng_overlapinterface.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_pollset(
	name varchar(40) not null,
	interval integer not null,
	timeout integer not null,
	retries integer not null,
	port_number integer not null default 161,
	getcommunitystring varchar(30),
	setcommunitystring varchar(30),
	retriesinterval integer,
	objectfilter varchar(30),
	hostfilter varchar(30)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_pollset to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_pollset () from 'tng_pollset.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_popup_menu(
	name varchar(40) not null,
	sequence_no integer not null,
	label varchar(40),
	method_name varchar(40),
	sub_popup_menu varchar(40),
	bitmap_name varchar(64),
	flag integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_popup_menu to btree unique on
	name,
	label,
	sequence_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_popup_menu () from 'tng_popup_menu.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_prop_status_history(
	sequence_no integer not null,
	class_name varchar(30) not null,
	record_uuid byte(16) not null,
	severity integer,
	status_no integer,
	timestamp date,
	user_name varchar(30)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_prop_status_history to btree unique on
	sequence_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_prop_status_history () from 'tng_prop_status_history.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_property_definition(
	id integer not null,
	class_id integer,
	name varchar(30) not null,
	datatype varchar(20) not null,
	length integer not null,
	is_key i1 not null default 0,
	required i1 not null,
	readonly i1,
	default_value varchar(255),
	instance_storage varchar(45),
	storage_field varchar(30),
	property_group varchar(10),
	external_data integer,
	override integer,
	method_name varchar(30)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_property_definition to btree unique on
	class_id,
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_property_definition () from 'tng_property_definition.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_severity_propagation(
	start_time integer,
	update_time integer,
	total_normal integer,
	total_unknown integer,
	total_warning integer,
	total_minor integer,
	total_major integer,
	total_critical integer,
	total_down integer,
	total_inservice integer,
	total_remove integer,
	total_future integer,
	last_update_time integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_severity_propagation to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy tng_severity_propagation () from 'tng_severity_propagation.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
create table tng_status(
	status_no integer not null,
	status_text varchar(255) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_status to btree on
	status_text
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_status () from 'tng_status.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_status_history(
	sequence_no integer not null,
	class_name varchar(30) not null,
	record_uuid byte(16) not null,
	severity integer,
	status_no integer,
	timestamp date,
	user_name varchar(30)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_status_history to btree unique on
	sequence_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_status_history () from 'tng_status_history.mdbadmin' */
/* with allocation = 4520, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_sysobjid(
	class_name varchar(30) not null,
	sysobjid varchar(128) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_sysobjid to btree unique on
	class_name,
	sysobjid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_sysobjid () from 'tng_sysobjid.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_tnd_geomap(
	name varchar(255) not null,
	height integer not null,
	width integer not null,
	altitude integer not null default 1,
	map_file_name varchar(64),
	background varchar(64),
	map_id integer,
	upper_left_longitude float,
	upper_left_latitude float,
	lower_right_longitude float,
	lower_right_latitude float,
	mapfunction varchar(64),
	tnd_xyz_vp11 float,
	tnd_xyz_vp12 float,
	tnd_xyz_vp13 float,
	tnd_xyz_vp21 float,
	tnd_xyz_vp22 float,
	tnd_xyz_vp23 float,
	tnd_xyz_vp31 float,
	tnd_xyz_vp32 float,
	tnd_xyz_vp33 float,
	tnd_vp_position_xyz1 float,
	tnd_vp_position_xyz2 float,
	tnd_vp_position_xyz3 float,
	tnd_image_pixels integer,
	tnd_image_raster_lines integer,
	tnd_projection_type integer,
	tnd_upper_left_corner_bitmap_x integer,
	tnd_upper_left_corner_bitmap_y integer,
	tnd_screen_height float,
	tnd_screen_width float
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_tnd_geomap to btree unique on
	name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_tnd_geomap () from 'tng_tnd_geomap.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_unclassified_tcp(
	uuid byte(16) not null,
	contact varchar(128),
	location varchar(128),
	sysobjid varchar(128),
	description varchar(255),
	comment varchar(255),
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_unclassified_tcp to btree unique on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_unclassified_tcp () from 'tng_unclassified_tcp.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_user_menu(
	name varchar(40) not null,
	menu_bar_label varchar(40) not null,
	sequence_no integer not null,
	label varchar(40),
	method_name varchar(40),
	sub_popup_menu varchar(40),
	bitmap_name varchar(64),
	flag integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_user_menu to btree unique on
	name,
	sequence_no
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_user_menu () from 'tng_user_menu.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table tng_vendor(
	vendor_id integer not null,
	name varchar(40),
	vendor_name varchar(10),
	comment varchar(80)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tng_vendor to btree unique on
	vendor_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy tng_vendor () from 'tng_vendor.mdbadmin' */
/* with allocation = 452, */
/* 	row_estimate = 0 */
/* \p\g */
create table toc(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(60) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify toc to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy toc () from 'toc.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on toc
\p\g
create table token_value(
	token_value_id decimal(31,0) not null,
	value_project_id decimal(31,0),
	value_task_id decimal(31,0),
	value_mvs_id decimal(31,0),
	value_task_mvs_id decimal(31,0),
	formula_token_id decimal(31,0) not null,
	context_mvs_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify token_value to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy token_value () from 'token_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on token_value
\p\g
create table tool(
	tool_id decimal(31,0) not null,
	tool_name varchar(1200) not null,
	tool_description varchar(4000),
	tool_path varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify tool to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy tool () from 'tool.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tool
\p\g
create table tool_keyword(
	tool_id decimal(31,0) not null,
	keyword_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify tool_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy tool_keyword () from 'tool_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on tool_keyword
\p\g
create table tplmemo(
	domainid integer not null,
	tpid integer not null,
	tpver integer not null,
	tpcont text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify tplmemo to btree unique on
	tpid,
	tpver,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy tplmemo () from 'tplmemo.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tplmemo
\p\g
create table train_57(
	date_and_time decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	calls_opened decimal(20,5),
	pattern_dow decimal(20,5),
	calls_resolved decimal(20,5),
	calls_esc decimal(20,5),
	calls_trans decimal(20,5),
	calls_reopened decimal(20,5),
	calls_closefirst decimal(20,5),
	avg_close_time decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify train_57 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy train_57 () from 'train_57.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on train_57
\p\g
create table train_62(
	date_and_time decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	priority decimal(20,5),
	open_dow decimal(20,5),
	open_tod decimal(20,5),
	sla_violation_dow decimal(20,5),
	impact decimal(20,5),
	sla_time decimal(20,5),
	time_of_violation decimal(20,5),
	category_code_0 decimal(20,5),
	category_code_1 decimal(20,5),
	category_code_2 decimal(20,5),
	category_code_3 decimal(20,5),
	category_code_4 decimal(20,5),
	category_code_5 decimal(20,5),
	category_code_6 decimal(20,5),
	category_code_7 decimal(20,5),
	category_code_8 decimal(20,5),
	category_code_9 decimal(20,5),
	customer_code_0 decimal(20,5),
	customer_code_1 decimal(20,5),
	customer_code_2 decimal(20,5),
	customer_code_3 decimal(20,5),
	customer_code_4 decimal(20,5),
	customer_code_5 decimal(20,5),
	customer_code_6 decimal(20,5),
	status_changes decimal(20,5),
	transfers decimal(20,5),
	sla_violation decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify train_62 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy train_62 () from 'train_62.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on train_62
\p\g
create table trainable_57(
	date_and_time decimal(20,5),
	consulted decimal(20,5),
	neugents_ahd_time_stamp decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	calls_opened_m6 decimal(20,5),
	calls_opened_m5 decimal(20,5),
	calls_opened_m4 decimal(20,5),
	calls_opened_m3 decimal(20,5),
	calls_opened_m2 decimal(20,5),
	calls_opened_m1 decimal(20,5),
	calls_opened decimal(20,5),
	calls_opened_p1 decimal(20,5),
	calls_opened_p2 decimal(20,5),
	calls_opened_p3 decimal(20,5),
	calls_opened_p4 decimal(20,5),
	calls_opened_p5 decimal(20,5),
	calls_opened_p6 decimal(20,5),
	calls_opened_p7 decimal(20,5),
	calls_opened_p1_actual decimal(20,5),
	calls_opened_p2_actual decimal(20,5),
	calls_opened_p3_actual decimal(20,5),
	calls_opened_p4_actual decimal(20,5),
	calls_opened_p5_actual decimal(20,5),
	calls_opened_p6_actual decimal(20,5),
	calls_opened_p7_actual decimal(20,5),
	pattern_dow_m6 decimal(20,5),
	pattern_dow_m5 decimal(20,5),
	pattern_dow_m4 decimal(20,5),
	pattern_dow_m3 decimal(20,5),
	pattern_dow_m2 decimal(20,5),
	pattern_dow_m1 decimal(20,5),
	pattern_dow decimal(20,5),
	calls_resolved_m6 decimal(20,5),
	calls_resolved_m5 decimal(20,5),
	calls_resolved_m4 decimal(20,5),
	calls_resolved_m3 decimal(20,5),
	calls_resolved_m2 decimal(20,5),
	calls_resolved_m1 decimal(20,5),
	calls_resolved decimal(20,5),
	calls_resolved_p1 decimal(20,5),
	calls_resolved_p2 decimal(20,5),
	calls_resolved_p3 decimal(20,5),
	calls_resolved_p4 decimal(20,5),
	calls_resolved_p5 decimal(20,5),
	calls_resolved_p6 decimal(20,5),
	calls_resolved_p7 decimal(20,5),
	calls_resolved_p1_actual decimal(20,5),
	calls_resolved_p2_actual decimal(20,5),
	calls_resolved_p3_actual decimal(20,5),
	calls_resolved_p4_actual decimal(20,5),
	calls_resolved_p5_actual decimal(20,5),
	calls_resolved_p6_actual decimal(20,5),
	calls_resolved_p7_actual decimal(20,5),
	calls_esc_m6 decimal(20,5),
	calls_esc_m5 decimal(20,5),
	calls_esc_m4 decimal(20,5),
	calls_esc_m3 decimal(20,5),
	calls_esc_m2 decimal(20,5),
	calls_esc_m1 decimal(20,5),
	calls_esc decimal(20,5),
	calls_trans_m6 decimal(20,5),
	calls_trans_m5 decimal(20,5),
	calls_trans_m4 decimal(20,5),
	calls_trans_m3 decimal(20,5),
	calls_trans_m2 decimal(20,5),
	calls_trans_m1 decimal(20,5),
	calls_trans decimal(20,5),
	calls_reopened_m6 decimal(20,5),
	calls_reopened_m5 decimal(20,5),
	calls_reopened_m4 decimal(20,5),
	calls_reopened_m3 decimal(20,5),
	calls_reopened_m2 decimal(20,5),
	calls_reopened_m1 decimal(20,5),
	calls_reopened decimal(20,5),
	calls_closefirst_m6 decimal(20,5),
	calls_closefirst_m5 decimal(20,5),
	calls_closefirst_m4 decimal(20,5),
	calls_closefirst_m3 decimal(20,5),
	calls_closefirst_m2 decimal(20,5),
	calls_closefirst_m1 decimal(20,5),
	calls_closefirst decimal(20,5),
	avg_close_time_m6 decimal(20,5),
	avg_close_time_m5 decimal(20,5),
	avg_close_time_m4 decimal(20,5),
	avg_close_time_m3 decimal(20,5),
	avg_close_time_m2 decimal(20,5),
	avg_close_time_m1 decimal(20,5),
	avg_close_time decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify trainable_57 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy trainable_57 () from 'trainable_57.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on trainable_57
\p\g
create table trainable_62(
	date_and_time decimal(20,5),
	consulted decimal(20,5),
	neugents_ahd_time_stamp decimal(20,5),
	from_consult decimal(20,5),
	neugents_ahd_pattern_label char(50),
	neugents_ahd_group_key char(50),
	priority decimal(20,5),
	open_dow decimal(20,5),
	open_tod decimal(20,5),
	sla_violation_dow decimal(20,5),
	impact decimal(20,5),
	sla_time decimal(20,5),
	time_of_violation decimal(20,5),
	category_code_0 decimal(20,5),
	category_code_1 decimal(20,5),
	category_code_2 decimal(20,5),
	category_code_3 decimal(20,5),
	category_code_4 decimal(20,5),
	category_code_5 decimal(20,5),
	category_code_6 decimal(20,5),
	category_code_7 decimal(20,5),
	category_code_8 decimal(20,5),
	category_code_9 decimal(20,5),
	customer_code_0 decimal(20,5),
	customer_code_1 decimal(20,5),
	customer_code_2 decimal(20,5),
	customer_code_3 decimal(20,5),
	customer_code_4 decimal(20,5),
	customer_code_5 decimal(20,5),
	customer_code_6 decimal(20,5),
	status_changes decimal(20,5),
	transfers decimal(20,5),
	sla_violation_actual decimal(20,5),
	sla_violation decimal(20,5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify trainable_62 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy trainable_62 () from 'trainable_62.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on trainable_62
\p\g
create table tree(
	eid integer not null not default,
	lev1 integer not null not default,
	lev2 integer not null not default,
	lev3 integer not null not default,
	lev4 integer not null not default,
	path varchar(153) not null not default,
	flags integer not null not default
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tree to btree unique on
	eid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 100,
	extend = 16,
	compression = (nokey, data)
\p\g
/* copy tree () from 'tree.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tree
\p\g
create table triggers(
	doctype varchar(50),
	condition varchar(200),
	definitionid varchar(20),
	id varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify triggers to heap
with extend = 16,
	allocation = 4
\p\g
/* copy triggers () from 'triggers.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on triggers
\p\g
create table ts_quota(
	ts_quota_id decimal(5,0) not null,
	tablespace_id decimal(5,0),
	user_head_id decimal(5,0),
	bytes decimal(5,0),
	max_bytes decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ts_quota to btree unique on
	ts_quota_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ts_quota () from 'ts_quota.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ts_quota
\p\g
create table tskstat(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	description varchar(500),
	code varchar(12) not null,
	allow_task_update integer not null,
	no_update_msg varchar(500),
	task_complete integer not null,
	do_next_task integer not null,
	allow_accumulate integer not null,
	hold integer not null,
	is_internal integer not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify tskstat to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy tskstat () from 'tskstat.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tskstat
\p\g
create table tskty(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	description varchar(500),
	code varchar(12) not null,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify tskty to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy tskty () from 'tskty.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tskty
\p\g
create table tspan(
	id integer not null,
	sym varchar(30) not null,
	code varchar(10) not null,
	start_year varchar(5),
	start_month varchar(5),
	start_day varchar(5),
	start_hour varchar(5),
	start_minute varchar(5),
	end_year varchar(5),
	end_month varchar(5),
	end_day varchar(5),
	end_hour varchar(5),
	end_minute varchar(5),
	trigger_year varchar(5),
	trigger_month varchar(5),
	trigger_day varchar(5),
	trigger_hour varchar(5),
	trigger_minute varchar(5),
	nx_desc varchar(240),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify tspan to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy tspan () from 'tspan.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tspan
\p\g
create table tsr_stats(
	job_id decimal(31,0) not null,
	job_run decimal(31,0) not null,
	mb_processed decimal(31,0),
	n_indexed_rows decimal(31,0),
	cpu_time decimal(31,0),
	elapsed_time decimal(31,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify tsr_stats to btree unique on
	job_id,
	job_run
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy tsr_stats () from 'tsr_stats.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tsr_stats
\p\g
create table type(
	type_id decimal(5,0) not null,
	collect_id decimal(5,0),
	owner varchar(30),
	type_name varchar(30) not null,
	typecode decimal(5,0),
	attributes decimal(5,0),
	methods decimal(5,0),
	predefined decimal(5,0),
	incomp decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify type to btree unique on
	type_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy type () from 'type.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on type
\p\g
create table tz(
	id integer not null,
	persid varchar(30),
	del integer not null,
	sym varchar(30) not null,
	last_mod_dt integer,
	last_mod_by byte varying(16),
	code varchar(12) not null,
	gmt_delta integer,
	description varchar(500),
	start_day integer,
	start_mon integer,
	start_pos integer,
	start_abs_date integer,
	end_day integer,
	end_mon integer,
	end_pos integer,
	end_abs_date integer,
	dst_delta integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify tz to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy tz () from 'tz.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on tz
\p\g
create table udf_allowable_value(
	user_defined_field_id decimal(31,0) not null,
	udf_allowable_value_id char(38) not null,
	value_name varchar(1200) not null,
	string_value varchar(4000),
	datetime_value date,
	long_value long byte,
	value_description varchar(4000),
	double_value decimal(31,2),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify udf_allowable_value to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy udf_allowable_value () from 'udf_allowable_value.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on udf_allowable_value
\p\g
create table udf_data_type(
	udf_data_type_id decimal(31,0) not null,
	udf_data_type_name varchar(1200) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify udf_data_type to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy udf_data_type () from 'udf_data_type.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on udf_data_type
\p\g
create table udoinstance(
	udoinstanceid integer not null,
	regionid integer not null,
	instancename varchar(5) not null,
	objectid integer not null,
	udoleft integer,
	udoright integer,
	udotop integer,
	udobottom integer,
	successor varchar(255),
	predecessor varchar(255),
	udoname varchar(255) not null,
	checkoutsid varchar(100),
	checkoutname varchar(100)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify udoinstance to btree unique on
	udoinstanceid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy udoinstance () from 'udoinstance.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on udoinstance
\p\g
create table udp(
	udpid integer not null,
	udpname varchar(50) not null,
	prompt varchar(255),
	description varchar(255),
	datatype smallint,
	defaultvalue varchar(255),
	inputstyle smallint,
	validationtype smallint,
	minvalue integer,
	maxvalue integer,
	errormsg varchar(255),
	errorcheck varchar(255),
	templateudp integer,
	checkoutsid varchar(100),
	checkoutname varchar(100),
	psname varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify udp to btree unique on
	udpid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy udp () from 'udp.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on udp
\p\g
create table udpselectionvalues(
	udpid integer not null,
	selectionvalue varchar(255) not null,
	mappedvalue varchar(255),
	valueid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify udpselectionvalues to btree unique on
	udpid,
	selectionvalue
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy udpselectionvalues () from 'udpselectionvalues.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on udpselectionvalues
\p\g
create table udpvalues(
	objectid integer not null,
	udpid integer not null,
	instanceid integer not null,
	strvalue varchar(255),
	intvalue integer,
	textvalue text(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify udpvalues to btree unique on
	instanceid,
	udpid,
	objectid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy udpvalues () from 'udpvalues.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on udpvalues
\p\g
create table ueacl10003data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10003data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10003data () from 'ueacl10003data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10003data
\p\g
create table ueacl10011data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10011data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10011data () from 'ueacl10011data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10011data
\p\g
create table ueacl10049data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10049data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10049data () from 'ueacl10049data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10049data
\p\g
create table ueacl10077data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10077data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10077data () from 'ueacl10077data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10077data
\p\g
create table ueacl10085data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10085data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10085data () from 'ueacl10085data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10085data
\p\g
create table ueacl10099data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10099data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10099data () from 'ueacl10099data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10099data
\p\g
create table ueacl10107data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10107data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10107data () from 'ueacl10107data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10107data
\p\g
create table ueacl10114data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10114data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10114data () from 'ueacl10114data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10114data
\p\g
create table ueacl10122data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10122data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10122data () from 'ueacl10122data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10122data
\p\g
create table ueacl10144data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10144data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10144data () from 'ueacl10144data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10144data
\p\g
create table ueacl10151data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10151data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10151data () from 'ueacl10151data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10151data
\p\g
create table ueacl10158data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10158data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10158data () from 'ueacl10158data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10158data
\p\g
create table ueacl10166data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10166data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10166data () from 'ueacl10166data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10166data
\p\g
create table ueacl10173data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10173data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10173data () from 'ueacl10173data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10173data
\p\g
create table ueacl10181data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10181data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10181data () from 'ueacl10181data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10181data
\p\g
create table ueacl10188data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10188data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10188data () from 'ueacl10188data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10188data
\p\g
create table ueacl10195data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10195data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10195data () from 'ueacl10195data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10195data
\p\g
create table ueacl10208data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl10208data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl10208data () from 'ueacl10208data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl10208data
\p\g
create table ueacl11407data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueresourceid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueacl11407data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueacl11407data () from 'ueacl11407data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueacl11407data
\p\g
create table ueadminassetresourcedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetname varchar(255),
	ueccitemfieldname varchar(255),
	ueccitemid integer,
	ueccitemtablename varchar(255),
	uecontainerpath varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueadminassetresourcedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueadminassetresourcedata () from 'ueadminassetresourcedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueadminassetresourcedata
\p\g
create table ueadminresourcebackbonedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueccitemfieldname varchar(255),
	ueccitemid integer,
	ueccitemtablename varchar(255),
	ueparentpath varchar(255),
	ueresourcename varchar(255),
	ueresourcetitle varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueadminresourcebackbonedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueadminresourcebackbonedata () from 'ueadminresourcebackbonedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueadminresourcebackbonedata
\p\g
create table ueaiffdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueaiff_author varchar(255),
	ueaiff_description varchar(1000),
	ueaiff_keywords varchar(255),
	ueaiff_title varchar(255),
	ueauthor varchar(255),
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecompression_type varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesample_frames integer,
	uesample_rate float,
	uesample_size integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ueaiffdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ueaiffdata () from 'ueaiffdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueaiffdata
\p\g
create table ueapprovalchaindata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueabout varchar(1000),
	ueappchainname varchar(255) not null,
	uestates varchar(1000)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify ueapprovalchaindata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy ueapprovalchaindata () from 'ueapprovalchaindata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueapprovalchaindata
\p\g
create table ueassetdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ueassetdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ueassetdata () from 'ueassetdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueassetdata
\p\g
create table ueassetfilemapdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetclsid integer,
	uedefault i1,
	uefileext varchar(255),
	uemajormime varchar(255),
	ueminormime varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueassetfilemapdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueassetfilemapdata () from 'ueassetfilemapdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueassetfilemapdata
\p\g
create table ueavidata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueaudio_codec varchar(255),
	ueauthor varchar(255),
	ueavi_author varchar(255),
	ueavi_create_date date,
	ueavi_description varchar(1000),
	ueavi_keywords varchar(255),
	ueavi_subject varchar(255),
	ueavi_title varchar(255),
	uebitrate float,
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecolor_depth integer,
	uecommissioned varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uecropped varchar(255),
	uedate_expires date,
	uedescription varchar(1000),
	uedimensions integer,
	uedots_per_inch varchar(255),
	ueengineer varchar(255),
	ueframe_number integer,
	ueframe_rate integer,
	uegenre varchar(255),
	ueheight integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uelightness varchar(255),
	uemajor_type varchar(255),
	uemedium varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	uename_of_subject varchar(255),
	uepalette varchar(255),
	ueparentid integer,
	ueproduct varchar(255),
	uesample_rate float,
	uesample_size integer,
	uesharpness varchar(255),
	uesoftware varchar(255),
	uesource varchar(255),
	uesubject varchar(255),
	uetechnician varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	uevideo_codec varchar(255),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify ueavidata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy ueavidata () from 'ueavidata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueavidata
\p\g
create table uecollectiondata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uecreation_date date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uename varchar(255),
	uesubject varchar(255),
	ueparentid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uecollectiondata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uecollectiondata () from 'uecollectiondata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uecollectiondata
\p\g
create table uedblog(
	uearea integer,
	uepriority integer,
	uemessage text(1),
	uesubsystem integer,
	uetype integer,
	uetimestamp date,
	ueparams text(1),
	ueuniqueid float not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uedblog to btree unique on
	ueuniqueid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uedblog () from 'uedblog.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uedblog
\p\g
create table ueerrordata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uecode integer,
	uelevel integer,
	uemessage varchar(1000),
	uetemplate varchar(255),
	uetype integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueerrordata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueerrordata () from 'ueerrordata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueerrordata
\p\g
create table uegroupdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uedescription varchar(1000),
	uegroupname varchar(255) not null,
	uegroups varchar(1000),
	ueusers varchar(1000)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify uegroupdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy uegroupdata () from 'uegroupdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uegroupdata
\p\g
create table ueimagedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebyte_count integer,
	uecolor_depth integer,
	uecompression_type varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueheight integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ueimagedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ueimagedata () from 'ueimagedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueimagedata
\p\g
create table uelrsdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueapp_name varchar(255),
	ueauthor varchar(255),
	uebrandname varchar(255),
	uebyte_count integer,
	uecategory varchar(255),
	uechar_count integer,
	uecompany varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueedit_time varchar(255),
	uehidden_count integer,
	uekeywords varchar(255),
	uelast_editor varchar(255),
	uelast_modified_by varchar(255),
	uelast_print_time date,
	uelast_saved_time date,
	ueline_count integer,
	uemajor_type varchar(255),
	uemanager varchar(255),
	ueminor_type varchar(255),
	uemmclips integer,
	uems_author varchar(255),
	uems_comments varchar(1000),
	uems_creation_date date,
	uems_keywords varchar(255),
	uems_subject varchar(255),
	uems_title varchar(255),
	uename varchar(255),
	uenote_count integer,
	uepage_count integer,
	uepara_count integer,
	ueparentid integer,
	uepres_format varchar(255),
	uerev_number varchar(255),
	uesecurity varchar(255),
	ueslide_count integer,
	uesubject varchar(255),
	uetemplate_name varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueword_count integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uelrsdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uelrsdata () from 'uelrsdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uelrsdata
\p\g
create table uemdidcolumnsdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uefield0 text(1),
	uefield1 text(1),
	uefield10 text(1),
	uefield11 text(1),
	uefield12 text(1),
	uefield13 text(1),
	uefield14 text(1),
	uefield15 text(1),
	uefield16 text(1),
	uefield17 text(1),
	uefield18 text(1),
	uefield19 text(1),
	uefield2 text(1),
	uefield20 text(1),
	uefield21 text(1),
	uefield22 text(1),
	uefield23 text(1),
	uefield24 text(1),
	uefield25 text(1),
	uefield26 text(1),
	uefield27 text(1),
	uefield28 text(1),
	uefield29 text(1),
	uefield3 text(1),
	uefield30 text(1),
	uefield31 text(1),
	uefield32 text(1),
	uefield33 text(1),
	uefield34 text(1),
	uefield35 text(1),
	uefield36 text(1),
	uefield37 text(1),
	uefield38 text(1),
	uefield39 text(1),
	uefield4 text(1),
	uefield40 text(1),
	uefield41 text(1),
	uefield42 text(1),
	uefield43 text(1),
	uefield44 text(1),
	uefield45 text(1),
	uefield46 text(1),
	uefield47 text(1),
	uefield48 text(1),
	uefield49 text(1),
	uefield5 text(1),
	uefield50 text(1),
	uefield51 text(1),
	uefield52 text(1),
	uefield53 text(1),
	uefield54 text(1),
	uefield55 text(1),
	uefield56 text(1),
	uefield57 text(1),
	uefield58 text(1),
	uefield59 text(1),
	uefield6 text(1),
	uefield60 text(1),
	uefield61 text(1),
	uefield62 text(1),
	uefield63 text(1),
	uefield64 text(1),
	uefield65 text(1),
	uefield66 text(1),
	uefield67 text(1),
	uefield68 text(1),
	uefield69 text(1),
	uefield7 text(1),
	uefield8 text(1),
	uefield9 text(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uemdidcolumnsdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uemdidcolumnsdata () from 'uemdidcolumnsdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uemdidcolumnsdata
\p\g
create table uemdiddata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uecache i1,
	uedescription varchar(1000),
	uekeyname1 varchar(255),
	uekeyname2 varchar(255),
	uekeyname3 varchar(255),
	uename varchar(255) not null,
	uenameplural varchar(255),
	ueparams varchar(4000),
	uepublicationstage integer,
	uereadpermission varchar(1000),
	uetablename varchar(255) not null,
	uewritepermission varchar(1000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uemdiddata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uemdiddata () from 'uemdiddata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uemdiddata
\p\g
create table uemgrseqopdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uefieldlist varchar(8000),
	ueflagmask integer,
	ueopmask integer,
	ueresourceclass varchar(255),
	ueresourceid integer,
	ueresourcepath varchar(255),
	ueuserdbid integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uemgrseqopdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uemgrseqopdata () from 'uemgrseqopdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uemgrseqopdata
\p\g
create table uemp3data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebitrate float,
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueemphasis varchar(255),
	ueframes integer,
	uegenre varchar(255),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelayer varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uemp3_author varchar(255),
	uemp3_description varchar(1000),
	uemp3_subject varchar(255),
	uemp3_title varchar(255),
	uename varchar(255),
	ueoriginal i1,
	ueparentid integer,
	ueprivate i1,
	uesample_rate float,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion_id varchar(255),
	ueworkflow_id integer,
	ueyear varchar(255)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uemp3data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uemp3data () from 'uemp3data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uemp3data
\p\g
create table uempegdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueaspect_ratio varchar(255),
	ueauthor varchar(255),
	uebitrate float,
	uebyte_count integer,
	uechroma_format varchar(255),
	uecolor_primaries varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedct_prediction integer,
	uedescription varchar(1000),
	ueframe_rate varchar(255),
	ueheight integer,
	ueintra_dc_prec varchar(255),
	ueintra_vlc_fmt integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	uematrix_coeffs varchar(255),
	ueminor_type varchar(255),
	uempeg_version varchar(255),
	uename varchar(255),
	ueparentid integer,
	ueprog_frame varchar(255),
	ueprog_sequence integer,
	uestream_type varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uetransfer_chars varchar(255),
	uevbf_buffer_size integer,
	uevercomment varchar(1000),
	uevideo_format varchar(255),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uempegdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uempegdata () from 'uempegdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uempegdata
\p\g
create table uemsofficedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueapp_name varchar(255),
	ueauthor varchar(255),
	uebyte_count integer,
	uecategory varchar(255),
	uechar_count integer,
	uecompany varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueedit_time varchar(255),
	uehidden_count integer,
	uekeywords varchar(255),
	uelast_editor varchar(255),
	uelast_modified_by varchar(255),
	uelast_print_time date,
	uelast_saved_time date,
	ueline_count integer,
	uemajor_type varchar(255),
	uemanager varchar(255),
	ueminor_type varchar(255),
	uemmclips integer,
	uems_author varchar(255),
	uems_comments varchar(1000),
	uems_creation_date date,
	uems_keywords varchar(255),
	uems_subject varchar(255),
	uems_title varchar(255),
	uename varchar(255),
	uenote_count integer,
	uepage_count integer,
	uepara_count integer,
	ueparentid integer,
	uepres_format varchar(255),
	uerev_number varchar(255),
	uesecurity varchar(255),
	ueslide_count integer,
	uesubject varchar(255),
	uetemplate_name varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueword_count integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uemsofficedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uemsofficedata () from 'uemsofficedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uemsofficedata
\p\g
create table uepdfdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uecreator varchar(255),
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uepdf_author varchar(255),
	uepdf_creation_dat date,
	uepdf_keywords varchar(255),
	uepdf_modification date,
	uepdf_subject varchar(255),
	uepdf_title varchar(255),
	ueproducer varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uepdfdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uepdfdata () from 'uepdfdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uepdfdata
\p\g
create table uepersistantstateinformationdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uebuildid varchar(255),
	uebuildtime date,
	uedbversion integer,
	uegensym integer,
	uenumfields integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uepersistantstateinformationdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uepersistantstateinformationdata () from 'uepersistantstateinformationdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uepersistantstateinformationdata
\p\g
create table uepersonalizationdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueattributename varchar(255) not null,
	uebooleanvalue i1,
	uedatacolumnname varchar(255),
	uedbidlvalue varchar(1000),
	uedbidvalue integer,
	ueintvalue integer,
	uetextstoryvalue varchar(8000),
	uetextvalue varchar(255),
	ueuserdbid integer not null
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uepersonalizationdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uepersonalizationdata () from 'uepersonalizationdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uepersonalizationdata
\p\g
create table uephotoshopdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebyte_count integer,
	uecolor_depth integer,
	uecompression_type varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueheight integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uephotoshopdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uephotoshopdata () from 'uephotoshopdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uephotoshopdata
\p\g
create table uepostscriptdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebounding_box varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uecreator varchar(255),
	uedate_expires date,
	uedescription varchar(1000),
	uedocument_data varchar(255),
	ueheader varchar(255),
	uekeywords varchar(255),
	uelanguage_level varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	uepages varchar(255),
	ueparentid integer,
	ueps_title varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uepostscriptdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uepostscriptdata () from 'uepostscriptdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uepostscriptdata
\p\g
create table uequicktimedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebyte_count integer,
	uechapter varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uedirector varchar(255),
	uedisclaimer varchar(255),
	ueedit_date date,
	ueframe_number integer,
	ueframe_rate integer,
	uefull_name varchar(1000),
	ueheight integer,
	uehost_computer varchar(255),
	ueinformation varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	uemake varchar(255),
	ueminor_type varchar(255),
	uemodel varchar(255),
	uename varchar(255),
	ueoriginal_format varchar(255),
	ueoriginal_source varchar(255),
	ueparentid integer,
	ueperformers varchar(255),
	ueplayback_req varchar(1000),
	ueproducer varchar(255),
	ueproduct varchar(255),
	ueqt_author varchar(255),
	ueqt_creation_date date,
	ueqt_description varchar(1000),
	ueqt_keywords varchar(255),
	ueqt_title varchar(255),
	uesoftware varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	uevolume integer,
	uewarning varchar(1000),
	uewidth integer,
	ueworkflow_id integer,
	uewriter varchar(255)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uequicktimedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uequicktimedata () from 'uequicktimedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uequicktimedata
\p\g
create table uerealaudiodata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uera_author varchar(255),
	uera_title varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerealaudiodata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerealaudiodata () from 'uerealaudiodata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerealaudiodata
\p\g
create table uerealmediadata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueallow_recording i1,
	ueaudio_format varchar(255),
	ueauthor varchar(255),
	ueavg_bitrate integer,
	ueavg_packet_size integer,
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedata_offset integer,
	uedate_expires date,
	uedescription varchar(1000),
	ueflags integer,
	uegenerated_by varchar(255),
	uehas_audio i1,
	uehas_event i1,
	uehas_image_map i1,
	uehas_video i1,
	ueheight integer,
	ueindex_offset integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	uemax_bitrate integer,
	uemax_packet_size integer,
	ueminor_type varchar(255),
	uemobile_playback i1,
	uemod_date date,
	uename varchar(255),
	uenum_of_streams integer,
	uenum_packets integer,
	ueobject_version varchar(255),
	ueparentid integer,
	ueperfect_play i1,
	uepreroll integer,
	uerm_author varchar(255),
	uerm_creation_date date,
	uerm_description varchar(1000),
	uerm_subject varchar(255),
	uerm_title varchar(255),
	uesubject varchar(255),
	uetarget_audiences varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	uevideo_quality varchar(255),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerealmediadata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerealmediadata () from 'uerealmediadata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerealmediadata
\p\g
create table uerollbk10011data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10011data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10011data () from 'uerollbk10011data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10011data
\p\g
create table uerollbk10049data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	ueurlfield varchar(1000),
	uevercomment varchar(1000),
	ueversion integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10049data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10049data () from 'uerollbk10049data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10049data
\p\g
create table uerollbk10077data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueaiff_author varchar(255),
	ueaiff_description varchar(1000),
	ueaiff_keywords varchar(255),
	ueaiff_title varchar(255),
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecompression_type varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesample_frames integer,
	uesample_rate float,
	uesample_size integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10077data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10077data () from 'uerollbk10077data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10077data
\p\g
create table uerollbk10085data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uecolor_depth integer,
	uecompression_type varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueheight integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10085data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10085data () from 'uerollbk10085data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10085data
\p\g
create table uerollbk10099data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueaudio_codec varchar(255),
	ueauthor varchar(255),
	ueavi_author varchar(255),
	ueavi_create_date date,
	ueavi_description varchar(1000),
	ueavi_keywords varchar(255),
	ueavi_subject varchar(255),
	ueavi_title varchar(255),
	uebitrate float,
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecolor_depth integer,
	uecommissioned varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uecropped varchar(255),
	uedate_expires date,
	uedescription varchar(1000),
	uedimensions integer,
	uedots_per_inch varchar(255),
	ueengineer varchar(255),
	ueframe_number integer,
	ueframe_rate integer,
	uegenre varchar(255),
	ueheight integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uelightness varchar(255),
	uemajor_type varchar(255),
	uemedium varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	uename_of_subject varchar(255),
	uepalette varchar(255),
	ueparentid integer,
	ueproduct varchar(255),
	uesample_rate float,
	uesample_size integer,
	uesharpness varchar(255),
	uesoftware varchar(255),
	uesource varchar(255),
	uesubject varchar(255),
	uetechnician varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uevideo_codec varchar(255),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10099data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uerollbk10099data () from 'uerollbk10099data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10099data
\p\g
create table uerollbk10107data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebitrate float,
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueemphasis varchar(255),
	ueframes integer,
	uegenre varchar(255),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelayer varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uemp3_author varchar(255),
	uemp3_description varchar(1000),
	uemp3_subject varchar(255),
	uemp3_title varchar(255),
	uename varchar(255),
	ueoriginal i1,
	ueparentid integer,
	ueprivate i1,
	uesample_rate float,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueversion_id varchar(255),
	ueworkflow_id integer,
	ueyear varchar(255)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10107data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10107data () from 'uerollbk10107data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10107data
\p\g
create table uerollbk10114data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueaspect_ratio varchar(255),
	ueassetid integer,
	ueauthor varchar(255),
	uebitrate float,
	uebyte_count integer,
	uechroma_format varchar(255),
	uecolor_primaries varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedct_prediction integer,
	uedescription varchar(1000),
	ueframe_rate varchar(255),
	ueheight integer,
	ueintra_dc_prec varchar(255),
	ueintra_vlc_fmt integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	uematrix_coeffs varchar(255),
	ueminor_type varchar(255),
	uempeg_version varchar(255),
	uename varchar(255),
	ueparentid integer,
	ueprog_frame varchar(255),
	ueprog_sequence integer,
	uestream_type varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uetransfer_chars varchar(255),
	uevbf_buffer_size integer,
	uevercomment varchar(1000),
	ueversion integer,
	uevideo_format varchar(255),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10114data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10114data () from 'uerollbk10114data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10114data
\p\g
create table uerollbk10122data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueapp_name varchar(255),
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uecategory varchar(255),
	uechar_count integer,
	uecompany varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueedit_time varchar(255),
	uehidden_count integer,
	uekeywords varchar(255),
	uelast_editor varchar(255),
	uelast_modified_by varchar(255),
	uelast_print_time date,
	uelast_saved_time date,
	ueline_count integer,
	uemajor_type varchar(255),
	uemanager varchar(255),
	ueminor_type varchar(255),
	uemmclips integer,
	uems_author varchar(255),
	uems_comments varchar(1000),
	uems_creation_date date,
	uems_keywords varchar(255),
	uems_subject varchar(255),
	uems_title varchar(255),
	uename varchar(255),
	uenote_count integer,
	uepage_count integer,
	uepara_count integer,
	ueparentid integer,
	uepres_format varchar(255),
	uerev_number varchar(255),
	uesecurity varchar(255),
	ueslide_count integer,
	uesubject varchar(255),
	uetemplate_name varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueword_count integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10122data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uerollbk10122data () from 'uerollbk10122data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10122data
\p\g
create table uerollbk10144data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uecreator varchar(255),
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uepdf_author varchar(255),
	uepdf_creation_dat date,
	uepdf_keywords varchar(255),
	uepdf_modification date,
	uepdf_subject varchar(255),
	uepdf_title varchar(255),
	ueproducer varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10144data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10144data () from 'uerollbk10144data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10144data
\p\g
create table uerollbk10151data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uecolor_depth integer,
	uecompression_type varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueheight integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10151data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10151data () from 'uerollbk10151data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10151data
\p\g
create table uerollbk10158data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebounding_box varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uecreator varchar(255),
	uedate_expires date,
	uedescription varchar(1000),
	uedocument_data varchar(255),
	ueheader varchar(255),
	uekeywords varchar(255),
	uelanguage_level varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	uepages varchar(255),
	ueparentid integer,
	ueps_title varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10158data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10158data () from 'uerollbk10158data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10158data
\p\g
create table uerollbk10166data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uechapter varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uedirector varchar(255),
	uedisclaimer varchar(255),
	ueedit_date date,
	ueframe_number integer,
	ueframe_rate integer,
	uefull_name varchar(1000),
	ueheight integer,
	uehost_computer varchar(255),
	ueinformation varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	uemake varchar(255),
	ueminor_type varchar(255),
	uemodel varchar(255),
	uename varchar(255),
	ueoriginal_format varchar(255),
	ueoriginal_source varchar(255),
	ueparentid integer,
	ueperformers varchar(255),
	ueplayback_req varchar(1000),
	ueproducer varchar(255),
	ueproduct varchar(255),
	ueqt_author varchar(255),
	ueqt_creation_date date,
	ueqt_description varchar(1000),
	ueqt_keywords varchar(255),
	ueqt_title varchar(255),
	uesoftware varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uevolume integer,
	uewarning varchar(1000),
	uewidth integer,
	ueworkflow_id integer,
	uewriter varchar(255)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10166data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uerollbk10166data () from 'uerollbk10166data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10166data
\p\g
create table uerollbk10173data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uera_author varchar(255),
	uera_title varchar(255),
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10173data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10173data () from 'uerollbk10173data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10173data
\p\g
create table uerollbk10181data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueallow_recording i1,
	ueassetid integer,
	ueaudio_format varchar(255),
	ueauthor varchar(255),
	ueavg_bitrate integer,
	ueavg_packet_size integer,
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedata_offset integer,
	uedate_expires date,
	uedescription varchar(1000),
	ueflags integer,
	uegenerated_by varchar(255),
	uehas_audio i1,
	uehas_event i1,
	uehas_image_map i1,
	uehas_video i1,
	ueheight integer,
	ueindex_offset integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	uemax_bitrate integer,
	uemax_packet_size integer,
	ueminor_type varchar(255),
	uemobile_playback i1,
	uemod_date date,
	uename varchar(255),
	uenum_of_streams integer,
	uenum_packets integer,
	ueobject_version varchar(255),
	ueparentid integer,
	ueperfect_play i1,
	uepreroll integer,
	uerm_author varchar(255),
	uerm_creation_date date,
	uerm_description varchar(1000),
	uerm_subject varchar(255),
	uerm_title varchar(255),
	uesubject varchar(255),
	uetarget_audiences varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uevideo_quality varchar(255),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10181data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10181data () from 'uerollbk10181data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10181data
\p\g
create table uerollbk10188data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebitrate float,
	ueblock_align integer,
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueformat varchar(255),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesample_rate float,
	uesample_size integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uewav_author varchar(255),
	uewav_description varchar(1000),
	uewav_keywords varchar(255),
	uewav_subject varchar(255),
	uewav_title varchar(255),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10188data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10188data () from 'uerollbk10188data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10188data
\p\g
create table uerollbk10195data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebitrate float,
	uebroadcast i1,
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uecurrent_bitrate float,
	uedate_expires date,
	uedescription varchar(1000),
	uehas_audio i1,
	uehas_event i1,
	uehas_image_map i1,
	uehas_video i1,
	ueis_protected i1,
	ueis_trusted i1,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueoptimal_bitrate float,
	ueparentid integer,
	uerating varchar(255),
	ueseekable i1,
	uesignature_name varchar(255),
	uestridable i1,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uewm_author varchar(255),
	uewm_description varchar(1000),
	uewm_title varchar(255),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10195data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10195data () from 'uerollbk10195data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10195data
\p\g
create table uerollbk10208data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassetid integer,
	ueauthor varchar(255),
	uebase varchar(255),
	uebgcolor varchar(255),
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueframe_number integer,
	ueframe_rate integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	ueloop i1,
	uemajor_type varchar(255),
	uemenu i1,
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uequality varchar(255),
	uesalign varchar(255),
	uescale varchar(255),
	uesubject varchar(255),
	ueswf_version integer,
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk10208data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uerollbk10208data () from 'uerollbk10208data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk10208data
\p\g
create table uerollbk11407data(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueapp_name varchar(255),
	ueassetid integer,
	ueauthor varchar(255),
	uebrandname varchar(255),
	uebyte_count integer,
	uecategory varchar(255),
	uechar_count integer,
	uecompany varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueedit_time varchar(255),
	uehidden_count integer,
	uekeywords varchar(255),
	uelast_editor varchar(255),
	uelast_modified_by varchar(255),
	uelast_print_time date,
	uelast_saved_time date,
	ueline_count integer,
	uemajor_type varchar(255),
	uemanager varchar(255),
	ueminor_type varchar(255),
	uemmclips integer,
	uems_author varchar(255),
	uems_comments varchar(1000),
	uems_creation_date date,
	uems_keywords varchar(255),
	uems_subject varchar(255),
	uems_title varchar(255),
	uename varchar(255),
	uenote_count integer,
	uepage_count integer,
	uepara_count integer,
	ueparentid integer,
	uepres_format varchar(255),
	uerev_number varchar(255),
	uesecurity varchar(255),
	ueslide_count integer,
	uesubject varchar(255),
	uetemplate_name varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	ueversion integer,
	ueword_count integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify uerollbk11407data to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy uerollbk11407data () from 'uerollbk11407data.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uerollbk11407data
\p\g
create table uescdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uescdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uescdata () from 'uescdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uescdata
\p\g
create table uescitemsdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueresid varchar(255),
	uescid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uescitemsdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uescitemsdata () from 'uescitemsdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uescitemsdata
\p\g
create table ueshockwavedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebase varchar(255),
	uebgcolor varchar(255),
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueframe_number integer,
	ueframe_rate integer,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	ueloop i1,
	uemajor_type varchar(255),
	uemenu i1,
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uequality varchar(255),
	uesalign varchar(255),
	uescale varchar(255),
	uesubject varchar(255),
	ueswf_version integer,
	uetitle varchar(255),
	uevercomment varchar(1000),
	uewidth integer,
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ueshockwavedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy ueshockwavedata () from 'ueshockwavedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueshockwavedata
\p\g
create table uesntabledata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uechanged i1,
	ueevtype integer,
	ueresource varchar(255),
	uesendmail i1,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uesntabledata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uesntabledata () from 'uesntabledata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uesntabledata
\p\g
create table uestdtriggerdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uedesc varchar(1000),
	uefolderpath varchar(255),
	uemajortype varchar(255),
	ueminortype varchar(255),
	uename varchar(255),
	ueop varchar(255),
	ueprocid integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify uestdtriggerdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy uestdtriggerdata () from 'uestdtriggerdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uestdtriggerdata
\p\g
create table ueurldata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebyte_count integer,
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesubject varchar(255),
	uetitle varchar(255),
	ueurlfield varchar(4000),
	uevercomment varchar(1000),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify ueurldata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 16384,
	unique_scope = statement
\p\g
/* copy ueurldata () from 'ueurldata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueurldata
\p\g
create table ueuserdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uebrowsescreensize integer,
	uecanassigntodo i1,
	ueemail varchar(255),
	uefax varchar(255),
	uefirstname varchar(255),
	uefontsize integer,
	ueincontextedit i1,
	uelastname varchar(255),
	ueldapuser i1,
	uelongchoosethresh integer,
	uepassword varchar(8),
	uephone varchar(255),
	ueuseapplets i1,
	ueusername varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ueuserdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy ueuserdata () from 'ueuserdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on ueuserdata
\p\g
create table uewavdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebitrate float,
	ueblock_align integer,
	uebyte_count integer,
	uechannel_mode varchar(255),
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uedate_expires date,
	uedescription varchar(1000),
	ueformat varchar(255),
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueparentid integer,
	uesample_rate float,
	uesample_size integer,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	uewav_author varchar(255),
	uewav_description varchar(1000),
	uewav_keywords varchar(255),
	uewav_subject varchar(255),
	uewav_title varchar(255),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uewavdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uewavdata () from 'uewavdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewavdata
\p\g
create table uewebdavlockdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueowner varchar(255),
	uepath varchar(255) not null,
	uetoken varchar(255),
	ueuser varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uewebdavlockdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uewebdavlockdata () from 'uewebdavlockdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewebdavlockdata
\p\g
create table uewfacldata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uegroup integer,
	uepermission integer,
	ueprocessdefid integer,
	ueuser integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uewfacldata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uewfacldata () from 'uewfacldata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewfacldata
\p\g
create table uewfactivitydata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueactdef integer,
	ueaction varchar(255),
	ueattr varchar(8000),
	uedesc varchar(1000),
	uegroups varchar(8000),
	uename varchar(255),
	ueorder integer,
	uestate integer,
	uesubject varchar(255),
	ueusers varchar(8000),
	ueworkitem integer
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify uewfactivitydata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 32768,
	unique_scope = statement
\p\g
/* copy uewfactivitydata () from 'uewfactivitydata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewfactivitydata
\p\g
create table uewfactivitydefdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueaction varchar(255),
	ueattr varchar(8000),
	uedesc varchar(1000),
	uegroups varchar(8000),
	uename varchar(255),
	ueorder integer,
	uesubject varchar(255),
	ueusers varchar(8000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify uewfactivitydefdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 32768,
	unique_scope = statement
\p\g
/* copy uewfactivitydefdata () from 'uewfactivitydefdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewfactivitydefdata
\p\g
create table uewfattributedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	uename varchar(255),
	uetype varchar(255),
	uevalue varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uewfattributedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uewfattributedata () from 'uewfattributedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewfattributedata
\p\g
create table uewfprocessdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueactv varchar(8000),
	ueattr varchar(8000),
	uedesc varchar(1000),
	uename varchar(255),
	ueowner integer,
	ueprocdef integer,
	uestate i1,
	uesubject varchar(255)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify uewfprocessdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 32768,
	unique_scope = statement
\p\g
/* copy uewfprocessdata () from 'uewfprocessdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewfprocessdata
\p\g
create table uewfprocessdefdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueactv varchar(8000),
	ueattr varchar(8000),
	uedesc varchar(1000),
	uename varchar(255),
	uestate i1,
	uesubject varchar(255)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify uewfprocessdefdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 32768,
	unique_scope = statement
\p\g
/* copy uewfprocessdefdata () from 'uewfprocessdefdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewfprocessdefdata
\p\g
create table uewfworkitemdata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueassigned i1,
	uemsg varchar(255),
	uesdate date,
	ueuserid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uewfworkitemdata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uewfworkitemdata () from 'uewfworkitemdata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewfworkitemdata
\p\g
create table uewindowsmediadata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueauthor varchar(255),
	uebitrate float,
	uebroadcast i1,
	uebyte_count integer,
	uecopyrighted varchar(255),
	uecreated_by varchar(255),
	uecreation_date date,
	uecurrent_bitrate float,
	uedate_expires date,
	uedescription varchar(1000),
	uehas_audio i1,
	uehas_event i1,
	uehas_image_map i1,
	uehas_video i1,
	ueis_protected i1,
	ueis_trusted i1,
	uekeywords varchar(255),
	uelast_modified_by varchar(255),
	uelength float,
	uemajor_type varchar(255),
	ueminor_type varchar(255),
	uename varchar(255),
	ueoptimal_bitrate float,
	ueparentid integer,
	uerating varchar(255),
	ueseekable i1,
	uesignature_name varchar(255),
	uestridable i1,
	uesubject varchar(255),
	uetitle varchar(255),
	uevercomment varchar(1000),
	uewm_author varchar(255),
	uewm_description varchar(1000),
	uewm_title varchar(255),
	ueworkflow_id integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify uewindowsmediadata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy uewindowsmediadata () from 'uewindowsmediadata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewindowsmediadata
\p\g
create table uewsstoragedata(
	uecheckedout integer,
	uecheckedouttime date,
	uedbid integer not null,
	uemodtime date,
	uenumemptyrequired integer,
	uepubstage integer,
	uepubtime date,
	ueasset_date varchar(255),
	ueasset_name varchar(255),
	ueasset_path varchar(255),
	ueasset_title varchar(255),
	ueitem varchar(255),
	ueproc integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify uewsstoragedata to btree unique on
	uedbid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy uewsstoragedata () from 'uewsstoragedata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on uewsstoragedata
\p\g
create table ump_emfilter(
	fid integer not null,
	gid integer not null,
	name varchar(255) not null,
	criteria varchar(4096) not null,
	des varchar(512),
	puid integer not null,
	pgids varchar(1024) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ump_emfilter to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy ump_emfilter () from 'ump_emfilter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ump_emfilter
\p\g
create table ump_emgroup(
	gid integer not null,
	name varchar(255) not null,
	des varchar(512),
	puid integer not null,
	pgids varchar(1024) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify ump_emgroup to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy ump_emgroup () from 'ump_emgroup.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ump_emgroup
\p\g
create table ump_msgs(
	text varchar(400) not null,
	msgid integer not null,
	groupid integer not null,
	severity char(1) not null,
	time date not null,
	cat varchar(256),
	linkurl varchar(100),
	isdelete char(1),
	uuid varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify ump_msgs to heap
with extend = 16,
	allocation = 4
\p\g
/* copy ump_msgs () from 'ump_msgs.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on ump_msgs
\p\g
create table unit(
	unitid integer not null,
	unitname char(254) not null,
	prec smallint,
	unitshortname char(10)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify unit to btree unique on
	unitid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy unit () from 'unit.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on unit
\p\g
create integrity  ON Unit IS UnitID >= 1
\p\g
create table unitrel(
	domainid integer not null,
	unitid integer not null,
	type integer,
	rdomid integer not null,
	rid integer not null,
	rtype integer,
	rcount integer,
	rdate integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify unitrel to btree unique on
	unitid,
	domainid,
	rid,
	rdomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy unitrel () from 'unitrel.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on unitrel
\p\g
create table unitsec(
	udomid integer not null,
	unitid integer not null,
	type integer not null,
	typex integer not null,
	ldomid integer not null,
	linkid integer not null,
	rflag integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify unitsec to btree unique on
	unitid,
	type,
	typex,
	linkid,
	udomid,
	ldomid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy unitsec () from 'unitsec.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on unitsec
\p\g
create table unittype(
	domainid integer not null,
	unittype integer not null,
	unitname varchar(127),
	unitconf text(1)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify unittype to btree unique on
	unittype,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy unittype () from 'unittype.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on unittype
\p\g
create table urc_active_session(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strhost nvarchar(64) not null,
	uidhost byte(16) not null,
	uidsession byte(16) not null,
	strviewer nvarchar(64) not null,
	datesessionstarted integer not null,
	iduration integer not null,
	strremoteuser nvarchar(255) not null,
	strstatus nvarchar(64) not null,
	strdescription nvarchar(255) not null,
	iseverity integer not null,
	iencryption integer not null,
	strprotocol nvarchar(32) not null,
	icategory integer not null,
	ieventid integer not null,
	ireasonsessionwasclosed integer not null,
	ifailsafe integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_active_session to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_active_session () from 'urc_active_session.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_active_session
\p\g
create table urc_address_book_global(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname nvarchar(255) not null,
	strdescription nvarchar(255) not null,
	uidcomputer byte(16) not null,
	streamaddress byte(510) not null,
	iisdeleted integer not null,
	datetimestamp integer not null,
	istatus integer not null,
	securityproviders byte(2) not null,
	domain_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_address_book_global to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_address_book_global () from 'urc_address_book_global.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_address_book_global
\p\g
create table urc_address_book_group_global(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname nvarchar(255) not null,
	strdescription nvarchar(255) not null,
	iinheritpermission integer not null,
	iisserver integer not null,
	iisdeleted integer not null,
	datetimestamp integer not null,
	strlabel nvarchar(255) not null,
	datetimestampgab integer not null,
	domain_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_address_book_group_global to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_address_book_group_global () from 'urc_address_book_group_global.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_address_book_group_global
\p\g
create table urc_computer(
	uid byte(16) not null,
	streamaddress byte(510) not null,
	strcamaddress nvarchar(64) not null,
	uidconfigpolicy byte(16) not null,
	iinheritconfiguration integer not null,
	datelastaccess integer not null,
	istatus integer not null,
	uidlastparent byte(16) not null,
	datelastevent integer not null,
	dateconfigpolicy integer not null,
	strversion nvarchar(64) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_computer to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_computer () from 'urc_computer.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_computer
\p\g
create table urc_computer_group(
	uid byte(16) not null,
	uidconfigpolicy byte(16) not null,
	iinheritconfiguration integer not null,
	isorthelp integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_computer_group to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_computer_group () from 'urc_computer_group.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_computer_group
\p\g
create table urc_local_server(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname nvarchar(64) not null,
	strpath nvarchar(255) not null,
	straddress nvarchar(255) not null,
	iisroot integer not null,
	uidconfigpolicy byte(16) not null,
	strdescription nvarchar(255) not null,
	dateconfigpolicy integer not null,
	iinheritconfiguration integer not null,
	ipropagatechanges integer not null,
	ageofeventstopurge integer not null,
	datetopurgeevents integer not null,
	ageofsessionstopurge integer not null,
	datetopurgesessions integer not null,
	nexteventpurge integer not null,
	nextsessionpurge integer not null,
	periodtopurgeevents integer not null,
	periodtopurgesessions integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_local_server to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_local_server () from 'urc_local_server.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_local_server
\p\g
create table urc_permission_global(
	uid byte(16) not null,
	uidparent byte(16) not null,
	uidaddressbook byte(16) not null,
	strobjectidentifier nvarchar(255) not null,
	iisinherited integer not null,
	iisdeleted integer not null,
	datetimestamp integer not null,
	strpermissions nvarchar(11) not null,
	domain_uuid byte(16),
	auto_rep_version date
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_permission_global to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_permission_global () from 'urc_permission_global.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_permission_global
\p\g
create table urc_repository_credentials(
	uid byte(16) not null,
	uidparent byte(16) not null,
	strname nvarchar(1048) not null,
	struser nvarchar(256) not null,
	strpassword nvarchar(256) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_repository_credentials to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy urc_repository_credentials () from 'urc_repository_credentials.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_repository_credentials
\p\g
create table urc_schema_version(
	uid byte(16) not null,
	uidparent byte(16) not null,
	iversion integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify urc_schema_version to heap
with extend = 16,
	allocation = 4
\p\g
/* copy urc_schema_version () from 'urc_schema_version.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on urc_schema_version
\p\g
create table urgncy(
	id integer not null,
	del integer not null,
	enum integer not null,
	sym varchar(12) not null,
	nx_desc varchar(40),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	value integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify urgncy to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy urgncy () from 'urgncy.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on urgncy
\p\g
create table usd_accounts(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	accountindex integer not null,
	accounttype integer not null,
	accountname nvarchar(129) not null,
	accountcomment nvarchar(255) not null,
	flag integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_accounts to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_accounts () from 'usd_accounts.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_accounts
\p\g
create table usd_acctempl(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	objectclassindex integer not null,
	templacl byte(32) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_acctempl to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_acctempl () from 'usd_acctempl.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_acctempl
\p\g
create table usd_activity(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	oid integer,
	ordernumb integer not null,
	actproc byte(16) not null,
	instproc byte(16) not null,
	state integer not null,
	startflag integer not null,
	activationtime integer not null,
	creationtime integer not null,
	giveuptime integer not null,
	compfold byte(16) not null,
	execmode integer not null,
	jobname nvarchar(255) not null,
	promptmsg nvarchar(255) not null,
	promptto integer not null,
	userparams nvarchar(255) not null,
	jobbanner nvarchar(65) not null,
	okcnt integer not null,
	activecnt integer not null,
	errorcnt integer not null,
	mask integer not null,
	opmask integer not null,
	bootbefore integer not null,
	bootafter integer not null,
	targetmask integer not null,
	dtsstate integer not null,
	deliverytime integer not null,
	cause integer not null,
	renewstate integer not null,
	waitingcnt integer not null,
	waitingrenewcnt integer not null,
	activerenewcnt integer not null,
	okrenewcnt integer not null,
	errorrenewcnt integer not null,
	permmask integer not null,
	calendar nvarchar(33),
	errorcause nvarchar(255),
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_activity to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_activity () from 'usd_activity.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_activity
\p\g
create table usd_actproc(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	oid integer,
	itemname nvarchar(129) not null,
	itemversion nvarchar(129) not null,
	apesos integer not null,
	subpathentered nvarchar(255) not null,
	filedby integer not null,
	activatedby integer not null,
	comment nvarchar(255) not null,
	creationdate integer not null,
	creationtime integer not null,
	changedate integer not null,
	changetime integer not null,
	type integer not null,
	task integer not null,
	subpath nvarchar(255) not null,
	proctorun nvarchar(255) not null,
	includedproc integer not null,
	rsw byte(16) not null,
	volume byte(16) not null,
	bootflags integer not null,
	mask integer not null,
	opmask integer not null,
	bootbefore integer not null,
	bootafter integer not null,
	mgmtmask integer not null,
	procparameter nvarchar(255),
	query nvarchar(512) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_actproc to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy usd_actproc () from 'usd_actproc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_actproc
\p\g
create table usd_apdep(
	objectid byte(16) not null,
	version integer not null,
	rswname nvarchar(129) not null,
	rswversion nvarchar(129) not null,
	apname nvarchar(129) not null,
	apversion nvarchar(129) not null,
	filedby integer not null,
	ap byte(16) not null,
	depap byte(16) not null,
	ordernumber integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_apdep to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_apdep () from 'usd_apdep.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_apdep
\p\g
create table usd_applic(
	objectid byte(16) not null,
	version integer not null,
	oid integer,
	target byte(16) not null,
	actproc byte(16) not null,
	activity byte(16) not null,
	installation byte(16) not null,
	status integer not null,
	errorcause integer not null,
	errorparam nvarchar(255) not null,
	creationtime integer not null,
	activationtime integer not null,
	completiontime integer not null,
	administrator nvarchar(129) not null,
	applicationid nvarchar(129) not null,
	comment nvarchar(255) not null,
	task byte(4) not null,
	percentsent integer not null,
	retentiontime integer not null,
	renewstatus integer not null,
	firstrenew byte(16) not null,
	nextrenew byte(16) not null,
	applicationgroup byte(16) not null,
	userparams nvarchar(255) not null,
	uuid nvarchar(37) not null,
	racassoc byte(16) not null,
	uninstallstate integer not null,
	permmask integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_applic to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_applic () from 'usd_applic.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_applic
\p\g
create table usd_carrier(
	objectid byte(16) not null,
	version integer not null,
	boundto byte(16) not null,
	status integer not null,
	transferid nvarchar(33) not null,
	transferdir nvarchar(255) not null,
	destination nvarchar(255) not null,
	transfertime integer not null,
	containername nvarchar(255) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_carrier to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_carrier () from 'usd_carrier.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_carrier
\p\g
create table usd_cc(
	objectid byte(16) not null,
	version integer not null,
	boundto byte(16) not null,
	diststatus integer not null,
	overalljobstatus integer not null,
	numberofparameters integer not null,
	failure byte(129) not null,
	creationdate integer not null,
	creationtime integer not null,
	cont byte(16) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_cc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_cc () from 'usd_cc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_cc
\p\g
create table usd_cmp_attr(
	objectid byte(16) not null,
	version integer not null,
	id integer not null,
	value nvarchar(129) not null,
	creationtime integer not null,
	changetime integer not null,
	computer byte(16) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_cmp_attr to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_cmp_attr () from 'usd_cmp_attr.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_cmp_attr
\p\g
create table usd_cmp_grp(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	qtask byte(16) not null,
	aux byte(16) not null,
	aux2 byte(16) not null,
	type integer not null,
	attributes byte(4) not null,
	name nvarchar(129) not null,
	comment nvarchar(255) not null,
	credate integer not null,
	cretime integer not null,
	chdate integer not null,
	chtime integer not null,
	propflag integer not null,
	qcalendar nvarchar(129) not null,
	qevalrate integer not null,
	qnextevaldate integer not null,
	qnextevaltime integer not null,
	qevaldate integer not null,
	qevaltime integer not null,
	qtemplfold byte(16) not null,
	qtype integer not null,
	state integer not null,
	seal integer not null,
	var integer not null,
	auxtext0 nvarchar(128),
	auxtext1 nvarchar(128),
	auxtext2 nvarchar(128),
	auxtext3 nvarchar(128),
	queryid byte(16),
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_cmp_grp to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_cmp_grp () from 'usd_cmp_grp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_cmp_grp
\p\g
create table usd_cont(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	name nvarchar(129) not null,
	overallstatus integer not null,
	sendid byte(16) not null,
	containerpath nvarchar(255) not null,
	distlistpath nvarchar(255) not null,
	distlisttype integer not null,
	distdate integer not null,
	disttime integer not null,
	credate integer not null,
	cretime integer not null,
	ahdinfo nvarchar(128) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_cont to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_cont () from 'usd_cont.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_cont
\p\g
create table usd_contfold(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	qtask byte(16) not null,
	aux byte(16) not null,
	aux2 byte(16) not null,
	type integer not null,
	attributes byte(4) not null,
	name nvarchar(129) not null,
	comment nvarchar(255) not null,
	credate integer not null,
	cretime integer not null,
	chdate integer not null,
	chtime integer not null,
	propflag integer not null,
	qcalendar nvarchar(129) not null,
	qevalrate integer not null,
	qnextevaldate integer not null,
	qnextevaltime integer not null,
	qevaldate integer not null,
	qevaltime integer not null,
	qtemplfold byte(16) not null,
	qtype integer not null,
	state integer not null,
	seal integer not null,
	var integer not null,
	auxtext0 nvarchar(128),
	auxtext1 nvarchar(128),
	auxtext2 nvarchar(128),
	auxtext3 nvarchar(128),
	queryid byte(16),
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_contfold to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_contfold () from 'usd_contfold.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_contfold
\p\g
create table usd_csite(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	siteid nvarchar(129) not null,
	location nvarchar(129) not null,
	address nvarchar(255) not null,
	tngname nvarchar(255) not null,
	admname nvarchar(65) not null,
	admphone nvarchar(65) not null,
	asmversion nvarchar(65) not null,
	releasedate integer not null,
	installationdate integer not null,
	creationdate integer not null,
	creationtime integer not null,
	changedate integer not null,
	changetime integer not null,
	archivepath nvarchar(255) not null,
	remoteaddress nvarchar(255) not null,
	networktype integer not null,
	accessname nvarchar(9) not null,
	password nvarchar(9) not null,
	usercomment nvarchar(255) not null,
	uuid nvarchar(37) not null,
	agcnt integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_csite to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_csite () from 'usd_csite.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_csite
\p\g
create table usd_distap(
	objectid byte(16) not null,
	version integer not null,
	distributiondate integer not null,
	distributiontime integer not null,
	ape byte(16) not null,
	distsw byte(16) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_distap to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_distap () from 'usd_distap.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_distap
\p\g
create table usd_distcgrp(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	qtask byte(16) not null,
	aux byte(16) not null,
	aux2 byte(16) not null,
	type integer not null,
	attributes byte(4) not null,
	name nvarchar(129) not null,
	comment nvarchar(255) not null,
	credate integer not null,
	cretime integer not null,
	chdate integer not null,
	chtime integer not null,
	propflag integer not null,
	qcalendar nvarchar(129) not null,
	qevalrate integer not null,
	qnextevaldate integer not null,
	qnextevaltime integer not null,
	qevaldate integer not null,
	qevaltime integer not null,
	qtemplfold byte(16) not null,
	qtype integer not null,
	state integer not null,
	seal integer not null,
	var integer not null,
	auxtext0 nvarchar(128),
	auxtext1 nvarchar(128),
	auxtext2 nvarchar(128),
	auxtext3 nvarchar(128),
	queryid byte(16),
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_distcgrp to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_distcgrp () from 'usd_distcgrp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_distcgrp
\p\g
create table usd_distsw(
	objectid byte(16) not null,
	version integer not null,
	distributiondate integer not null,
	distributiontime integer not null,
	numberofinstallations integer not null,
	numberofinstsfound integer not null,
	numberofinstslocally integer not null,
	filedby integer not null,
	rsw byte(16) not null,
	localsite byte(16) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_distsw to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_distsw () from 'usd_distsw.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_distsw
\p\g
create table usd_fio(
	objectid byte(16) not null,
	version integer not null,
	finame nvarchar(255) not null,
	fienviron nvarchar(255) not null,
	creationdate integer not null,
	creationtime integer not null,
	comment nvarchar(255) not null,
	assoc integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_fio to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_fio () from 'usd_fio.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_fio
\p\g
create table usd_fitem(
	objectid byte(16) not null,
	version integer not null,
	fetchdate integer not null,
	fetchtime integer not null,
	fipath nvarchar(255) not null,
	copied integer not null,
	localsite byte(16) not null,
	fio byte(16) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_fitem to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_fitem () from 'usd_fitem.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_fitem
\p\g
create table usd_jcappgr(
	objectid byte(16) not null,
	version integer not null,
	jobcontview byte(16) not null,
	jobtarget byte(16) not null,
	jobstatus integer not null,
	renewedjobstatus integer not null,
	okcnt integer not null,
	activecnt integer not null,
	errorcnt integer not null,
	waitingcnt integer not null,
	okrenewcnt integer not null,
	activerenewcnt integer not null,
	waitingrenewcnt integer not null,
	errorrenewcnt integer not null,
	permmask integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_jcappgr to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_jcappgr () from 'usd_jcappgr.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_jcappgr
\p\g
create table usd_jcview(
	objectid byte(16) not null,
	version integer not null,
	jobcont byte(16) not null,
	type integer not null,
	waitingcnt integer not null,
	activecnt integer not null,
	errorcnt integer not null,
	okcnt integer not null,
	waitingrenewcnt integer not null,
	activerenewcnt integer not null,
	errorrenewcnt integer not null,
	okrenewcnt integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_jcview to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_jcview () from 'usd_jcview.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_jcview
\p\g
create table usd_job_cont(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	qtask byte(16) not null,
	aux byte(16) not null,
	aux2 byte(16) not null,
	type integer not null,
	attributes byte(4) not null,
	name nvarchar(129) not null,
	comment nvarchar(255) not null,
	credate integer not null,
	cretime integer not null,
	chdate integer not null,
	chtime integer not null,
	propflag integer not null,
	qcalendar nvarchar(129) not null,
	qevalrate integer not null,
	qnextevaldate integer not null,
	qnextevaltime integer not null,
	qevaldate integer not null,
	qevaltime integer not null,
	qtemplfold byte(16) not null,
	qtype integer not null,
	state integer not null,
	seal integer not null,
	var integer not null,
	auxtext0 nvarchar(128),
	auxtext1 nvarchar(128),
	auxtext2 nvarchar(128),
	auxtext3 nvarchar(128),
	queryid byte(16),
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null,
	oid integer,
	dts_state integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_job_cont to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_job_cont () from 'usd_job_cont.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_job_cont
\p\g
create table usd_link_act_inst(
	activity byte(16) not null,
	installation byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_act_inst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_act_inst () from 'usd_link_act_inst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_act_inst
\p\g
create table usd_link_cfold_cont(
	contfold byte(16) not null,
	cont byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_cfold_cont to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_cfold_cont () from 'usd_link_cfold_cont.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_cfold_cont
\p\g
create table usd_link_cmpgrp(
	grpparent byte(16) not null,
	grpchild byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_cmpgrp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_cmpgrp () from 'usd_link_cmpgrp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_cmpgrp
\p\g
create table usd_link_contfold(
	cfold_parent byte(16) not null,
	cfold_child byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_contfold to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_contfold () from 'usd_link_contfold.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_contfold
\p\g
create table usd_link_grp_cmp(
	grp byte(16) not null,
	comp byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_grp_cmp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_grp_cmp () from 'usd_link_grp_cmp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_grp_cmp
\p\g
create table usd_link_grp_proc(
	procgrp byte(16) not null,
	ap byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_grp_proc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_grp_proc () from 'usd_link_grp_proc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_grp_proc
\p\g
create table usd_link_jc(
	jcparent byte(16) not null,
	jcchild byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_jc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_jc () from 'usd_link_jc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_jc
\p\g
create table usd_link_jc_act(
	jcont byte(16) not null,
	activity byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_jc_act to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_jc_act () from 'usd_link_jc_act.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_jc_act
\p\g
create table usd_link_jc_srv(
	jcont byte(16) not null,
	server byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_jc_srv to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_jc_srv () from 'usd_link_jc_srv.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_jc_srv
\p\g
create table usd_link_lsg(
	lsgparent byte(16) not null,
	lsgchild byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_lsg to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_lsg () from 'usd_link_lsg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_lsg
\p\g
create table usd_link_lsg_ls(
	lsg byte(16) not null,
	ls byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_lsg_ls to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_lsg_ls () from 'usd_link_lsg_ls.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_lsg_ls
\p\g
create table usd_link_swg_sw(
	swg byte(16) not null,
	sw byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_swg_sw to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_swg_sw () from 'usd_link_swg_sw.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_swg_sw
\p\g
create table usd_link_swgrp(
	grpparent byte(16) not null,
	grpchild byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_link_swgrp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_link_swgrp () from 'usd_link_swgrp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_link_swgrp
\p\g
create table usd_ls(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	siteid nvarchar(129) not null,
	location nvarchar(129) not null,
	address nvarchar(255) not null,
	tngname nvarchar(255) not null,
	admname nvarchar(65) not null,
	admphone nvarchar(65) not null,
	asmversion nvarchar(65) not null,
	releasedate integer not null,
	installationdate integer not null,
	creationdate integer not null,
	creationtime integer not null,
	changedate integer not null,
	changetime integer not null,
	archivepath nvarchar(255) not null,
	remoteaddress nvarchar(255) not null,
	networktype integer not null,
	accessname nvarchar(9) not null,
	password nvarchar(9) not null,
	usercomment nvarchar(255) not null,
	uuid nvarchar(37) not null,
	agcnt integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_ls to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_ls () from 'usd_ls.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_ls
\p\g
create table usd_lsg(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	qtask byte(16) not null,
	aux byte(16) not null,
	aux2 byte(16) not null,
	type integer not null,
	attributes byte(4) not null,
	name nvarchar(129) not null,
	comment nvarchar(255) not null,
	credate integer not null,
	cretime integer not null,
	chdate integer not null,
	chtime integer not null,
	propflag integer not null,
	qcalendar nvarchar(129) not null,
	qevalrate integer not null,
	qnextevaldate integer not null,
	qnextevaltime integer not null,
	qevaldate integer not null,
	qevaltime integer not null,
	qtemplfold byte(16) not null,
	qtype integer not null,
	state integer not null,
	seal integer not null,
	var integer not null,
	auxtext0 nvarchar(128),
	auxtext1 nvarchar(128),
	auxtext2 nvarchar(128),
	auxtext3 nvarchar(128),
	queryid byte(16),
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_lsg to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_lsg () from 'usd_lsg.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_lsg
\p\g
create table usd_order(
	objectid byte(16) not null,
	version integer not null,
	type integer not null,
	operand byte(16) not null,
	miscitem byte(16) not null,
	sequenceno integer not null,
	activationdate integer not null,
	activationtime integer not null,
	creationdate integer not null,
	creationtime integer not null,
	cont byte(16) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_order to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_order () from 'usd_order.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_order
\p\g
create table usd_ownsite(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	siteid nvarchar(129) not null,
	location nvarchar(129) not null,
	address nvarchar(255) not null,
	tngname nvarchar(255) not null,
	admname nvarchar(65) not null,
	admphone nvarchar(65) not null,
	asmversion nvarchar(65) not null,
	releasedate integer not null,
	installationdate integer not null,
	creationdate integer not null,
	creationtime integer not null,
	changedate integer not null,
	changetime integer not null,
	archivepath nvarchar(255) not null,
	remoteaddress nvarchar(255) not null,
	networktype integer not null,
	accessname nvarchar(9) not null,
	password nvarchar(9) not null,
	usercomment nvarchar(255) not null,
	uuid nvarchar(37) not null,
	agcnt integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_ownsite to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_ownsite () from 'usd_ownsite.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_ownsite
\p\g
create table usd_rsw(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	oid integer,
	packagesize integer not null,
	packagetype integer not null,
	itemname nvarchar(129) not null,
	itemversion nvarchar(129) not null,
	itemtype integer not null,
	sourcemedium integer not null,
	productname nvarchar(129) not null,
	productversion nvarchar(129) not null,
	filedby integer not null,
	supplier nvarchar(255) not null,
	comment nvarchar(255) not null,
	creationdate integer not null,
	creationtime integer not null,
	changedate integer not null,
	changetime integer not null,
	reportevents integer not null,
	activationproc integer not null,
	recnotification integer not null,
	singlemediasourcepath nvarchar(255) not null,
	singlemediasourcepathentered nvarchar(255) not null,
	basedon byte(16) not null,
	deliverproc byte(16) not null,
	undeliverproc byte(16) not null,
	archtime integer not null,
	addsize integer not null,
	archpath nvarchar(255),
	archby nvarchar(129),
	archcomment nvarchar(255),
	archflag integer not null,
	flags integer not null,
	crc32 integer not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_rsw to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy usd_rsw () from 'usd_rsw.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_rsw
\p\g
create table usd_sdusers(
	objectid byte(16) not null,
	version integer not null,
	username nvarchar(129) not null,
	domain nvarchar(129) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_sdusers to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_sdusers () from 'usd_sdusers.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_sdusers
\p\g
create table usd_swfold(
	objectid byte(16) not null,
	version integer not null,
	ownerid byte(16) not null,
	acl byte(32) not null,
	qtask byte(16) not null,
	aux byte(16) not null,
	aux2 byte(16) not null,
	type integer not null,
	attributes byte(4) not null,
	name nvarchar(129) not null,
	comment nvarchar(255) not null,
	credate integer not null,
	cretime integer not null,
	chdate integer not null,
	chtime integer not null,
	propflag integer not null,
	qcalendar nvarchar(129) not null,
	qevalrate integer not null,
	qnextevaldate integer not null,
	qnextevaltime integer not null,
	qevaldate integer not null,
	qevaltime integer not null,
	qtemplfold byte(16) not null,
	qtype integer not null,
	state integer not null,
	seal integer not null,
	var integer not null,
	auxtext0 nvarchar(128),
	auxtext1 nvarchar(128),
	auxtext2 nvarchar(128),
	auxtext3 nvarchar(128),
	queryid byte(16),
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_swfold to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_swfold () from 'usd_swfold.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_swfold
\p\g
create table usd_target(
	objectid byte(16) not null,
	version integer not null default 0,
	ownerid byte(16),
	acl byte(32),
	oid integer not null,
	managementtype integer not null default 1,
	tngname nvarchar(255),
	owner nvarchar(65),
	phonenumber nvarchar(65),
	location nvarchar(129),
	state integer,
	currosvers nvarchar(65),
	comment nvarchar(255),
	calendar nvarchar(33) not null,
	download_method integer not null default 1,
	spare1 byte(16),
	spare2 byte(16),
	spare3 byte(16),
	spare4 byte(16)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_target to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_target () from 'usd_target.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_target
\p\g
create table usd_task(
	objectid byte(16) not null,
	version integer not null,
	referredentity byte(16) not null,
	tasktype integer not null,
	taskstate integer not null,
	creationtime integer not null,
	activationtime integer not null,
	transactiontime integer not null,
	runningstate integer not null,
	runcounter integer not null,
	lasteventmsgtime integer not null,
	noofmsgparameters integer not null,
	lasteventmsgid integer not null,
	eventmsgparams nvarchar(1023) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_task to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy usd_task () from 'usd_task.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_task
\p\g
create table usd_volume(
	objectid byte(16) not null,
	version integer not null,
	name nvarchar(129) not null,
	comment nvarchar(255) not null,
	number integer not null,
	rsw byte(16) not null,
	spare1 byte(16) not null,
	spare2 byte(16) not null,
	spare3 byte(16) not null,
	spare4 byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify usd_volume to heap
with extend = 16,
	allocation = 4
\p\g
/* copy usd_volume () from 'usd_volume.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on usd_volume
\p\g
create table "user"(
	user_uuid byte(16) not null,
	user_name varchar(64) not null,
	encrypted_password varchar(64) not null,
	person_id byte(16) not null,
	incorrect_login_count smallint,
	suspended_date integer,
	suspension_reason_attribute varchar(16),
	disable_date integer,
	enable_date integer,
	description varchar(255),
	location_name varchar(255),
	company_name varchar(64),
	office_name varchar(64),
	comments long varchar,
	generation integer,
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify "user" to heap
with extend = 16,
	allocation = 4
\p\g
/* copy "user" () from 'user.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on "user"
\p\g
create table user_acct_asset_group_matrix(
	user_account_asset_group_id byte(16) not null,
	user_account_id byte(16) not null,
	asset_group_id byte(16),
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64),
	last_update_date integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify user_acct_asset_group_matrix to btree unique on
	user_account_asset_group_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy user_acct_asset_group_matrix () from 'user_acct_asset_group_matrix.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on user_acct_asset_group_matrix
\p\g
create table user_anal(
	collect_id decimal(5,0) not null,
	object_id decimal(5,0) not null,
	metric_name varchar(60),
	metric_value decimal(5,0),
	metric_str_value varchar(200)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify user_anal to heap
with extend = 16,
	allocation = 4
\p\g
/* copy user_anal () from 'user_anal.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on user_anal
\p\g
create table user_defined(
	project_id decimal(31,0) not null,
	udf_owner_id decimal(31,0) not null,
	udf_owner_type decimal(31,0) not null,
	udf_integer_1 decimal(31,0),
	udf_integer_2 decimal(31,0),
	udf_integer_3 decimal(31,0),
	udf_integer_4 decimal(31,0),
	udf_integer_5 decimal(31,0),
	udf_currency_1 float,
	udf_currency_2 float,
	udf_currency_3 float,
	udf_currency_4 float,
	udf_currency_5 float,
	udf_flag_1 decimal(31,0),
	udf_flag_2 decimal(31,0),
	udf_flag_3 decimal(31,0),
	udf_flag_4 decimal(31,0),
	udf_flag_5 decimal(31,0),
	udf_text_1 varchar(4000),
	udf_text_2 varchar(4000),
	udf_text_3 varchar(4000),
	udf_text_4 varchar(4000),
	udf_text_5 varchar(4000),
	udf_start_date_1 date,
	udf_start_date_2 date,
	udf_start_date_3 date,
	udf_start_date_4 date,
	udf_start_date_5 date,
	udf_finish_date_1 date,
	udf_finish_date_2 date,
	udf_finish_date_3 date,
	udf_finish_date_4 date,
	udf_finish_date_5 date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify user_defined to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy user_defined () from 'user_defined.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on user_defined
\p\g
create table user_defined_field(
	user_defined_field_id decimal(31,0) not null,
	udf_data_type_id decimal(31,0),
	udf_field_name varchar(1200) not null,
	udf_field_size decimal(31,2),
	required_flag smallint,
	udf_field_description varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify user_defined_field to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy user_defined_field () from 'user_defined_field.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on user_defined_field
\p\g
create table user_group(
	usernode varchar(64) not null,
	id varchar(32) not null,
	gid integer not null,
	name varchar(255) not null,
	userid varchar(32) not null,
	type varchar(8) not null,
	createdate integer,
	createtime integer,
	createsource varchar(32),
	createnode varchar(64),
	createuser varchar(32),
	createpid varchar(5),
	updatedate integer,
	updatetime integer,
	updatesource varchar(32),
	updatenode varchar(64),
	updateuser varchar(32),
	updatepid varchar(5),
	globalgroup varchar(5)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify user_group to btree on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy user_group () from 'user_group.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on user_group
\p\g
create table user_group_identity_asc(
	user_group_identity_asc_id byte(16) not null,
	security_group_id byte(16) not null,
	identity_label varchar(255),
	creation_user varchar(64),
	creation_date integer,
	last_update_user varchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify user_group_identity_asc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy user_group_identity_asc () from 'user_group_identity_asc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on user_group_identity_asc
\p\g
create table user_head(
	user_head_id decimal(5,0) not null,
	collect_id decimal(5,0),
	user# decimal(5,0),
	username varchar(30),
	account_status decimal(5,0),
	lock_date date,
	expiry_date date,
	default_ts_id decimal(5,0),
	temp_ts_id decimal(5,0),
	created date,
	profile_name varchar(30),
	external_name varchar(2000)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify user_head to btree unique on
	user_head_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy user_head () from 'user_head.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on user_head
\p\g
create table user_pref(
	oid integer not null,
	userid varchar(25),
	passwordx varchar(256),
	firstname varchar(32),
	lastname varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify user_pref to heap
with extend = 16,
	allocation = 4
\p\g
/* copy user_pref () from 'user_pref.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on user_pref
\p\g
create table user_preferences(
	preference_userid integer not null,
	preference_type integer not null,
	product_code integer not null,
	preference_value char(60) not null,
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify user_preferences to btree unique on
	preference_userid,
	preference_type,
	product_code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy user_preferences () from 'user_preferences.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on user_preferences
\p\g
create table user_roles(
	user_name varchar(50) not null,
	role_name varchar(15) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify user_roles to btree unique on
	user_name,
	role_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy user_roles () from 'user_roles.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on user_roles
\p\g
create table user_stat(
	user_head_id decimal(5,0),
	nbr_table decimal(5,0),
	nbr_btree decimal(5,0),
	nbr_bitmap decimal(5,0),
	nbr_iot decimal(5,0),
	nbr_cluster decimal(5,0),
	nbr_trigger decimal(5,0),
	nbr_procedure decimal(5,0),
	nbr_function decimal(5,0),
	nbr_package decimal(5,0),
	nbr_package_body decimal(5,0),
	nbr_view decimal(5,0),
	nbr_synonym decimal(5,0),
	nbr_sequence decimal(5,0),
	nbr_type decimal(5,0),
	nbr_type_body decimal(5,0),
	nbr_object decimal(5,0),
	nbr_link decimal(5,0),
	nbr_ref decimal(5,0),
	total_alloc decimal(5,0)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify user_stat to heap
with extend = 16,
	allocation = 4
\p\g
/* copy user_stat () from 'user_stat.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on user_stat
\p\g
create table user_view_preferences(
	user_view_id decimal(31,0) not null,
	rsrc_id decimal(31,0),
	user_view_name varchar(1200) not null,
	user_view_description varchar(4000),
	public_flag integer,
	view_template_object varchar(4000),
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify user_view_preferences to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy user_view_preferences () from 'user_view_preferences.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on user_view_preferences
\p\g
create table userprofiles(
	user_index integer,
	user_id varchar(64),
	user_pswd varchar(64),
	access_level varchar(64),
	server_list varchar(255),
	def_view1 integer,
	def_view2 integer,
	def_view3 integer,
	def_view4 integer,
	def_view1_settings integer,
	def_view2_settings integer,
	def_view3_settings integer,
	def_view4_settings integer,
	access_groups varchar(255),
	passwordset char(1)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify userprofiles to hash unique on
	user_index,
	user_id
with fillfactor = 50,
	extend = 4
\p\g
/* copy userprofiles () from 'userprofiles.mdbadmin' */
/* with minpages = 10, */
/* 	allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on userprofiles
\p\g
create table users(
	user_name varchar(50) not null,
	user_pass varchar(15) not null,
	actor varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify users to btree unique on
	user_name
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy users () from 'users.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on users
\p\g
create table usersec(
	domainid integer not null,
	userid integer not null,
	scname varchar(32) not null,
	scpass varchar(32),
	scdesc varchar(127),
	sctype integer,
	scdate integer,
	scmail varchar(64),
	scoption1 varchar(64),
	scrights text(1),
	scmtype integer,
	scmsrv varchar(127),
	scstate integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usersec to btree unique on
	userid,
	domainid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy usersec () from 'usersec.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usersec
\p\g
create table usersec_profile(
	node varchar(64) not null,
	id varchar(32) not null,
	uid integer,
	gid integer,
	platform varchar(8),
	ugroupname varchar(20),
	ownerid varchar(20),
	name varchar(255),
	home varchar(255),
	shell varchar(255),
	domain varchar(32),
	phone varchar(14),
	datefmt varchar(11),
	dateseparator char(1),
	decpoint char(1),
	ccase char(1),
	nlscode char(2),
	resparea char(3),
	probesc varchar(6),
	effdate integer,
	expdate integer,
	loginoption varchar(12),
	logincnt integer,
	critprof varchar(20),
	calendar varchar(20),
	defsesid varchar(15),
	lldate integer,
	lltime integer,
	llpid varchar(5),
	llnode varchar(64),
	llsource varchar(32),
	password varchar(32),
	pwddate integer,
	pwdtime integer,
	pwdpid varchar(5),
	pwdnode varchar(64),
	pwduser varchar(32),
	pwdsource varchar(32),
	pwdexpdate integer,
	pwdchange varchar(8),
	pwdqsize integer,
	pwdchgmindays integer,
	pwdchgmaxdays integer,
	pwdmask1 varchar(13),
	pwdmask2 varchar(13),
	pwdviodate integer,
	pwdviotime integer,
	pwdvionode varchar(64),
	pwdviouser varchar(32),
	pwdviosource varchar(32),
	pwdviocount integer,
	violmode varchar(8),
	violaction varchar(16),
	viodate integer,
	viotime integer,
	viopid varchar(5),
	vionode varchar(64),
	viouser varchar(32),
	viosource varchar(32),
	viocount integer,
	status varchar(8),
	susdate integer,
	sustime integer,
	suspid varchar(5),
	susnode varchar(64),
	sususer varchar(32),
	sussource varchar(32),
	suscount integer,
	tmoutintv varchar(8),
	tmodate integer,
	tmotime integer,
	tmopid varchar(5),
	tmonode varchar(64),
	tmosource varchar(32),
	tmocount integer,
	updatedate integer,
	updatetime integer,
	updatepid varchar(5),
	updatenode varchar(64),
	updateuser varchar(32),
	updatesource varchar(32),
	createdate integer,
	createtime integer,
	createpid varchar(5),
	createnode varchar(64),
	createuser varchar(32),
	createsource varchar(32),
	violaction_c char(1),
	violaction_l char(1),
	violaction_s char(1),
	suspended char(3),
	upsstat varchar(20),
	userorigin varchar(12),
	extraint1 integer,
	extraint2 integer,
	extraint3 integer,
	extraint4 integer,
	extraint5 integer,
	extraint6 integer,
	extraint7 integer,
	extraint8 integer,
	extravarchar1 varchar(2),
	extravarchar2 varchar(4),
	extravarchar3 varchar(6),
	extravarchar4 varchar(8),
	extravarchar5 varchar(10),
	extravarchar6 varchar(20),
	extravarchar7 varchar(60)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify usersec_profile to btree on
	node,
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096
\p\g
/* copy usersec_profile () from 'usersec_profile.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usersec_profile
\p\g
create table usp_company(
	id integer not null,
	persid varchar(30),
	del integer not null,
	company_uuid byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usp_company to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usp_company () from 'usp_company.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usp_company
\p\g
create table usp_contact(
	id integer not null,
	persid varchar(30),
	del integer not null,
	contact_uuid byte varying(16),
	c_acctyp_id integer,
	c_email_service varchar(30),
	c_pref_order varchar(12),
	c_cm_id1 integer,
	c_cm_id2 integer,
	c_cm_id3 integer,
	c_cm_id4 integer,
	c_ws_id1 varchar(30),
	c_ws_id2 varchar(30),
	c_ws_id3 varchar(30),
	c_ws_id4 varchar(30),
	c_nx_string1 varchar(40),
	c_nx_string2 varchar(40),
	c_nx_string3 varchar(40),
	c_nx_string4 varchar(40),
	c_nx_string5 varchar(40),
	c_nx_string6 varchar(40),
	c_nx_ref_1 byte varying(16),
	c_nx_ref_2 byte varying(16),
	c_nx_ref_3 byte varying(16),
	c_parent byte varying(16),
	c_vendor byte varying(16),
	c_domain integer,
	c_service_type varchar(30),
	c_timezone varchar(30),
	c_val_req integer,
	c_schedule varchar(30),
	c_available integer,
	global_queue_id integer,
	ldap_dn varchar(512)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usp_contact to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usp_contact () from 'usp_contact.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usp_contact
\p\g
create table usp_location(
	id integer not null,
	persid varchar(30),
	del integer not null,
	location_uuid byte varying(16),
	last_mod integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usp_location to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usp_location () from 'usp_location.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usp_location
\p\g
create table usp_organization(
	id integer not null,
	persid varchar(30),
	del integer not null,
	organization_uuid byte varying(16),
	last_mod integer,
	iorg_service_type varchar(30),
	iorg_assigned_svr integer,
	owning_contract integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usp_organization to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usp_organization () from 'usp_organization.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usp_organization
\p\g
create table usp_owned_resource(
	id integer not null,
	persid varchar(30),
	owned_resource_uuid byte varying(16),
	del integer not null,
	nr_prim_skt_id integer,
	nr_pr_id integer,
	nr_wrty_st_dt integer,
	nr_wrty_end_dt integer,
	nr_exp_dt integer,
	nr_sla_id integer,
	nr_nx_string1 varchar(40),
	nr_nx_string2 varchar(40),
	nr_nx_string3 varchar(40),
	nr_nx_string4 varchar(40),
	nr_nx_string5 varchar(40),
	nr_nx_string6 varchar(40),
	nr_nx_ref_1 byte varying(16),
	nr_nx_ref_2 byte varying(16),
	nr_nx_ref_3 byte varying(16),
	nr_financial_id varchar(40),
	nr_service_type varchar(30),
	nr_argis_id varchar(40),
	nr_bms integer,
	nr_bmlabel varchar(255),
	nr_bm_rep integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usp_owned_resource to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usp_owned_resource () from 'usp_owned_resource.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usp_owned_resource
\p\g
create table usp_preferences(
	id integer not null,
	analyst_id byte varying(16),
	arc_docs_to_display integer,
	user_def_id integer,
	author integer,
	status integer,
	owner integer,
	subject_expert integer,
	initiator integer,
	assignee integer,
	priority integer,
	doc_type integer,
	creation_date integer,
	modify_date integer,
	start_date integer,
	expiration_date integer,
	review_date integer,
	last_accepted_date integer,
	published_date integer,
	bu_result integer,
	product integer,
	item integer,
	sd_rootcause integer,
	sd_priority integer,
	sd_severity integer,
	sd_impact integer,
	sd_urgency integer,
	sd_accepted_hits integer,
	created_via integer,
	primary_index integer,
	current_action integer,
	doc_template integer,
	wf_template integer,
	doc_version integer,
	custom1 integer,
	custom2 integer,
	custom3 integer,
	custom4 integer,
	custom5 integer,
	custom_num1 integer,
	custom_num2 integer,
	one_b_docs_to_display integer,
	one_b_search_type integer,
	one_b_doc_view_mode integer,
	one_b_hide_details integer,
	doc_id integer,
	hits integer,
	inbox_counter integer,
	one_b_word_parts integer,
	one_b_match_type integer,
	one_b_search_fields integer,
	one_b_search_order varchar(255),
	web_suppress_tour integer,
	web_last_login integer,
	web_popup1_height integer,
	web_popup1_width integer,
	web_popup2_height integer,
	web_popup2_width integer,
	web_toolbar_tab integer,
	web_preferences integer,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usp_preferences to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usp_preferences () from 'usp_preferences.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usp_preferences
\p\g
create table usp_properties(
	id integer not null,
	property_name varchar(100),
	property_type varchar(100),
	property_description varchar(255),
	property_default long varchar,
	property_value long varchar,
	last_mod_dt integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usp_properties to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usp_properties () from 'usp_properties.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usp_properties
\p\g
create table usq(
	id integer not null,
	persid varchar(30),
	sequence integer not null,
	label varchar(80) not null,
	analyst byte varying(16),
	query_set integer,
	query_type integer,
	query varchar(30),
	parent integer,
	factory varchar(30),
	expanded integer,
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify usq to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy usq () from 'usq.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on usq
\p\g
create table validation_method(
	validation_method_id byte(16) not null,
	name nvarchar(60) not null,
	description long nvarchar,
	creation_user nvarchar(64) not null,
	creation_date integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify validation_method to btree unique on
	validation_method_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy validation_method () from 'validation_method.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on validation_method
\p\g
create table variable(
	variable_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	owning_library_id decimal(31,0),
	instantiation_source_id decimal(31,0),
	reference_id varchar(120),
	alt_ref_id varchar(120),
	variable_name varchar(1200) not null,
	variable_description varchar(4000),
	question varchar(320),
	advice varchar(4000),
	formula varchar(4000),
	assumptions varchar(4000),
	default_value float,
	value float,
	derivation_source integer,
	format_category integer,
	variable_data_type integer,
	logical_delete_flag smallint,
	ref_name varchar(4000),
	alt_ref_name varchar(4000),
	value_last_update date,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 32768,
location = (ii_database),
security_audit=(table,norow)
;
modify variable to heap
with extend = 16,
	allocation = 4,
	page_size = 32768
\p\g
/* copy variable () from 'variable.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on variable
\p\g
create table variable_keyword(
	keyword_id decimal(31,0) not null,
	variable_id decimal(31,0) not null,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify variable_keyword to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy variable_keyword () from 'variable_keyword.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on variable_keyword
\p\g
create table version(
	version integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify version to heap
with extend = 16,
	allocation = 4
\p\g
/* copy version () from 'version.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on version
\p\g
create table view_column(
	view_component_id decimal(31,0) not null,
	view_id decimal(31,0) not null,
	column_width integer,
	column_position integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify view_column to heap
with extend = 16,
	allocation = 4,
	page_size = 8192
\p\g
/* copy view_column () from 'view_column.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on view_column
\p\g
create table view_component(
	view_component_id decimal(31,0) not null,
	project_id decimal(31,0) not null,
	pe_udf_field_id decimal(31,0),
	metric_id decimal(31,0),
	metric_value_set_id decimal(31,0),
	scheduler_property_id decimal(31,0),
	view_component_name varchar(1200),
	view_path varchar(4000),
	column_width integer,
	column_type integer not null,
	level_flags smallint,
	default_position integer,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify view_component to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy view_component () from 'view_component.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on view_component
\p\g
create table viewgroups(
	spid integer not null,
	rptid integer not null,
	grpindex integer not null,
	server_addr integer not null,
	probe_addr integer not null,
	rsrcindex integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify viewgroups to btree on
	spid,
	rptid,
	grpindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy viewgroups () from 'viewgroups.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on viewgroups
\p\g
create table viewlanquerydata(
	spid integer not null,
	rptid integer not null,
	server_addr integer not null,
	probe_addr integer not null,
	probeindex integer not null,
	probeinterfacename varchar(40),
	agentipaddress varchar(16),
	community varchar(30),
	string1 varchar(128),
	string2 varchar(40),
	string3 varchar(40),
	intervaldatetime date,
	value1 float,
	value2 float,
	value3 float,
	value4 float,
	value5 float,
	value6 float,
	value7 float,
	value8 float,
	value9 float,
	value10 float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify viewlanquerydata to btree on
	spid,
	rptid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy viewlanquerydata () from 'viewlanquerydata.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
create table viewquerydata(
	spid integer not null,
	rptid integer not null,
	server_addr integer not null,
	probe_addr integer not null,
	rsrcindex integer,
	ip_addr varchar(20),
	mib_descr varchar(255),
	user_descr varchar(255),
	if_speed integer,
	if_type integer,
	if_type_descr varchar(50),
	total_alerts integer,
	select_alert integer,
	value1 float,
	value2 float,
	value3 float,
	value4 float,
	value5 float,
	value6 float,
	string1 varchar(128),
	string2 varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify viewquerydata to btree on
	spid,
	rptid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy viewquerydata () from 'viewquerydata.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table viewsettings(
	vuserindex integer,
	vindex integer not null,
	vname varchar(64) not null,
	vselect integer not null,
	vsubtype1 integer,
	vsubtype2 integer,
	startdatetime date,
	stopdatetime date,
	vlastcount integer,
	vlastunit integer,
	vgroupindex integer,
	vtopn integer,
	vtopncolumn integer,
	valert integer,
	vlinktype integer,
	vlinkspeed integer,
	vformat integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify viewsettings to btree on
	vuserindex,
	vindex
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 4
\p\g
/* copy viewsettings () from 'viewsettings.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on viewsettings
\p\g
create table vrsn(
	oid integer not null,
	qmset_oid integer not null,
	user_name varchar(60) not null,
	create_date char(10) not null,
	create_time char(8) not null,
	activated_date char(10),
	activated_time char(8),
	vrsn_num integer not null,
	descr varchar(254)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify vrsn to heap
with extend = 16,
	allocation = 4
\p\g
/* copy vrsn () from 'vrsn.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on vrsn
\p\g
create table vuln_management_backup_config(
	unit_id byte(16) not null,
	backup_file_url nvarchar(255),
	backup_location_password nvarchar(30),
	backup_location_user_name nvarchar(85),
	is_active i1 not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify vuln_management_backup_config to btree unique on
	unit_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy vuln_management_backup_config () from 'vuln_management_backup_config.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on vuln_management_backup_config
\p\g
create table vuln_management_configuration(
	unit_id byte(16) not null,
	host_name nvarchar(255) not null,
	license_key nvarchar(128) not null,
	content_source_url nvarchar(300) not null,
	ip_address nvarchar(15),
	license_expiration_date integer,
	content_update_interval nvarchar(1) not null,
	content_update_time smallint,
	sub_net_mask_ip nvarchar(15),
	units_managed_soft_limit integer,
	units_managed_hard_limit integer,
	default_gateway_ip nvarchar(15),
	dns_server_ip nvarchar(15),
	proxy_url nvarchar(256),
	proxy_user_name nvarchar(256),
	proxy_password nvarchar(256),
	maintenance_time smallint,
	last_successful_content_update integer,
	allow_configuration_standard_mgm i1,
	preferred_language_id byte(16),
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify vuln_management_configuration to btree unique on
	unit_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy vuln_management_configuration () from 'vuln_management_configuration.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on vuln_management_configuration
\p\g
create table vulnerability(
	vuln_id byte(16) not null,
	computer_associates_id integer,
	name nvarchar(255) not null,
	long_description long nvarchar,
	short_description nvarchar(255),
	impact_statement long nvarchar,
	technical_recommendation long nvarchar,
	discovery_date integer,
	discovered_by nvarchar(255),
	vulnerability_type nvarchar(2) not null,
	initial_published_date integer,
	creation_user nvarchar(64) not null,
	creation_date integer not null,
	last_update_user nvarchar(64) not null,
	last_update_date integer not null,
	version_number integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify vulnerability to btree unique on
	vuln_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy vulnerability () from 'vulnerability.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on vulnerability
\p\g
create table vulnerability_vailidation_method(
	vuln_validation_rec_id byte(16) not null,
	vuln_id byte(16) not null,
	validation_method_id byte(16) not null,
	creation_user nvarchar(64) not null,
	creation_date integer not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify vulnerability_vailidation_method to btree unique on
	vuln_validation_rec_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy vulnerability_vailidation_method () from 'vulnerability_vailidation_method.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on vulnerability_vailidation_method
\p\g
create table vunerability_asset_group(
	asset_group_id byte(16) not null,
	name nvarchar(255) not null,
	is_default i1,
	protection_level_id byte(16) not null,
	partial_host_name nvarchar(50),
	beginning_ip_address nvarchar(15),
	ending_ip_address nvarchar(15),
	is_allowed_to_use_auto_inv i1,
	unit_id byte(16) not null,
	creation_user nvarchar(64),
	creation_date integer,
	last_update_user nvarchar(64),
	last_update_date integer,
	version_number integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify vunerability_asset_group to btree unique on
	asset_group_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy vunerability_asset_group () from 'vunerability_asset_group.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on vunerability_asset_group
\p\g
create table wait_que(
	joid integer,
	job_load integer,
	que_name varchar(62),
	max_load integer,
	priority integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wait_que to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wait_que () from 'wait_que.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wait_que
\p\g
create table weekday(
	id integer,
	name varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify weekday to heap
with extend = 16,
	allocation = 4
\p\g
/* copy weekday () from 'weekday.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on weekday
\p\g
create table wf(
	id integer not null,
	persid varchar(30),
	del integer not null,
	object_type varchar(30) not null,
	object_id integer not null,
	task varchar(12) not null,
	wf_template integer,
	sequence integer not null,
	status varchar(12),
	group_task integer not null,
	asset byte varying(16),
	creator byte varying(16),
	date_created integer,
	assignee byte varying(16),
	group_id byte varying(16),
	support_lev varchar(30),
	done_by byte varying(16),
	start_date integer,
	est_comp_date integer,
	completion_date integer,
	est_duration integer,
	actual_duration integer,
	est_cost integer,
	cost integer,
	description varchar(1000),
	last_mod_dt integer,
	last_mod_by byte varying(16)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify wf to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy wf () from 'wf.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wf
\p\g
create table wfschema(
	name varchar(50) not null,
	schemainfo long byte not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wfschema to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wfschema () from 'wfschema.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wfschema
\p\g
create table wftpl(
	id integer not null,
	persid varchar(30),
	del integer not null,
	description varchar(240),
	last_mod_dt integer,
	last_mod_by byte varying(16),
	object_type varchar(30) not null,
	object_attrname varchar(30) not null,
	object_attrval integer not null,
	task varchar(12) not null,
	sequence integer not null,
	assignee byte varying(16),
	group_id byte varying(16),
	service_type varchar(30),
	deleteable integer not null,
	est_duration integer,
	est_cost integer,
	auto_assign integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify wftpl to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy wftpl () from 'wftpl.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wftpl
\p\g
create table wftpl_grp(
	id integer not null,
	l_persid varchar(30),
	l_attr varchar(30),
	l_sql integer,
	r_persid varchar(30),
	r_attr varchar(30),
	r_sql integer
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify wftpl_grp to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy wftpl_grp () from 'wftpl_grp.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wftpl_grp
\p\g
create table wip(
	oid integer not null,
	qmset_oid integer not null,
	user_name varchar(60) not null,
	create_date char(10) not null,
	create_time char(8) not null,
	vrsn_num integer not null,
	descr varchar(254)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wip to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wip () from 'wip.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wip
\p\g
create table wkresourceprofile(
	resourceid varchar(17) not null,
	jobid integer not null,
	stationid varchar(21),
	amount integer,
	weight integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wkresourceprofile to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wkresourceprofile () from 'wkresourceprofile.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wkresourceprofile
\p\g
create table wktriggerprofile(
	jobid integer not null,
	triggertype varchar(9) not null,
	triggerid varchar(65) not null,
	triggerfile varchar(255),
	triggerjobset varchar(65),
	triggerjob varchar(65),
	triggerjobno integer,
	statcode integer,
	caevent varchar(9),
	usestat varchar(4),
	triggeruser varchar(33),
	batchqueue varchar(2)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wktriggerprofile to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy wktriggerprofile () from 'wktriggerprofile.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wktriggerprofile
\p\g
create table work_week(
	work_week_id decimal(31,0) not null,
	project_id decimal(31,0),
	work_week_type decimal(31,0),
	work_week_name varchar(1200) not null,
	work_week_description varchar(4000),
	shiftstart_sun date,
	shiftstart_mon date,
	shiftstart_tue date,
	shiftstart_wed date,
	shiftstart_thu date,
	shiftstart_fri date,
	shiftstart_sat date,
	work_week_ovt_hrs_sun decimal(31,0),
	work_week_ovt_hrs_mon decimal(31,0),
	work_week_ovt_hrs_tue decimal(31,0),
	work_week_ovt_hrs_wed decimal(31,0),
	work_week_ovt_hrs_thu decimal(31,0),
	work_week_ovt_hrs_fri decimal(31,0),
	work_week_ovt_hrs_sat decimal(31,0),
	work_week_start_date date,
	work_week_end_date date,
	work_week_hrs_sun decimal(31,0),
	work_week_hrs_mon decimal(31,0),
	work_week_hrs_tue decimal(31,0),
	work_week_hrs_wed decimal(31,0),
	work_week_hrs_thu decimal(31,0),
	work_week_hrs_fri decimal(31,0),
	work_week_hrs_sat decimal(31,0),
	avl_ovt_ent decimal(5,0),
	logical_delete_flag smallint,
	creation_datetime date,
	creation_user_name varchar(1200),
	last_update_datetime date,
	last_update_user_name varchar(1200),
	comments varchar(4000)
)
with duplicates,
nojournaling,
	page_size = 16384,
location = (ii_database),
security_audit=(table,norow)
;
modify work_week to heap
with extend = 16,
	allocation = 4,
	page_size = 16384
\p\g
/* copy work_week () from 'work_week.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on work_week
\p\g
create table workalert(
	spid integer,
	rpid integer,
	server_addr integer,
	probe_addr integer,
	rsrcindex integer,
	rsrcotherindex integer,
	fieldindex integer,
	intervaldatetime date,
	ip_addr varchar(32),
	sysname varchar(255),
	userdescr varchar(255),
	sysdescr varchar(255),
	interfacename varchar(255),
	interfacedescr varchar(255),
	lsyprobe varchar(64),
	value float,
	threshold float,
	severity varchar(16),
	alertdescr varchar(255),
	unit varchar(32),
	string1 varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workalert to btree on
	spid,
	rpid,
	probe_addr
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy workalert () from 'workalert.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
create table workbench_product(
	product_code integer not null,
	product_name char(60) not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify workbench_product to btree unique on
	product_code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy workbench_product () from 'workbench_product.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on workbench_product
\p\g
create table workbench_provider(
	provider_name char(20) not null,
	product_code integer not null,
	datetime_updated date not null
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify workbench_provider to btree unique on
	provider_name,
	product_code
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 4096,
	unique_scope = statement
\p\g
/* copy workbench_provider () from 'workbench_provider.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on workbench_provider
\p\g
create table workflow_configuration(
	filename varchar(50) not null,
	content long byte not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workflow_configuration to heap
with extend = 16,
	allocation = 4
\p\g
/* copy workflow_configuration () from 'workflow_configuration.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on workflow_configuration
\p\g
create table workflow_groups(
	groupname varchar(50),
	actorname varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workflow_groups to heap
with extend = 16,
	allocation = 4
\p\g
/* copy workflow_groups () from 'workflow_groups.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on workflow_groups
\p\g
create table workitems(
	processid varchar(20) not null default '',
	nodeid varchar(20) not null default '',
	content long byte
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workitems to heap
with extend = 16,
	allocation = 4
\p\g
/* copy workitems () from 'workitems.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on workitems
\p\g
create table worklist(
	actor varchar(50) not null,
	processid varchar(20) not null,
	activityname varchar(30) not null,
	activitydesc varchar(200),
	processname varchar(30) not null,
	label varchar(30),
	operation long byte not null,
	activated float,
	completed float,
	duedate float,
	activityid varchar(20),
	workitemid varchar(30),
	executionid varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify worklist to heap
with extend = 16,
	allocation = 4
\p\g
/* copy worklist () from 'worklist.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on worklist
\p\g
create table workloadcommon(
	jobid integer not null,
	regionid integer,
	instancename varchar(64),
	jobname varchar(139) not null,
	jobtype varchar(32) not null,
	jobleft integer,
	jobright integer,
	jobtop integer,
	jobbottom integer,
	cloneid integer,
	templatejobid integer,
	checkoutsid varchar(100),
	checkoutname varchar(100),
	lastsynctime integer,
	lastmodtime integer,
	boxjobid integer,
	applicationid varchar(8),
	abendaction varchar(64),
	anycpu varchar(10),
	autosel varchar(10),
	averagetime varchar(9),
	backlog varchar(10),
	boxname varchar(64),
	calendar varchar(12),
	createdate varchar(11),
	createtime varchar(9),
	createuser varchar(50),
	adjustment integer,
	critcal varchar(12),
	crithact varchar(20),
	critnwact varchar(20),
	critkeys varchar(255),
	description varchar(255),
	earlytime varchar(9),
	effectivedate varchar(11),
	expiresdate varchar(11),
	failcondl integer,
	failcondh integer,
	history integer,
	hold varchar(10),
	maxtime varchar(9),
	mustcomptime varchar(9),
	muststarttime varchar(9),
	subuserid varchar(16),
	subdomain varchar(16),
	subpass varchar(255),
	priority integer,
	skip integer,
	station varchar(20),
	updatedate varchar(11),
	updatetime varchar(9),
	updateuser varchar(33),
	userenv varchar(10),
	wk_condition text(1),
	jobnumber integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workloadcommon to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy workloadcommon () from 'workloadcommon.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on workloadcommon
\p\g
create table workloadextendedprops(
	jobid integer not null,
	indexid integer not null,
	parm varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workloadextendedprops to btree unique on
	jobid,
	indexid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy workloadextendedprops () from 'workloadextendedprops.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on workloadextendedprops
\p\g
create table workloadjob(
	jobid integer not null,
	autostart varchar(10),
	cycfreq integer,
	cyccount integer,
	cyclic varchar(10),
	interruptible varchar(10),
	subfile varchar(255),
	cloneid integer,
	templatejobid integer,
	type varchar(50)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workloadjob to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy workloadjob () from 'workloadjob.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on workloadjob
\p\g
create table workloadjobset(
	jobid integer not null,
	settype varchar(50),
	cloneid integer,
	templatejobid integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify workloadjobset to btree unique on
	jobid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy workloadjobset () from 'workloadjobset.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on workloadjobset
\p\g
create table wsdl_catalog(
	wsdl_catalog_id integer not null,
	name varchar(255),
	url varchar(255),
	service_name varchar(255),
	target_namespace varchar(255),
	documentation varchar(255),
	creation_date date,
	modification_date date,
	current_version integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wsdl_catalog to btree unique on
	wsdl_catalog_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy wsdl_catalog () from 'wsdl_catalog.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wsdl_catalog
\p\g
create table wsdl_file(
	wsdl_file_id integer not null,
	wsdl_catalog_id integer,
	file char(1),
	notes varchar(255),
	modification_date date,
	version integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wsdl_file to btree unique on
	wsdl_file_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy wsdl_file () from 'wsdl_file.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wsdl_file
\p\g
create table wsdl_operation(
	wsdl_operation_id integer not null,
	wsdl_catalog_id integer,
	service_name varchar(255),
	port_address varchar(255),
	name varchar(255),
	documentation varchar(255),
	type varchar(255),
	status integer,
	version integer,
	security_type integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wsdl_operation to btree unique on
	wsdl_operation_id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	unique_scope = statement
\p\g
/* copy wsdl_operation () from 'wsdl_operation.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wsdl_operation
\p\g
create table wt_3com(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wt_3com to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wt_3com () from 'wt_3com.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wt_3com
\p\g
create table wt_3com_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wt_3com_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wt_3com_access_point () from 'wt_3com_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wt_3com_access_point
\p\g
create table wtaccess_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtaccess_point to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtaccess_point () from 'wtaccess_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtaccess_point
\p\g
create table wtaccesspointreference(
	name varchar(40) not null,
	description varchar(40),
	uuid byte(16) not null,
	failedcountw integer,
	failedcountc integer,
	deltafailedcountw integer,
	deltafailedcountc integer,
	ratefailedcountw integer,
	ratefailedcountc integer,
	failedcountrateint integer,
	retrycountw integer,
	retrycountc integer,
	deltaretrycountw integer,
	deltaretrycountc integer,
	rateretrycountw integer,
	rateretrycountc integer,
	retrycountrateint integer,
	multipleretrycountw integer,
	multipleretrycountc integer,
	deltamultipleretrycountw integer,
	deltamultipleretrycountc integer,
	ratemultipleretrycountw integer,
	ratemultipleretrycountc integer,
	multipleretrycountrateint integer,
	frameduplicatecountw integer,
	frameduplicatecountc integer,
	deltaframeduplicatecountw integer,
	deltaframeduplicatecountc integer,
	rateframeduplicatecountw integer,
	rateframeduplicatecountc integer,
	frameduplicatecountrateint integer,
	rtsfailurecountw integer,
	rtsfailurecountc integer,
	deltartsfailurecountw integer,
	deltartsfailurecountc integer,
	ratertsfailurecountw integer,
	ratertsfailurecountc integer,
	rtsfailurecountrateint integer,
	ackfailurecountw integer,
	ackfailurecountc integer,
	deltaackfailurecountw integer,
	deltaackfailurecountc integer,
	rateackfailurecountw integer,
	rateackfailurecountc integer,
	ackfailurecountrateint integer,
	fcserrorcountw integer,
	fcserrorcountc integer,
	deltafcserrorcountw integer,
	deltafcserrorcountc integer,
	ratefcserrorcountw integer,
	ratefcserrorcountc integer,
	fcserrorcountrateint integer,
	wepundecryptablecountw integer,
	wepundecryptablecountc integer,
	deltawepundecryptablecountw integer,
	deltawepundecryptablecountc integer,
	ratewepundecryptablecountw integer,
	ratewepundecryptablecountc integer,
	wepundecryptablecountrateint integer,
	wepexcludedcountw integer,
	wepexcludedcountc integer,
	deltawepexcludedcountw integer,
	deltawepexcludedcountc integer,
	ratewepexcludedcountw integer,
	ratewepexcludedcountc integer,
	wepexcludedcountrateint integer,
	wepicverrorcountw integer,
	wepicverrorcountc integer,
	deltawepicverrorcountw integer,
	deltawepicverrorcountc integer,
	ratewepicverrorcountw integer,
	ratewepicverrorcountc integer,
	wepicverrorcountrateint integer,
	validssid varchar(40),
	securityviolationsetting integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtaccesspointreference to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtaccesspointreference () from 'wtaccesspointreference.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtaccesspointreference
\p\g
create table wtaccessstax(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtaccessstax to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtaccessstax () from 'wtaccessstax.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtaccessstax
\p\g
create table wtadhoc_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtadhoc_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtadhoc_access_point () from 'wtadhoc_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtadhoc_access_point
\p\g
create table wtagent(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtagent to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtagent () from 'wtagent.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtagent
\p\g
create table wtapc_ups(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtapc_ups to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtapc_ups () from 'wtapc_ups.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtapc_ups
\p\g
create table wtas400(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtas400 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtas400 () from 'wtas400.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtas400
\p\g
create table wtasante(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtasante to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtasante () from 'wtasante.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtasante
\p\g
create table wtavayaaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtavayaaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtavayaaccesspoint () from 'wtavayaaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtavayaaccesspoint
\p\g
create table wtbattery(
	uuid byte(16) not null,
	battery_level integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbattery to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtbattery () from 'wtbattery.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbattery
\p\g
create table wtbaybridge(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbaybridge to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtbaybridge () from 'wtbaybridge.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbaybridge
\p\g
create table wtbayhub(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbayhub to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtbayhub () from 'wtbayhub.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbayhub
\p\g
create table wtbelkinaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbelkinaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtbelkinaccesspoint () from 'wtbelkinaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbelkinaccesspoint
\p\g
create table wtbillboard(
	uuid byte(16) not null,
	billboard_type varchar(8),
	severity_level integer,
	status_text_query varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbillboard to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtbillboard () from 'wtbillboard.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbillboard
\p\g
create table wtbreezecomaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbreezecomaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtbreezecomaccesspoint () from 'wtbreezecomaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbreezecomaccesspoint
\p\g
create table wtbridge(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbridge to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtbridge () from 'wtbridge.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbridge
\p\g
create table wtbuffalo_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbuffalo_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtbuffalo_access_point () from 'wtbuffalo_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbuffalo_access_point
\p\g
create table wtbull(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtbull to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtbull () from 'wtbull.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtbull
\p\g
create table wtcabletron(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcabletron to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtcabletron () from 'wtcabletron.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcabletron
\p\g
create table wtcamera_3d(
	name varchar(40) not null,
	lookfrom_x float,
	lookfrom_y float,
	lookfrom_z float,
	lookat_x float,
	lookat_y float,
	lookat_z float,
	up_x float,
	up_y float,
	up_z float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcamera_3d to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtcamera_3d () from 'wtcamera_3d.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcamera_3d
\p\g
create table wtchargeback(
	uuid byte(16) not null,
	performance_system_type varchar(40),
	performance_host_name varchar(200),
	performance_host_uuid byte(16) not null,
	performance_host_class varchar(40),
	performance_psc_file varchar(254),
	performance_flags integer,
	performance_test_copy_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtchargeback to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtchargeback () from 'wtchargeback.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtchargeback
\p\g
create table wtchipcom(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtchipcom to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtchipcom () from 'wtchipcom.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtchipcom
\p\g
create table wtciprico(
	uuid byte(16) not null,
	firmware_version varchar(40),
	scsi_inquiry varchar(128),
	serial_num varchar(40),
	stratification_level integer,
	device_name varchar(40),
	model_id integer,
	num_drives integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtciprico to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtciprico () from 'wtciprico.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtciprico
\p\g
create table wtcisco(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcisco to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtcisco () from 'wtcisco.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcisco
\p\g
create table wtcisco_aironet1100_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcisco_aironet1100_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtcisco_aironet1100_access_point () from 'wtcisco_aironet1100_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcisco_aironet1100_access_point
\p\g
create table wtcisco_aironet1200_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcisco_aironet1200_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtcisco_aironet1200_access_point () from 'wtcisco_aironet1200_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcisco_aironet1200_access_point
\p\g
create table wtcisco_aironet340_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcisco_aironet340_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtcisco_aironet340_access_point () from 'wtcisco_aironet340_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcisco_aironet340_access_point
\p\g
create table wtcisco_aironet350_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcisco_aironet350_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtcisco_aironet350_access_point () from 'wtcisco_aironet350_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcisco_aironet350_access_point
\p\g
create table wtclariion_dae(
	uuid byte(16) not null,
	firmware_version varchar(40),
	scsi_inquiry varchar(128),
	serial_num varchar(40),
	stratification_level integer,
	device_name varchar(40),
	model_id varchar(40),
	num_drives integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtclariion_dae to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtclariion_dae () from 'wtclariion_dae.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtclariion_dae
\p\g
create table wtclariion_dpe(
	uuid byte(16) not null,
	firmware_version varchar(40),
	scsi_inquiry varchar(128),
	serial_num varchar(40),
	wwnspa varchar(40),
	wwnspb varchar(40),
	stratification_level integer,
	device_name varchar(40),
	model_id varchar(40),
	num_drives integer,
	num_sps integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtclariion_dpe to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtclariion_dpe () from 'wtclariion_dpe.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtclariion_dpe
\p\g
create table wtcmutek(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcmutek to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtcmutek () from 'wtcmutek.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcmutek
\p\g
create table wtcompaq_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcompaq_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtcompaq_access_point () from 'wtcompaq_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcompaq_access_point
\p\g
create table wtcontextmenu(
	name varchar(40) not null,
	background_color integer,
	font varchar(30),
	font_size integer,
	foreground_color integer,
	shadow i1,
	transparency float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtcontextmenu to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtcontextmenu () from 'wtcontextmenu.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtcontextmenu
\p\g
create table wtdatacomagtinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	dtcmport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdatacomagtinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdatacomagtinst () from 'wtdatacomagtinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdatacomagtinst
\p\g
create table wtdbpvqueryinfo(
	sequence_number integer,
	query_name varchar(255) not null,
	identifier varchar(255) not null,
	operator varchar(255) not null,
	attribute varchar(255) not null,
	type integer not null,
	value varchar(255),
	enabled i1 not null,
	schema_name varchar(255) not null,
	logical_op integer,
	reserved varchar(255),
	weight integer,
	start_group integer,
	end_group integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdbpvqueryinfo to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdbpvqueryinfo () from 'wtdbpvqueryinfo.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdbpvqueryinfo
\p\g
create table wtdecbridge(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdecbridge to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdecbridge () from 'wtdecbridge.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdecbridge
\p\g
create table wtdechub(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdechub to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdechub () from 'wtdechub.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdechub
\p\g
create table wtdecrouter(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdecrouter to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdecrouter () from 'wtdecrouter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdecrouter
\p\g
create table wtdecsystem(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdecsystem to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdecsystem () from 'wtdecsystem.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdecsystem
\p\g
create table wtdevice_disk_ide(
	uuid byte(16) not null,
	ide_channel integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdevice_disk_ide to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdevice_disk_ide () from 'wtdevice_disk_ide.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdevice_disk_ide
\p\g
create table wtdevice_disk_scsi(
	uuid byte(16) not null,
	scsi_address integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdevice_disk_scsi to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdevice_disk_scsi () from 'wtdevice_disk_scsi.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdevice_disk_scsi
\p\g
create table wtdevice_tapelibrary(
	uuid byte(16) not null,
	library_configuration varchar(64)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdevice_tapelibrary to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdevice_tapelibrary () from 'wtdevice_tapelibrary.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdevice_tapelibrary
\p\g
create table wtdg_ux(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdg_ux to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtdg_ux () from 'wtdg_ux.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdg_ux
\p\g
create table wtdlink_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtdlink_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtdlink_access_point () from 'wtdlink_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtdlink_access_point
\p\g
create table wteauditmessageannotate(
	collectornode varchar(32) not null,
	collectortable varchar(32) not null,
	collectorid integer not null,
	username varchar(32) not null,
	timestamp varchar(30) not null,
	text varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wteauditmessageannotate to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wteauditmessageannotate () from 'wteauditmessageannotate.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wteauditmessageannotate
\p\g
create table wteauditmessagegroup(
	name varchar(30) not null,
	description varchar(255),
	owner varchar(32),
	priority integer,
	pending i1,
	pendingid varchar(32),
	viewerprofile varchar(128),
	annotated i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wteauditmessagegroup to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wteauditmessagegroup () from 'wteauditmessagegroup.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wteauditmessagegroup
\p\g
create table wteauditmessagegroupannotate(
	messagegroupname varchar(30) not null,
	username varchar(32) not null,
	timestamp varchar(30) not null,
	text varchar(255) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wteauditmessagegroupannotate to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wteauditmessagegroupannotate () from 'wteauditmessagegroupannotate.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wteauditmessagegroupannotate
\p\g
create table wteauditmessagegroupmessage(
	messagegroupname varchar(30) not null,
	collectornode varchar(32) not null,
	collectortable varchar(32) not null,
	collectorid integer not null,
	timestamp varchar(30) not null,
	owner varchar(32),
	priority integer,
	pending i1,
	annotated i1,
	pendingid varchar(32),
	columns1 varchar(255),
	columns2 varchar(255),
	columns3 varchar(255),
	columns4 varchar(255),
	columns5 varchar(255),
	columns6 varchar(255),
	columns7 varchar(255),
	columns8 varchar(255),
	columns9 varchar(255),
	columns10 varchar(255),
	columns11 varchar(255),
	columns12 varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wteauditmessagegroupmessage to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wteauditmessagegroupmessage () from 'wteauditmessagegroupmessage.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wteauditmessagegroupmessage
\p\g
create table wtentrasys_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtentrasys_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtentrasys_access_point () from 'wtentrasys_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtentrasys_access_point
\p\g
create table wtepcomsmpnodegroup(
	uuid byte(16) not null,
	type integer,
	queryclass varchar(40),
	queryproperty varchar(40),
	join_name1 varchar(200),
	join_name2 varchar(200),
	join_type integer,
	ip_query varchar(255),
	et_platform varchar(40),
	et_product varchar(200)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepcomsmpnodegroup to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepcomsmpnodegroup () from 'wtepcomsmpnodegroup.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepcomsmpnodegroup
\p\g
create table wtepworld_ecs_c6(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_ecs_c6 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_ecs_c6 () from 'wtepworld_ecs_c6.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_ecs_c6
\p\g
create table wtepworld_ecs_pc(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_ecs_pc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_ecs_pc () from 'wtepworld_ecs_pc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_ecs_pc
\p\g
create table wtepworld_ecs_s1(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_ecs_s1 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_ecs_s1 () from 'wtepworld_ecs_s1.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_ecs_s1
\p\g
create table wtepworld_ecs_s2(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_ecs_s2 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_ecs_s2 () from 'wtepworld_ecs_s2.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_ecs_s2
\p\g
create table wtepworld_ecs_s3(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_ecs_s3 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_ecs_s3 () from 'wtepworld_ecs_s3.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_ecs_s3
\p\g
create table wtepworld_ecs_s4(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_ecs_s4 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_ecs_s4 () from 'wtepworld_ecs_s4.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_ecs_s4
\p\g
create table wtepworld_ecs_s5(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_ecs_s5 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_ecs_s5 () from 'wtepworld_ecs_s5.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_ecs_s5
\p\g
create table wtepworld_eportal_c5(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_c5 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_c5 () from 'wtepworld_eportal_c5.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_c5
\p\g
create table wtepworld_eportal_c8(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_c8 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_c8 () from 'wtepworld_eportal_c8.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_c8
\p\g
create table wtepworld_eportal_pc(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_pc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_pc () from 'wtepworld_eportal_pc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_pc
\p\g
create table wtepworld_eportal_s10(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s10 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s10 () from 'wtepworld_eportal_s10.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s10
\p\g
create table wtepworld_eportal_s11(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s11 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s11 () from 'wtepworld_eportal_s11.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s11
\p\g
create table wtepworld_eportal_s12(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s12 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s12 () from 'wtepworld_eportal_s12.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s12
\p\g
create table wtepworld_eportal_s14(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s14 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s14 () from 'wtepworld_eportal_s14.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s14
\p\g
create table wtepworld_eportal_s15(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s15 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s15 () from 'wtepworld_eportal_s15.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s15
\p\g
create table wtepworld_eportal_s2(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s2 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s2 () from 'wtepworld_eportal_s2.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s2
\p\g
create table wtepworld_eportal_s3(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s3 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s3 () from 'wtepworld_eportal_s3.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s3
\p\g
create table wtepworld_eportal_s6(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s6 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s6 () from 'wtepworld_eportal_s6.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s6
\p\g
create table wtepworld_eportal_s7(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_eportal_s7 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_eportal_s7 () from 'wtepworld_eportal_s7.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_eportal_s7
\p\g
create table wtepworld_itech_c3(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_itech_c3 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_itech_c3 () from 'wtepworld_itech_c3.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_itech_c3
\p\g
create table wtepworld_itech_c4(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_itech_c4 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_itech_c4 () from 'wtepworld_itech_c4.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_itech_c4
\p\g
create table wtepworld_itech_pc(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_itech_pc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_itech_pc () from 'wtepworld_itech_pc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_itech_pc
\p\g
create table wtepworld_itech_s5(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_itech_s5 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_itech_s5 () from 'wtepworld_itech_s5.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_itech_s5
\p\g
create table wtepworld_itech_s7(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_itech_s7 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_itech_s7 () from 'wtepworld_itech_s7.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_itech_s7
\p\g
create table wtepworld_mswin_c2(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_mswin_c2 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_mswin_c2 () from 'wtepworld_mswin_c2.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_mswin_c2
\p\g
create table wtepworld_mswin_c3(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_mswin_c3 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_mswin_c3 () from 'wtepworld_mswin_c3.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_mswin_c3
\p\g
create table wtepworld_mswin_pc(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_mswin_pc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_mswin_pc () from 'wtepworld_mswin_pc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_mswin_pc
\p\g
create table wtepworld_mswin_s1(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_mswin_s1 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_mswin_s1 () from 'wtepworld_mswin_s1.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_mswin_s1
\p\g
create table wtepworld_tsenbl_pc(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_tsenbl_pc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_tsenbl_pc () from 'wtepworld_tsenbl_pc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_tsenbl_pc
\p\g
create table wtepworld_tsenbl_s1(
	uuid byte(16) not null,
	et_node_uuid byte(16) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworld_tsenbl_s1 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworld_tsenbl_s1 () from 'wtepworld_tsenbl_s1.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworld_tsenbl_s1
\p\g
create table wtepworldspace(
	uuid byte(16) not null,
	et_nodename varchar(255) not null,
	et_platform varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtepworldspace to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtepworldspace () from 'wtepworldspace.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtepworldspace
\p\g
create table wtericsson_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtericsson_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtericsson_access_point () from 'wtericsson_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtericsson_access_point
\p\g
create table wtethairnetaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtethairnetaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtethairnetaccesspoint () from 'wtethairnetaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtethairnetaccesspoint
\p\g
create table wtetsmim(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtetsmim to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtetsmim () from 'wtetsmim.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtetsmim
\p\g
create table wtfoundry(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtfoundry to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtfoundry () from 'wtfoundry.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtfoundry
\p\g
create table wtfujiuxp(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtfujiuxp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtfujiuxp () from 'wtfujiuxp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtfujiuxp
\p\g
create table wtgatorstar(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtgatorstar to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtgatorstar () from 'wtgatorstar.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtgatorstar
\p\g
create table wtgenericpc(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtgenericpc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtgenericpc () from 'wtgenericpc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtgenericpc
\p\g
create table wthawking_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wthawking_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wthawking_access_point () from 'wthawking_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthawking_access_point
\p\g
create table wthost(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wthost to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wthost () from 'wthost.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthost
\p\g
create table wthp_printer(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wthp_printer to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wthp_printer () from 'wthp_printer.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthp_printer
\p\g
create table wthpbridge(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wthpbridge to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wthpbridge () from 'wthpbridge.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthpbridge
\p\g
create table wthphub(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wthphub to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wthphub () from 'wthphub.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthphub
\p\g
create table wthpserver(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wthpserver to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wthpserver () from 'wthpserver.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthpserver
\p\g
create table wthpunix(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wthpunix to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wthpunix () from 'wthpunix.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthpunix
\p\g
create table wthub(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wthub to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wthub () from 'wthub.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wthub
\p\g
create table wtibm(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtibm to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtibm () from 'wtibm.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtibm
\p\g
create table wtibm3090(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtibm3090 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtibm3090 () from 'wtibm3090.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtibm3090
\p\g
create table wtibm_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtibm_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtibm_access_point () from 'wtibm_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtibm_access_point
\p\g
create table wticlunix(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wticlunix to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wticlunix () from 'wticlunix.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wticlunix
\p\g
create table wticssnmp(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wticssnmp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wticssnmp () from 'wticssnmp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wticssnmp
\p\g
create table wtidmsinstance(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	idmsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtidmsinstance to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtidmsinstance () from 'wtidmsinstance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtidmsinstance
\p\g
create table wtintel_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtintel_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtintel_access_point () from 'wtintel_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtintel_access_point
\p\g
create table wtinteractive(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtinteractive to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtinteractive () from 'wtinteractive.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtinteractive
\p\g
create table wtipx_generic_interface(
	uuid byte(16) not null,
	segment varchar(8),
	lanmode char(1),
	nodeaddresstype char(1),
	maxdatasize integer,
	transporttime integer,
	version varchar(10),
	flagether char(1),
	selectedcfg char(1),
	landesc varchar(80),
	ioaddress1 integer,
	ioaddress2 integer,
	iorange1 integer,
	iorange2 integer,
	memoryaddress1 varchar(3),
	memoryaddress2 varchar(3),
	memoryrange1 integer,
	memoryrange2 integer,
	interruptline1 char(1),
	interruptline2 char(1),
	dmaline1 char(1),
	dmaline2 char(1),
	microchannelflag char(1),
	textdesc varchar(80)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtipx_generic_interface to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtipx_generic_interface () from 'wtipx_generic_interface.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtipx_generic_interface
\p\g
create table wtipx_host(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	ipx_version varchar(6),
	spx_version varchar(6),
	server_version varchar(20),
	ipx_internal_net varchar(25),
	ipx_virtual_mac varchar(25)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtipx_host to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtipx_host () from 'wtipx_host.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtipx_host
\p\g
create table wtipx_printserver(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	ipx_version varchar(6),
	spx_version varchar(6),
	server_version varchar(20),
	ipx_segment_id varchar(25)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtipx_printserver to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtipx_printserver () from 'wtipx_printserver.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtipx_printserver
\p\g
create table wtirm2snmp(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtirm2snmp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtirm2snmp () from 'wtirm2snmp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtirm2snmp
\p\g
create table wtkarlnetaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtkarlnetaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtkarlnetaccesspoint () from 'wtkarlnetaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtkarlnetaccesspoint
\p\g
create table wtlaserprinter(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtlaserprinter to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtlaserprinter () from 'wtlaserprinter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtlaserprinter
\p\g
create table wtlight_3d(
	name varchar(40) not null,
	position_x float,
	position_y float,
	position_z float,
	direction_x float,
	direction_y float,
	direction_z float,
	distance_5 float,
	distance_6 float,
	type integer,
	color_red integer,
	color_green integer,
	color_blue integer,
	interior_index integer,
	transition_type integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtlight_3d to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtlight_3d () from 'wtlight_3d.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtlight_3d
\p\g
create table wtlinksysaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtlinksysaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtlinksysaccesspoint () from 'wtlinksysaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtlinksysaccesspoint
\p\g
create table wtlinux(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtlinux to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtlinux () from 'wtlinux.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtlinux
\p\g
create table wtlun(
	uuid byte(16) not null,
	state varchar(40),
	type varchar(40),
	scsiid integer,
	scsilun integer,
	adpbus integer,
	adpid integer,
	raidlevel integer,
	blocksize integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtlun to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtlun () from 'wtlun.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtlun
\p\g
create table wtmacintosh(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmacintosh to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmacintosh () from 'wtmacintosh.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmacintosh
\p\g
create table wtmanagedpc(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	netpc_vendor_name varchar(40) not null,
	boot_once varchar(128),
	boot_file varchar(128),
	run_once varchar(128),
	run_file varchar(128),
	run_dir varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmanagedpc to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmanagedpc () from 'wtmanagedpc.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmanagedpc
\p\g
create table wtmicom(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmicom to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmicom () from 'wtmicom.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmicom
\p\g
create table wtmkagent(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mk_domain varchar(30),
	mk_user varchar(30),
	mk_passwd varchar(30),
	mk_server varchar(30)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmkagent to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmkagent () from 'wtmkagent.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmkagent
\p\g
create table wtmobiledevice(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	owner varchar(40),
	serial_no varchar(40),
	os varchar(40),
	manufacturer varchar(40),
	product_id varchar(40),
	model_id varchar(40),
	system_ram integer,
	available_ram integer,
	memory_load integer,
	main_battery integer,
	external_battery integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmobiledevice to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmobiledevice () from 'wtmobiledevice.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmobiledevice
\p\g
create table wtmqaliasq(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqaliasq to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqaliasq () from 'wtmqaliasq.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqaliasq
\p\g
create table wtmqaliasqinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqaliasqinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqaliasqinst () from 'wtmqaliasqinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqaliasqinst
\p\g
create table wtmqchaninit(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqchaninit to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqchaninit () from 'wtmqchaninit.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqchaninit
\p\g
create table wtmqchaninitinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqchaninitinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqchaninitinst () from 'wtmqchaninitinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqchaninitinst
\p\g
create table wtmqchannel(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqchannel to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqchannel () from 'wtmqchannel.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqchannel
\p\g
create table wtmqchannelinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqchannelinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqchannelinst () from 'wtmqchannelinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqchannelinst
\p\g
create table wtmqdlq(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqdlq to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqdlq () from 'wtmqdlq.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqdlq
\p\g
create table wtmqdlqinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqdlqinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqdlqinst () from 'wtmqdlqinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqdlqinst
\p\g
create table wtmqmgr(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqmgr to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqmgr () from 'wtmqmgr.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqmgr
\p\g
create table wtmqmgrinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqmgrinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqmgrinst () from 'wtmqmgrinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqmgrinst
\p\g
create table wtmqmodelq(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqmodelq to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqmodelq () from 'wtmqmodelq.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqmodelq
\p\g
create table wtmqmodelqinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqmodelqinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqmodelqinst () from 'wtmqmodelqinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqmodelqinst
\p\g
create table wtmqprocess(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqprocess to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqprocess () from 'wtmqprocess.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqprocess
\p\g
create table wtmqprocessinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqprocessinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqprocessinst () from 'wtmqprocessinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqprocessinst
\p\g
create table wtmqpsid(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqpsid to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqpsid () from 'wtmqpsid.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqpsid
\p\g
create table wtmqpsidinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqpsidinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqpsidinst () from 'wtmqpsidinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqpsidinst
\p\g
create table wtmqqueue(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqqueue to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqqueue () from 'wtmqqueue.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqqueue
\p\g
create table wtmqqueueinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqqueueinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqqueueinst () from 'wtmqqueueinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqqueueinst
\p\g
create table wtmqremoteq(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqremoteq to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqremoteq () from 'wtmqremoteq.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqremoteq
\p\g
create table wtmqremoteqinst(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqremoteqinst to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqremoteqinst () from 'wtmqremoteqinst.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqremoteqinst
\p\g
create table wtmqsinstance(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	mqsport varchar(5) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmqsinstance to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmqsinstance () from 'wtmqsinstance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmqsinstance
\p\g
create table wtmulti_port(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmulti_port to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmulti_port () from 'wtmulti_port.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmulti_port
\p\g
create table wtmultinet(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtmultinet to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtmultinet () from 'wtmultinet.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtmultinet
\p\g
create table wtncrunix(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtncrunix to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtncrunix () from 'wtncrunix.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtncrunix
\p\g
create table wtnetgearaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnetgearaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtnetgearaccesspoint () from 'wtnetgearaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnetgearaccesspoint
\p\g
create table wtnetgeneral(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnetgeneral to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtnetgeneral () from 'wtnetgeneral.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnetgeneral
\p\g
create table wtnetjet_printerserver(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnetjet_printerserver to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtnetjet_printerserver () from 'wtnetjet_printerserver.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnetjet_printerserver
\p\g
create table wtnetque_printerserver(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnetque_printerserver to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtnetque_printerserver () from 'wtnetque_printerserver.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnetque_printerserver
\p\g
create table wtnetsnmp(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnetsnmp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtnetsnmp () from 'wtnetsnmp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnetsnmp
\p\g
create table wtnetworth(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnetworth to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtnetworth () from 'wtnetworth.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnetworth
\p\g
create table wtngsniffer(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtngsniffer to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtngsniffer () from 'wtngsniffer.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtngsniffer
\p\g
create table wtnortel_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnortel_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtnortel_access_point () from 'wtnortel_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnortel_access_point
\p\g
create table wtnovell(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnovell to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtnovell () from 'wtnovell.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnovell
\p\g
create table wtnovellhub(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtnovellhub to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtnovellhub () from 'wtnovellhub.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtnovellhub
\p\g
create table wtopenvms(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	comment varchar(255),
	contact varchar(128),
	description varchar(255),
	location varchar(128),
	sysobjid varchar(128),
	hostname varchar(255),
	statusmessgarbage integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtopenvms to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtopenvms () from 'wtopenvms.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtopenvms
\p\g
create table wtopenvms_system_monitor(
	uuid byte(16) not null,
	hostname varchar(255),
	in_host integer,
	statusmessgarbage integer,
	prod_code varchar(4),
	prod_name varchar(23)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtopenvms_system_monitor to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtopenvms_system_monitor () from 'wtopenvms_system_monitor.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtopenvms_system_monitor
\p\g
create table wtorinocoaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtorinocoaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtorinocoaccesspoint () from 'wtorinocoaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtorinocoaccesspoint
\p\g
create table wtos2(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtos2 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtos2 () from 'wtos2.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtos2
\p\g
create table wtotherdevices(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	pollset_name varchar(40),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtotherdevices to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtotherdevices () from 'wtotherdevices.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtotherdevices
\p\g
create table wtpcniu(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtpcniu to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtpcniu () from 'wtpcniu.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtpcniu
\p\g
create table wtperformance(
	uuid byte(16) not null,
	performance_system_type varchar(40),
	performance_host_name varchar(200),
	performance_host_uuid byte(16) not null,
	performance_host_class varchar(40),
	performance_psc_file varchar(254),
	performance_flags integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtperformance to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtperformance () from 'wtperformance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtperformance
\p\g
create table wtperformancetrend(
	uuid byte(16) not null,
	performance_system_type varchar(40),
	performance_host_name varchar(200),
	performance_host_uuid byte(16) not null,
	performance_host_class varchar(40),
	performance_psc_file varchar(254),
	performance_flags integer,
	performance_chart_definition varchar(64),
	performance_chart_type varchar(32)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtperformancetrend to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtperformancetrend () from 'wtperformancetrend.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtperformancetrend
\p\g
create table wtprinters(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtprinters to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtprinters () from 'wtprinters.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtprinters
\p\g
create table wtprobe(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	pollset_name varchar(40),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtprobe to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtprobe () from 'wtprobe.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtprobe
\p\g
create table wtprofiledomainserver(
	uuid byte(16) not null,
	performance_system_type varchar(40),
	performance_host_name varchar(200),
	performance_host_uuid byte(16) not null,
	performance_host_class varchar(40),
	performance_psc_file varchar(254),
	performance_flags integer,
	objectid varchar(30),
	active i1,
	performance_profile_name varchar(255),
	performance_agent_version integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtprofiledomainserver to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtprofiledomainserver () from 'wtprofiledomainserver.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtprofiledomainserver
\p\g
create table wtproxim_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtproxim_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtproxim_access_point () from 'wtproxim_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtproxim_access_point
\p\g
create table wtpv705n(
	uuid byte(16) not null,
	firmware_version varchar(40),
	scsi_inquiry varchar(128),
	serial_num varchar(40),
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtpv705n to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtpv705n () from 'wtpv705n.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtpv705n
\p\g
create table wtqlogic_switch(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	tb_discovered i1,
	wwn varchar(40),
	firmware_version varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtqlogic_switch to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtqlogic_switch () from 'wtqlogic_switch.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtqlogic_switch
\p\g
create table wtrisc6000(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtrisc6000 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtrisc6000 () from 'wtrisc6000.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtrisc6000
\p\g
create table wtroamaboutaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtroamaboutaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtroamaboutaccesspoint () from 'wtroamaboutaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtroamaboutaccesspoint
\p\g
create table wtrogue_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtrogue_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtrogue_access_point () from 'wtrogue_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtrogue_access_point
\p\g
create table wtrouter(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtrouter to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtrouter () from 'wtrouter.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtrouter
\p\g
create table wtsamsung(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsamsung to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsamsung () from 'wtsamsung.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsamsung
\p\g
create table wtsapagent(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	sap_sysnum varchar(30) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsapagent to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsapagent () from 'wtsapagent.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsapagent
\p\g
create table wtsapinstance(
	uuid byte(16) not null,
	containerhost varchar(60),
	pollset_name varchar(30),
	get_auth_name varchar(30),
	set_auth_name varchar(30),
	port_number integer,
	dsm_obj_name varchar(255),
	sap_sysnum varchar(30) not null
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsapinstance to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsapinstance () from 'wtsapinstance.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsapinstance
\p\g
create table wtscounix(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtscounix to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtscounix () from 'wtscounix.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtscounix
\p\g
create table wtsequent_server(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsequent_server to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsequent_server () from 'wtsequent_server.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsequent_server
\p\g
create table wtsiemenux(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsiemenux to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsiemenux () from 'wtsiemenux.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsiemenux
\p\g
create table wtsilicon(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsilicon to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsilicon () from 'wtsilicon.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsilicon
\p\g
create table wtsmcaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsmcaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtsmcaccesspoint () from 'wtsmcaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsmcaccesspoint
\p\g
create table wtsolaris(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsolaris to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsolaris () from 'wtsolaris.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsolaris
\p\g
create table wtstoragesubsystem(
	uuid byte(16) not null,
	firmware_version varchar(40),
	scsi_inquiry varchar(128),
	serial_num varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtstoragesubsystem to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtstoragesubsystem () from 'wtstoragesubsystem.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtstoragesubsystem
\p\g
create table wtsunos(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsunos to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsunos () from 'wtsunos.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsunos
\p\g
create table wtsuspectaccesspoint(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsuspectaccesspoint to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtsuspectaccesspoint () from 'wtsuspectaccesspoint.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsuspectaccesspoint
\p\g
create table wtswitch(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	tb_discovered i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtswitch to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtswitch () from 'wtswitch.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtswitch
\p\g
create table wtsymbol80211_11m_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsymbol80211_11m_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtsymbol80211_11m_access_point () from 'wtsymbol80211_11m_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsymbol80211_11m_access_point
\p\g
create table wtsymbol80211_1_2m_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsymbol80211_1_2m_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtsymbol80211_1_2m_access_point () from 'wtsymbol80211_1_2m_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsymbol80211_1_2m_access_point
\p\g
create table wtsymbol_1m_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsymbol_1m_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtsymbol_1m_access_point () from 'wtsymbol_1m_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsymbol_1m_access_point
\p\g
create table wtsynoptics(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsynoptics to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsynoptics () from 'wtsynoptics.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsynoptics
\p\g
create table wtsynoptics_bridge(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtsynoptics_bridge to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtsynoptics_bridge () from 'wtsynoptics_bridge.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtsynoptics_bridge
\p\g
create table wttandem(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wttandem to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wttandem () from 'wttandem.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wttandem
\p\g
create table wttapesubsystem(
	uuid byte(16) not null,
	library_configuration varchar(64),
	model_id varchar(40),
	scsilun integer,
	scsibus integer,
	scsitarget integer,
	num_drives integer,
	slotcount integer,
	pickercount integer,
	firmware_version varchar(40),
	scsi_inquiry varchar(128),
	serial_num varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wttapesubsystem to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wttapesubsystem () from 'wttapesubsystem.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wttapesubsystem
\p\g
create table wttelebit(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wttelebit to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wttelebit () from 'wttelebit.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wttelebit
\p\g
create table wttnd_icon(
	name varchar(40) not null,
	image_large varchar(40),
	image_small varchar(40),
	image_decal varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wttnd_icon to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wttnd_icon () from 'wttnd_icon.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wttnd_icon
\p\g
create table wttng_ipx_discovery_status(
	comment varchar(250),
	ipx_segment_id varchar(20),
	ipx_network_address varchar(35),
	type varchar(20),
	weight integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wttng_ipx_discovery_status to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wttng_ipx_discovery_status () from 'wttng_ipx_discovery_status.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wttng_ipx_discovery_status
\p\g
create table wttooltip(
	name varchar(40) not null,
	background_color integer,
	display_time float,
	font varchar(30),
	font_size integer,
	foreground_color integer,
	hovering_time float,
	shadow i1,
	show_object i1,
	transparency float
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wttooltip to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wttooltip () from 'wttooltip.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wttooltip
\p\g
create table wtubempower(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtubempower to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtubempower () from 'wtubempower.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtubempower
\p\g
create table wtubniu(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtubniu to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtubniu () from 'wtubniu.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtubniu
\p\g
create table wtunicenter_openvms(
	uuid byte(16) not null,
	hostname varchar(255),
	in_host integer,
	statusmessgarbage integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtunicenter_openvms to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtunicenter_openvms () from 'wtunicenter_openvms.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtunicenter_openvms
\p\g
create table wtunicenter_openvmsmanagedobject(
	uuid byte(16) not null,
	in_host integer,
	hostname varchar(255),
	statusmessgarbage integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtunicenter_openvmsmanagedobject to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtunicenter_openvmsmanagedobject () from 'wtunicenter_openvmsmanagedobject.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtunicenter_openvmsmanagedobject
\p\g
create table wtunisys(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtunisys to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtunisys () from 'wtunisys.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtunisys
\p\g
create table wtunix(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtunix to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtunix () from 'wtunix.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtunix
\p\g
create table wtunixware(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtunixware to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtunixware () from 'wtunixware.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtunixware
\p\g
create table wtups(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtups to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtups () from 'wtups.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtups
\p\g
create table wturm(
	uuid byte(16) not null,
	urm_resource varchar(246),
	urm_agent varchar(246)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wturm to btree on
	uuid
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16
\p\g
/* copy wturm () from 'wturm.mdbadmin' */
/* with allocation = 4, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on wturm
\p\g
create table wtusr_access_point(
	uuid byte(16) not null,
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255),
	policy varchar(255),
	desiredssid varchar(64),
	rogue i1,
	mobilityenabled i1,
	pollset_name varchar(40),
	modelid varchar(255),
	ssid varchar(64),
	wepstate varchar(32),
	authenticationmethod varchar(32),
	apmode varchar(32),
	regulatoryzone varchar(128),
	txrates varchar(255),
	txpower integer,
	channel integer,
	fragmentationthreshold integer,
	rtsthreshold integer,
	sitename varchar(255),
	sitelevel integer,
	sitemanager varchar(255)
)
with duplicates,
nojournaling,
	page_size = 4096,
location = (ii_database),
security_audit=(table,norow)
;
modify wtusr_access_point to heap
with extend = 16,
	allocation = 4,
	page_size = 4096
\p\g
/* copy wtusr_access_point () from 'wtusr_access_point.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtusr_access_point
\p\g
create table wtvcp_1000(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtvcp_1000 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtvcp_1000 () from 'wtvcp_1000.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtvcp_1000
\p\g
create table wtvitalink(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtvitalink to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtvitalink () from 'wtvitalink.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtvitalink
\p\g
create table wtwbem(
	uuid byte(16) not null,
	containerhost varchar(60),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	pollset_name varchar(40),
	wbem_version varchar(40),
	wbem_defnamespace varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwbem to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwbem () from 'wtwbem.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwbem
\p\g
create table wtwellfleet(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwellfleet to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwellfleet () from 'wtwellfleet.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwellfleet
\p\g
create table wtwindows(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindows to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindows () from 'wtwindows.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindows
\p\g
create table wtwindows2000(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindows2000 to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindows2000 () from 'wtwindows2000.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindows2000
\p\g
create table wtwindows2000_server(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindows2000_server to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindows2000_server () from 'wtwindows2000_server.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindows2000_server
\p\g
create table wtwindows9x(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindows9x to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindows9x () from 'wtwindows9x.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindows9x
\p\g
create table wtwindows_netserver(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindows_netserver to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindows_netserver () from 'wtwindows_netserver.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindows_netserver
\p\g
create table wtwindowsnt(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindowsnt to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindowsnt () from 'wtwindowsnt.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindowsnt
\p\g
create table wtwindowsnt_server(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindowsnt_server to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindowsnt_server () from 'wtwindowsnt_server.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindowsnt_server
\p\g
create table wtwindowsxp(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwindowsxp to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwindowsxp () from 'wtwindowsxp.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwindowsxp
\p\g
create table wtwireless_domain(
	uuid byte(16) not null,
	domain_id varchar(40)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtwireless_domain to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtwireless_domain () from 'wtwireless_domain.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtwireless_domain
\p\g
create table wtworkstation(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtworkstation to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtworkstation () from 'wtworkstation.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtworkstation
\p\g
create table wtxiotech(
	uuid byte(16) not null,
	firmware_version varchar(40),
	scsi_inquiry varchar(128),
	serial_num varchar(40),
	stratification_level integer,
	device_name varchar(40),
	model_id integer,
	num_drives integer
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtxiotech to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtxiotech () from 'wtxiotech.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtxiotech
\p\g
create table wtxterm(
	uuid byte(16) not null,
	pollset_name varchar(40),
	get_auth_name varchar(40),
	set_auth_name varchar(40),
	casp i1,
	sysobjid varchar(128),
	contact varchar(128),
	location varchar(128),
	description varchar(255),
	comment varchar(255)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtxterm to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtxterm () from 'wtxterm.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtxterm
\p\g
create table wtzone(
	uuid byte(16) not null,
	fabric varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtzone to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtzone () from 'wtzone.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtzone
\p\g
create table wtzoneset(
	uuid byte(16) not null,
	fabric varchar(20)
)
with duplicates,
nojournaling,
location = (ii_database),
security_audit=(table,norow)
;
modify wtzoneset to heap
with extend = 16,
	allocation = 4
\p\g
/* copy wtzoneset () from 'wtzoneset.mdbadmin' */
/* with row_estimate = 0 */
/* \p\g */
set journaling on wtzoneset
\p\g
create table xent_map(
	id integer not null,
	persid varchar(30),
	xentity_id varchar(180) not null,
	xschema_code varchar(12) not null,
	xschema_ver integer not null,
	ob_persid varchar(30),
	ob_type varchar(30),
	int1_rsrved integer,
	int2_rsrved integer,
	int3_rsrved integer,
	int4_rsrved integer,
	int5_rsrved integer,
	int6_rsrved integer,
	str1_rsrved varchar(80),
	str2_rsrved varchar(80),
	lstr1_rsrved varchar(255),
	lstr2_rsrved varchar(255)
)
with duplicates,
nojournaling,
	page_size = 8192,
location = (ii_database),
security_audit=(table,norow)
;
modify xent_map to btree unique on
	id
with nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	extend = 16,
	page_size = 8192,
	unique_scope = statement
\p\g
/* copy xent_map () from 'xent_map.mdbadmin' */
/* with allocation = 16, */
/* 	row_estimate = 0 */
/* \p\g */
set journaling on xent_map
\p\g

	/* INDEXES */
create unique index acc_lvls_x0 on acc_lvls (
	enum)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (enum),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index acc_lvls_x1 on acc_lvls (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif2access_policy_identity_asc on access_policy_identity_asc (
	access_policy_uuid)
with structure = isam,
	nocompression,
	key = (access_policy_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkaccess_policy_identity_asc on access_policy_identity_asc (
	user_group_identity_asc_id)
with structure = isam,
	nocompression,
	key = (user_group_identity_asc_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index acctyp_x0 on acctyp (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index act_log_x0 on act_log (
	call_req_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (call_req_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index act_log_x1 on act_log (
	time_stamp,
	type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (time_stamp, type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index act_type_x0 on act_type (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index act_type_x1 on act_type (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index actbool_x0 on actbool (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index actrbool_x0 on actrbool (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1address on address (
	person_uuid)
with structure = isam,
	nocompression,
	key = (person_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkaddress on address (
	location_id)
with structure = isam,
	nocompression,
	key = (location_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ialias on alias (
	a_eid,
	eid)
with structure = btree,
	nocompression,
	key = (a_eid, eid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index am_map_x0 on am_map (
	am_unit_domain_id,
	am_unit_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (am_unit_domain_id, am_unit_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index am_map_x1 on am_map (
	ob_persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ob_persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index analysis_idx_01 on analysis (
	name,
	owner)
with structure = isam,
	nocompression,
	key = (name, owner),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index analysis_idx_02 on analysis (
	owner,
	name)
with structure = isam,
	nocompression,
	key = (owner, name),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index anima_x0 on anima (
	a_time)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (a_time),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index anima_x1 on anima (
	t_persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (t_persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1application_instance on application_instance (
	product_instance_name)
with structure = isam,
	nocompression,
	key = (product_instance_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkapplication_instance on application_instance (
	product_instance_id)
with structure = isam,
	nocompression,
	key = (product_instance_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index arcpur_rule_x0 on arcpur_rule (
	name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index acindex02 on arg_action (
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index acindex03 on arg_action (
	acadid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (acadid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index adindex02 on arg_actiondf (
	ad1obty,
	adtext,
	adtype)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ad1obty, adtext, adtype),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lkindex02 on arg_actionlk (
	primary_object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (primary_object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lkindex03 on arg_actionlk (
	secondary_object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (secondary_object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index avindex02 on arg_assetver (
	avstatus)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (avstatus),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index avindex03 on arg_assetver (
	avivid,
	own_resource_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (avivid, own_resource_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index avindex04 on arg_assetver (
	avivid,
	model_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (avivid, model_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index amindex02 on arg_attachmt (
	amfile,
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (amfile, object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sysadindex02 on arg_attribute_def (
	field_name,
	table_name)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (field_name, table_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sysadindex03 on arg_attribute_def (
	join_name)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (join_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sysadindex04 on arg_attribute_def (
	class_template)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (class_template),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sysadindex05 on arg_attribute_def (
	control_name,
	control_object)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (control_name, control_object),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index syscdindex02 on arg_class_def (
	table_name)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (table_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index syscdindex03 on arg_class_def (
	class_template)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (class_template),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index syscdindex04 on arg_class_def (
	control_name,
	control_object)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (control_name, control_object),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index cnindex02 on arg_controls (
	cndefid,
	cnname,
	cnobject)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (cndefid, cnname, cnobject),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cdindex02 on arg_costdet (
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cdindex03 on arg_costdet (
	company_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (company_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index dlindex02 on arg_drpdnlst (
	dlldid,
	dlpavalu,
	dlvalue)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (dlldid, dlpavalu, dlvalue),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index dlindex03 on arg_drpdnlst (
	dlkey)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (dlkey),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index evindex02 on arg_evdefhdr (
	evname)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (evname),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index evindex03 on arg_evdefhdr (
	evenable)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (evenable),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index evindex04 on arg_evdefhdr (
	evaction)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (evaction),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index evindex05 on arg_evdefhdr (
	field_name,
	table_name)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (field_name, table_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index evindex06 on arg_evdefhdr (
	evenable,
	table_name)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (evenable, table_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index enindex02 on arg_evdefny (
	enevid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (enevid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index enindex03 on arg_evdefny (
	contact_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (contact_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index nyindex02 on arg_evnotify (
	contact_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (contact_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index nyindex03 on arg_evnotify (
	nyid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (nyid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index erindex02 on arg_evrem (
	contact_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (contact_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index erindex03 on arg_evrem (
	erstat)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (erstat),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index erindex04 on arg_evrem (
	erevid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (erevid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index erindex05 on arg_evrem (
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index erindex06 on arg_evrem (
	erstat,
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (erstat, object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index esindex02 on arg_extsys (
	esid,
	esobty,
	esvalue1,
	esvalue2,
	esvalue3,
	esvalue4,
	esvalue5)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (esid, esobty, esvalue1, esvalue2, esvalue3, esvalue4, esvalue5),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index fcindex02 on arg_filtcrit (
	fcfeid,
	fcname)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (fcfeid, fcname),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index fcindex03 on arg_filtcrit (
	fcname)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (fcname),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index feindex02 on arg_filtdef (
	fename,
	feobtype)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (fename, feobtype),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index feindex03 on arg_filtdef (
	feobtype)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (feobtype),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index fnindex02 on arg_filtind (
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index hsindex02 on arg_history (
	field_name,
	hsinstnc)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (field_name, hsinstnc),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index hnindex02 on arg_hsnotify (
	contact_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (contact_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index hrindex02 on arg_hsrem (
	hrevid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (hrevid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index hrindex03 on arg_hsrem (
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index hrindex04 on arg_hsrem (
	contact_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (contact_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sysidindex02 on arg_index_def (
	table_name)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (table_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sysimindex02 on arg_index_member (
	field_name,
	table_name)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (field_name, table_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ixindex02 on arg_intxref (
	ixdomid,
	ixunitid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ixdomid, ixunitid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ivindex02 on arg_itemver (
	ivid,
	model_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ivid, model_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ivindex03 on arg_itemver (
	ivname,
	model_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ivname, model_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ivindex04 on arg_itemver (
	ivmannbr)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ivmannbr),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sysjmindex02 on arg_join_member (
	left_side_field,
	left_side_table)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (left_side_field, left_side_table),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index kdindex02 on arg_keydef (
	kdkwtext)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (kdkwtext),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index kwindex02 on arg_keyword (
	kwkdid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (kwkdid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index lgindex02 on arg_legaldef (
	lgtype)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (lgtype),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ltindex02 on arg_legaldet (
	lttdid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (lttdid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index leindex02 on arg_legaldoc (
	external_company_uuid,
	internal_company_uuid,
	ledocidn,
	leeffdt,
	lelgid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (external_company_uuid, internal_company_uuid, ledocidn, leeffdt, lelgid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index leindex03 on arg_legaldoc (
	external_company_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (external_company_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index leindex04 on arg_legaldoc (
	ledocidn)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ledocidn),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index leindex05 on arg_legaldoc (
	requestor_contact_uuid,
	vendor_contact_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (requestor_contact_uuid, vendor_contact_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lpindex02 on arg_legalpar (
	company_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (company_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index laindex02 on arg_legasset (
	own_resource_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (own_resource_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lcindex02 on arg_legasstc (
	own_resource_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (own_resource_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lcindex03 on arg_legasstc (
	lctdid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (lctdid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ndindex02 on arg_linkdef (
	ndadid,
	ndtext)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ndadid, ndtext),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ldindex02 on arg_listdef (
	ldlist)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (ldlist),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tdindex02 on arg_ltcdef (
	tdtext)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (tdtext),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index noindex02 on arg_notes (
	object_uuid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (object_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index noindex03 on arg_notes (
	notype)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (notype),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index pdindex02 on arg_paydet (
	pdduedt)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (pdduedt),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index rdindex02 on arg_roledef (
	rdname)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (rdname),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index scindex02 on arg_script (
	scenable)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (scenable),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index tlindex02 on arg_tclgdef (
	tltdid)
with structure = isam,
	page_size = 4096,
	nocompression,
	key = (tltdid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index atn_x0 on atn (
	at_obj,
	at_sys)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (at_obj, at_sys),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index atomic_cond_x0 on atomic_cond (
	owning_macro,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owning_macro, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index att_evt_x0 on att_evt (
	event_tmpl)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (event_tmpl),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index att_evt_x1 on att_evt (
	obj_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (obj_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index att_evt_x2 on att_evt (
	fire_time)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (fire_time),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index att_evt_x3 on att_evt (
	owning_ast)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owning_ast),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attached_sla_x0 on attached_sla (
	ticket_id,
	ticket_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ticket_id, ticket_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attached_sla_x1 on attached_sla (
	time_to_violation)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (time_to_violation),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attached_sla_x2 on attached_sla (
	_mapped_cr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (_mapped_cr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attached_sla_x3 on attached_sla (
	_mapped_chg)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (_mapped_chg),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attached_sla_x4 on attached_sla (
	_mapped_iss)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (_mapped_iss),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attached_sla_x5 on attached_sla (
	_mapped_wf)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (_mapped_wf),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attached_sla_x6 on attached_sla (
	_mapped_iss_wf)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (_mapped_iss_wf),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_x0 on attmnt (
	created_dt)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (created_dt),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index attmnt_x1 on attmnt (
	persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_x2 on attmnt (
	folder_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (folder_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_x3 on attmnt (
	folder_path_ids)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (folder_path_ids),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_x4 on attmnt (
	inherit_permission_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (inherit_permission_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_x5 on attmnt (
	read_pgroup)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (read_pgroup),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_x6 on attmnt (
	write_pgroup)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (write_pgroup),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x0 on attmnt_folder (
	folder_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (folder_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x1 on attmnt_folder (
	folder_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (folder_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x2 on attmnt_folder (
	parent_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x3 on attmnt_folder (
	folder_path_ids)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (folder_path_ids),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x4 on attmnt_folder (
	inherit_permission_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (inherit_permission_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x5 on attmnt_folder (
	read_pgroup)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (read_pgroup),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x6 on attmnt_folder (
	write_pgroup)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (write_pgroup),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_folder_x7 on attmnt_folder (
	repository)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (repository),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_lrel_x0 on attmnt_lrel (
	l_persid,
	l_attr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (l_persid, l_attr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index attmnt_lrel_x1 on attmnt_lrel (
	r_persid,
	r_attr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (r_persid, r_attr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index atyp_asc_x0 on atyp_asc (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index atyp_asc_x1 on atyp_asc (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index audit_log_x0 on audit_log (
	change_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (change_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index audithis_sk1 on audithis (
	acid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (acid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index audithis_sk2 on audithis (
	unitid,
	domainid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (unitid, domainid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bckdef_sk1 on bckdef (
	dbname)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (dbname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index bhvtpl_x0 on bhvtpl (
	object_id,
	context_type,
	context_attrname,
	context_attrval)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_id, context_type, context_attrname, context_attrval),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index bool_tab_x0 on bool_tab (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bpwshft_x0 on bpwshft (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bpwshft_x1 on bpwshft (
	persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bu_trans_x0 on bu_trans (
	bu_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (bu_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bu_trans_x1 on bu_trans (
	doc_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bu_trans_x2 on bu_trans (
	hit_no_vote)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (hit_no_vote),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bu_trans_x3 on bu_trans (
	hit_origin)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (hit_origin),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bu_trans_x4 on bu_trans (
	index_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (index_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index bu_trans_x5 on bu_trans (
	user_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (user_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index buscls_x0 on buscls (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index business_hours_idx_01 on business_hours (
	start_time)
with structure = btree,
	nocompression,
	key = (start_time),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index busmgt_x0 on busmgt (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index busmgt_x1 on busmgt (
	hier_parent)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (hier_parent),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index busmgt_x2 on busmgt (
	hier_child)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (hier_child),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index busrep_x0 on busrep (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index busrep_x1 on busrep (
	hostname)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (hostname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index busstat_x0 on busstat (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index busstat_x1 on busstat (
	status_no)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status_no),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_contact_idx_01 on ca_contact (
	last_update_date)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (last_update_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_disc_hardware_idx_01 on ca_discovered_hardware (
	domain_uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (domain_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_disc_hardware_idx_02 on ca_discovered_hardware (
	last_update_date)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (last_update_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ca_disc_hardware_idx_03 on ca_discovered_hardware (
	label)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (label),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_disc_software_idx_01 on ca_discovered_software (
	last_update_date)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (last_update_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_disc_software_prop_idx_01 on ca_discovered_software_prop (
	last_update_date)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (last_update_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_disc_user_idx_01 on ca_discovered_user (
	domain_uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (domain_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_disc_user_idx_02 on ca_discovered_user (
	last_update_date)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (last_update_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x1ca_group_ace on ca_group_ace (
	security_profile_uuid)
with structure = isam,
	nocompression,
	key = (security_profile_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index lnkdisusrsefcproidx01 on ca_link_dis_user_sec_profile (
	security_profile_uuid,
	user_uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (security_profile_uuid, user_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x1ca_object_ace on ca_object_ace (
	object_def_uuid)
with structure = isam,
	nocompression,
	key = (object_def_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ca_organization_idx_01 on ca_organization (
	last_update_date)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (last_update_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xca_proc_os_id_unique on ca_proc_os (
	proc_os_id)
with structure = isam,
	nocompression,
	key = (proc_os_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index adjoin_user_preference_idx_01 on ca_user_preference (
	ca_user_id,
	category,
	sub_category,
	name)
with structure = isam,
	nocompression,
	key = (ca_user_id, category, sub_category, name),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index adjoin_user_principal_idx_01 on ca_user_principal (
	principal_type,
	principal_name)
with structure = btree,
	nocompression,
	key = (principal_type, principal_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index call_req_x0 on call_req (
	open_date,
	ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (open_date, ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x1 on call_req (
	customer,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (customer, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x10 on call_req (
	status)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x11 on call_req (
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x12 on call_req (
	persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x13 on call_req (
	parent)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x14 on call_req (
	template_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x15 on call_req (
	close_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (close_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x16 on call_req (
	resolve_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (resolve_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x17 on call_req (
	change)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (change),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x2 on call_req (
	log_agent,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (log_agent, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index call_req_x3 on call_req (
	ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x4 on call_req (
	assignee,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x5 on call_req (
	group_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x6 on call_req (
	affected_rc,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (affected_rc, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x7 on call_req (
	category,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (category, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x8 on call_req (
	priority,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (priority, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index call_req_x9 on call_req (
	extern_ref)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (extern_ref),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index change_log_idx_01 on change_log (
	table_name,
	table_id,
	column_name)
with structure = isam,
	nocompression,
	key = (table_name, table_id, column_name),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index chg_x0 on chg (
	open_date,
	chg_ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (open_date, chg_ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x1 on chg (
	requestor,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (requestor, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x10 on chg (
	persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x11 on chg (
	parent)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x12 on chg (
	template_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x13 on chg (
	close_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (close_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x14 on chg (
	resolve_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (resolve_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x2 on chg (
	log_agent,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (log_agent, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index chg_x3 on chg (
	chg_ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (chg_ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x4 on chg (
	assignee,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x5 on chg (
	group_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x6 on chg (
	category,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (category, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x7 on chg (
	priority,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (priority, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x8 on chg (
	status)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_x9 on chg (
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index chg_template_x0 on chg_template (
	template_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chg_template_x1 on chg_template (
	template_class)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_class),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chgalg_x0 on chgalg (
	change_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (change_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index chgalg_x1 on chgalg (
	time_stamp,
	type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (time_stamp, type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index chgcat_x0 on chgcat (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index chgcat_x1 on chgcat (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index chgstat_x0 on chgstat (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index chgstat_x1 on chgstat (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ci_actions_x0 on ci_actions (
	id,
	wf_template_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (id, wf_template_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_actions_x1 on ci_actions (
	action_order)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (action_order),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_actions_x2 on ci_actions (
	analyst_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (analyst_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_actions_x3 on ci_actions (
	group_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_actions_x4 on ci_actions (
	status_current_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status_current_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_actions_x5 on ci_actions (
	unpublish)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (unpublish),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_actions_x6 on ci_actions (
	unretire)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (unretire),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ci_actions_alternate_x0 on ci_actions_alternate (
	action_id,
	contact_type,
	contact_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (action_id, contact_type, contact_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_actions_alternate_x1 on ci_actions_alternate (
	action_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (action_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ci_bookmarks_x0 on ci_bookmarks (
	user_id,
	document_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (user_id, document_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_bookmarks_x1 on ci_bookmarks (
	user_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (user_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_doc_links_x0 on ci_doc_links (
	doc_id1)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_id1),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_doc_links_x1 on ci_doc_links (
	doc_id2)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_id2),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_doc_templates_x0 on ci_doc_templates (
	is_default)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (is_default),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ci_doc_templates_x1 on ci_doc_templates (
	template_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_priorities_x0 on ci_priorities (
	priority)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (priority),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_statuses_x0 on ci_statuses (
	status_order)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status_order),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ci_statuses_x1 on ci_statuses (
	status)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ci_wf_templates_x0 on ci_wf_templates (
	is_default)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (is_default),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ci_wf_templates_x1 on ci_wf_templates (
	wf_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (wf_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ciscostatstime on ciscostats (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index cmprules_idx_01 on cmprules (
	id)
with structure = btree,
	nocompression,
	key = (id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cn_x0 on cn (
	cn_table,
	cn_sys)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (cn_table, cn_sys),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cnote_x0 on cnote (
	posted_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (posted_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cnote_x1 on cnote (
	control_group)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (control_group),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index collected_data_idx_01 on collected_data (
	sampletime)
with structure = btree,
	nocompression,
	key = (sampletime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index computer_i1 on computer (
	uidparent)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (uidparent),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index computergroup_i1 on computergroup (
	uidparent)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (uidparent),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index confmemo_idx_01 on confmemo (
	unitid,
	domainid)
with structure = btree,
	nocompression,
	key = (unitid, domainid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index contact_list_contact_idx_01 on contact_list_contact (
	contact_list_id,
	contact_id)
with structure = btree,
	nocompression,
	key = (contact_list_id, contact_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index counterdata_idx_01 on counterdata (
	tstamp)
with structure = btree,
	nocompression,
	key = (tstamp),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index countersource_idx_01 on countersource (
	hostname)
with structure = btree,
	nocompression,
	key = (hostname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cr_prp_x0 on cr_prp (
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cr_prp_x1 on cr_prp (
	owning_cr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owning_cr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cr_prptpl_x0 on cr_prptpl (
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cr_prptpl_x1 on cr_prptpl (
	owning_area)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owning_area),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index cr_stat_x0 on cr_stat (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index cr_stat_x1 on cr_stat (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index cr_template_x0 on cr_template (
	template_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index cr_template_x1 on cr_template (
	template_class)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_class),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index crctmr_x0 on crctmr (
	threshold)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (threshold),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index crepository_idx_01 on crepository (
	serno)
with structure = btree,
	nocompression,
	key = (serno),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index crsol_x0 on crsol (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index crsq_x0 on crsq (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index crsq_x1 on crsq (
	obj_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (obj_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index crt_x0 on crt (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xie2csm_object on csm_object (
	name)
with structure = hash,
	page_size = 4096,
	nocompression,
	key = (name),
	persistence,
	minpages = 2,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xie2csm_property on csm_property (
	name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ct_mth_x0 on ct_mth (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ctab_x0 on ctab (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index d_painter_x0 on d_painter (
	formname,
	cntlid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (formname, cntlid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index d_painter_x1 on d_painter (
	formgroup)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (formgroup),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index data_collect_attrs_idx_01 on data_collect_attrs (
	attr_name)
with structure = hash,
	nocompression,
	key = (attr_name),
	persistence,
	minpages = 2,
	fillfactor = 50,
	location = (ii_database)
\p\g
create index data_collections_idx_01 on data_collections (
	metric_name)
with structure = btree,
	nocompression,
	key = (metric_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index idx_db_indexcol on db_indexcol (
	dbrep_indexiid)
with structure = isam,
	nocompression,
	key = (dbrep_indexiid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index idx_db_objparent on db_object (
	dbrep_parentiid)
with structure = isam,
	nocompression,
	key = (dbrep_parentiid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index dcon_x0 on dcon (
	dom_id,
	tbl_id,
	type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (dom_id, tbl_id, type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index idx_ddtablemodify on ddtablemodify (
	executionid,
	ddtableproviderid,
	ddtablemodifyname)
with structure = isam,
	nocompression,
	key = (executionid, ddtableproviderid, ddtablemodifyname),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index default_business_hours_idx_01 on default_business_hours (
	start_time)
with structure = btree,
	nocompression,
	key = (start_time),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index deletedjobs_idx_01 on deletedjobs (
	jobname)
with structure = btree,
	nocompression,
	key = (jobname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index idit1 on dit (
	eid,
	parent)
with structure = btree,
	nocompression,
	key = (eid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index idit2 on dit (
	parent,
	eid,
	flags)
with structure = btree,
	nocompression,
	key = (parent, eid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index dlgtsrv_x0 on dlgtsrv (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index dmn_x0 on dmn (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index doc_rep_x0 on doc_rep (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index doc_rep_x1 on doc_rep (
	repository_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (repository_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index doc_rep_x2 on doc_rep (
	archive_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (archive_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index i_dts_dtfilter on dts_dtfilter (
	object_id)
with structure = isam,
	nocompression,
	key = (object_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index i__dts_dttransfer on dts_dttransfer (
	object_id)
with structure = isam,
	nocompression,
	key = (object_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index i_dts_dttransfergroup on dts_dttransfergroup (
	object_id)
with structure = isam,
	nocompression,
	key = (object_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index i__dts_dtversion on dts_dtversion (
	object_id)
with structure = isam,
	nocompression,
	key = (object_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index i_dts_torproperties on dts_torproperties (
	object_id,
	row_num)
with structure = isam,
	nocompression,
	key = (object_id, row_num),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_acronyms_x0 on ebr_acronyms (
	acronym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (acronym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_fulltext_x0 on ebr_fulltext (
	entity_id,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_x1 on ebr_fulltext (
	doc_type,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_type, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_x2 on ebr_fulltext (
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_x3 on ebr_fulltext (
	product,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (product, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_x4 on ebr_fulltext (
	entity_id,
	word_count,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, word_count, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_fulltext_adm_x0 on ebr_fulltext_adm (
	entity_id,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_adm_x1 on ebr_fulltext_adm (
	doc_type,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_type, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_adm_x2 on ebr_fulltext_adm (
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_adm_x3 on ebr_fulltext_adm (
	product,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (product, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_adm_x4 on ebr_fulltext_adm (
	entity_id,
	word_count,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, word_count, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_fulltext_sd_x0 on ebr_fulltext_sd (
	entity_id,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_x1 on ebr_fulltext_sd (
	doc_type,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_type, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_x2 on ebr_fulltext_sd (
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_x3 on ebr_fulltext_sd (
	product,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (product, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_x4 on ebr_fulltext_sd (
	entity_id,
	word_count,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, word_count, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_fulltext_sd_adm_x0 on ebr_fulltext_sd_adm (
	entity_id,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_adm_x1 on ebr_fulltext_sd_adm (
	doc_type,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_type, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_adm_x2 on ebr_fulltext_sd_adm (
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_adm_x3 on ebr_fulltext_sd_adm (
	product,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (product, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_fulltext_sd_adm_x4 on ebr_fulltext_sd_adm (
	entity_id,
	word_count,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, word_count, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_indexing_queue_x0 on ebr_indexing_queue (
	obj_persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (obj_persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_keywords_x0 on ebr_keywords (
	entity_id,
	ext_table_id,
	full_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id, ext_table_id, full_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_log_x0 on ebr_log (
	asked_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (asked_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_log_x1 on ebr_log (
	num_matches)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (num_matches),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_log_x2 on ebr_log (
	external_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (external_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_log_x3 on ebr_log (
	top_match_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (top_match_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_log_x4 on ebr_log (
	user_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (user_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_metrics_x0 on ebr_metrics (
	metric)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (metric),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_noise_words_x0 on ebr_noise_words (
	noise_word)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (noise_word),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_patterns_x0 on ebr_patterns (
	pattern_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (pattern_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_properties_x0 on ebr_properties (
	property_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (property_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ebr_properties_x1 on ebr_properties (
	property_admin)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (property_admin),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_substits_x0 on ebr_substits (
	symbol1)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (symbol1),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_suffixes_x0 on ebr_suffixes (
	suffix)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (suffix),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_synonyms_x0 on ebr_synonyms (
	keyword1,
	keyword2)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (keyword1, keyword2),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ebr_synonyms_adm_x0 on ebr_synonyms_adm (
	keyword1,
	keyword2)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (keyword1, keyword2),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index ent_package_idx_01 on enterprise_package (
	ep_name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (ep_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ent_package_his_idx_01 on enterprise_package_history (
	chrono1,
	chrono2)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (chrono1, chrono2),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ent_package_his_idx_02 on enterprise_package_history (
	product_package_name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (product_package_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ent_package_his_idx_03 on enterprise_package_history (
	action)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (action),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index epd_job_details_idx_01 on epd_job_details (
	parent_id)
with structure = btree,
	nocompression,
	key = (parent_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index es_constants_x0 on es_constants (
	propertyid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (propertyid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index es_constants_x1 on es_constants (
	name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index es_nodes_x0 on es_nodes (
	node_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (node_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_nodes_x1 on es_nodes (
	link_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (link_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_nodes_x2 on es_nodes (
	parent_node_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent_node_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_nodes_x3 on es_nodes (
	root_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (root_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_nodes_x4 on es_nodes (
	tree_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (tree_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index es_responses_x0 on es_responses (
	parent_node_id,
	response_link_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent_node_id, response_link_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_responses_x1 on es_responses (
	parent_node_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent_node_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_responses_x2 on es_responses (
	response_link_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (response_link_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_responses_x3 on es_responses (
	response_link_order)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (response_link_order),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index es_sessions_x0 on es_sessions (
	session_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (session_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_sessions_x1 on es_sessions (
	external_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (external_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index es_sessions_x2 on es_sessions (
	tree_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (tree_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index eventlog_i1 on eventlog (
	ieventid,
	datetimestamp)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (ieventid, datetimestamp),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index evt_x0 on evt (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index evt_dly_x0 on evt_dly (
	obj_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (obj_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index evtdlytp_x0 on evtdlytp (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1extended_user_attribute_def on extended_user_attribute_def (
	product_instance_name)
with structure = isam,
	nocompression,
	key = (product_instance_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkextended_user_attribute_def on extended_user_attribute_def (
	extended_attribute_def_id)
with structure = isam,
	nocompression,
	key = (extended_attribute_def_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index filter_idx_01 on filter (
	owner,
	name)
with structure = isam,
	nocompression,
	key = (owner, name),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index filter_idx_02 on filter (
	name,
	owner)
with structure = isam,
	nocompression,
	key = (name, owner),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index frcircuitstatstime on frcircuitstats (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index frmgrp_x0 on frmgrp (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_chg_ext_x0 on g_chg_ext (
	last_mod_dt)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (last_mod_dt),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_chg_ext_x1 on g_chg_ext (
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_chg_queue_x0 on g_chg_queue (
	open_date,
	chg_ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (open_date, chg_ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_chg_queue_x1 on g_chg_queue (
	remote_sys_id,
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_sys_id, remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_chg_queue_x2 on g_chg_queue (
	global_queue_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (global_queue_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_chg_queue_x3 on g_chg_queue (
	assignee,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_chg_queue_x4 on g_chg_queue (
	group_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_chg_queue_x5 on g_chg_queue (
	category,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (category, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_contact_x0 on g_contact (
	last_name,
	first_name,
	middle_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (last_name, first_name, middle_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_contact_x1 on g_contact (
	remote_sys_id,
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_sys_id, remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_contact_x2 on g_contact (
	userid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (userid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_contact_x3 on g_contact (
	pri_phone_number)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (pri_phone_number),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_contact_x4 on g_contact (
	email_addr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (email_addr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_ext_x0 on g_iss_ext (
	last_mod_dt)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (last_mod_dt),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_ext_x1 on g_iss_ext (
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_queue_x0 on g_iss_queue (
	open_date,
	ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (open_date, ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_iss_queue_x1 on g_iss_queue (
	remote_sys_id,
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_sys_id, remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_queue_x2 on g_iss_queue (
	global_queue_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (global_queue_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_queue_x3 on g_iss_queue (
	assignee,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_queue_x4 on g_iss_queue (
	group_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_queue_x5 on g_iss_queue (
	category,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (category, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_iss_queue_x6 on g_iss_queue (
	product,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (product, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_org_x0 on g_org (
	org_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (org_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_org_x1 on g_org (
	remote_sys_id,
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_sys_id, remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_product_x0 on g_product (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_product_x1 on g_product (
	remote_sys_id,
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_sys_id, remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_queue_names_x0 on g_queue_names (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_req_ext_x0 on g_req_ext (
	last_mod_dt)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (last_mod_dt),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_req_ext_x1 on g_req_ext (
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_req_queue_x0 on g_req_queue (
	open_date,
	ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (open_date, ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_req_queue_x1 on g_req_queue (
	remote_sys_id,
	remote_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_sys_id, remote_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_req_queue_x2 on g_req_queue (
	global_queue_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (global_queue_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_req_queue_x3 on g_req_queue (
	assignee,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_req_queue_x4 on g_req_queue (
	group_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index g_req_queue_x5 on g_req_queue (
	category,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (category, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_srvr_x0 on g_srvr (
	remote_sys_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (remote_sys_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_srvr_x1 on g_srvr (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_srvr_x2 on g_srvr (
	global_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (global_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_tbl_map_x0 on g_tbl_map (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index g_tbl_rule_x0 on g_tbl_rule (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index grpmem_x0 on grpmem (
	group_id,
	member)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id, member),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index grpmem_x1 on grpmem (
	group_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index grpmem_x2 on grpmem (
	member)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (member),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harallchildrenpath_cld_idx on harallchildrenpath (
	childitemid)
with structure = btree,
	nocompression,
	key = (childitemid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harapprove_spid_idx on harapprove (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harapprhist_ind on harapprovehist (
	packageobjid)
with structure = btree,
	nocompression,
	key = (packageobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harapprovelist_spid_ind on harapprovelist (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harapprovelist_usrgrp_ind on harapprovelist (
	usrgrpobjid)
with structure = btree,
	nocompression,
	key = (usrgrpobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harapprovelist_usrid_ind on harapprovelist (
	usrobjid)
with structure = btree,
	nocompression,
	key = (usrobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harassocpkg_ind on harassocpkg (
	assocpkgid)
with structure = btree,
	nocompression,
	key = (assocpkgid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harbranch_itemid_ind on harbranch (
	itemobjid)
with structure = btree,
	nocompression,
	key = (itemobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harcheckinproc_spid_ind on harcheckinproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harcheckoutproc_spid_ind on harcheckoutproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harconmrgproc_spid_ind on harconmrgproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harcrpkgproc_spid_ind on harcrpkgproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harcrsenvmrgproc_spid_ind on harcrsenvmrgproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index hardelversproc_spid_ind on hardelversproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index hardemoteproc_spid_ind on hardemoteproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harenvironment_ind on harenvironment (
	environmentname)
with structure = btree,
	nocompression,
	key = (environmentname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harform_ind on harform (
	formname,
	formtypeobjid)
with structure = btree,
	nocompression,
	key = (formname, formtypeobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harformtype_ind on harformtype (
	formtypename)
with structure = btree,
	nocompression,
	key = (formtypename),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harformtypedef_alt on harformtypedefs (
	formtypeobjid,
	columnname)
with structure = btree,
	nocompression,
	key = (formtypeobjid, columnname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harformtypedef_col on harformtypedefs (
	columnname)
with structure = btree,
	nocompression,
	key = (columnname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index haritemrelationship_jps3 on haritemrelationship (
	relationship,
	refitemid,
	versionobjid)
with structure = btree,
	nocompression,
	key = (relationship),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index haritemrelationship_refitm_idx on haritemrelationship (
	refitemid)
with structure = btree,
	nocompression,
	key = (refitemid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index haritems_idx_001 on haritems (
	itemtype,
	itemobjid,
	parentobjid,
	itemname,
	repositobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itemtype, itemobjid, parentobjid, itemname, repositobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index haritems_idx_002 on haritems (
	parentobjid,
	itemobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (parentobjid, itemobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index haritems_ind_type on haritems (
	itemtype,
	parentobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itemtype, parentobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index haritems_pki on haritems (
	itemobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itemobjid),
	unique_scope = statement,
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index p_ukey on haritems (
	parentobjid,
	itemname)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (parentobjid, itemname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harnotifylist_spid_ind on harnotifylist (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harnotifylist_usrgrp_ind on harnotifylist (
	usrgrpobjid)
with structure = btree,
	nocompression,
	key = (usrgrpobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harnotifylist_usrid_ind on harnotifylist (
	usrobjid)
with structure = btree,
	nocompression,
	key = (usrobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harpackage_ind on harpackage (
	packagename,
	envobjid,
	packageobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (packagename, envobjid, packageobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harpackage_ind_env on harpackage (
	envobjid,
	stateobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (envobjid, stateobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harpkggrp_ind on harpackagegroup (
	envobjid,
	pkggrpname)
with structure = btree,
	nocompression,
	key = (envobjid, pkggrpname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harpathfullname_path on harpathfullname (
	pathfullname,
	itemobjid)
with structure = hash,
	nocompression,
	key = (pathfullname, itemobjid),
	persistence,
	minpages = 2,
	fillfactor = 50,
	location = (ii_database)
\p\g
create index harpathfullname_pupper on harpathfullname (
	pathfullnameupper)
with structure = hash,
	nocompression,
	key = (pathfullnameupper),
	persistence,
	minpages = 2,
	fillfactor = 50,
	location = (ii_database)
\p\g
create index harpkgsinpkggrp_ind on harpkgsinpkggrp (
	pkggrpobjid)
with structure = btree,
	nocompression,
	key = (pkggrpobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harrepository_ind on harrepository (
	repositname)
with structure = btree,
	nocompression,
	key = (repositname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harstate_ind on harstate (
	statename,
	envobjid)
with structure = btree,
	nocompression,
	key = (statename, envobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harstateproc_ind on harstateprocess (
	stateobjid,
	processname)
with structure = btree,
	nocompression,
	key = (stateobjid, processname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harswitchpkgproc_spid_ind on harswitchpkgproc (
	stateobjid,
	processobjid)
with structure = btree,
	nocompression,
	key = (stateobjid, processobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index haruser_ind on haruser (
	username)
with structure = btree,
	nocompression,
	key = (username),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harusergroup_ind on harusergroup (
	usergroupname)
with structure = btree,
	nocompression,
	key = (usergroupname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harusersingroup_jps4 on harusersingroup (
	usrgrpobjid,
	usrobjid)
with structure = btree,
	nocompression,
	key = (usrgrpobjid, usrobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harversiondata_pki on harversiondata (
	versiondataobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (versiondataobjid),
	unique_scope = statement,
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversioninview_jps1 on harversioninview (
	versionobjid,
	viewobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (versionobjid, viewobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harversioninview_pki on harversioninview (
	viewobjid,
	versionobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (viewobjid, versionobjid),
	unique_scope = statement,
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversioninview_version_ind on harversioninview (
	versionobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (versionobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversioninview_view_ind on harversioninview (
	viewobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (viewobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversions_item_ind on harversions (
	itemobjid,
	versionobjid,
	inbranch,
	versionstatus)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itemobjid, versionobjid, inbranch, versionstatus),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversions_merged_ind on harversions (
	mergedversionid,
	packageobjid,
	parentversionid,
	versionobjid,
	mappedversion)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (mergedversionid, packageobjid, parentversionid, versionobjid, mappedversion),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversions_par_ind on harversions (
	parentversionid,
	packageobjid,
	mergedversionid,
	versionobjid,
	mappedversion)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (parentversionid, packageobjid, mergedversionid, versionobjid, mappedversion),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversions_pkg_ind on harversions (
	packageobjid,
	modifierid,
	creatorid,
	versionstatus)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (packageobjid, modifierid, creatorid, versionstatus),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harversions_pki on harversions (
	versionobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (versionobjid),
	unique_scope = statement,
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harversions_versionobjid on harversions (
	versionobjid,
	itemobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (versionobjid, itemobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index har_subpack_act_idx_01 on harvest_subpackage_actions (
	ep_id,
	sp_id)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (ep_id, sp_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harview_baseline on harview (
	viewobjid,
	baselineviewid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (viewobjid, baselineviewid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harview_name_ind on harview (
	viewname,
	envobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (viewname, envobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index harview_viewobjid_jps2 on harview (
	envobjid,
	viewobjid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (envobjid, viewobjid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index harview_viewobjid_rec on harview (
	viewobjid,
	envobjid,
	viewtype)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (viewobjid, envobjid, viewtype),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index hier_x0 on hier (
	hier_parent,
	hier_child)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (hier_parent, hier_child),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1iam_attribute on iam_attribute (
	attribute_shortvalue)
with structure = isam,
	nocompression,
	key = (attribute_shortvalue),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif2iam_attribute on iam_attribute (
	attribute_name)
with structure = isam,
	nocompression,
	key = (attribute_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif3iam_attribute on iam_attribute (
	object_guid)
with structure = isam,
	nocompression,
	key = (object_guid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif4iam_attribute on iam_attribute (
	attribute_order)
with structure = isam,
	nocompression,
	key = (attribute_order),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1iam_object on iam_object (
	product_instance_name)
with structure = isam,
	nocompression,
	key = (product_instance_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif2iam_object on iam_object (
	object_class)
with structure = isam,
	nocompression,
	key = (object_class),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif3iam_object on iam_object (
	location_name)
with structure = isam,
	nocompression,
	key = (location_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif4iam_object on iam_object (
	object_name)
with structure = isam,
	nocompression,
	key = (object_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif5iam_object on iam_object (
	object_link)
with structure = isam,
	nocompression,
	key = (object_link),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xiu1iam_object on iam_object (
	location_name,
	object_name)
with structure = isam,
	nocompression,
	key = (location_name, object_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkiam_object on iam_object (
	object_guid)
with structure = isam,
	nocompression,
	key = (object_guid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index identifier_u1 on identifier (
	id_type)
with structure = isam,
	nocompression,
	key = (id_type),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index impact_x0 on impact (
	enum)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (enum),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index impact_x1 on impact (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index index_doc_links_x0 on index_doc_links (
	doc_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index index_doc_links_x1 on index_doc_links (
	index_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (index_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index index_doc_links_x2 on index_doc_links (
	relational_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (relational_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index infolng_sk1 on infolng (
	itval)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itval),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index infolng_sk2 on infolng (
	itprnmid,
	itrootid,
	itrtnmid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itprnmid, itrootid, itrtnmid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index infolng_sk6 on infolng (
	itrootid,
	itprnmid,
	itdate)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itrootid, itprnmid, itdate),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index iqlt_groups on infoqlt (
	itprnmid,
	itrtnmid,
	itident)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (itprnmid, itrtnmid, itident),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index interface_x0 on interface (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index invgene_sk1 on invgene (
	gid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (gid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index invgene_sk2 on invgene (
	iconkey)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (iconkey),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index iss_template_x0 on iss_template (
	template_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index iss_template_x1 on iss_template (
	template_class)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_class),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issalg_x0 on issalg (
	issue_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (issue_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issalg_x1 on issalg (
	time_stamp,
	type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (time_stamp, type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index isscat_x0 on isscat (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index isscat_x1 on isscat (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issprp_x0 on issprp (
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issprp_x1 on issprp (
	owning_iss)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owning_iss),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index issstat_x0 on issstat (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index issstat_x1 on issstat (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index issue_x0 on issue (
	open_date,
	ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (open_date, ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x1 on issue (
	requestor,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (requestor, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x10 on issue (
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x11 on issue (
	parent)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x12 on issue (
	template_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (template_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x13 on issue (
	close_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (close_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x14 on issue (
	resolve_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (resolve_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x2 on issue (
	log_agent,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (log_agent, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index issue_x3 on issue (
	ref_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ref_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x4 on issue (
	assignee,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x5 on issue (
	group_id,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (group_id, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x6 on issue (
	category,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (category, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x7 on issue (
	priority,
	active_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (priority, active_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x8 on issue (
	persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index issue_x9 on issue (
	status)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index isswf_x0 on isswf (
	object_id,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_id, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index isswf_x1 on isswf (
	assignee)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index jmo_psr1_idx_01 on jmo_psr1 (
	psr_pscd,
	psr_pjob,
	psr_pjno,
	psr_pqua,
	_ii_sec_tabkey)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (psr_pscd, psr_pjob, psr_pjno, psr_pqua),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index jmo_psrm_idx_01 on jmo_psrm (
	psr_pscd,
	psr_pjob,
	psr_pjno,
	_ii_sec_tabkey)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (psr_pscd, psr_pjob, psr_pjno),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index jmo_psrm_idx_02 on jmo_psrm (
	psr_pjob,
	_ii_sec_tabkey)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (psr_pjob),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index jmo_psrt_idx_01 on jmo_psrt (
	psr_pscd,
	psr_pjob,
	psr_pjno,
	psr_pqua,
	_ii_sec_tabkey)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (psr_pscd, psr_pjob, psr_pjno, psr_pqua),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index job_cond_idx_01 on job_cond (
	cond_mode,
	cond_job_name,
	joid)
with structure = btree,
	nocompression,
	key = (cond_mode, cond_job_name, joid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index job_event_idx_01 on job_event (
	que_status,
	priority,
	stamp)
with structure = btree,
	nocompression,
	key = (que_status, priority, stamp),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index job_event_idx_02 on job_event (
	evt_num)
with structure = btree,
	nocompression,
	key = (evt_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index job_event_idx_03 on job_event (
	joid,
	run_num)
with structure = btree,
	nocompression,
	key = (joid, run_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index job_event_idx_04 on job_event (
	event,
	box_name,
	run_num)
with structure = btree,
	nocompression,
	key = (event, box_name, run_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index job_job_idx_01 on job_job (
	job_name)
with structure = btree,
	nocompression,
	key = (job_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index job_job_idx_02 on job_job (
	box_joid)
with structure = btree,
	nocompression,
	key = (box_joid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index job_runs_idx_01 on job_runs (
	evt_num)
with structure = btree,
	nocompression,
	key = (evt_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index job_template_idx_01 on job_template (
	name)
with structure = btree,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index joborder_sk1 on joborder (
	unitid,
	udomid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (unitid, udomid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index joborder_sk2 on joborder (
	jobid,
	unitid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (jobid, unitid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index jobs_idx_01 on jobs (
	id)
with structure = btree,
	nocompression,
	key = (id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index kd_attmnt_x0 on kd_attmnt (
	doc_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index kd_attmnt_x1 on kd_attmnt (
	attmnt_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (attmnt_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index kdlinks_x0 on kdlinks (
	kd)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (kd),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index kdlinks_x1 on kdlinks (
	sd_obj_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sd_obj_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index kdlinks_x2 on kdlinks (
	sd_obj_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sd_obj_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index kdlinks_x3 on kdlinks (
	link_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (link_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index km_kword_x0 on km_kword (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index km_lrel_x0 on km_lrel (
	l_persid,
	l_attr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (l_persid, l_attr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index km_lrel_x1 on km_lrel (
	r_persid,
	r_attr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (r_persid, r_attr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index linkbck_sk1 on linkbck (
	unitid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (unitid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index linkjob_sk1 on linkjob (
	unitid,
	udomid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (unitid, udomid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index linkjob_sk2 on linkjob (
	jobid,
	unitid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (jobid, unitid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index list_idx_01 on list (
	name,
	owner)
with structure = isam,
	nocompression,
	key = (name, owner),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index list_idx_02 on list (
	owner,
	name)
with structure = isam,
	nocompression,
	key = (owner, name),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index listproperties_idx_01 on listproperties (
	listid,
	colno)
with structure = btree,
	nocompression,
	key = (listid, colno),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index long_texts_x0 on long_texts (
	ref_persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ref_persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index long_texts_x1 on long_texts (
	cnt_order)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (cnt_order),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lrel_x0 on lrel (
	l_persid,
	l_attr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (l_persid, l_attr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lrel_x1 on lrel (
	r_persid,
	r_attr)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (r_persid, r_attr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lsyfileserverclientstime on lsyfileserverclients (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lsyfileserverstatstime on lsyfileserverstats (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lsytermserverclientstime on lsytermserverclients (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index lsytermserverstatstime on lsytermserverstats (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index m2ifstatstime on m2ifstats (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index m2ipstatstime on m2ipstats (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index maildb_idx_01 on maildb (
	dbtitle)
with structure = btree,
	nocompression,
	key = (dbtitle),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index man_mod_x0 on man_mod (
	mdl_mfr_id,
	mdl_sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (mdl_mfr_id, mdl_sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index alert_idx_01 on management_alert (
	tstamp)
with structure = btree,
	nocompression,
	key = (tstamp),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index management_asset_grp_idx_01 on management_asset_group (
	asset)
with structure = btree,
	nocompression,
	key = (asset),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xie1mibdefinition on mibdefinition (
	description)
with structure = isam,
	nocompression,
	key = (description),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index server_name_ind on mit_server (
	server_name)
with structure = btree,
	nocompression,
	key = (server_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index server_type_ind on mit_server (
	server_type)
with structure = btree,
	nocompression,
	key = (server_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index monitor_idx_01 on monitor (
	monitor_type)
with structure = btree,
	nocompression,
	key = (monitor_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index monitor_notification_idx_01 on monitor_notification (
	severity_id,
	snmp_manager_id)
with structure = btree,
	nocompression,
	key = (severity_id, snmp_manager_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ncipc_sk1 on ncipc (
	ipcsid,
	sdomid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (ipcsid, sdomid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ncipc_sk3 on ncipc (
	ipcdate)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (ipcdate),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ncipc_sk4 on ncipc (
	ipctype,
	ipctypex,
	udomid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (ipctype, ipctypex, udomid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ncjobcfg_sk1 on ncjobcfg (
	joflag)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (joflag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index nctngref_sk1 on nctngref (
	uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index alertfieldindex on network_alert (
	fieldindex)
with structure = btree,
	nocompression,
	key = (fieldindex),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index alerttime on network_alert (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index probeflag on network_probe (
	collect_flags)
with structure = btree,
	nocompression,
	key = (collect_flags),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index not_log_x0 on not_log (
	nlh_c_addressee,
	nlh_start)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (nlh_c_addressee, nlh_start),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index not_log_x1 on not_log (
	nlh_status,
	nlh_c_addressee,
	cmth_used)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (nlh_status, nlh_c_addressee, cmth_used),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index notification_x0 on notification (
	analyst_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (analyst_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index notification_x1 on notification (
	doc_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index notification_x2 on notification (
	ntf_level)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ntf_level),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index noturg_x0 on noturg (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index nr_com_x0 on nr_com (
	com_par_id,
	com_dt)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (com_par_id, com_dt),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ntfl_x0 on ntfl (
	object_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_comments_x0 on o_comments (
	doc_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_comments_x1 on o_comments (
	ver_count)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ver_count),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_comments_x2 on o_comments (
	user_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (user_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_comments_x3 on o_comments (
	comment_timestamp)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (comment_timestamp),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_events_x0 on o_events (
	entity_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (entity_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_events_x1 on o_events (
	ver_count)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ver_count),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_events_x2 on o_events (
	wf_action_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (wf_action_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_events_x3 on o_events (
	wf_user_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (wf_user_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_indexes_x0 on o_indexes (
	caption)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (caption),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_indexes_x1 on o_indexes (
	permission_index_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (permission_index_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_indexes_x2 on o_indexes (
	parent_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (parent_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index o_indexes_x3 on o_indexes (
	relational_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (relational_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index objects_idx_01 on objects (
	objecttype,
	maildiskid)
with structure = btree,
	nocompression,
	key = (objecttype, maildiskid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index openunit_sk1 on openunit (
	opunit)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (opunit),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index operation_idx_01 on operation (
	port_address,
	service_name,
	name)
with structure = isam,
	nocompression,
	key = (port_address, service_name, name),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index op_group_monitor_type_idx_01 on operation_group_monitor_type (
	operation_group_id,
	monitor_type)
with structure = btree,
	nocompression,
	key = (operation_group_id, monitor_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index options_x0 on options (
	app_name,
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (app_name, sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index p_groups_x0 on p_groups (
	grp_list_key)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (grp_list_key),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1password_history on password_history (
	user_uuid)
with structure = isam,
	nocompression,
	key = (user_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkpassword_history on password_history (
	password_id)
with structure = isam,
	nocompression,
	key = (password_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index idx_pd_day_date1 on pd_day (
	current_date)
with structure = btree,
	nocompression,
	key = (current_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index idx_pd_day_date2 on pd_day (
	current_date_int)
with structure = btree,
	nocompression,
	key = (current_date_int),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index idx_pd_machine1 on pd_machine (
	asset_id)
with structure = btree,
	nocompression,
	key = (asset_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index permission_i1 on permission (
	uidaddressbook)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (uidaddressbook),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index permissionglobal_i1 on permissionglobal (
	uidaddressbook)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (uidaddressbook),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index permit_profile_idx_01 on permit_profile (
	usernode,
	userid,
	usertype,
	assetid,
	assetnode,
	assettype,
	accesstype)
with structure = hash,
	nocompression,
	key = (usernode, userid, usertype, assetid, assetnode, assettype, accesstype),
	persistence,
	minpages = 2,
	fillfactor = 50,
	location = (ii_database)
\p\g
create index permit_profile_idx_02 on permit_profile (
	assetid)
with structure = btree,
	nocompression,
	key = (assetid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index permit_profile_idx_03 on permit_profile (
	usernode)
with structure = btree,
	nocompression,
	key = (usernode),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index permit_profile_idx_04 on permit_profile (
	userid)
with structure = btree,
	nocompression,
	key = (userid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index perscon_x0 on perscon (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1policy_resource_class_asc on policy_resource_class_asc (
	resource_class_uuid)
with structure = isam,
	nocompression,
	key = (resource_class_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif2policy_resource_class_asc on policy_resource_class_asc (
	access_policy_uuid)
with structure = isam,
	nocompression,
	key = (access_policy_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkpolicy_resource_class_asc on policy_resource_class_asc (
	access_policy_uuid,
	resource_class_uuid)
with structure = isam,
	nocompression,
	key = (access_policy_uuid, resource_class_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index dpagegrpobkey on por_dftpage (
	group_objectkey)
with structure = isam,
	nocompression,
	key = (group_objectkey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index dpageusrobkey on por_dftpage (
	user_objectkey)
with structure = isam,
	nocompression,
	key = (user_objectkey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discchanged on por_discussion (
	changed)
with structure = isam,
	nocompression,
	key = (changed),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discdepth on por_discussion (
	depth)
with structure = isam,
	nocompression,
	key = (depth),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discobkey on por_discussion (
	objectkey)
with structure = isam,
	nocompression,
	key = (objectkey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discownerid on por_discussion (
	ownerid)
with structure = isam,
	nocompression,
	key = (ownerid),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discpathid on por_discussion (
	pathid)
with structure = isam,
	nocompression,
	key = (pathid),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discnfyobkey on por_discussion_nfy (
	objectkey)
with structure = isam,
	nocompression,
	key = (objectkey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discnfypathid on por_discussion_nfy (
	pathid)
with structure = isam,
	nocompression,
	key = (pathid),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index discnfyuserid on por_discussion_nfy (
	userid)
with structure = isam,
	nocompression,
	key = (userid),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index docdoctype on por_document (
	doctype)
with structure = isam,
	nocompression,
	key = (doctype),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index docexpires on por_document (
	expires)
with structure = isam,
	nocompression,
	key = (expires),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index docfilename on por_document (
	filename)
with structure = hash,
	nocompression,
	key = (filename),
	persistence,
	minpages = 2,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index docisrequired on por_document (
	isrequired)
with structure = isam,
	nocompression,
	key = (isrequired),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index doclocation on por_document (
	location)
with structure = isam,
	nocompression,
	key = (location),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index docreluri on por_document (
	relativeuri)
with structure = hash,
	nocompression,
	key = (relativeuri),
	persistence,
	minpages = 2,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index docshortcut on por_document (
	shortcut)
with structure = isam,
	nocompression,
	key = (shortcut),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index objobjectname on por_objectrepos (
	objectname)
with structure = isam,
	nocompression,
	key = (objectname),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index objownerid on por_objectrepos (
	ownerid)
with structure = isam,
	nocompression,
	key = (ownerid),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index objpassword on por_objectrepos (
	password)
with structure = isam,
	nocompression,
	key = (password),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index objtypekey on por_objectrepos (
	objecttypekey)
with structure = isam,
	nocompression,
	key = (objecttypekey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index pagecol_pageid on por_pagecols (
	portalpage_id_fk)
with structure = isam,
	nocompression,
	key = (portalpage_id_fk),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index compsdocidfk on por_pagecomps (
	document_id_fk)
with structure = isam,
	nocompression,
	key = (document_id_fk),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index pagecomps_colid on por_pagecomps (
	compcolumnid)
with structure = isam,
	nocompression,
	key = (compcolumnid),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index pagesuserkeyfk on por_pages (
	user_objectkey_fk)
with structure = isam,
	nocompression,
	key = (user_objectkey_fk),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index prefname on por_preferences (
	name)
with structure = btree,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index prefobjectkey on por_preferences (
	objectkey)
with structure = btree,
	nocompression,
	key = (objectkey),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index prefuserkey on por_preferences (
	userkey)
with structure = btree,
	nocompression,
	key = (userkey),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index prefcongrpkey on por_prefsconfig (
	group_objectkey)
with structure = isam,
	nocompression,
	key = (group_objectkey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index relchild on por_relationships (
	childkey)
with structure = isam,
	nocompression,
	key = (childkey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index relparent on por_relationships (
	parentkey)
with structure = isam,
	nocompression,
	key = (parentkey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index reltype on por_relationships (
	relationshiptype)
with structure = isam,
	nocompression,
	key = (relationshiptype),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sesslastactime on por_session (
	lastaccesstime)
with structure = btree,
	nocompression,
	key = (lastaccesstime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sesssid on por_session (
	sid)
with structure = btree,
	nocompression,
	key = (sid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sessuserkey on por_session (
	userkey)
with structure = btree,
	nocompression,
	key = (userkey),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sessusername on por_session (
	username)
with structure = btree,
	nocompression,
	key = (username),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sessobjpwsid on por_sessobjpw (
	sid)
with structure = hash,
	nocompression,
	key = (sid),
	persistence,
	minpages = 2,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index tmpltdefptr on por_template (
	defptr)
with structure = isam,
	nocompression,
	key = (defptr),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index templateindex on por_templatelookup (
	idx)
with structure = isam,
	nocompression,
	key = (idx),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index templatekey on por_templatelookup (
	templatekey)
with structure = isam,
	nocompression,
	key = (templatekey),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index pri_x0 on pri (
	enum)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (enum),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index pri_x1 on pri (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index prob_ctg_x0 on prob_ctg (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index proc_event_idx_01 on proc_event (
	que_status,
	priority,
	stamp)
with structure = btree,
	nocompression,
	key = (que_status, priority, stamp),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index proc_event_idx_02 on proc_event (
	evt_num)
with structure = btree,
	nocompression,
	key = (evt_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index proc_event_idx_03 on proc_event (
	joid,
	run_num)
with structure = btree,
	nocompression,
	key = (joid, run_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index proc_event_idx_04 on proc_event (
	event,
	box_name,
	run_num)
with structure = btree,
	nocompression,
	key = (event, box_name, run_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index product_x0 on product (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index provider_user_idx_01 on provider_user (
	provider_name,
	product_code,
	username,
	provider_number)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (provider_name, product_code, username, provider_number),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index prp_x0 on prp (
	object_id,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_id, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index prptpl_x0 on prptpl (
	object_attrname,
	object_attrval,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_attrname, object_attrval, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index quick_tpl_types_x0 on quick_tpl_types (
	enum)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (enum),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index rbooltab_x0 on rbooltab (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index region_idx_01 on region (
	regionname,
	instancename)
with structure = btree,
	nocompression,
	key = (regionname, instancename),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index region_idx_02 on region (
	regiontype)
with structure = btree,
	nocompression,
	key = (regiontype),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index region_idx_03 on region (
	parentregionid)
with structure = btree,
	nocompression,
	key = (parentregionid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index region_idx_04 on region (
	parentboxid)
with structure = btree,
	nocompression,
	key = (parentboxid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index rem_ref_x0 on rem_ref (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index repmeth_x0 on repmeth (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index resnonhealthindex on resnonhealth (
	probe_addr,
	intervaldatetime,
	ifindex,
	intervalduration,
	downduration,
	criticalduration,
	majorduration,
	minorduration,
	warningduration)
with structure = btree,
	nocompression,
	key = (probe_addr, intervaldatetime, ifindex, intervalduration, downduration, criticalduration, majorduration, minorduration, warningduration),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1resource_class on resource_class (
	product_instance_name)
with structure = isam,
	nocompression,
	key = (product_instance_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif2resource_class on resource_class (
	product_instance_id)
with structure = isam,
	nocompression,
	key = (product_instance_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkresource_class on resource_class (
	resource_class_uuid)
with structure = isam,
	nocompression,
	key = (resource_class_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xie1resourcemonitoring on resourcemonitoring (
	server_addr,
	probe_addr,
	mibidx)
with structure = isam,
	nocompression,
	key = (server_addr, probe_addr, mibidx),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xie2resourcemonitoring on resourcemonitoring (
	probe_addr)
with structure = isam,
	nocompression,
	key = (probe_addr),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xie3resourcemonitoring on resourcemonitoring (
	mibidx,
	probe_addr)
with structure = isam,
	nocompression,
	key = (mibidx, probe_addr),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index response_x0 on response (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index response_x1 on response (
	response_owner)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (response_owner),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index response_x2 on response (
	cr_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (cr_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index response_x3 on response (
	in_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (in_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index response_x4 on response (
	pr_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (pr_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index response_x5 on response (
	chg_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (chg_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index response_x6 on response (
	iss_flag)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (iss_flag),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index rmon2alhosttime on rmon2alhost (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index rmon2nlmatrixtime on rmon2nlmatrix (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index rmon2protocoldisttime on rmon2protocoldist (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index rm2protocolid on rmon2protocolid (
	protocoldirid)
with structure = hash,
	nocompression,
	key = (protocoldirid),
	persistence,
	minpages = 2,
	fillfactor = 50,
	location = (ii_database)
\p\g
create index rmonetherstatsstatstime on rmonetherstatsstats (
	intervaldatetime)
with structure = btree,
	nocompression,
	key = (intervaldatetime),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index rootcause_x0 on rootcause (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index rptmth_x0 on rptmth (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index sapolicy_x0 on sapolicy (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index saprobtyp_x0 on saprobtyp (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sdsc_map_x0 on sdsc_map (
	map_contract)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (map_contract),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index sdsc_map_x1 on sdsc_map (
	map_contract,
	map_objid,
	map_objtype)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (map_contract, map_objid, map_objtype),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index isearch on search (
	eid,
	aid,
	vid,
	normkey)
with structure = btree,
	nocompression,
	key = (eid, aid, vid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1security_cal_time_block on security_cal_time_block (
	calendar_id)
with structure = isam,
	nocompression,
	key = (calendar_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpksecurity_cal_time_block on security_cal_time_block (
	time_block_id)
with structure = isam,
	nocompression,
	key = (time_block_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpksecurity_calendar on security_calendar (
	calendar_id)
with structure = isam,
	nocompression,
	key = (calendar_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpksecurity_person on security_person (
	person_id)
with structure = isam,
	nocompression,
	key = (person_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1policy on security_policy (
	calendar_name)
with structure = isam,
	nocompression,
	key = (calendar_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif3policy on security_policy (
	product_instance_name)
with structure = isam,
	nocompression,
	key = (product_instance_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkpolicy on security_policy (
	policy_uuid)
with structure = isam,
	nocompression,
	key = (policy_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1policy_action_association on security_policy_action_asc (
	policy_action_uuid)
with structure = isam,
	nocompression,
	key = (policy_action_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif2policy_action_association on security_policy_action_asc (
	access_policy_uuid)
with structure = isam,
	nocompression,
	key = (access_policy_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkpolicy_action_association on security_policy_action_asc (
	policy_action_uuid,
	access_policy_uuid)
with structure = isam,
	nocompression,
	key = (policy_action_uuid, access_policy_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1policy_action_type on security_policy_action_type (
	resource_class_uuid)
with structure = isam,
	nocompression,
	key = (resource_class_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkpolicy_action_type on security_policy_action_type (
	policy_action_uuid)
with structure = isam,
	nocompression,
	key = (policy_action_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1security_user_group on security_user_group (
	product_instance_name)
with structure = isam,
	nocompression,
	key = (product_instance_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpksecurity_user_group on security_user_group (
	security_group_id)
with structure = isam,
	nocompression,
	key = (security_group_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ix_computername on seosdata (
	computername)
with structure = btree,
	nocompression,
	key = (computername),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ix_eventid on seosdata (
	eventid)
with structure = btree,
	nocompression,
	key = (eventid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ix_timestamp on seosdata (
	timstamp)
with structure = btree,
	nocompression,
	key = (timstamp),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index ix_username on seosdata (
	username)
with structure = btree,
	nocompression,
	key = (username),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index seqctl_x0 on seqctl (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index seqctl_x1 on seqctl (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index collector_idx_01 on server_collector (
	hostname)
with structure = btree,
	nocompression,
	key = (hostname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index person_idx_01 on server_person (
	displayname)
with structure = btree,
	nocompression,
	key = (displayname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index service_incidents_idx_01 on service_incidents (
	calendar_oid)
with structure = btree,
	nocompression,
	key = (calendar_oid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sessionlengthindex on sessionlength (
	start_time)
with structure = btree,
	nocompression,
	key = (start_time),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index severity_idx_01 on severity (
	operation_group_id,
	"level")
with structure = btree,
	nocompression,
	key = (operation_group_id, "level"),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index sevrty_x0 on sevrty (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index show_obj_x0 on show_obj (
	obj_persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (obj_persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x0 on skeletons (
	active_state)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (active_state),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x1 on skeletons (
	initiator_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (initiator_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x10 on skeletons (
	hits)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (hits),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x11 on skeletons (
	inherit_permission)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (inherit_permission),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x12 on skeletons (
	user_def_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (user_def_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x13 on skeletons (
	kd_permission_index_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (kd_permission_index_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x14 on skeletons (
	modify_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (modify_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x15 on skeletons (
	review_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (review_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x16 on skeletons (
	last_accepted_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (last_accepted_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x17 on skeletons (
	owner_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owner_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x18 on skeletons (
	assignee_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x19 on skeletons (
	primary_index)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (primary_index),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x2 on skeletons (
	author_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (author_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x20 on skeletons (
	priority_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (priority_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x21 on skeletons (
	published_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (published_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x22 on skeletons (
	read_pgroup)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (read_pgroup),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x23 on skeletons (
	sd_asset_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sd_asset_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x24 on skeletons (
	sd_accepted_hits)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sd_accepted_hits),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x25 on skeletons (
	sd_product_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sd_product_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x26 on skeletons (
	start_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (start_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x27 on skeletons (
	status_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (status_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x28 on skeletons (
	subject_expert_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (subject_expert_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x29 on skeletons (
	id,
	active_state,
	read_pgroup)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (id, active_state, read_pgroup),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x3 on skeletons (
	bu_result)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (bu_result),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x30 on skeletons (
	wf_template)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (wf_template),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x31 on skeletons (
	doc_version)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_version),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x32 on skeletons (
	ver_count)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ver_count),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x33 on skeletons (
	ver_cross_ref_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ver_cross_ref_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x34 on skeletons (
	locked_by_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (locked_by_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x4 on skeletons (
	created_via)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (created_via),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x5 on skeletons (
	creation_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (creation_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x6 on skeletons (
	doc_type_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_type_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x7 on skeletons (
	doc_version)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (doc_version),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x8 on skeletons (
	expiration_date)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (expiration_date),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index skeletons_x9 on skeletons (
	expire_notification_sent)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (expire_notification_sent),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index slatpl_x0 on slatpl (
	object_type,
	service_type,
	elapsed)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_type, service_type, elapsed),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index slatpl_x1 on slatpl (
	event)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (event),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index splmac_x0 on splmac (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index splmactp_x0 on splmactp (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index sql_tab_x0 on sql_tab (
	sql_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sql_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index srv_desc_x0 on srv_desc (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index srv_desc_x1 on srv_desc (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index srvr_aliases_x0 on srvr_aliases (
	alias_name,
	zone_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (alias_name, zone_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index srvr_zones_x0 on srvr_zones (
	zone_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (zone_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_backups_u1 on stg_backups (
	name,
	seqno)
with structure = isam,
	nocompression,
	key = (name, seqno),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_device_alloc_u1 on stg_device_alloc (
	machineid,
	devid)
with structure = isam,
	nocompression,
	key = (machineid, devid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_devices_idx_01 on stg_devices (
	name,
	device_type)
with structure = btree,
	nocompression,
	key = (name, device_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_devices_u1 on stg_devices (
	devid)
with structure = isam,
	nocompression,
	key = (devid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_devices_u2 on stg_devices (
	name,
	device_type)
with structure = isam,
	nocompression,
	key = (name, device_type),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_group_idx_01 on stg_group (
	creator,
	name)
with structure = btree,
	nocompression,
	key = (creator, name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_group_u1 on stg_group (
	stgid)
with structure = isam,
	nocompression,
	key = (stgid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_group_u2 on stg_group (
	creator,
	name)
with structure = isam,
	nocompression,
	key = (creator, name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_group_adsm_u1 on stg_group_adsm (
	stgid)
with structure = isam,
	nocompression,
	key = (stgid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index stg_group_devices_d1 on stg_group_devices (
	stgid)
with structure = isam,
	nocompression,
	key = (stgid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_group_openv_u1 on stg_group_openv (
	stgid)
with structure = isam,
	nocompression,
	key = (stgid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_group_tape_u1 on stg_group_tape (
	stgid)
with structure = isam,
	nocompression,
	key = (stgid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_volume_alloc_u1 on stg_volume_alloc (
	volid)
with structure = isam,
	nocompression,
	key = (volid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index stg_volumes_d1 on stg_volumes (
	stgid,
	machineid,
	devid)
with structure = isam,
	nocompression,
	key = (stgid, machineid, devid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index stg_volumes_idx_01 on stg_volumes (
	stgid,
	machineid,
	devid)
with structure = btree,
	nocompression,
	key = (stgid, machineid, devid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stg_volumes_u1 on stg_volumes (
	volid)
with structure = isam,
	nocompression,
	key = (volid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategies_idx_01 on strategies (
	version,
	strategy_owner,
	strategy_name,
	strategy_type,
	product_code)
with structure = btree,
	nocompression,
	key = (version, strategy_owner, strategy_name, strategy_type, product_code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_idx_01 on strategy (
	str_name,
	str_creator)
with structure = btree,
	nocompression,
	key = (str_name, str_creator),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_u1 on strategy (
	strid)
with structure = isam,
	nocompression,
	key = (strid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_u2 on strategy (
	str_name,
	str_creator)
with structure = isam,
	nocompression,
	key = (str_name, str_creator),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_db_server_d1 on strategy_db_server (
	instanceid)
with structure = isam,
	nocompression,
	key = (instanceid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_db_server_idx_01 on strategy_db_server (
	instanceid)
with structure = btree,
	nocompression,
	key = (instanceid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_db_server_u1 on strategy_db_server (
	serverid)
with structure = isam,
	nocompression,
	key = (serverid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_db_store_idx_01 on strategy_db_store (
	store_name,
	dbid,
	machineid)
with structure = btree,
	nocompression,
	key = (store_name, dbid, machineid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_db_store_u1 on strategy_db_store (
	storeid)
with structure = isam,
	nocompression,
	key = (storeid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_db_store_u2 on strategy_db_store (
	store_name,
	dbid,
	machineid)
with structure = isam,
	nocompression,
	key = (store_name, dbid, machineid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_group_u1 on strategy_group (
	strid,
	groupid)
with structure = isam,
	nocompression,
	key = (strid, groupid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_host_id_d1 on strategy_host_id (
	machineid)
with structure = isam,
	nocompression,
	key = (machineid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_host_id_idx_01 on strategy_host_id (
	host_name,
	domain_name)
with structure = btree,
	nocompression,
	key = (host_name, domain_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_host_id_idx_02 on strategy_host_id (
	machineid)
with structure = btree,
	nocompression,
	key = (machineid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_host_id_u1 on strategy_host_id (
	hostid)
with structure = isam,
	nocompression,
	key = (hostid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_host_id_u2 on strategy_host_id (
	host_name,
	domain_name)
with structure = isam,
	nocompression,
	key = (host_name, domain_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_ins_store_u1 on strategy_ins_store (
	instanceid,
	storeid)
with structure = isam,
	nocompression,
	key = (instanceid, storeid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_instance_idx_01 on strategy_instance (
	instance_name,
	machineid)
with structure = btree,
	nocompression,
	key = (instance_name, machineid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_instance_u1 on strategy_instance (
	instanceid)
with structure = isam,
	nocompression,
	key = (instanceid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_instance_u2 on strategy_instance (
	instance_name,
	machineid)
with structure = isam,
	nocompression,
	key = (instance_name, machineid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_job_d1 on strategy_job (
	serverid,
	jobid)
with structure = isam,
	nocompression,
	key = (serverid, jobid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_job_idx_01 on strategy_job (
	groupid,
	serverid,
	run_num)
with structure = btree,
	nocompression,
	key = (groupid, serverid, run_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_job_idx_02 on strategy_job (
	serverid,
	jobid)
with structure = btree,
	nocompression,
	key = (serverid, jobid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_job_u1 on strategy_job (
	strid,
	groupid,
	serverid,
	run_num)
with structure = isam,
	nocompression,
	key = (strid, groupid, serverid, run_num),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_job_u2 on strategy_job (
	groupid,
	serverid,
	run_num)
with structure = isam,
	nocompression,
	key = (groupid, serverid, run_num),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_lock_u1 on strategy_lock (
	creator,
	name)
with structure = isam,
	nocompression,
	key = (creator, name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_machine_idx_01 on strategy_machine (
	platform,
	ident_string)
with structure = btree,
	nocompression,
	key = (platform, ident_string),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_machine_u1 on strategy_machine (
	machineid)
with structure = isam,
	nocompression,
	key = (machineid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_machine_u2 on strategy_machine (
	platform,
	ident_string)
with structure = isam,
	nocompression,
	key = (platform, ident_string),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_objs_slct_d1 on strategy_objs_slct (
	strid,
	target_serverid)
with structure = isam,
	nocompression,
	key = (strid, target_serverid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_run_d1 on strategy_run (
	groupid)
with structure = isam,
	nocompression,
	key = (groupid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index strategy_run_idx_01 on strategy_run (
	groupid)
with structure = btree,
	nocompression,
	key = (groupid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_run_u1 on strategy_run (
	strid,
	groupid,
	run_num)
with structure = isam,
	nocompression,
	key = (strid, groupid, run_num),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index strategy_ver_info_u1 on strategy_ver_info (
	owner_name,
	table_name)
with structure = isam,
	nocompression,
	key = (owner_name, table_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index stratglblchg_idx_01 on stratglblchg (
	id)
with structure = btree,
	nocompression,
	key = (id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index isubsearch on subsearch (
	eid,
	aid,
	cid,
	vid,
	cvid,
	normkey)
with structure = btree,
	nocompression,
	key = (eid, aid, cid, vid, cvid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index survey_x0 on survey (
	object_type,
	object_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_type, object_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index survey_answer_x0 on survey_answer (
	own_srvy_question,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (own_srvy_question, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index survey_atpl_x0 on survey_atpl (
	own_srvy_question,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (own_srvy_question, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index survey_qtpl_x0 on survey_qtpl (
	owning_survey,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owning_survey, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index survey_question_x0 on survey_question (
	owning_survey,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (owning_survey, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index survey_tpl_x0 on survey_tpl (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index svc_contract_x0 on svc_contract (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index svc_contract_x1 on svc_contract (
	contract_num)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (contract_num),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1tau_mdb_product on tau_mdb_product (
	mdbmajorversion,
	mdbminorversion)
with structure = isam,
	nocompression,
	key = (mdbmajorversion, mdbminorversion),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif2tau_mdb_product on tau_mdb_product (
	productname,
	productmajorversion,
	productminorversion)
with structure = isam,
	nocompression,
	key = (productname, productmajorversion, productminorversion),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index thresholdindex on thresholds (
	probe_addr,
	rsrcindex,
	rsrcotherindex,
	fieldindex)
with structure = btree,
	nocompression,
	key = (probe_addr, rsrcindex, rsrcotherindex, fieldindex),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index tn_x0 on tn (
	tn_sys)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (tn_sys),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index tn_x1 on tn (
	tn_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (tn_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_address_type_desc on tng_address_type (
	address_description)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (address_description),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_adminstatus_admin_text on tng_adminstatus (
	admin_text)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (admin_text),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_name on tng_class (
	name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index tng_ca_x_ipsubnet_addr on tng_discovery_ipsubnet (
	subnet_addr)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (subnet_addr),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tng_ca_x_ipsubnet_name on tng_discovery_ipsubnet (
	name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tngdsmclassscope on tng_dsm_class_scope (
	dsmserver,
	classname)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (dsmserver, classname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tngdsmcommscope on tng_dsm_comm_scope (
	dsmserver,
	ipmask,
	nodeclassname,
	agentclassname,
	getcommstring,
	setcommstring,
	portnumber)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (dsmserver, ipmask, nodeclassname, agentclassname, getcommstring, setcommstring, portnumber),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_dsmservermask on tng_dsm_ip_scope (
	dsmserver,
	ipmask)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (dsmserver, ipmask),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tngdsmmocope on tng_dsm_mo_scope (
	dsmserver,
	ipmask,
	agentclassname,
	agentinstancename)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (dsmserver, ipmask, agentclassname, agentinstancename),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tngdsmpollscope on tng_dsm_poll_scope (
	dsmserver,
	ipmask,
	nodeclassname,
	agentclassname,
	interval,
	timeout,
	retries)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (dsmserver, ipmask, nodeclassname, agentclassname, interval, timeout, retries),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_inclusion_child_parent on tng_inclusion (
	child_uuid,
	parent_uuid,
	parent_class)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (child_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_inclusion_child_uuid on tng_inclusion (
	child_uuid,
	uuid,
	child_sequence_no)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (child_uuid, uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_inclusion_hidden on tng_inclusion (
	hidden)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (hidden),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_inclusion_parent_child on tng_inclusion (
	parent_uuid,
	child_uuid,
	uuid,
	child_class)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (parent_uuid, child_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_jii_inclusion_child_svr on tng_jii_inclusion (
	child_jii_server)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (child_jii_server),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_jii_inclusion_child_uuid on tng_jii_inclusion (
	child_jii_objid,
	uuid,
	child_sequence_no)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (child_jii_objid, uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_link_class_name on tng_link (
	class_name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (class_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_link_dest_uuid on tng_link (
	dest_uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (dest_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_link_source_uuid on tng_link (
	source_uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (source_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_manobj_address on tng_managedobject (
	address)
with structure = btree,
	nocompression,
	key = (address),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_manobj_asset_uuid on tng_managedobject (
	asset_uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (asset_uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_manobj_clsname_add on tng_managedobject (
	class_name,
	address)
with structure = btree,
	nocompression,
	key = (class_name, address),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_manobj_clsname_name on tng_managedobject (
	class_name,
	name)
with structure = btree,
	nocompression,
	key = (class_name, name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_manobj_clsname_uuid on tng_managedobject (
	class_name,
	uuid)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (class_name, uuid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_manobj_hidden on tng_managedobject (
	hidden)
with structure = btree,
	nocompression,
	key = (hidden),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_manobj_ip_addr_hex on tng_managedobject (
	ip_address_hex)
with structure = btree,
	nocompression,
	key = (ip_address_hex),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_prop_def_class_id_name on tng_property_definition (
	class_id,
	name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (class_id, name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_prop_def_id on tng_property_definition (
	id)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tng_status_status_text on tng_status (
	status_no,
	status_text)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (status_no, status_text),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_vendor_name on tng_vendor (
	name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index x_tng_vendor_shortname on tng_vendor (
	vendor_name)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (vendor_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index toc_x0 on toc (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index itree1 on tree (
	lev1,
	eid)
with structure = btree,
	nocompression,
	key = (lev1, eid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index itree2 on tree (
	lev2,
	eid)
with structure = btree,
	nocompression,
	key = (lev2, eid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index itree3 on tree (
	lev3,
	eid)
with structure = btree,
	nocompression,
	key = (lev3, eid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index itree4 on tree (
	lev4,
	eid)
with structure = btree,
	nocompression,
	key = (lev4, eid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tskstat_x0 on tskstat (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tskstat_x1 on tskstat (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tskty_x0 on tskty (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tskty_x1 on tskty (
	code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tspan_x0 on tspan (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index tz_x0 on tz (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index udoinstance_idx_01 on udoinstance (
	regionid)
with structure = btree,
	nocompression,
	key = (regionid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index udpselectionvalues_idx_01 on udpselectionvalues (
	udpid,
	valueid)
with structure = btree,
	nocompression,
	key = (udpid, valueid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdce1 on ueadminresourcebackbonedata (
	ueparentpath,
	ueresourcename)
with structure = isam,
	nocompression,
	key = (ueparentpath, ueresourcename),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdce2 on ueadminresourcebackbonedata (
	ueparentpath,
	ueresourcetitle)
with structure = isam,
	nocompression,
	key = (ueparentpath, ueresourcetitle),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdcd7 on ueapprovalchaindata (
	ueappchainname)
with structure = btree,
	nocompression,
	key = (ueappchainname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdcdb on uegroupdata (
	uegroupname)
with structure = btree,
	nocompression,
	key = (uegroupname),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdcd4 on uemdiddata (
	uename)
with structure = btree,
	nocompression,
	key = (uename),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdcd5 on uemdiddata (
	uetablename)
with structure = btree,
	nocompression,
	key = (uetablename),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdcde on uepersonalizationdata (
	ueattributename,
	ueuserdbid,
	ueintvalue)
with structure = btree,
	nocompression,
	key = (ueattributename, ueuserdbid, ueintvalue),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f64cdcd9 on ueuserdata (
	ueusername)
with structure = btree,
	nocompression,
	key = (ueusername),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index uef9f6a38e23 on uewebdavlockdata (
	uepath)
with structure = btree,
	nocompression,
	key = (uepath),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_active_session_i1 on urc_active_session (
	datesessionstarted,
	uid)
with structure = isam,
	nocompression,
	key = (datesessionstarted, uid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_active_session_i2 on urc_active_session (
	uidparent,
	iduration)
with structure = isam,
	nocompression,
	key = (uidparent, iduration),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_address_book_global_i1 on urc_address_book_global (
	uidparent,
	strname)
with structure = isam,
	nocompression,
	key = (uidparent, strname),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_address_book_global_i2 on urc_address_book_global (
	uidcomputer,
	uidparent)
with structure = isam,
	nocompression,
	key = (uidcomputer, uidparent),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_address_book_global_i3 on urc_address_book_global (
	domain_uuid)
with structure = isam,
	nocompression,
	key = (domain_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_address_book_group_global_i2 on urc_address_book_group_global (
	iisserver)
with structure = isam,
	nocompression,
	key = (iisserver),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_address_book_group_global_i3 on urc_address_book_group_global (
	domain_uuid)
with structure = isam,
	nocompression,
	key = (domain_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_permission_global_i1 on urc_permission_global (
	uidaddressbook)
with structure = isam,
	nocompression,
	key = (uidaddressbook),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index urc_permission_global_i2 on urc_permission_global (
	domain_uuid)
with structure = isam,
	nocompression,
	key = (domain_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index urgncy_x0 on urgncy (
	sym)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (sym),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xak1user on "user" (
	user_name)
with structure = isam,
	nocompression,
	key = (user_name),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif4user on "user" (
	person_id)
with structure = isam,
	nocompression,
	key = (person_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkuser on "user" (
	user_uuid)
with structure = isam,
	nocompression,
	key = (user_uuid),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index user_acct_asset_grp_mtx_idx_01 on user_acct_asset_group_matrix (
	user_account_id)
with structure = isam,
	nocompression,
	key = (user_account_id),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index user_group_idx_01 on user_group (
	usernode)
with structure = isam,
	nocompression,
	key = (usernode),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index user_group_idx_02 on user_group (
	usernode,
	id,
	gid,
	name,
	userid,
	type)
with structure = isam,
	nocompression,
	key = (usernode, id, gid, name, userid, type),
	persistence,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xif1user_group_identity_asc on user_group_identity_asc (
	security_group_id)
with structure = isam,
	nocompression,
	key = (security_group_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xpkuser_group_identity_asc on user_group_identity_asc (
	user_group_identity_asc_id)
with structure = isam,
	nocompression,
	key = (user_group_identity_asc_id),
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index get_user on user_head (
	collect_id,
	user#)
with structure = isam,
	nocompression,
	key = (collect_id, user#),
	fillfactor = 80,
	location = (ii_database)
\p\g
create index user_preferences_idx_01 on user_preferences (
	preference_userid,
	product_code)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (preference_userid, product_code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index usersec_profile_idx_01 on usersec_profile (
	node)
with structure = btree,
	nocompression,
	key = (node),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index usp_owned_resource_x0 on usp_owned_resource (
	nr_argis_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (nr_argis_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index usp_owned_resource_x1 on usp_owned_resource (
	nr_bms)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (nr_bms),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index usp_owned_resource_x2 on usp_owned_resource (
	nr_bmlabel)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (nr_bmlabel),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index usp_owned_resource_x3 on usp_owned_resource (
	nr_bm_rep)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (nr_bm_rep),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index usp_preferences_x0 on usp_preferences (
	analyst_id)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (analyst_id),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index usp_properties_x0 on usp_properties (
	property_name)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (property_name),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index usq_x0 on usq (
	analyst,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (analyst, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index usq_x1 on usq (
	query_type)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (query_type),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index wf_x0 on wf (
	object_id,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_id, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index wf_x1 on wf (
	assignee)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index wftpl_x0 on wftpl (
	object_attrname,
	object_attrval,
	sequence)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (object_attrname, object_attrval, sequence),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index wftpl_x1 on wftpl (
	assignee)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (assignee),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index workbench_provider_idx_01 on workbench_provider (
	provider_name,
	product_code)
with structure = btree,
	page_size = 4096,
	nocompression,
	key = (provider_name, product_code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x__3com_x on wt_3com (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x__3com_access_point_x on wt_3com_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_access_point_x on wtaccess_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_accesspointreferencename_x on wtaccesspointreference (
	name)
with structure = btree,
	nocompression,
	key = (name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_accesspointreferenceuuid_x on wtaccesspointreference (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_accessstax_x on wtaccessstax (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_adhoc_access_point_x on wtadhoc_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_agent_x on wtagent (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_apc_ups_x on wtapc_ups (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_as400_x on wtas400 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_asante_x on wtasante (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_avayaaccesspoint_x on wtavayaaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_battery_x on wtbattery (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_baybridge_x on wtbaybridge (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_bayhub_x on wtbayhub (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_belkinaccesspoint_x on wtbelkinaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_billboard_x on wtbillboard (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_breezecomaccesspoint_x on wtbreezecomaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_bridge_x on wtbridge (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_buffalo_access_point_x on wtbuffalo_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_bull_x on wtbull (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_cabletron_x on wtcabletron (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_camera_3dname_x on wtcamera_3d (
	name)
with structure = btree,
	nocompression,
	key = (name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_chargeback_x on wtchargeback (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_chipcom_x on wtchipcom (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ciprico_x on wtciprico (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_cisco_x on wtcisco (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_cisco_aironet1100_access__x on wtcisco_aironet1100_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_cisco_aironet1200_access__x on wtcisco_aironet1200_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_cisco_aironet340_access_p_x on wtcisco_aironet340_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_cisco_aironet350_access_p_x on wtcisco_aironet350_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_clariion_dae_x on wtclariion_dae (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_clariion_dpe_x on wtclariion_dpe (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_cmutek_x on wtcmutek (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_compaq_access_point_x on wtcompaq_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_contextmenuname_x on wtcontextmenu (
	name)
with structure = btree,
	nocompression,
	key = (name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_datacomagtinst_x on wtdatacomagtinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_dbpvqueryinfoquery_name_x on wtdbpvqueryinfo (
	query_name)
with structure = btree,
	nocompression,
	key = (query_name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_decbridge_x on wtdecbridge (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_dechub_x on wtdechub (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_decrouter_x on wtdecrouter (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_decsystem_x on wtdecsystem (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_device_disk_ide_x on wtdevice_disk_ide (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_device_disk_scsi_x on wtdevice_disk_scsi (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_device_tapelibrary_x on wtdevice_tapelibrary (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_dg_ux_x on wtdg_ux (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_dlink_access_point_x on wtdlink_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_eauditmessagegroupname_x on wteauditmessagegroup (
	name)
with structure = btree,
	nocompression,
	key = (name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_entrasys_access_point_x on wtentrasys_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epcomsmpnodegroup_x on wtepcomsmpnodegroup (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_ecs_c6_x on wtepworld_ecs_c6 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_ecs_pc_x on wtepworld_ecs_pc (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_ecs_s1_x on wtepworld_ecs_s1 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_ecs_s2_x on wtepworld_ecs_s2 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_ecs_s3_x on wtepworld_ecs_s3 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_ecs_s4_x on wtepworld_ecs_s4 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_ecs_s5_x on wtepworld_ecs_s5 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_c5_x on wtepworld_eportal_c5 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_c8_x on wtepworld_eportal_c8 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_pc_x on wtepworld_eportal_pc (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s10_x on wtepworld_eportal_s10 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s11_x on wtepworld_eportal_s11 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s12_x on wtepworld_eportal_s12 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s14_x on wtepworld_eportal_s14 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s15_x on wtepworld_eportal_s15 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s2_x on wtepworld_eportal_s2 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s3_x on wtepworld_eportal_s3 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s6_x on wtepworld_eportal_s6 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_eportal_s7_x on wtepworld_eportal_s7 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_itech_c3_x on wtepworld_itech_c3 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_itech_c4_x on wtepworld_itech_c4 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_itech_pc_x on wtepworld_itech_pc (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_itech_s5_x on wtepworld_itech_s5 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_itech_s7_x on wtepworld_itech_s7 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_mswin_c2_x on wtepworld_mswin_c2 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_mswin_c3_x on wtepworld_mswin_c3 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_mswin_pc_x on wtepworld_mswin_pc (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_mswin_s1_x on wtepworld_mswin_s1 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_tsenbl_pc_x on wtepworld_tsenbl_pc (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworld_tsenbl_s1_x on wtepworld_tsenbl_s1 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_epworldspace_x on wtepworldspace (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ericsson_access_point_x on wtericsson_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ethairnetaccesspoint_x on wtethairnetaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_etsmim_x on wtetsmim (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_foundry_x on wtfoundry (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_fujiuxp_x on wtfujiuxp (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_gatorstar_x on wtgatorstar (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_genericpc_x on wtgenericpc (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_hawking_access_point_x on wthawking_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_host_x on wthost (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_hp_printer_x on wthp_printer (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_hpbridge_x on wthpbridge (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_hphub_x on wthphub (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_hpserver_x on wthpserver (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_hpunix_x on wthpunix (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_hub_x on wthub (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ibm_x on wtibm (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ibm3090_x on wtibm3090 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ibm_access_point_x on wtibm_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_iclunix_x on wticlunix (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_icssnmp_x on wticssnmp (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_idmsinstance_x on wtidmsinstance (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_intel_access_point_x on wtintel_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_interactive_x on wtinteractive (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ipx_generic_interface_x on wtipx_generic_interface (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ipx_host_x on wtipx_host (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ipx_printserver_x on wtipx_printserver (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_irm2snmp_x on wtirm2snmp (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_karlnetaccesspoint_x on wtkarlnetaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_laserprinter_x on wtlaserprinter (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_light_3dname_x on wtlight_3d (
	name)
with structure = btree,
	nocompression,
	key = (name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_linksysaccesspoint_x on wtlinksysaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_linux_x on wtlinux (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_lun_x on wtlun (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_macintosh_x on wtmacintosh (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_managedpc_x on wtmanagedpc (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_micom_x on wtmicom (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mkagent_x on wtmkagent (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mobiledevice_x on wtmobiledevice (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqaliasq_x on wtmqaliasq (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqaliasqinst_x on wtmqaliasqinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqchaninit_x on wtmqchaninit (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqchaninitinst_x on wtmqchaninitinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqchannel_x on wtmqchannel (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqchannelinst_x on wtmqchannelinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqdlq_x on wtmqdlq (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqdlqinst_x on wtmqdlqinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqmgr_x on wtmqmgr (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqmgrinst_x on wtmqmgrinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqmodelq_x on wtmqmodelq (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqmodelqinst_x on wtmqmodelqinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqprocess_x on wtmqprocess (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqprocessinst_x on wtmqprocessinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqpsid_x on wtmqpsid (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqpsidinst_x on wtmqpsidinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqqueue_x on wtmqqueue (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqqueueinst_x on wtmqqueueinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqremoteq_x on wtmqremoteq (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqremoteqinst_x on wtmqremoteqinst (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_mqsinstance_x on wtmqsinstance (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_multi_port_x on wtmulti_port (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_multinet_x on wtmultinet (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ncrunix_x on wtncrunix (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_netgearaccesspoint_x on wtnetgearaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_netgeneral_x on wtnetgeneral (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_netjet_printerserver_x on wtnetjet_printerserver (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_netque_printerserver_x on wtnetque_printerserver (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_netsnmp_x on wtnetsnmp (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_networth_x on wtnetworth (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ngsniffer_x on wtngsniffer (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_nortel_access_point_x on wtnortel_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_novell_x on wtnovell (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_novellhub_x on wtnovellhub (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_openvms_x on wtopenvms (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_openvms_system_monitor_x on wtopenvms_system_monitor (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_orinocoaccesspoint_x on wtorinocoaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_os2_x on wtos2 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_otherdevices_x on wtotherdevices (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_pcniu_x on wtpcniu (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_performance_x on wtperformance (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_performancetrend_x on wtperformancetrend (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_printers_x on wtprinters (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_probe_x on wtprobe (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_profiledomainserver_x on wtprofiledomainserver (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_proxim_access_point_x on wtproxim_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_pv705n_x on wtpv705n (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_qlogic_switch_x on wtqlogic_switch (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_risc6000_x on wtrisc6000 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_roamaboutaccesspoint_x on wtroamaboutaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_rogue_access_point_x on wtrogue_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_router_x on wtrouter (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_samsung_x on wtsamsung (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_sapagent_x on wtsapagent (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_sapinstance_x on wtsapinstance (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_scounix_x on wtscounix (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_sequent_server_x on wtsequent_server (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_siemenux_x on wtsiemenux (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_silicon_x on wtsilicon (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_smcaccesspoint_x on wtsmcaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_solaris_x on wtsolaris (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_storagesubsystem_x on wtstoragesubsystem (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_sunos_x on wtsunos (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_suspectaccesspoint_x on wtsuspectaccesspoint (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_switch_x on wtswitch (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_symbol80211_11m_access_po_x on wtsymbol80211_11m_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_symbol80211_1_2m_access_p_x on wtsymbol80211_1_2m_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_symbol_1m_access_point_x on wtsymbol_1m_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_synoptics_x on wtsynoptics (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_synoptics_bridge_x on wtsynoptics_bridge (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tandem_x on wttandem (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tapesubsystem_x on wttapesubsystem (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_telebit_x on wttelebit (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tnd_iconname_x on wttnd_icon (
	name)
with structure = btree,
	nocompression,
	key = (name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_tooltipname_x on wttooltip (
	name)
with structure = btree,
	nocompression,
	key = (name),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ubempower_x on wtubempower (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ubniu_x on wtubniu (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_unicenter_openvms_x on wtunicenter_openvms (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_unicenter_openvmsmanagedo_x on wtunicenter_openvmsmanagedobject (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_unisys_x on wtunisys (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_unix_x on wtunix (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_unixware_x on wtunixware (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_ups_x on wtups (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_usr_access_point_x on wtusr_access_point (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_vcp_1000_x on wtvcp_1000 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_vitalink_x on wtvitalink (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_wbem_x on wtwbem (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_wellfleet_x on wtwellfleet (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windows_x on wtwindows (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windows2000_x on wtwindows2000 (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windows2000_server_x on wtwindows2000_server (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windows9x_x on wtwindows9x (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windows_netserver_x on wtwindows_netserver (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windowsnt_x on wtwindowsnt (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windowsnt_server_x on wtwindowsnt_server (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_windowsxp_x on wtwindowsxp (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_wireless_domain_x on wtwireless_domain (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_workstation_x on wtworkstation (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_xiotech_x on wtxiotech (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_xterm_x on wtxterm (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_zone_x on wtzone (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index x_zoneset_x on wtzoneset (
	uuid)
with structure = btree,
	nocompression,
	key = (uuid),
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create unique index xent_map_x0 on xent_map (
	xentity_id,
	xschema_code)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (xentity_id, xschema_code),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g
create index xent_map_x1 on xent_map (
	ob_persid)
with structure = btree,
	page_size = 8192,
	nocompression,
	key = (ob_persid),
	persistence,
	nonleaffill = 80,
	leaffill = 70,
	fillfactor = 80,
	location = (ii_database)
\p\g

	/* CONSTRAINTS */
alter table ca_asset add  PRIMARY KEY(asset_uuid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_asset_class_def add  PRIMARY KEY(class_id) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table ca_asset_source add  PRIMARY KEY(asset_source_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_asset_source_location add  PRIMARY 
KEY(source_location_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_asset_subschema add  PRIMARY KEY(subschema_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_asset_type add  PRIMARY KEY(asset_type_id) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table ca_capacity_unit add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_category_def add  PRIMARY KEY(category_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_category_member add  PRIMARY KEY(category_uuid, 
sw_def_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_company add  PRIMARY KEY(company_uuid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_company_type add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_config_item add  PRIMARY KEY(config_item_uuid, 
asset_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_contact add  PRIMARY KEY(contact_uuid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_contact_type add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_country_code add  PRIMARY KEY(country_code) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table ca_discovered_hardware add  PRIMARY KEY(dis_hw_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_discovered_hardware_ext_sys add  PRIMARY 
KEY(dis_hw_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_reconcile_item add  PRIMARY KEY(object_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_reconcile_tree add  PRIMARY KEY(object_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_discovered_software add  PRIMARY KEY(dis_sw_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_discovered_software_prop add  PRIMARY 
KEY(dis_sw_prop_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_discovered_user add  PRIMARY KEY(user_uuid) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table ca_document add  PRIMARY KEY(doc_uuid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_geo_coord_type add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_job_title add  PRIMARY KEY(id) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table ca_license_type add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_link_asset_class_def add  PRIMARY KEY(from_class_id, 
to_class_id, hierarchy_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_logical_asset_class_def add  PRIMARY KEY(class_id,
logical_asset_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_config_item_doc add  PRIMARY KEY(doc_uuid, 
config_item_uuid, asset_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_configured_service add  PRIMARY 
KEY(named_config_uuid, own_resource_uuid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_link_contact_user add  PRIMARY KEY(contact_uuid, 
user_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_config_item add  PRIMARY KEY(config_item_uuid_1, 
asset_uuid_1, config_item_uuid_2, asset_uuid_2) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_link_dis_hw add  PRIMARY KEY(link_dis_hw_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_dis_hw_user add  PRIMARY 
KEY(link_dis_hw_user_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_license_sw_def add  PRIMARY KEY(license_uuid, 
sw_def_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_named_config_doc add  PRIMARY KEY(doc_uuid, 
named_config_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_named_config_item add  PRIMARY 
KEY(named_config_uuid, config_item_uuid, asset_uuid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_link_own_dis_hw add  PRIMARY KEY(dis_hw_uuid, 
own_resource_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_sw_def add  PRIMARY KEY(primary_sw_def_uuid, 
seconday_sw_def_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_type add  PRIMARY KEY(link_type_id) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_location add  PRIMARY KEY(location_uuid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_location_type add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_logical_asset add  PRIMARY KEY(logical_asset_uuid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_logical_asset_property add  PRIMARY KEY(dns_name, 
mac_address, logical_asset_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_model_def add  PRIMARY KEY(id) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table ca_named_configuration add  PRIMARY KEY(named_config_uuid)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_organization add  PRIMARY KEY(organization_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_owned_resource add  PRIMARY KEY(own_resource_uuid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_resource_class add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_resource_family add  PRIMARY KEY(id) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ca_resource_status add  PRIMARY KEY(id) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ca_schema_info add  PRIMARY KEY(product_name) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table ca_site add  PRIMARY KEY(id) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_software_def add  PRIMARY KEY(sw_def_uuid) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table ca_software_license add  PRIMARY KEY(license_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_software_signature add  PRIMARY KEY(signature_uuid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_software_type add  PRIMARY KEY(software_type_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_source_type add  PRIMARY KEY(source_type_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_state_province add  PRIMARY KEY(id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_reg_control add  PRIMARY KEY(control_uuid, 
control_name) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_asset add  FOREIGN KEY (asset_type_id) REFERENCES 
"mdbadmin".ca_asset_type
\p\g
alter table ca_asset_source add  FOREIGN KEY (subschema_id) REFERENCES
"mdbadmin".ca_asset_subschema
\p\g
alter table ca_asset_source add  FOREIGN KEY (source_location_uuid) 
REFERENCES "mdbadmin".ca_asset_source_location
\p\g
alter table ca_asset_source add  FOREIGN KEY (logical_asset_uuid) 
REFERENCES "mdbadmin".ca_logical_asset
\p\g
alter table ca_category_member add  FOREIGN KEY (sw_def_uuid) 
REFERENCES "mdbadmin".ca_software_def
\p\g
alter table ca_category_member add  FOREIGN KEY (category_uuid) 
REFERENCES "mdbadmin".ca_category_def WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_company add  FOREIGN KEY (primary_contact_uuid) 
REFERENCES "mdbadmin".ca_contact
\p\g
alter table ca_company add  FOREIGN KEY (company_type) REFERENCES 
"mdbadmin".ca_company_type
\p\g
alter table ca_company add  FOREIGN KEY (parent_company_uuid) 
REFERENCES "mdbadmin".ca_company
\p\g
alter table ca_company add  FOREIGN KEY (location_uuid) REFERENCES 
"mdbadmin".ca_location
\p\g
alter table ca_config_item add  FOREIGN KEY (asset_uuid) REFERENCES 
"mdbadmin".ca_asset
\p\g
alter table ca_contact add  FOREIGN KEY (contact_uuid) REFERENCES 
"mdbadmin".ca_contact WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_contact add  FOREIGN KEY (location_uuid) REFERENCES 
"mdbadmin".ca_location
\p\g
alter table ca_contact add  FOREIGN KEY (admin_organization_uuid) 
REFERENCES "mdbadmin".ca_organization
\p\g
alter table ca_contact add  FOREIGN KEY (organization_uuid) REFERENCES
"mdbadmin".ca_organization
\p\g
alter table ca_contact add  FOREIGN KEY (company_uuid) REFERENCES 
"mdbadmin".ca_company
\p\g
alter table ca_contact add  FOREIGN KEY (job_title) REFERENCES 
"mdbadmin".ca_job_title
\p\g
alter table ca_contact add  FOREIGN KEY (pager_cc) REFERENCES 
"mdbadmin".ca_country_code
\p\g
alter table ca_contact add  FOREIGN KEY (mobile_phone_cc) REFERENCES 
"mdbadmin".ca_country_code
\p\g
alter table ca_contact add  FOREIGN KEY (fax_cc) REFERENCES "mdbadmin"
.ca_country_code
\p\g
alter table ca_contact add  FOREIGN KEY (alt_phone_cc) REFERENCES 
"mdbadmin".ca_country_code
\p\g
alter table ca_contact add  FOREIGN KEY (pri_phone_cc) REFERENCES 
"mdbadmin".ca_country_code
\p\g
alter table ca_contact add  FOREIGN KEY (contact_type) REFERENCES 
"mdbadmin".ca_contact_type
\p\g
alter table ca_contact_type add  FOREIGN KEY (user_uuid) REFERENCES 
"mdbadmin".ca_discovered_user
\p\g
alter table ca_discovered_hardware add  FOREIGN KEY 
(asset_source_uuid) REFERENCES "mdbadmin".ca_asset_source
\p\g
alter table ca_discovered_hardware_ext_sys add  FOREIGN KEY 
(dis_hw_uuid) REFERENCES "mdbadmin".ca_discovered_hardware
\p\g
alter table ca_discovered_software add  FOREIGN KEY (license_uuid) 
REFERENCES "mdbadmin".ca_software_license
\p\g
alter table ca_discovered_software add  FOREIGN KEY 
(asset_source_uuid) REFERENCES "mdbadmin".ca_asset_source
\p\g
alter table ca_discovered_software add  FOREIGN KEY (sw_def_uuid) 
REFERENCES "mdbadmin".ca_software_def
\p\g
alter table ca_discovered_software_prop add  FOREIGN KEY (dis_sw_uuid)
REFERENCES "mdbadmin".ca_discovered_software
\p\g
alter table ca_link_asset_class_def add  FOREIGN KEY (to_class_id) 
REFERENCES "mdbadmin".ca_asset_class_def
\p\g
alter table ca_link_asset_class_def add  FOREIGN KEY (from_class_id) 
REFERENCES "mdbadmin".ca_asset_class_def WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_link_logical_asset_class_def add  FOREIGN KEY 
(class_id) REFERENCES "mdbadmin".ca_asset_class_def
\p\g
alter table ca_link_logical_asset_class_def add  FOREIGN KEY 
(logical_asset_uuid) REFERENCES "mdbadmin".ca_logical_asset
\p\g
alter table ca_link_config_item add  FOREIGN KEY (link_type_id) 
REFERENCES "mdbadmin".ca_link_type
\p\g
alter table ca_link_config_item add  FOREIGN KEY (config_item_uuid_2, 
asset_uuid_2) REFERENCES "mdbadmin".ca_config_item
\p\g
alter table ca_link_config_item add  FOREIGN KEY (config_item_uuid_1, 
asset_uuid_1) REFERENCES "mdbadmin".ca_config_item WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_link_config_item_doc add  FOREIGN KEY (doc_uuid) 
REFERENCES "mdbadmin".ca_document WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_config_item_doc add  FOREIGN KEY 
(config_item_uuid, asset_uuid) REFERENCES "mdbadmin".ca_config_item
\p\g
alter table ca_link_configured_service add  FOREIGN KEY 
(named_config_uuid) REFERENCES "mdbadmin".ca_named_configuration WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_configured_service add  FOREIGN KEY 
(own_resource_uuid) REFERENCES "mdbadmin".ca_owned_resource
\p\g
alter table ca_link_contact_user add  FOREIGN KEY (contact_uuid) 
REFERENCES "mdbadmin".ca_contact WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_contact_user add  FOREIGN KEY (user_uuid) 
REFERENCES "mdbadmin".ca_discovered_user
\p\g
alter table ca_link_dis_hw add  FOREIGN KEY (secondary_dis_hw_uuid) 
REFERENCES "mdbadmin".ca_discovered_hardware
\p\g
alter table ca_link_dis_hw_user add  FOREIGN KEY (user_uuid) 
REFERENCES "mdbadmin".ca_discovered_user
\p\g
alter table ca_link_dis_hw_user add  FOREIGN KEY (dis_hw_uuid) 
REFERENCES "mdbadmin".ca_discovered_hardware
\p\g
alter table ca_link_license_sw_def add  FOREIGN KEY (sw_def_uuid) 
REFERENCES "mdbadmin".ca_software_def
\p\g
alter table ca_link_license_sw_def add  FOREIGN KEY (license_uuid) 
REFERENCES "mdbadmin".ca_software_license WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_link_named_config_doc add  FOREIGN KEY 
(named_config_uuid) REFERENCES "mdbadmin".ca_named_configuration
\p\g
alter table ca_link_named_config_doc add  FOREIGN KEY (doc_uuid) 
REFERENCES "mdbadmin".ca_document WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_named_config_item add  FOREIGN KEY 
(named_config_uuid) REFERENCES "mdbadmin".ca_named_configuration WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_named_config_item add  FOREIGN KEY 
(config_item_uuid, asset_uuid) REFERENCES "mdbadmin".ca_config_item
\p\g
alter table ca_link_own_dis_hw add  FOREIGN KEY (own_resource_uuid) 
REFERENCES "mdbadmin".ca_owned_resource
\p\g
alter table ca_link_own_dis_hw add  FOREIGN KEY (dis_hw_uuid) 
REFERENCES "mdbadmin".ca_discovered_hardware WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_link_sw_def add  FOREIGN KEY (source_type_id) 
REFERENCES "mdbadmin".ca_source_type
\p\g
alter table ca_link_sw_def add  FOREIGN KEY (link_type_id) REFERENCES 
"mdbadmin".ca_link_type
\p\g
alter table ca_link_sw_def add  FOREIGN KEY (primary_sw_def_uuid) 
REFERENCES "mdbadmin".ca_software_def WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_link_sw_def add  FOREIGN KEY (seconday_sw_def_uuid) 
REFERENCES "mdbadmin".ca_software_def
\p\g
alter table ca_location add  FOREIGN KEY (primary_contact_uuid) 
REFERENCES "mdbadmin".ca_contact
\p\g
alter table ca_location add  FOREIGN KEY (company_uuid) REFERENCES 
"mdbadmin".ca_company
\p\g
alter table ca_location add  FOREIGN KEY (site_id) REFERENCES 
"mdbadmin".ca_site
\p\g
alter table ca_location add  FOREIGN KEY (geo_coord_type) REFERENCES 
"mdbadmin".ca_geo_coord_type
\p\g
alter table ca_location add  FOREIGN KEY (state) REFERENCES "mdbadmin"
.ca_state_province
\p\g
alter table ca_location add  FOREIGN KEY (fax_cc) REFERENCES 
"mdbadmin".ca_country_code
\p\g
alter table ca_location add  FOREIGN KEY (pri_phone_cc) REFERENCES 
"mdbadmin".ca_country_code
\p\g
alter table ca_location add  FOREIGN KEY (location_type) REFERENCES 
"mdbadmin".ca_location_type
\p\g
alter table ca_logical_asset add  FOREIGN KEY (asset_uuid) REFERENCES 
"mdbadmin".ca_asset
\p\g
alter table ca_logical_asset_property add  FOREIGN KEY 
(logical_asset_uuid) REFERENCES "mdbadmin".ca_logical_asset
\p\g
alter table ca_organization add  FOREIGN KEY (contact_uuid) REFERENCES
"mdbadmin".ca_contact
\p\g
alter table ca_organization add  FOREIGN KEY (alt_phone_cc) REFERENCES
"mdbadmin".ca_country_code
\p\g
alter table ca_organization add  FOREIGN KEY (pri_phone_cc) REFERENCES
"mdbadmin".ca_country_code
\p\g
alter table ca_organization add  FOREIGN KEY (parent_org_uuid) 
REFERENCES "mdbadmin".ca_organization
\p\g
alter table ca_organization add  FOREIGN KEY (location_uuid) 
REFERENCES "mdbadmin".ca_location
\p\g
alter table ca_organization add  FOREIGN KEY (company_uuid) REFERENCES
"mdbadmin".ca_company
\p\g
alter table ca_owned_resource add  FOREIGN KEY (license_uuid) 
REFERENCES "mdbadmin".ca_software_license
\p\g
alter table ca_owned_resource add  FOREIGN KEY (asset_source_uuid) 
REFERENCES "mdbadmin".ca_asset_source
\p\g
alter table ca_owned_resource add  FOREIGN KEY (asset_type_id) 
REFERENCES "mdbadmin".ca_asset_type
\p\g
alter table ca_owned_resource add  FOREIGN KEY (location_uuid) 
REFERENCES "mdbadmin".ca_location
\p\g
alter table ca_owned_resource add  FOREIGN KEY (resource_owner_uuid) 
REFERENCES "mdbadmin".ca_contact
\p\g
alter table ca_owned_resource add  FOREIGN KEY (resource_contact_uuid)
REFERENCES "mdbadmin".ca_contact
\p\g
alter table ca_owned_resource add  FOREIGN KEY (org_bought_for_uuid) 
REFERENCES "mdbadmin".ca_organization
\p\g
alter table ca_owned_resource add  FOREIGN KEY (responsible_org_uuid) 
REFERENCES "mdbadmin".ca_organization
\p\g
alter table ca_owned_resource add  FOREIGN KEY (maintenance_org_uuid) 
REFERENCES "mdbadmin".ca_organization
\p\g
alter table ca_owned_resource add  FOREIGN KEY 
(responsible_vendor_uuid) REFERENCES "mdbadmin".ca_company
\p\g
alter table ca_owned_resource add  FOREIGN KEY (manufacturer_uuid) 
REFERENCES "mdbadmin".ca_company
\p\g
alter table ca_owned_resource add  FOREIGN KEY 
(resource_capacity_units) REFERENCES "mdbadmin".ca_capacity_unit
\p\g
alter table ca_owned_resource add  FOREIGN KEY (model_id) REFERENCES 
"mdbadmin".ca_model_def
\p\g
alter table ca_owned_resource add  FOREIGN KEY (resource_status) 
REFERENCES "mdbadmin".ca_resource_status
\p\g
alter table ca_owned_resource add  FOREIGN KEY (resource_class) 
REFERENCES "mdbadmin".ca_resource_class
\p\g
alter table ca_owned_resource add  FOREIGN KEY (resource_family) 
REFERENCES "mdbadmin".ca_resource_family
\p\g
alter table ca_owned_resource add  FOREIGN KEY (supply_vendor_uuid) 
REFERENCES "mdbadmin".ca_company
\p\g
alter table ca_owned_resource add  FOREIGN KEY 
(maintenance_vendor_uuid) REFERENCES "mdbadmin".ca_company
\p\g
alter table ca_owned_resource add  FOREIGN KEY 
(company_bought_for_uuid) REFERENCES "mdbadmin".ca_location
\p\g
alter table ca_software_def add  FOREIGN KEY (manufacturer_uuid) 
REFERENCES "mdbadmin".ca_company
\p\g
alter table ca_software_def add  FOREIGN KEY (source_type_id) 
REFERENCES "mdbadmin".ca_source_type
\p\g
alter table ca_software_def add  FOREIGN KEY (software_type_id) 
REFERENCES "mdbadmin".ca_software_type
\p\g
alter table ca_software_license add  FOREIGN KEY (license_type_id) 
REFERENCES "mdbadmin".ca_license_type
\p\g
alter table ca_software_license add  FOREIGN KEY (asset_uuid) 
REFERENCES "mdbadmin".ca_asset
\p\g
alter table ca_software_signature add  FOREIGN KEY (source_type_id) 
REFERENCES "mdbadmin".ca_source_type
\p\g
alter table ca_software_signature add  FOREIGN KEY (sw_def_uuid) 
REFERENCES "mdbadmin".ca_software_def
\p\g
alter table ca_agent_component add  PRIMARY KEY(agent_comp_id, 
object_uuid)
\p\g
alter table ca_discovered_hardware_network add  PRIMARY 
KEY(dis_hw_uuid, mac_address)
\p\g
alter table ca_group_ace add  PRIMARY KEY(group_def_uuid, 
security_profile_uuid)
\p\g
alter table ca_link_object_owner add  PRIMARY KEY(object_uuid)
\p\g
alter table ca_object_ace add  PRIMARY KEY(object_def_uuid, 
security_profile_uuid)
\p\g
alter table ca_proc_os add  PRIMARY KEY(proc_os_uuid)
\p\g
alter table addmemo add  PRIMARY KEY(adid, adtype, part, domainid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table addtext add  PRIMARY KEY(adid, adtype, part, domainid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table amaccmap add  PRIMARY KEY(acid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table amepdef add  PRIMARY KEY(epid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table amepjobs add  PRIMARY KEY(epid, epdomid, epjtype, 
epjorder) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table appappr add  PRIMARY KEY(mdomid, adomid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table appuknow add  PRIMARY KEY(unitid, domainid, filepart) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table arg_action add  PRIMARY KEY(ac1ivid, acadid, acdatedt, 
actimetm, object_uuid)
\p\g
alter table arg_actiondf add  PRIMARY KEY(adid)
\p\g
alter table arg_actionlk add  PRIMARY KEY(lk2ivid, lkac1ivi, lkacadid,
lkacdadt, lkactitm, lkinstnc, lkndid, primary_object_uuid, 
secondary_object_uuid)
\p\g
alter table arg_argdeflt add  PRIMARY KEY(dfid, dfkey, dfsubkey)
\p\g
alter table arg_assetver add  PRIMARY KEY(avivid, own_resource_uuid)
\p\g
alter table arg_attachmt add  PRIMARY KEY(amid, object_uuid)
\p\g
alter table arg_attribute_def add  PRIMARY KEY(attribute_name, 
class_name)
\p\g
alter table arg_class_def add  PRIMARY KEY(class_name)
\p\g
alter table arg_controls add  PRIMARY KEY(cnid)
\p\g
alter table arg_costdet add  PRIMARY KEY(cdid, object_uuid)
\p\g
alter table arg_drpdnlst add  PRIMARY KEY(dlkey, dlldid)
\p\g
alter table arg_evdefhdr add  PRIMARY KEY(evid)
\p\g
alter table arg_evdefny add  PRIMARY KEY(enevid, enid)
\p\g
alter table arg_evnotify add  PRIMARY KEY(nyerid, nyid)
\p\g
alter table arg_evrem add  PRIMARY KEY(erid)
\p\g
alter table arg_extsys add  PRIMARY KEY(esid, esivid, object_uuid)
\p\g
alter table arg_filtcrit add  PRIMARY KEY(fcfeid, fcid)
\p\g
alter table arg_filtdata add  PRIMARY KEY(ftfcid, ftfeid, ftid)
\p\g
alter table arg_filtdef add  PRIMARY KEY(feid)
\p\g
alter table arg_filtind add  PRIMARY KEY(fnfcid, fnfeid, object_uuid)
\p\g
alter table arg_flagsobj add  PRIMARY KEY(object_uuid)
\p\g
alter table arg_history add  PRIMARY KEY(field_name, hsinstnc, 
last_update_date, object_uuid)
\p\g
alter table arg_hsnotify add  PRIMARY KEY(hnhrid, hnid)
\p\g
alter table arg_hsrem add  PRIMARY KEY(hrid)
\p\g
alter table arg_index_def add  PRIMARY KEY(index_name)
\p\g
alter table arg_index_member add  PRIMARY KEY(index_name, 
member_instance)
\p\g
alter table arg_intxref add  PRIMARY KEY(ixatfrid)
\p\g
alter table arg_itemver add  PRIMARY KEY(ivid, model_uuid)
\p\g
alter table arg_join_def add  PRIMARY KEY(join_name)
\p\g
alter table arg_join_member add  PRIMARY KEY(join_name, 
member_instance)
\p\g
alter table arg_keydef add  PRIMARY KEY(kdid)
\p\g
alter table arg_keyword add  PRIMARY KEY(kwkdid, object_uuid)
\p\g
alter table arg_legaldef add  PRIMARY KEY(lgid)
\p\g
alter table arg_legaldet add  PRIMARY KEY(legaldoc_uuid, lttdid)
\p\g
alter table arg_legaldoc add  PRIMARY KEY(legaldoc_uuid)
\p\g
alter table arg_legalpar add  PRIMARY KEY(company_uuid, legaldoc_uuid)
\p\g
alter table arg_legasset add  PRIMARY KEY(legaldoc_uuid, 
own_resource_uuid)
\p\g
alter table arg_legasstc add  PRIMARY KEY(lctdid, legaldoc_uuid, 
own_resource_uuid)
\p\g
alter table arg_linkdef add  PRIMARY KEY(ndadid, ndid)
\p\g
alter table arg_listdef add  PRIMARY KEY(ldid)
\p\g
alter table arg_ltcdef add  PRIMARY KEY(tdid)
\p\g
alter table arg_map add  PRIMARY KEY(old_object_id_1, old_object_id_2)
\p\g
alter table arg_note_text add  PRIMARY KEY(instance, object_uuid)
\p\g
alter table arg_notes add  PRIMARY KEY(noinstnc, object_uuid)
\p\g
alter table arg_paydet add  PRIMARY KEY(object_uuid, pdcdid, pdid)
\p\g
alter table arg_popuplst add  PRIMARY KEY(pldesc, plldid, plvalue)
\p\g
alter table arg_query_assignment add  PRIMARY KEY(query_id, 
assignment_uuid)
\p\g
alter table arg_query_def add  PRIMARY KEY(instance, query_id)
\p\g
alter table arg_reconcile_data add  PRIMARY KEY(reconcile_data_id, 
task_uuid)
\p\g
alter table arg_reconcile_modification add  PRIMARY 
KEY(reconcile_modification_id, sys_name)
\p\g
alter table arg_reconcile_msg_queue add  PRIMARY KEY(reconcile_msg_id,
task_uuid)
\p\g
alter table arg_reconcile_msg_text add  PRIMARY KEY(reconcile_msg_id, 
task_uuid)
\p\g
alter table arg_reconcile_rule add  PRIMARY KEY(rule_id, task_uuid)
\p\g
alter table arg_reconcile_task add  PRIMARY KEY(task_uuid)
\p\g
alter table arg_roledef add  PRIMARY KEY(rdid)
\p\g
alter table arg_script add  PRIMARY KEY(scobtype, sctype)
\p\g
alter table arg_security add  PRIMARY KEY(secnid, serdid)
\p\g
alter table arg_stathist add  PRIMARY KEY(object_uuid, shivid, 
shstatdt, shstatus)
\p\g
alter table arg_strlst add  PRIMARY KEY(slentry, slid)
\p\g
alter table arg_table_def add  PRIMARY KEY(table_name)
\p\g
alter table arg_tclgdef add  PRIMARY KEY(tllgid, tltdid)
\p\g
alter table arg_translation_list add  PRIMARY 
KEY(translation_list_entry, translation_list_id)
\p\g
alter table audithis add  PRIMARY KEY(unitid, exename, sttotal, 
domainid, vernr) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table bckbin add  PRIMARY KEY(udomid, unitid, bdomid, bckid, 
bknr, bkver) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table bckdef add  PRIMARY KEY(bckid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table bckfile add  PRIMARY KEY(udomid, unitid, bdomid, bckid, 
bknr, bkver) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_agent add  PRIMARY KEY(object_uuid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ca_class_ace add  PRIMARY KEY(security_profile_uuid, 
class_def_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_class_def add  PRIMARY KEY(class_def_uuid) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table ca_configuration_policy add  PRIMARY KEY(uid) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table ca_directory_details add  PRIMARY KEY(directory_uuid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_directory_schema_map add  PRIMARY KEY(dir_schema_uuid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_engine add  PRIMARY KEY(engine_uuid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ca_group_def add  PRIMARY KEY(group_uuid, 
group_domain_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_group_def_ace add  PRIMARY KEY(group_def_ace_uuid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_group_member add  PRIMARY KEY(member_uuid, group_uuid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_dir_details_map add  PRIMARY 
KEY(dir_details_map_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_link_dis_user_sec_profile add  PRIMARY KEY(user_uuid, 
security_profile_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_manager add  PRIMARY KEY(manager_uuid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_manager_component add  PRIMARY KEY(manager_comp_uuid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_n_tier add  PRIMARY KEY(domain_uuid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ca_query_def add  PRIMARY KEY(query_uuid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_query_result add  PRIMARY KEY(query_uuid, 
query_domain_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_query_version add  PRIMARY KEY(query_uuid, 
query_domain_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_replication_conf add  PRIMARY 
KEY(replication_conf_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_replication_history add  PRIMARY KEY(primary_uuid, 
secondary_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_replication_status add  PRIMARY 
KEY(replication_conf_uuid, domain_uuid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ca_security_profile add  PRIMARY 
KEY(security_profile_uuid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_server add  PRIMARY KEY(server_uuid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ca_server_component add  PRIMARY KEY(server_comp_uuid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_server_push_status add  PRIMARY KEY(server_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_server_queue add  PRIMARY KEY(queue_id) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ca_settings add  PRIMARY KEY(set_id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table computer add  PRIMARY KEY(uid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table computergroup add  PRIMARY KEY(uid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table confmemo add  PRIMARY KEY(unitid, conftype, domainid, 
confver) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table csm_class add  PRIMARY KEY(id) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table csm_object add  PRIMARY KEY(id) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table csm_property add  PRIMARY KEY(id) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table eventlog add  PRIMARY KEY(uid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table filemgr add  PRIMARY KEY(unitid, domainid, filepart) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table infohis add  PRIMARY KEY(apid, sttotal, adomid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table infolng add  PRIMARY KEY(unitid, domainid, itprid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table infotrid add  PRIMARY KEY(unitid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table inv_default_item add  PRIMARY KEY(object_uuid, 
item_name_id, item_parent_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_default_tree add  PRIMARY KEY(object_uuid, item_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_generalinventory_item add  PRIMARY KEY(object_uuid, 
item_name_id, item_parent_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_generalinventory_tree add  PRIMARY KEY(object_uuid, 
item_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_item_name_id add  PRIMARY KEY(domain_uuid, 
item_name_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_object_tree_id add  PRIMARY KEY(object_uuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_root_map add  PRIMARY KEY(object_uuid, 
item_root_name_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_table_map add  PRIMARY KEY(domain_uuid, 
component_name) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inv_tree_name_id add  PRIMARY KEY(domain_uuid, 
tree_name_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table invgene add  PRIMARY KEY(gindex, unittype, domainid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table invsetup add  PRIMARY KEY(invid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table joborder add  PRIMARY KEY(unitid, jobid, udomid, jdomid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table linkbck add  PRIMARY KEY(udomid, unitid, bckid, bdomid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table linkjob add  PRIMARY KEY(unitid, jobid, udomid, jdomid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table linkmod add  PRIMARY KEY(unitid, moid, modtype, udomid, 
mdomid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table linkunit add  PRIMARY KEY(type, ver, domainid) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table lnkitrmwv add  PRIMARY KEY(domainid, wvuuid, unitid, 
wvclass) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table localserver add  PRIMARY KEY(uid) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table lockunit add  PRIMARY KEY(unitid, domainid, sectorid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table logicalrelations add  PRIMARY KEY(primluuid) WITH (INDEX =
BASE TABLE STRUCTURE)
\p\g
alter table miftypes add  PRIMARY KEY(typeid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ncipc add  PRIMARY KEY(ipcid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ncjobbin add  PRIMARY KEY(jobid, jobpart, domainid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ncjobcfg add  PRIMARY KEY(jobid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table nclog add  PRIMARY KEY(logid, domainid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ncmodbin add  PRIMARY KEY(mopart, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ncmodcfg add  PRIMARY KEY(domainid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ncovervw add  PRIMARY KEY(nameid, prnmid, unittype, type, 
domainid, idomid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ncprofil add  PRIMARY KEY(profilid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ncqryres add  PRIMARY KEY(qryid, qryver, unitid, qdomid, 
udomid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ncqryver add  PRIMARY KEY(qryid, qryver, domainid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ncrc add  PRIMARY KEY(rid, typeid, itemid, domainid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table nctngref add  PRIMARY KEY(unitid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table nctpldef add  PRIMARY KEY(tpid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table openunit add  PRIMARY KEY(unitid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table permission add  PRIMARY KEY(uid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table permissionglobal add  PRIMARY KEY(uid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table permissionserver add  PRIMARY KEY(uid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table platform add  PRIMARY KEY(pltid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table policonf add  PRIMARY KEY(polid, poltype, pdomid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table policygroup add  PRIMARY KEY(uid) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table policyproperty add  PRIMARY KEY(uid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table policyvalue add  PRIMARY KEY(uid) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table polidef add  PRIMARY KEY(polid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table polijob add  PRIMARY KEY(polid, polorder, polact, 
domainid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table polilog add  PRIMARY KEY(polid, unitid, udomid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table propertyvalue add  PRIMARY KEY(uid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table repositorycredentials add  PRIMARY KEY(uid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table rpauto add  PRIMARY KEY(objid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rpceng add  PRIMARY KEY(rpcengid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table rpfield add  PRIMARY KEY(objid, fldindex) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table rpfilter add  PRIMARY KEY(tplid, resid, argid) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table rpglobal add  PRIMARY KEY(keyname, subname) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table rpipc add  PRIMARY KEY(ipcid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rppub add  PRIMARY KEY(objid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rpqq add  PRIMARY KEY(qqid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rpresult add  PRIMARY KEY(tplid, tplsubid, resid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table rpstats add  PRIMARY KEY(tplid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rptables add  PRIMARY KEY(tblname) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table rptpl add  PRIMARY KEY(objid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rptree add  PRIMARY KEY(root, ownerid, objid) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table rpview add  PRIMARY KEY(tplid, viewid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table snapmain add  PRIMARY KEY(unitid, snapmain, domainid, 
snappart) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table snapmemo add  PRIMARY KEY(unitid, domainid, snappart) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table statjob add  PRIMARY KEY(unitid, jobid, udomid, jdomid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table statjobm add  PRIMARY KEY(unitid, jobid, statpart, udomid,
jdomid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table statmod add  PRIMARY KEY(unitid, moid, udomid, mdomid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table statmodm add  PRIMARY KEY(unitid, moid, statpart, udomid, 
mdomid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table t_accounts add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table t_acctempl add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table t_activity add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table t_actproc add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_apdep add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_applic add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_carrier add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_cc add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table t_cmp_attr add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table t_cmp_grp add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_compos add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_computer add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table t_cont add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_contfold add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table t_csite add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_distap add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_distsw add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_fio add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_fitem add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_iprocos add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_jcappgr add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_jcview add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_job_cont add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table t_ls add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table t_lsg add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_objdict add  PRIMARY KEY(c_table, c_name) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table t_order add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_ownsite add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_rsw add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_sdusers add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_swfold add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_task add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table t_volume add  PRIMARY KEY(c_objectid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table tl_act_inst add  PRIMARY KEY(c_activity, c_installation) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_cmpgrp add  PRIMARY KEY(c_grpparent, c_grpchild) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_grp_cmp add  PRIMARY KEY(c_comp, c_grp) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table tl_grp_proc add  PRIMARY KEY(c_procgrp, c_proc) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_jc add  PRIMARY KEY(c_jcparent, c_jcchild) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table tl_lsg add  PRIMARY KEY(c_lsgchild, c_lsgparent) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_lsg_ls add  PRIMARY KEY(c_lsg, c_ls) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table tl_swg_sw add  PRIMARY KEY(c_swg, c_sw) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table tl_swgrp add  PRIMARY KEY(c_grpparent, c_grpchild) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tplmemo add  PRIMARY KEY(tpid, tpver, domainid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table unitrel add  PRIMARY KEY(unitid, domainid, rid, rdomid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table unitsec add  PRIMARY KEY(unitid, type, typex, linkid, 
udomid, ldomid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table unittype add  PRIMARY KEY(unittype, domainid) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table usersec add  PRIMARY KEY(userid, domainid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table amephis add  FOREIGN KEY (epid, domainid) REFERENCES 
"mdbadmin".amepdef
\p\g
alter table appappr add  FOREIGN KEY (domainid) REFERENCES "mdbadmin"
.ncmodcfg
\p\g
alter table appuknow add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".infotrid WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table appuknow add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".nctngref WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table appuknow add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".openunit WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table audithis add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".infotrid WITH (INDEX = "audithis_sk2")
\p\g
alter table audithis add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".nctngref WITH (INDEX = "audithis_sk2")
\p\g
alter table audithis add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".openunit WITH (INDEX = "audithis_sk2")
\p\g
alter table ca_agent add  FOREIGN KEY (server_uuid) REFERENCES 
"mdbadmin".ca_server
\p\g
alter table ca_class_ace add  FOREIGN KEY (class_def_uuid) REFERENCES 
"mdbadmin".ca_class_def
\p\g
alter table ca_class_ace add  FOREIGN KEY (security_profile_uuid) 
REFERENCES "mdbadmin".ca_security_profile
\p\g
alter table ca_class_def add  FOREIGN KEY (owner_uuid) REFERENCES 
"mdbadmin".ca_discovered_user ON DELETE SET NULL
\p\g
alter table ca_configuration_policy add  FOREIGN KEY (uid) REFERENCES 
"mdbadmin".localserver WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_engine add  FOREIGN KEY (dis_hw_uuid) REFERENCES 
"mdbadmin".ca_discovered_hardware
\p\g
alter table ca_group_def add  FOREIGN KEY (owner_uuid) REFERENCES 
"mdbadmin".ca_discovered_user
\p\g
alter table ca_group_def add  FOREIGN KEY (directory_uuid) REFERENCES 
"mdbadmin".ca_directory_details
\p\g
alter table ca_group_def add  FOREIGN KEY (evaluation_uuid) REFERENCES
"mdbadmin".ca_engine
\p\g
alter table ca_group_def add  FOREIGN KEY (query_uuid) REFERENCES 
"mdbadmin".ca_query_def
\p\g
alter table ca_group_def_ace add  FOREIGN KEY (security_profile_uuid) 
REFERENCES "mdbadmin".ca_security_profile
\p\g
alter table ca_group_member add  FOREIGN KEY (group_uuid, 
group_domain_uuid) REFERENCES "mdbadmin".ca_group_def
\p\g
alter table ca_link_dir_details_map add  FOREIGN KEY (dir_schema_uuid)
REFERENCES "mdbadmin".ca_directory_schema_map
\p\g
alter table ca_link_dir_details_map add  FOREIGN KEY (directory_uuid) 
REFERENCES "mdbadmin".ca_directory_details
\p\g
alter table ca_link_dis_user_sec_profile add  FOREIGN KEY (user_uuid) 
REFERENCES "mdbadmin".ca_discovered_user
\p\g
alter table ca_link_dis_user_sec_profile add  FOREIGN KEY 
(security_profile_uuid) REFERENCES "mdbadmin".ca_security_profile WITH
(INDEX = "lnkdisusrsefcproidx01")
\p\g
alter table ca_manager add  FOREIGN KEY (dis_hw_uuid) REFERENCES 
"mdbadmin".ca_discovered_hardware
\p\g
alter table ca_manager_component add  FOREIGN KEY (manager_uuid) 
REFERENCES "mdbadmin".ca_manager
\p\g
alter table ca_n_tier add  FOREIGN KEY (dis_hw_uuid) REFERENCES 
"mdbadmin".ca_discovered_hardware
\p\g
alter table ca_n_tier add  FOREIGN KEY (dis_hw_uuid) REFERENCES 
"mdbadmin".ca_asset
\p\g
alter table ca_n_tier add  FOREIGN KEY (parent_domain_uuid) REFERENCES
"mdbadmin".ca_n_tier
\p\g
alter table ca_query_result add  FOREIGN KEY (query_uuid) REFERENCES 
"mdbadmin".ca_query_def WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_query_version add  FOREIGN KEY (query_uuid) REFERENCES 
"mdbadmin".ca_query_def WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_replication_status add  FOREIGN KEY 
(replication_conf_uuid) REFERENCES "mdbadmin".ca_replication_conf WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_server add  FOREIGN KEY (dis_hw_uuid) REFERENCES 
"mdbadmin".ca_discovered_hardware
\p\g
alter table ca_server_component add  FOREIGN KEY (server_uuid) 
REFERENCES "mdbadmin".ca_server
\p\g
alter table ca_server_push_status add  FOREIGN KEY (server_uuid) 
REFERENCES "mdbadmin".ca_server WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_server_queue add  FOREIGN KEY (server_uuid) REFERENCES 
"mdbadmin".ca_server
\p\g
alter table computer add  FOREIGN KEY (uid) REFERENCES "mdbadmin"
.computergroup WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table computergroup add  FOREIGN KEY (uid) REFERENCES "mdbadmin"
.computergroup WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table confmemo add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".infotrid WITH (INDEX = "confmeno_idx_01")
\p\g
alter table confmemo add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".openunit WITH (INDEX = "confmeno_idx_01")
\p\g
alter table csm_link add  FOREIGN KEY (child) REFERENCES "mdbadmin"
.csm_object WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table csm_link add  FOREIGN KEY (parent) REFERENCES "mdbadmin"
.csm_object
\p\g
alter table csm_object add  FOREIGN KEY (class) REFERENCES "mdbadmin"
.csm_class
\p\g
alter table csm_property add  FOREIGN KEY (object) REFERENCES 
"mdbadmin".csm_object
\p\g
alter table t_cmp_attr add  FOREIGN KEY (c_computer) REFERENCES 
"mdbadmin".t_computer
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_ownerid) REFERENCES 
"mdbadmin".t_sdusers
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_schedevaltask) REFERENCES 
"mdbadmin".t_task
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_cataloggrp) REFERENCES 
"mdbadmin".t_swfold
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_mylocalsite) REFERENCES 
"mdbadmin".t_ls
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_unschedevaltask) REFERENCES 
"mdbadmin".t_task
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_qtemplfold) REFERENCES 
"mdbadmin".t_job_cont
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_theactivity) REFERENCES 
"mdbadmin".t_activity
\p\g
alter table t_cmp_grp add  FOREIGN KEY (c_mycmpgrp) REFERENCES 
"mdbadmin".t_cmp_grp
\p\g
alter table t_computer add  FOREIGN KEY (c_ownerid) REFERENCES 
"mdbadmin".t_sdusers ON DELETE SET NULL
\p\g
alter table t_computer add  FOREIGN KEY (c_ssid) REFERENCES "mdbadmin"
.t_computer
\p\g
alter table t_cont add  FOREIGN KEY (c_ownerid) REFERENCES "mdbadmin"
.t_sdusers
\p\g
alter table t_cont add  FOREIGN KEY (c_contfold) REFERENCES "mdbadmin"
.t_contfold
\p\g
alter table t_contfold add  FOREIGN KEY (c_ownerid) REFERENCES 
"mdbadmin".t_sdusers
\p\g
alter table t_csite add  FOREIGN KEY (c_ownerid) REFERENCES "mdbadmin"
.t_sdusers ON DELETE SET NULL
\p\g
alter table t_distap add  FOREIGN KEY (c_distsw) REFERENCES "mdbadmin"
.t_distsw
\p\g
alter table t_distap add  FOREIGN KEY (c_ape) REFERENCES "mdbadmin"
.t_activity
\p\g
alter table t_distsw add  FOREIGN KEY (c_localsite) REFERENCES 
"mdbadmin".t_ls
\p\g
alter table t_distsw add  FOREIGN KEY (c_rsw) REFERENCES "mdbadmin"
.t_rsw
\p\g
alter table t_fitem add  FOREIGN KEY (c_localsite) REFERENCES 
"mdbadmin".t_ls
\p\g
alter table t_fitem add  FOREIGN KEY (c_fio) REFERENCES "mdbadmin"
.t_fio
\p\g
alter table t_jcappgr add  FOREIGN KEY (c_jobcontview) REFERENCES 
"mdbadmin".t_jcview
\p\g
alter table t_jcappgr add  FOREIGN KEY (c_jobtarget) REFERENCES 
"mdbadmin".t_computer ON DELETE CASCADE
\p\g
alter table t_jcview add  FOREIGN KEY (c_jobcont) REFERENCES 
"mdbadmin".t_job_cont
\p\g
alter table t_job_cont add  FOREIGN KEY (c_ownerid) REFERENCES 
"mdbadmin".t_sdusers
\p\g
alter table t_job_cont add  FOREIGN KEY (c_qtask) REFERENCES 
"mdbadmin".t_task
\p\g
alter table t_job_cont add  FOREIGN KEY (c_qtemplfold) REFERENCES 
"mdbadmin".t_cmp_grp
\p\g
alter table t_job_cont add  FOREIGN KEY (c_exceptiongrp) REFERENCES 
"mdbadmin".t_cmp_grp
\p\g
alter table t_ls add  FOREIGN KEY (c_compgrp) REFERENCES "mdbadmin"
.t_cmp_grp
\p\g
alter table t_lsg add  FOREIGN KEY (c_ownerid) REFERENCES "mdbadmin"
.t_sdusers
\p\g
alter table t_order add  FOREIGN KEY (c_software) REFERENCES 
"mdbadmin".t_rsw
\p\g
alter table t_order add  FOREIGN KEY (c_softwarebase) REFERENCES 
"mdbadmin".t_rsw
\p\g
alter table t_order add  FOREIGN KEY (c_actproc) REFERENCES "mdbadmin"
.t_actproc
\p\g
alter table t_order add  FOREIGN KEY (c_fitemorder) REFERENCES 
"mdbadmin".t_fio
\p\g
alter table t_order add  FOREIGN KEY (c_cmpgrp) REFERENCES "mdbadmin"
.t_cmp_grp
\p\g
alter table t_order add  FOREIGN KEY (c_jobcont) REFERENCES "mdbadmin"
.t_job_cont
\p\g
alter table t_order add  FOREIGN KEY (c_cont) REFERENCES "mdbadmin"
.t_cont
\p\g
alter table t_ownsite add  FOREIGN KEY (c_ownerid) REFERENCES 
"mdbadmin".t_sdusers ON DELETE SET NULL
\p\g
alter table t_rsw add  FOREIGN KEY (c_ownerid) REFERENCES "mdbadmin"
.t_sdusers
\p\g
alter table t_rsw add  FOREIGN KEY (c_basedon) REFERENCES "mdbadmin"
.t_rsw
\p\g
alter table t_rsw add  FOREIGN KEY (c_deliverproc) REFERENCES 
"mdbadmin".t_actproc
\p\g
alter table t_rsw add  FOREIGN KEY (c_undeliverproc) REFERENCES 
"mdbadmin".t_actproc
\p\g
alter table t_swfold add  FOREIGN KEY (c_ownerid) REFERENCES 
"mdbadmin".t_sdusers
\p\g
alter table t_swfold add  FOREIGN KEY (c_cmpgrp) REFERENCES "mdbadmin"
.t_cmp_grp
\p\g
alter table t_volume add  FOREIGN KEY (c_rsw) REFERENCES "mdbadmin"
.t_rsw
\p\g
alter table tl_act_inst add  FOREIGN KEY (c_activity) REFERENCES 
"mdbadmin".t_activity WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_act_inst add  FOREIGN KEY (c_installation) REFERENCES 
"mdbadmin".t_applic
\p\g
alter table tl_cmpgrp add  FOREIGN KEY (c_grpparent) REFERENCES 
"mdbadmin".t_cmp_grp WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_cmpgrp add  FOREIGN KEY (c_grpchild) REFERENCES 
"mdbadmin".t_cmp_grp
\p\g
alter table tl_grp_cmp add  FOREIGN KEY (c_grp) REFERENCES "mdbadmin"
.t_cmp_grp
\p\g
alter table tl_grp_cmp add  FOREIGN KEY (c_comp) REFERENCES "mdbadmin"
.t_computer WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_grp_proc add  FOREIGN KEY (c_procgrp) REFERENCES 
"mdbadmin".t_swfold WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_grp_proc add  FOREIGN KEY (c_proc) REFERENCES 
"mdbadmin".t_actproc
\p\g
alter table tl_jc add  FOREIGN KEY (c_jcparent) REFERENCES "mdbadmin"
.t_job_cont WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_jc add  FOREIGN KEY (c_jcchild) REFERENCES "mdbadmin"
.t_job_cont
\p\g
alter table tl_lsg add  FOREIGN KEY (c_lsgparent) REFERENCES 
"mdbadmin".t_lsg
\p\g
alter table tl_lsg add  FOREIGN KEY (c_lsgchild) REFERENCES "mdbadmin"
.t_lsg WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_lsg_ls add  FOREIGN KEY (c_lsg) REFERENCES "mdbadmin"
.t_lsg ON DELETE CASCADE WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_lsg_ls add  FOREIGN KEY (c_ls) REFERENCES "mdbadmin"
.t_ls ON DELETE CASCADE
\p\g
alter table tl_swg_sw add  FOREIGN KEY (c_swg) REFERENCES "mdbadmin"
.t_swfold WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_swg_sw add  FOREIGN KEY (c_sw) REFERENCES "mdbadmin"
.t_rsw
\p\g
alter table tl_swgrp add  FOREIGN KEY (c_grpparent) REFERENCES 
"mdbadmin".t_swfold WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table tl_swgrp add  FOREIGN KEY (c_grpchild) REFERENCES 
"mdbadmin".t_swfold
\p\g
alter table tplmemo add  FOREIGN KEY (tpid, domainid) REFERENCES 
"mdbadmin".nctpldef
\p\g
alter table unitrel add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".infotrid WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table unitrel add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".nctngref WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table unitrel add  FOREIGN KEY (unitid, domainid) REFERENCES 
"mdbadmin".openunit WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table urc_active_session add  PRIMARY KEY(uid)
\p\g
alter table urc_address_book_global add  PRIMARY KEY(uid)
\p\g
alter table urc_address_book_group_global add  PRIMARY KEY(uid)
\p\g
alter table urc_computer add  PRIMARY KEY(uid)
\p\g
alter table urc_computer_group add  PRIMARY KEY(uid)
\p\g
alter table urc_local_server add  PRIMARY KEY(uid)
\p\g
alter table urc_permission_global add  PRIMARY KEY(uid)
\p\g
alter table urc_repository_credentials add  PRIMARY KEY(uid)
\p\g
alter table urc_schema_version add  PRIMARY KEY(uid)
\p\g
alter table usd_accounts add  PRIMARY KEY(objectid)
\p\g
alter table usd_acctempl add  PRIMARY KEY(objectid)
\p\g
alter table usd_activity add  PRIMARY KEY(objectid)
\p\g
alter table usd_actproc add  PRIMARY KEY(objectid)
\p\g
alter table usd_apdep add  PRIMARY KEY(objectid)
\p\g
alter table usd_applic add  PRIMARY KEY(objectid)
\p\g
alter table usd_carrier add  PRIMARY KEY(objectid)
\p\g
alter table usd_cc add  PRIMARY KEY(objectid)
\p\g
alter table usd_cmp_attr add  PRIMARY KEY(objectid)
\p\g
alter table usd_cmp_grp add  PRIMARY KEY(objectid)
\p\g
alter table usd_cont add  PRIMARY KEY(objectid)
\p\g
alter table usd_contfold add  PRIMARY KEY(objectid)
\p\g
alter table usd_csite add  PRIMARY KEY(objectid)
\p\g
alter table usd_distap add  PRIMARY KEY(objectid)
\p\g
alter table usd_distcgrp add  PRIMARY KEY(objectid)
\p\g
alter table usd_distsw add  PRIMARY KEY(objectid)
\p\g
alter table usd_fio add  PRIMARY KEY(objectid)
\p\g
alter table usd_fitem add  PRIMARY KEY(objectid)
\p\g
alter table usd_jcappgr add  PRIMARY KEY(objectid)
\p\g
alter table usd_jcview add  PRIMARY KEY(objectid)
\p\g
alter table usd_job_cont add  PRIMARY KEY(objectid)
\p\g
alter table usd_link_act_inst add  PRIMARY KEY(activity, installation)
\p\g
alter table usd_link_cfold_cont add  PRIMARY KEY(contfold, cont)
\p\g
alter table usd_link_cmpgrp add  PRIMARY KEY(grpparent, grpchild)
\p\g
alter table usd_link_contfold add  PRIMARY KEY(cfold_parent, 
cfold_child)
\p\g
alter table usd_link_grp_cmp add  PRIMARY KEY(grp, comp)
\p\g
alter table usd_link_grp_proc add  PRIMARY KEY(procgrp, ap)
\p\g
alter table usd_link_jc add  PRIMARY KEY(jcparent, jcchild)
\p\g
alter table usd_link_jc_act add  PRIMARY KEY(jcont, activity)
\p\g
alter table usd_link_jc_srv add  PRIMARY KEY(jcont, server)
\p\g
alter table usd_link_lsg add  PRIMARY KEY(lsgparent, lsgchild)
\p\g
alter table usd_link_lsg_ls add  PRIMARY KEY(lsg, ls)
\p\g
alter table usd_link_swg_sw add  PRIMARY KEY(swg, sw)
\p\g
alter table usd_link_swgrp add  PRIMARY KEY(grpparent, grpchild)
\p\g
alter table usd_ls add  PRIMARY KEY(objectid)
\p\g
alter table usd_lsg add  PRIMARY KEY(objectid)
\p\g
alter table usd_order add  PRIMARY KEY(objectid)
\p\g
alter table usd_ownsite add  PRIMARY KEY(objectid)
\p\g
alter table usd_rsw add  PRIMARY KEY(objectid)
\p\g
alter table usd_sdusers add  PRIMARY KEY(objectid)
\p\g
alter table usd_swfold add  PRIMARY KEY(objectid)
\p\g
alter table usd_target add  PRIMARY KEY(objectid)
\p\g
alter table usd_task add  PRIMARY KEY(objectid)
\p\g
alter table usd_volume add  PRIMARY KEY(objectid)
\p\g
alter table dts_dtfilter add  PRIMARY KEY(object_id)
\p\g
alter table dts_dtsubscribers add  PRIMARY KEY(object_id)
\p\g
alter table dts_dttransfer add  PRIMARY KEY(object_id)
\p\g
alter table dts_dttransfergroup add  PRIMARY KEY(object_id)
\p\g
alter table dts_dtversion add  PRIMARY KEY(object_id)
\p\g
alter table dts_torproperties add  PRIMARY KEY(object_id, row_num)
\p\g
alter table ca_discovered_hardware add  FOREIGN KEY (domain_uuid) 
REFERENCES "mdbadmin".ca_n_tier
\p\g
alter table ca_discovered_user add  FOREIGN KEY (domain_uuid) 
REFERENCES "mdbadmin".ca_n_tier
\p\g
alter table tng_class add  UNIQUE("class_id")
\p\g
alter table tng_class_ext add  FOREIGN KEY (class_id) REFERENCES 
"mdbadmin".tng_class(class_id)
\p\g
alter table tng_property_definition add  FOREIGN KEY (class_id) 
REFERENCES "mdbadmin".tng_class(class_id)
\p\g
alter table tng_alarmset add  UNIQUE("name")
\p\g
alter table tng_alarmset_entry add  FOREIGN KEY (alarmset_name) 
REFERENCES "mdbadmin".tng_alarmset(name)
\p\g
alter table tng_field_storage add  UNIQUE("uuid")
\p\g
alter table frs_circuit_line add  PRIMARY KEY(l_net_name, l_node_name,
l_line, l_port)
\p\g
alter table frs_connection add  PRIMARY KEY(l_node_name, l_line, 
l_slot, l_port, l_dlci)
\p\g
alter table frs_frp add  PRIMARY KEY(l_node_name, l_slot, l_port)
\p\g
alter table frs_ip add  PRIMARY KEY(lastip)
\p\g
alter table frs_node_id add  PRIMARY KEY(node_name)
\p\g
alter table frs_packet_line add  PRIMARY KEY(l_net_name, l_node_name, 
l_line, l_slot, l_port, l_vtrk)
\p\g
alter table frs_stat add  PRIMARY KEY(strnodename, nslot, nport, 
ndlci, nobjecttype, nstattype)
\p\g
alter table frs_stat_threshold add  PRIMARY KEY(strnodename, 
objecttype, subtype, stattype)
\p\g
alter table frs_svp add  PRIMARY KEY(address)
\p\g
alter table nr_com add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table man_mod add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ct_mth add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table pri add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table urgncy add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table sevrty add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table bool_tab add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rbooltab add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table not_log add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table not_que add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table nottrn add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table noturg add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table impact add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table tn add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table cn add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table atn add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table sql_tab add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table dlgtsrv add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table km_kword add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table km_lrel add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table dmn add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ctab add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table dcon add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table dcon_typ add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table grpmem add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table session_log add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table event_log add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table session_type add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table event_type add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table ext_appl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table tz add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table kc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table audit_log add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table toc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table repmeth add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table perscon add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table product add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rootcause add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table busmgt add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table busstat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table buscls add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table busrep add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table buslrel add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table act_log add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table call_req add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table crt add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table act_type add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table atyp_asc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table srv_desc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table prob_ctg add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table crsol add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table cr_stat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rem_ref add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table seqctl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table crsq add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table crctmr add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table cnote add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table slatpl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table doc_rep add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table attmnt add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table attmnt_folder add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table attmnt_lrel add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table hier add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table cr_prptpl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table cr_prp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table usq add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table xent_map add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table cr_template add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table iss_template add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table chg_template add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table quick_tpl_types add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table svc_contract add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table sdsc_map add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table attached_sla add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table admin_tree add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table lrel add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table anima add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table bpwshft add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table options add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rptmth add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table actbool add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table actrbool add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table d_painter add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table tspan add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table interface add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table survey_tpl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table survey_qtpl add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table survey_atpl add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table survey add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table survey_question add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table survey_answer add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table survey_tracking add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table survey_statistics add  PRIMARY KEY("id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table managed_survey add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table mgsalg add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table mgsstat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table pcat_loc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table pcat_grp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table grp_loc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table pcat_wrkshft add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ccat_loc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ccat_grp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ccat_wrkshft add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table icat_loc add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table icat_grp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table icat_wrkshft add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table wftpl_grp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table frmgrp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table response add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table acctyp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table acc_lvls add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table arcpur_rule add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table arcpur_hist add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table sapolicy add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table saprobtyp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table splmac add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table splmactp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table atomic_cond add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table evt add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table att_evt add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ntfl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table evt_dly add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table evtdlytp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table usp_owned_resource add  PRIMARY KEY("id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table usp_company add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table usp_organization add  PRIMARY KEY("id") WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table usp_contact add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table usp_location add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table am_map add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table chgalg add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table chg add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table chgcat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table chgstat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_tbl_map add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_tbl_rule add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table g_srvr add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table srvr_zones add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table srvr_aliases add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table g_contact add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_org add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_queue_names add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table g_product add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_req_ext add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_req_queue add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table g_chg_ext add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_chg_queue add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table g_iss_ext add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table g_iss_queue add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table issalg add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table issue add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table isscat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table issstat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table tskty add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table tskstat add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table wftpl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table wf add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table prptpl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table prp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table bhvtpl add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table isswf add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table issprp add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table bu_trans add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ci_actions add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table ci_actions_alternate add  PRIMARY KEY("id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ebr_log add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table ci_bookmarks add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ci_doc_templates add  PRIMARY KEY("id") WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ci_doc_links add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ci_doc_types add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table usp_preferences add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ci_priorities add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table usp_properties add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ci_statuses add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ci_wf_templates add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_acronyms add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_fulltext add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_fulltext_adm add  PRIMARY KEY("id") WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ebr_fulltext_sd add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_fulltext_sd_adm add  PRIMARY KEY("id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ebr_metrics add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_noise_words add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_prefixes add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_properties add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_substits add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_suffixes add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_synonyms add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ebr_synonyms_adm add  PRIMARY KEY("id") WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ebr_indexing_queue add  PRIMARY KEY("id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ebr_keywords add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table es_constants add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table es_nodes add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table es_responses add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table es_sessions add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table index_doc_links add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table kd_attmnt add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table kdlinks add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table long_texts add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table notification add  PRIMARY KEY("id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table o_comments add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table o_events add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table o_indexes add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table p_groups add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table show_obj add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table skeletons add  PRIMARY KEY("id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table sonarapplication add  PRIMARY KEY(applicationuuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table sonarcomponentdef add  PRIMARY KEY(sonarcomponentuuid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table sonarperformance add  PRIMARY KEY(localcomponentuuid, 
remotecomponentuuid, intervalstart, intervalstartseconds) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table sonarperformance add constraint localcomponent  FOREIGN 
KEY (localcomponentuuid) REFERENCES "mdbadmin"
.sonarcomponentdef(sonarcomponentuuid)
\p\g
alter table sonarperformance add constraint remotecomponent  FOREIGN 
KEY (remotecomponentuuid) REFERENCES "mdbadmin"
.sonarcomponentdef(sonarcomponentuuid)
\p\g
alter table sonartransaction add  PRIMARY KEY(transactionuuid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table pd_machine add constraint unique_machine  
UNIQUE(machine_name) WITH (STRUCTURE = BTREE)
\p\g
alter table pd_resource add constraint unique_resource  
UNIQUE(res_type, res_subtype, res_instance) WITH (STRUCTURE = BTREE)
\p\g
alter table pd_time add  UNIQUE("time_value")
\p\g
alter table pd_bpv add constraint unique_bpv  UNIQUE(bpv_name) WITH 
(STRUCTURE = BTREE)
\p\g
alter table columndefinition add  PRIMARY KEY(tableidx, orderofcolumn)
\p\g
alter table componentofindex add  PRIMARY KEY(componentmibindexidx, 
componentofindexorder)
\p\g
alter table discoveryvariable add  PRIMARY KEY(mibidx)
\p\g
alter table gdcdiscovery add  PRIMARY KEY(server_addr, probe_addr, 
mibidx)
\p\g
alter table indextable add  PRIMARY KEY(componentmibindexidx)
\p\g
alter table network_mib add  PRIMARY KEY(id)
\p\g
alter table mibdefinition add  PRIMARY KEY(mibidx)
\p\g
alter table mibstructure add  PRIMARY KEY(mibidx, oididxformib)
\p\g
alter table mibvariabletype add  PRIMARY KEY(typeid)
\p\g
alter table pollrowdefinition add  PRIMARY KEY(rowid, mibidx, 
oididxformib)
\p\g
alter table tabledefinition add  PRIMARY KEY(tableidx)
\p\g
alter table tablesdescription add  PRIMARY KEY(oididxformib, mibidx, 
tableidx, orderofcolumn)
\p\g
alter table thresholddesc add  PRIMARY KEY(fieldindex)
\p\g
alter table columndefinition add  FOREIGN KEY (tableidx) REFERENCES 
"mdbadmin".tabledefinition(tableidx)
\p\g
alter table columndefinition add  FOREIGN KEY (typeid) REFERENCES 
"mdbadmin".mibvariabletype(typeid)
\p\g
alter table componentofindex add  FOREIGN KEY (componentmibindexidx) 
REFERENCES "mdbadmin".indextable(componentmibindexidx)
\p\g
alter table componentofindex add  FOREIGN KEY (mibidx, oididxformib) 
REFERENCES "mdbadmin".mibstructure(mibidx, oididxformib)
\p\g
alter table discoveryvariable add  FOREIGN KEY (typeid) REFERENCES 
"mdbadmin".mibvariabletype(typeid)
\p\g
alter table discoveryvariable add  FOREIGN KEY (mibidx) REFERENCES 
"mdbadmin".mibdefinition(mibidx)
\p\g
alter table discoveryvariable add  FOREIGN KEY (mibidx, oididxformib) 
REFERENCES "mdbadmin".mibstructure(mibidx, oididxformib)
\p\g
alter table gdcdiscovery add  FOREIGN KEY (mibidx) REFERENCES 
"mdbadmin".mibdefinition(mibidx)
\p\g
alter table mibdefinition add  FOREIGN KEY (mib_id) REFERENCES 
"mdbadmin".network_mib(id) ON DELETE SET NULL
\p\g
alter table mibstructure add  FOREIGN KEY (componentmibindexidx) 
REFERENCES "mdbadmin".indextable(componentmibindexidx) ON DELETE SET 
NULL ON UPDATE SET NULL
\p\g
alter table mibstructure add  FOREIGN KEY (mibidx) REFERENCES 
"mdbadmin".mibdefinition(mibidx)
\p\g
alter table mibvariabletype add  FOREIGN KEY (basetypeidx) REFERENCES 
"mdbadmin".mibvariabletype(typeid) ON DELETE SET NULL
\p\g
alter table pollrowdefinition add  FOREIGN KEY (mibidx, oididxformib) 
REFERENCES "mdbadmin".mibstructure(mibidx, oididxformib)
\p\g
alter table resourcemonitoring add  FOREIGN KEY (mibidx) REFERENCES 
"mdbadmin".mibdefinition(mibidx)
\p\g
alter table tablesdescription add  FOREIGN KEY (mibidx, oididxformib) 
REFERENCES "mdbadmin".mibstructure(mibidx, oididxformib)
\p\g
alter table tablesdescription add  FOREIGN KEY (tableidx, 
orderofcolumn) REFERENCES "mdbadmin".columndefinition(tableidx, 
orderofcolumn)
\p\g
alter table thresholddesc add  FOREIGN KEY (mibidx) REFERENCES 
"mdbadmin".mibdefinition(mibidx) ON DELETE SET NULL ON UPDATE SET NULL
\p\g
alter table thresholdformula add  PRIMARY KEY("fieldindex")
\p\g
alter table tableindex add  PRIMARY KEY("tablename")
\p\g
alter table resourcetype add  PRIMARY KEY("rsrctype")
\p\g
alter table calendars add  PRIMARY KEY("calendar_oid") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table exporters add  PRIMARY KEY("exporter_oid") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table pattern_types add  PRIMARY KEY("pattern_type_oid") WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table event_categories add  PRIMARY KEY("event_category_oid") 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table event_categories add  FOREIGN KEY ("exporter_oid") 
REFERENCES "mdbadmin".exporters(exporter_oid)
\p\g
alter table calendar_categories add  PRIMARY 
KEY("calendar_category_oid") WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table calendar_categories add  FOREIGN KEY ("calendar_oid") 
REFERENCES "mdbadmin".calendars(calendar_oid)
\p\g
alter table calendar_categories add  FOREIGN KEY ("event_category_oid"
) REFERENCES "mdbadmin".event_categories(event_category_oid)
\p\g
alter table event_category_values add  PRIMARY 
KEY("event_category_value_oid") WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table event_category_values add  FOREIGN KEY 
("event_category_oid") REFERENCES "mdbadmin"
.event_categories(event_category_oid)
\p\g
alter table recurring_events add  PRIMARY KEY("recurring_event_oid") 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table recurring_events add  FOREIGN KEY ("calendar_oid") 
REFERENCES "mdbadmin".calendars(calendar_oid)
\p\g
alter table recurring_events add  FOREIGN KEY ("pattern_type_oid") 
REFERENCES "mdbadmin".pattern_types(pattern_type_oid)
\p\g
alter table recurring_events add  FOREIGN KEY ("event_category_oid") 
REFERENCES "mdbadmin".event_categories(event_category_oid)
\p\g
alter table recurring_events add  FOREIGN KEY 
("event_category_value_oid") REFERENCES "mdbadmin"
.event_category_values(event_category_value_oid)
\p\g
alter table onetime_events add  PRIMARY KEY("onetime_event_oid") WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table onetime_events add  FOREIGN KEY ("calendar_oid") 
REFERENCES "mdbadmin".calendars(calendar_oid)
\p\g
alter table onetime_events add  FOREIGN KEY ("event_category_oid") 
REFERENCES "mdbadmin".event_categories(event_category_oid)
\p\g
alter table onetime_events add  FOREIGN KEY ("recurring_event_oid") 
REFERENCES "mdbadmin".recurring_events(recurring_event_oid)
\p\g
alter table onetime_events add  FOREIGN KEY 
("event_category_value_oid") REFERENCES "mdbadmin"
.event_category_values(event_category_value_oid)
\p\g
alter table ipuser add constraint pk_ipuser  PRIMARY KEY(userid)
\p\g
alter table ipobject add constraint fk_objectuserid  FOREIGN KEY 
("userid") REFERENCES "mdbadmin".ipuser
\p\g
alter table ipobject add constraint pk_object  PRIMARY KEY(objectid)
\p\g
alter table codefragment add constraint pk_codefragment  PRIMARY 
KEY(fragmentid)
\p\g
alter table iprequest add constraint fk_requestobject  FOREIGN KEY 
("requestid") REFERENCES "mdbadmin".ipobject
\p\g
alter table iprequest add constraint pk_request  PRIMARY 
KEY(requestid)
\p\g
alter table lookoutserver add constraint pk_lookoutserver  PRIMARY 
KEY(serverid)
\p\g
alter table execution add constraint fk_execrequestid  FOREIGN KEY 
("requestid") REFERENCES "mdbadmin".iprequest
\p\g
alter table execution add constraint fk_execserverid  FOREIGN KEY 
("serverid") REFERENCES "mdbadmin".lookoutserver
\p\g
alter table execution add constraint pk_execution  PRIMARY 
KEY(executionid)
\p\g
alter table ddtable add constraint fk_ddtexecutionid  FOREIGN KEY 
("executionid") REFERENCES "mdbadmin".execution
\p\g
alter table ddtable add constraint pk_ddtable  PRIMARY KEY(ddtableid)
\p\g
alter table ddcolumn add constraint fk_ddcddtableid  FOREIGN KEY 
("ddtableid") REFERENCES "mdbadmin".ddtable
\p\g
alter table ddcolumn add constraint pk_ddcolumn  PRIMARY 
KEY(ddtableid, ddcolumnname)
\p\g
alter table ddtablemodify add constraint fk_ddtmodexecutionid  FOREIGN
KEY ("executionid") REFERENCES "mdbadmin".execution
\p\g
alter table error add constraint fk_errorexecutionid  FOREIGN KEY 
("executionid") REFERENCES "mdbadmin".execution
\p\g
alter table error add constraint pk_error  PRIMARY KEY(executionid, 
errororder)
\p\g
alter table globalvariable add constraint pk_globalvariable  PRIMARY 
KEY(variableid)
\p\g
alter table lookoutcontrol add constraint fk_locserver  FOREIGN KEY 
("serverid") REFERENCES "mdbadmin".lookoutserver
\p\g
alter table lookoutcontrol add constraint pk_lookoutcontrol  PRIMARY 
KEY(controlentryid)
\p\g
alter table lookoutidcontrol add constraint pk_lookoutidcontrol  
PRIMARY KEY(lookoutversion)
\p\g
alter table permissions add constraint fk_permobjectid  FOREIGN KEY 
("objectid") REFERENCES "mdbadmin".ipobject
\p\g
alter table permissions add constraint pk_permissions  PRIMARY 
KEY(objectid, granteeid)
\p\g
alter table ipprovider add constraint fk_providerobject  FOREIGN KEY 
("providerid") REFERENCES "mdbadmin".ipobject
\p\g
alter table ipprovider add constraint pk_provider  PRIMARY 
KEY(providerid)
\p\g
alter table providerversion add constraint pk_providerversion  PRIMARY
KEY(providertype, providersubtype, serverid)
\p\g
alter table rdbms_provider add constraint fk_rdbmsobject  FOREIGN KEY 
("providerid") REFERENCES "mdbadmin".ipobject
\p\g
alter table rdbms_provider add constraint pk_rdbms_provider  PRIMARY 
KEY(providerid)
\p\g
alter table iprequestcode add constraint pk_iprequestcode  PRIMARY 
KEY(requestid)
\p\g
alter table requestprovider add constraint fk_rpprovider  FOREIGN KEY 
("providerid") REFERENCES "mdbadmin".ipprovider
\p\g
alter table requestprovider add constraint fk_rprequest  FOREIGN KEY 
("requestid") REFERENCES "mdbadmin".iprequest
\p\g
alter table requestprovider add constraint pk_requestprovider  PRIMARY
KEY(providerid, requestid)
\p\g
alter table requestqueue add constraint fk_rqrequest  FOREIGN KEY 
("requestid") REFERENCES "mdbadmin".iprequest
\p\g
alter table requestqueue add constraint pk_requestqueue  PRIMARY 
KEY(requestid)
\p\g
alter table scriptmessagelog add constraint fk_smlexecution  FOREIGN 
KEY ("executionid") REFERENCES "mdbadmin".execution
\p\g
alter table scriptmessagelog add constraint pk_scriptmessagelog  
PRIMARY KEY(requestid, executionid, messageorder)
\p\g
alter table simplerequest add constraint fk_srrequest  FOREIGN KEY 
("requestid") REFERENCES "mdbadmin".iprequest
\p\g
alter table simplerequest add constraint pk_simplerequest  PRIMARY 
KEY(requestid)
\p\g
alter table systemparameter add constraint pk_systemparameter  PRIMARY
KEY(serverid, parametername)
\p\g
alter table db_object add constraint pk_db_object  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_object add constraint db_objectunique  
UNIQUE(dbrep_parentiid, dbrep_name, dbrep_objecttype, dbrep_status, 
dbrep_version)
\p\g
alter table db_object add constraint fk_db_object  FOREIGN KEY 
("dbrep_parentiid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_infoblob add constraint fk_db_infoblob  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_infoblob add constraint pk_db_infoblob  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_servertype add constraint fk_db_servertype  FOREIGN KEY
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_servertype add constraint pk_db_servertype  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_datatype add constraint fk_db_datatype  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_datatype add constraint pk_db_datatype  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_table add constraint fk_db_table  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_table add constraint pk_db_table  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_seqtable add constraint fk_db_seqtable  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_table
\p\g
alter table db_seqtable add constraint pk_db_seqtable  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_column add constraint fk_db_column_1  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_column add constraint fk_db_column_2  FOREIGN KEY 
("dbrep_datatypeiid") REFERENCES "mdbadmin".db_datatype
\p\g
alter table db_column add constraint pk_db_column  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_seqcolumn add constraint fk_db_seqcolumn  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_column
\p\g
alter table db_seqcolumn add constraint pk_db_seqcolumn  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_layout add constraint fk_db_layout  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_layout add constraint pk_db_layout  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_field add constraint fk_db_field  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_field add constraint pk_db_field  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_index add constraint fk_db_index  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_index add constraint pk_db_index  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_indexcol add constraint fk_db_indexcol_1  FOREIGN KEY 
("dbrep_indexiid") REFERENCES "mdbadmin".db_index
\p\g
alter table db_indexcol add constraint fk_db_indexcol_2  FOREIGN KEY 
("dbrep_columniid") REFERENCES "mdbadmin".db_column
\p\g
alter table db_star add constraint fk_db_star  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_star add constraint pk_db_star  PRIMARY KEY(dbrep_iid)
\p\g
alter table db_startable add constraint fk_db_startable_1  FOREIGN KEY
("dbrep_stariid") REFERENCES "mdbadmin".db_star
\p\g
alter table db_startable add constraint fk_db_startable_2  FOREIGN KEY
("dbrep_tableiid") REFERENCES "mdbadmin".db_table
\p\g
alter table db_gator add constraint fk_db_gator  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_gator add constraint pk_db_gator  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_gatorstar add constraint fk_db_gatorstar_1  FOREIGN KEY
("dbrep_gatoriid") REFERENCES "mdbadmin".db_gator
\p\g
alter table db_gatorstar add constraint fk_db_gatorstar_2  FOREIGN KEY
("dbrep_stariid") REFERENCES "mdbadmin".db_star
\p\g
alter table db_application add constraint fk_db_application  FOREIGN 
KEY ("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_application add constraint pk_db_application  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_program add constraint fk_db_program  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_program add constraint pk_db_program  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_op add constraint fk_db_op  FOREIGN KEY ("dbrep_iid") 
REFERENCES "mdbadmin".db_object
\p\g
alter table db_op add constraint pk_db_op  PRIMARY KEY(dbrep_iid)
\p\g
alter table db_opsegment add constraint fk_db_opsegment  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_op
\p\g
alter table db_parameter add constraint fk_db_parameter  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_parameter add constraint pk_db_parameter  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_wkf add constraint fk_db_wkf  FOREIGN KEY ("dbrep_iid")
REFERENCES "mdbadmin".db_object
\p\g
alter table db_wkf add constraint pk_db_wkf  PRIMARY KEY(dbrep_iid)
\p\g
alter table db_wkfconnection add constraint fk_db_wkfconnection  
FOREIGN KEY ("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_wkfconnection add constraint pk_db_wkfconnection  
PRIMARY KEY(dbrep_iid)
\p\g
alter table db_programinstance add constraint fk_db_programinstance_1 
FOREIGN KEY ("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_programinstance add constraint fk_db_programinstance_2 
FOREIGN KEY ("dbrep_programiid") REFERENCES "mdbadmin".db_program
\p\g
alter table db_programinstance add constraint pk_db_programinstance  
PRIMARY KEY(dbrep_iid)
\p\g
alter table db_programtype add constraint fk_db_programtype  FOREIGN 
KEY ("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_programtype add constraint pk_db_programtype  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table db_programtypemisc add constraint fk_db_programtypemisc  
FOREIGN KEY ("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_programtypemisc add constraint pk_db_programtypemisc  
PRIMARY KEY(dbrep_iid)
\p\g
alter table db_psafile add constraint fk_db_psafile  FOREIGN KEY 
("dbrep_iid") REFERENCES "mdbadmin".db_object
\p\g
alter table db_psafile add constraint pk_db_psafile  PRIMARY 
KEY(dbrep_iid)
\p\g
alter table enterprise_package add constraint pk_enterprise_package  
PRIMARY KEY(ep_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table counter add constraint pk_counter  PRIMARY KEY(id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table eccm_configuration add constraint pk_eccm_configuration  
PRIMARY KEY(eccm_configurationid, provider_name, product_code) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table eccm_user add constraint pk_eccm_user  PRIMARY 
KEY(eccmuserid, userid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table enterprise_package_history add constraint 
pk_enterprise_package_history  PRIMARY KEY(ep_id, chrono1, chrono2) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table eccm_log add constraint pk_eccm_log  PRIMARY KEY(key1, 
key2, chrono1, chrono2, log_type, seq) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table eccm_actionlog add constraint pk_eccm_actionlog  PRIMARY 
KEY(key1, key2, chrono1, chrono2, log_type, seq) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table enterprise_package_subpackage add constraint 
pk_enterprise_package_subpackage  PRIMARY KEY(sp_id, ep_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harvest_subpackage_actions add constraint 
pk_harvest_subpackage_actions  PRIMARY KEY(sp_id, ep_id) WITH (INDEX =
BASE TABLE STRUCTURE)
\p\g
alter table workbench_product add constraint pk_workbench_product  
PRIMARY KEY(product_code) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table workbench_provider add constraint pk_workbench_provider  
PRIMARY KEY(provider_name, product_code) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table provider_user add constraint pk_provider_user  PRIMARY 
KEY(userid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table user_preferences add constraint pk_user_preferences  
PRIMARY KEY(preference_userid, preference_type, product_code) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table settings add constraint pk_settings  PRIMARY 
KEY(eccmuserid, context) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table building add  UNIQUE("screenname")
\p\g
alter table resource add  UNIQUE("filename")
\p\g
alter table datasource add  UNIQUE("screenname")
\p\g
alter table secure_job add  UNIQUE("name")
\p\g
alter table engine_config add  UNIQUE("name")
\p\g
alter table investigation add  UNIQUE("name")
\p\g
alter table por_group add  PRIMARY KEY(objectkey) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table por_publisher add  PRIMARY KEY(objectkey) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table por_server add  PRIMARY KEY(serverkey) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table por_task add  PRIMARY KEY(taskkey) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table por_template add  PRIMARY KEY(templatekey) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table por_user add  PRIMARY KEY(objectkey) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table por_pages add  PRIMARY KEY(portalpage_id) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table por_pagecols add  PRIMARY KEY(component_column) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table por_documentgroups add  PRIMARY KEY(objectkey, groupowner)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table por_objectrepos add  PRIMARY KEY(objectkey) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table por_document add  PRIMARY KEY(objectkey) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ump_emfilter add  UNIQUE("name")
\p\g
alter table ump_emgroup add  UNIQUE("name")
\p\g
alter table uelrsdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueacl10107data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ueacl11407data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10107data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerollbk11407data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uemp3data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueacl10114data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10114data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uedblog add  PRIMARY KEY(ueuniqueid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uempegdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueacl10122data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10122data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uemsofficedata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uepersistantstateinformationdata add  PRIMARY KEY(uedbid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ueacl10144data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uemdidcolumnsdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerollbk10144data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uemdiddata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uepdfdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueapprovalchaindata add  PRIMARY KEY(uedbid) WITH (INDEX =
BASE TABLE STRUCTURE)
\p\g
alter table ueuserdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueacl10151data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10151data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uegroupdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uephotoshopdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueerrordata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uepersonalizationdata add  PRIMARY KEY(uedbid) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table ueacl10158data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ueadminassetresourcedata add  PRIMARY KEY(uedbid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table uerollbk10158data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueadminresourcebackbonedata add  PRIMARY KEY(uedbid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table uepostscriptdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueacl10166data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uecollectiondata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerollbk10166data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueacl10003data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uequicktimedata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueassetdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueacl10011data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ueacl10173data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10011data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerollbk10173data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueassetfilemapdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerealaudiodata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueurldata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueacl10049data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table ueacl10181data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10049data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerollbk10181data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uewfattributedata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerealmediadata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uewfactivitydefdata add  PRIMARY KEY(uedbid) WITH (INDEX =
BASE TABLE STRUCTURE)
\p\g
alter table uewfprocessdefdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uewfactivitydata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueacl10188data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uewfprocessdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uerollbk10188data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uewfworkitemdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uewavdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uewfacldata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uewsstoragedata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uestdtriggerdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueacl10195data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10195data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uewindowsmediadata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueacl10077data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10077data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueaiffdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table ueacl10208data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10208data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueshockwavedata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueacl10085data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uemgrseqopdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uerollbk10085data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueimagedata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uesntabledata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uescdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table ueacl10099data add  PRIMARY KEY(uedbid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table uescitemsdata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table uerollbk10099data add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table uewebdavlockdata add  PRIMARY KEY(uedbid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table ueavidata add  PRIMARY KEY(uedbid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table harallchildrenpath add constraint harallchildrenpath_pk  
PRIMARY KEY(itemobjid, childitemid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table harallusers add constraint harallusers_pk  PRIMARY 
KEY(usrobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harapprove add constraint harapprove_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harapprovehist add constraint harapprovehist_pk  PRIMARY 
KEY(envobjid, stateobjid, packageobjid, usrobjid, execdtime, action) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harbranch add constraint harbranch_pk  PRIMARY 
KEY(branchobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harcheckinproc add constraint harcheckinproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harcheckoutproc add constraint harcheckoutproc_pk  PRIMARY
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harcomment add constraint harcomment_pk  PRIMARY 
KEY(formobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harconmrgproc add constraint harconmrgproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harconversionlog add constraint harconversionlog_pk  
PRIMARY KEY(tablename) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harcrpkgproc add constraint harcrpkgproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harcrsenvmrgproc add constraint harcrsenvmrgproc_pk  
PRIMARY KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table hardefect add constraint hardefect_pk  PRIMARY 
KEY(formobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table hardelversproc add constraint hardelversproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table hardemoteproc add constraint hardemoteproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harenvironment add constraint harenvironment_pk  PRIMARY 
KEY(envobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harenvironmentaccess add constraint harenvaccess_pk  
PRIMARY KEY(envobjid, usrgrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table haresd add constraint haresd_pk  PRIMARY KEY(formobjid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harexternassoc add constraint harexternassoc_pk  PRIMARY 
KEY(externalid, usrobjid, packageobjid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table harfileextension add constraint harfileextension_pk  
PRIMARY KEY(repositobjid, fileextension) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table harform add constraint harform_pk  PRIMARY KEY(formobjid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harformtype add constraint harformtype_pk  PRIMARY 
KEY(formtypeobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harformtype add constraint unq_formtablename  
UNIQUE(formtablename)
\p\g
alter table harformtypeaccess add constraint harformtypeaccess_pk  
PRIMARY KEY(formtypeobjid, usrgrpobjid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table harformtypedefs add constraint harformtypedefs_pk  PRIMARY
KEY(attrid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harharvest add constraint harharvest_pk  PRIMARY 
KEY(usrgrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harintmrgproc add constraint harintmrgproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table haritemaccess add constraint haritemaccess_pk  PRIMARY 
KEY(itemobjid, usrgrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table haritemrelationship add constraint haritemrelationship_pk 
PRIMARY KEY(itemobjid, refitemid, versionobjid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table haritems add constraint haritems_pk  PRIMARY 
KEY(itemobjid) WITH (INDEX = "haritems_pki")
\p\g
alter table harlinkedprocess add constraint harlinkedprocess_pk  
PRIMARY KEY(parentprocobjid, processobjid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table harlistdiffproc add constraint harlistdiffproc_pk  PRIMARY
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harlistversproc add constraint harlistversproc_pk  PRIMARY
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harmovepkgproc add constraint harmovepkgproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harmr add constraint harmr_pk  PRIMARY KEY(formobjid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harnotify add constraint harnotify_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harobjectsequenceid add constraint harobjectsequenceid_pk 
PRIMARY KEY(hartablename) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpac add constraint harpac_pk  PRIMARY KEY(formobjid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpackage add constraint harpackage_pk  PRIMARY 
KEY(packageobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpackagegroup add constraint harpackagegroup_pk  PRIMARY
KEY(pkggrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpackagenamegen add constraint harpackagenamegen_pk  
PRIMARY KEY(nameformat) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpathfullname add constraint harpathfullname_pk  PRIMARY
KEY(itemobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpkgsinpkggrp add constraint harpkgsinpkggrp_pk  PRIMARY
KEY(packageobjid, pkggrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpmstatus add constraint harpmstatus_pk  PRIMARY 
KEY(pmstatusindex) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harproblemreport add constraint harproblemreport_pk  
PRIMARY KEY(formobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harpromoteproc add constraint harpromoteproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harqanda add constraint harqanda_pk  PRIMARY 
KEY(formobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harremitemproc add constraint harremitemproc_pk  PRIMARY 
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harrenameitemproc add constraint harrenameitemproc_pk  
PRIMARY KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harrepinview add constraint harrepinview_pk  PRIMARY 
KEY(viewobjid, repositobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harrepository add constraint harrepository_pk  PRIMARY 
KEY(repositobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harrepositoryaccess add constraint harrepaccess_pk  
PRIMARY KEY(repositobjid, usrgrpobjid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table harsite add constraint harsite_pk  PRIMARY KEY(siteobjid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harsite add constraint unq_harsite  UNIQUE(sitename)
\p\g
alter table harsnapviewproc add constraint harsnapviewproc_pk  PRIMARY
KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harstate add constraint harstate_pk  PRIMARY 
KEY(stateobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harstateaccess add constraint harstateaccess_pk  PRIMARY 
KEY(stateobjid, usrgrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harstateprocess add constraint harstateprocess_pk  PRIMARY
KEY(stateobjid, processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harstateprocessaccess add constraint 
harstateprocessaccess_pk  PRIMARY KEY(stateobjid, processobjid, 
usrgrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harsync add constraint harsync_pk  PRIMARY KEY(syncobjid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harsync add constraint unq_harsync  UNIQUE(packageobjid)
\p\g
alter table harsyncconfig add constraint harsyncconfig_pk  PRIMARY 
KEY(configobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harsyncconfig add constraint unq_harsyncconfig  
UNIQUE(siteobjid, envobjid, stateobjid, viewpathobjid, remoteenv, 
remotestate, remoteviewpath)
\p\g
alter table harsyncfullpath add constraint harsyncfullpath_pk  PRIMARY
KEY(pathobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table hartestinginfo add constraint hartestinginfo_pk  PRIMARY 
KEY(formobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harudp add constraint harudp_pk  PRIMARY KEY(processobjid)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table haruser add constraint haruser_pk  PRIMARY KEY(usrobjid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harusercontact add constraint harusercontact_pk  PRIMARY 
KEY(formobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harusergroup add constraint harusergroup_pk  PRIMARY 
KEY(usrgrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harusersingroup add constraint harusersingroup_pk  PRIMARY
KEY(usrobjid, usrgrpobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harversiondata add constraint harversiondata_pk  PRIMARY 
KEY(versiondataobjid) WITH (INDEX = "harversiondata_pki")
\p\g
alter table harversiondelta add constraint harversiondelta_pk  PRIMARY
KEY(childversiondataid, parentversiondataid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table harversioninview add constraint harversioninview_pk  
PRIMARY KEY(viewobjid, versionobjid) WITH (INDEX = 
"harversioninview_pki")
\p\g
alter table harversions add constraint harversions_pk  PRIMARY 
KEY(versionobjid) WITH (INDEX = "harversions_pki")
\p\g
alter table harview add constraint harview_pk  PRIMARY KEY(viewobjid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harapprove add constraint harapprove_spid_fk  FOREIGN KEY 
(stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH NO 
INDEX
\p\g
alter table harapprovehist add constraint harapprovehist_envid_fk  
FOREIGN KEY (envobjid) REFERENCES "mdbadmin".harenvironment(envobjid) 
ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harapprovelist add constraint harapprovelist_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "harapprovelist_spid_ind")
\p\g
alter table harapprovelist add constraint harapprovelist_usrgrp_fk  
FOREIGN KEY (usrgrpobjid) REFERENCES "mdbadmin"
.harusergroup(usrgrpobjid) ON DELETE CASCADE WITH (INDEX = 
"harapprovelist_usrgrp_ind")
\p\g
alter table harassocpkg add constraint harassocpkg_aid_fk  FOREIGN KEY
(assocpkgid) REFERENCES "mdbadmin".harpackage(packageobjid) ON DELETE 
CASCADE WITH (INDEX = "harassocpkg_ind")
\p\g
alter table harassocpkg add constraint harassocpkg_fid_fk  FOREIGN KEY
(formobjid) REFERENCES "mdbadmin".harform(formobjid) ON DELETE CASCADE
WITH NO INDEX
\p\g
alter table harcheckinproc add constraint harcheckinproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "harcheckinproc_spid_ind")
\p\g
alter table harcheckoutproc add constraint harcheckoutproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "harcheckoutproc_spid_ind")
\p\g
alter table harcomment add constraint harcomment_formid_fk  FOREIGN 
KEY (formobjid) REFERENCES "mdbadmin".harform(formobjid) ON DELETE 
CASCADE WITH NO INDEX
\p\g
alter table harconmrgproc add constraint harconmrgproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "harconmrgproc_spid_ind")
\p\g
alter table harcrpkgproc add constraint harcrpkgproc_spid_fk  FOREIGN 
KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "harcrpkgproc_spid_ind")
\p\g
alter table harcrsenvmrgproc add constraint harcrsenvmrgproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "harcrsenvmrgproc_spid_ind")
\p\g
alter table hardefect add constraint hardefect_formid_fk  FOREIGN KEY 
(formobjid) REFERENCES "mdbadmin".harform(formobjid) ON DELETE CASCADE
WITH NO INDEX
\p\g
alter table hardelversproc add constraint hardelversproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "hardelversproc_spid_ind")
\p\g
alter table hardemoteproc add constraint hardemoteproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "hardemoteproc_spid_ind")
\p\g
alter table harenvironmentaccess add constraint harenvaccess_envid_fk 
FOREIGN KEY (envobjid) REFERENCES "mdbadmin".harenvironment(envobjid) 
ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harenvironmentaccess add constraint 
harenvaccess_usrgrpid_fk  FOREIGN KEY (usrgrpobjid) REFERENCES 
"mdbadmin".harusergroup(usrgrpobjid) ON DELETE CASCADE WITH (INDEX = 
"harenvaccess_usrgrpid_ind")
\p\g
alter table haresd add constraint haresd_formid_fk  FOREIGN KEY 
(formobjid) REFERENCES "mdbadmin".harform(formobjid) ON DELETE CASCADE
WITH NO INDEX
\p\g
alter table harexternassoc add constraint harexternassoc_pkg_fk  
FOREIGN KEY (packageobjid) REFERENCES "mdbadmin"
.harpackage(packageobjid) ON DELETE CASCADE
\p\g
alter table harexternassoc add constraint harexternassoc_usr_fk  
FOREIGN KEY (usrobjid) REFERENCES "mdbadmin".harallusers(usrobjid)
\p\g
alter table harfileextension add constraint harfileextension_repid_fk 
FOREIGN KEY (repositobjid) REFERENCES "mdbadmin"
.harrepository(repositobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harform add constraint harform_ftid_fk  FOREIGN KEY 
(formtypeobjid) REFERENCES "mdbadmin".harformtype(formtypeobjid) ON 
DELETE CASCADE
\p\g
alter table harformhistory add constraint harformhist_formid_fk  
FOREIGN KEY (formobjid) REFERENCES "mdbadmin".harform(formobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harformtypeaccess add constraint harformtypeaccess_ftid_fk
FOREIGN KEY (formtypeobjid) REFERENCES "mdbadmin"
.harformtype(formtypeobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harformtypeaccess add constraint 
harformtypeaccess_usrgrpid_fk  FOREIGN KEY (usrgrpobjid) REFERENCES 
"mdbadmin".harusergroup(usrgrpobjid) ON DELETE CASCADE
\p\g
alter table harformtypedefs add constraint harformtypedefs_ftid_fk  
FOREIGN KEY (formtypeobjid) REFERENCES "mdbadmin"
.harformtype(formtypeobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harharvest add constraint harharvest_usrgrpid_fk  FOREIGN 
KEY (usrgrpobjid) REFERENCES "mdbadmin".harusergroup(usrgrpobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harintmrgproc add constraint harintmrgproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table haritemaccess add constraint haritemaccess_usrgrpid_fk  
FOREIGN KEY (usrgrpobjid) REFERENCES "mdbadmin"
.harusergroup(usrgrpobjid) ON DELETE CASCADE
\p\g
alter table haritemrelationship add constraint haritemrel_verid_fk  
FOREIGN KEY (versionobjid) REFERENCES "mdbadmin"
.harversions(versionobjid) ON DELETE CASCADE
\p\g
alter table haritems add constraint haritems_pid_fk  FOREIGN KEY 
(parentobjid) REFERENCES "mdbadmin".haritems(itemobjid) ON DELETE 
CASCADE
\p\g
alter table harlinkedprocess add constraint harlinkedprocess_spid_fk  
FOREIGN KEY (stateobjid, parentprocobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harlinkedprocess add constraint 
harlinkedprocess_stateid_fk  FOREIGN KEY (stateobjid) REFERENCES 
"mdbadmin".harstate(stateobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harlistdiffproc add constraint harlistdiffproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harlistversproc add constraint harlistversproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harmovepkgproc add constraint harmovepkgproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harmr add constraint harmr_formid_fk  FOREIGN KEY 
(formobjid) REFERENCES "mdbadmin".harform(formobjid) ON DELETE CASCADE
WITH NO INDEX
\p\g
alter table harnotify add constraint harnotify_ppid_fk  FOREIGN KEY 
(parentprocobjid, processobjid) REFERENCES "mdbadmin"
.harlinkedprocess(parentprocobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harnotify add constraint harnotify_spid_fk  FOREIGN KEY 
(stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harnotifylist add constraint harnotifylist_usrgrpid_fk  
FOREIGN KEY (usrgrpobjid) REFERENCES "mdbadmin"
.harusergroup(usrgrpobjid) ON DELETE CASCADE
\p\g
alter table harpac add constraint harpac_formid_fk  FOREIGN KEY 
(formobjid) REFERENCES "mdbadmin".harform(formobjid) ON DELETE CASCADE
WITH NO INDEX
\p\g
alter table harpackage add constraint harpackage_aid_fk  FOREIGN KEY 
(assigneeid) REFERENCES "mdbadmin".harallusers(usrobjid)
\p\g
alter table harpackage add constraint harpackage_envid_fk  FOREIGN KEY
(envobjid) REFERENCES "mdbadmin".harenvironment(envobjid) ON DELETE 
CASCADE WITH (INDEX = "harpackage_ind_env")
\p\g
alter table harpackagegroup add constraint harpackagegroup_envid_fk  
FOREIGN KEY (envobjid) REFERENCES "mdbadmin".harenvironment(envobjid) 
ON DELETE CASCADE WITH (INDEX = "harpkggrp_ind")
\p\g
alter table harpkghistory add constraint harpkghistory_pkgid_fk  
FOREIGN KEY (packageobjid) REFERENCES "mdbadmin"
.harpackage(packageobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harpkgsinpkggrp add constraint harpkgsingrp_pkggrpid_fk  
FOREIGN KEY (pkggrpobjid) REFERENCES "mdbadmin"
.harpackagegroup(pkggrpobjid) ON DELETE CASCADE WITH (INDEX = 
"harpkgsinpkggrp_ind")
\p\g
alter table harpkgsinpkggrp add constraint harpkgsingrp_pkgid_fk  
FOREIGN KEY (packageobjid) REFERENCES "mdbadmin"
.harpackage(packageobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harproblemreport add constraint harproblemreport_formid_fk
FOREIGN KEY (formobjid) REFERENCES "mdbadmin".harform(formobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harpromoteproc add constraint harpromoteproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harqanda add constraint harqanda_formid_fk  FOREIGN KEY 
(formobjid) REFERENCES "mdbadmin".harform(formobjid) ON DELETE CASCADE
WITH NO INDEX
\p\g
alter table harreceiveupdates add constraint recupd_cfg_fkey  FOREIGN 
KEY (configobjid) REFERENCES "mdbadmin".harsyncconfig(configobjid) 
WITH NO INDEX
\p\g
alter table harreceiveupdates add constraint recupd_sync_fkey  FOREIGN
KEY (syncobjid) REFERENCES "mdbadmin".harsync(syncobjid)
\p\g
alter table harremitemproc add constraint harremitemproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harrenameitemproc add constraint harrenameitemproc_spid_fk
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harrepinview add constraint harrepinview_repid_fk  FOREIGN
KEY (repositobjid) REFERENCES "mdbadmin".harrepository(repositobjid) 
ON DELETE CASCADE
\p\g
alter table harrepinview add constraint harrepinview_viewid_fk  
FOREIGN KEY (viewobjid) REFERENCES "mdbadmin".harview(viewobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harrepositoryaccess add constraint harrepaccess_repid_fk  
FOREIGN KEY (repositobjid) REFERENCES "mdbadmin"
.harrepository(repositobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harrepositoryaccess add constraint harrepaccess_usrgrp_fk 
FOREIGN KEY (usrgrpobjid) REFERENCES "mdbadmin"
.harusergroup(usrgrpobjid) ON DELETE CASCADE
\p\g
alter table harsendupdates add constraint sndupd_cfg_fkey  FOREIGN KEY
(configobjid) REFERENCES "mdbadmin".harsyncconfig(configobjid) WITH NO
INDEX
\p\g
alter table harsnapviewproc add constraint harsnapviewproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harstate add constraint harstate_envid_fk  FOREIGN KEY 
(envobjid) REFERENCES "mdbadmin".harenvironment(envobjid) ON DELETE 
CASCADE
\p\g
alter table harstate add constraint harstate_viewid_fk  FOREIGN KEY 
(viewobjid) REFERENCES "mdbadmin".harview(viewobjid)
\p\g
alter table harstate add constraint harstate_pmstatusindex_fk  FOREIGN
KEY (pmstatusindex) REFERENCES "mdbadmin".harpmstatus(pmstatusindex)
\p\g
alter table harstateaccess add constraint harstateaccess_stateid_fk  
FOREIGN KEY (stateobjid) REFERENCES "mdbadmin".harstate(stateobjid) ON
DELETE CASCADE WITH NO INDEX
\p\g
alter table harstateaccess add constraint harstateaccess_usrgrpid_fk  
FOREIGN KEY (usrgrpobjid) REFERENCES "mdbadmin"
.harusergroup(usrgrpobjid) ON DELETE CASCADE
\p\g
alter table harstateprocess add constraint harstateproc_stateid_fk  
FOREIGN KEY (stateobjid) REFERENCES "mdbadmin".harstate(stateobjid) ON
DELETE CASCADE WITH NO INDEX
\p\g
alter table harstateprocessaccess add constraint 
harstateprocaccess_spid_fk  FOREIGN KEY (stateobjid, processobjid) 
REFERENCES "mdbadmin".harstateprocess(stateobjid, processobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harstateprocessaccess add constraint 
harstateprocaccess_usrgrp_fk  FOREIGN KEY (usrgrpobjid) REFERENCES 
"mdbadmin".harusergroup(usrgrpobjid) ON DELETE CASCADE
\p\g
alter table harsync add constraint sync_cfg_fkey  FOREIGN KEY 
(configobjid) REFERENCES "mdbadmin".harsyncconfig(configobjid)
\p\g
alter table harsyncconfig add constraint site_fkey  FOREIGN KEY 
(siteobjid) REFERENCES "mdbadmin".harsite(siteobjid) ON DELETE CASCADE
\p\g
alter table hartestinginfo add constraint hartestinginfo_formid_fk  
FOREIGN KEY (formobjid) REFERENCES "mdbadmin".harform(formobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harudp add constraint harudp_ppid_fk  FOREIGN KEY 
(parentprocobjid, processobjid) REFERENCES "mdbadmin"
.harlinkedprocess(parentprocobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harudp add constraint harudp_spid_fk  FOREIGN KEY 
(stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE
\p\g
alter table harusercontact add constraint harusercontact_formid_fk  
FOREIGN KEY (formobjid) REFERENCES "mdbadmin".harform(formobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harusersingroup add constraint harusringrp_usrgrpid_fk  
FOREIGN KEY (usrgrpobjid) REFERENCES "mdbadmin"
.harusergroup(usrgrpobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harusersingroup add constraint harusringrp_usrid_fk  
FOREIGN KEY (usrobjid) REFERENCES "mdbadmin".haruser(usrobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harversiondelta add constraint harversiondelta_chidid_fk  
FOREIGN KEY (childversiondataid) REFERENCES "mdbadmin"
.harversiondata(versiondataobjid) ON DELETE CASCADE WITH NO INDEX
\p\g
alter table harversiondelta add constraint harversiondelta_parentid_fk
FOREIGN KEY (parentversiondataid) REFERENCES "mdbadmin"
.harversiondata(versiondataobjid) ON DELETE CASCADE
\p\g
alter table harversioninview add constraint harversioninview_verid_fk 
FOREIGN KEY (versionobjid) REFERENCES "mdbadmin"
.harversions(versionobjid) ON DELETE CASCADE
\p\g
alter table harversioninview add constraint harversioninview_viewid_fk
FOREIGN KEY (viewobjid) REFERENCES "mdbadmin".harview(viewobjid) ON 
DELETE CASCADE WITH NO INDEX
\p\g
alter table harversions add constraint harversions_pkgid_fk  FOREIGN 
KEY (packageobjid) REFERENCES "mdbadmin".harpackage(packageobjid) WITH
(INDEX = "harversions_pkg_ind")
\p\g
alter table harversions add constraint harversions_itemid_fk  FOREIGN 
KEY (itemobjid) REFERENCES "mdbadmin".haritems(itemobjid) ON DELETE 
CASCADE WITH (INDEX = "harversions_item_ind")
\p\g
alter table harview add constraint harview_envid_fk  FOREIGN KEY 
(envobjid) REFERENCES "mdbadmin".harenvironment(envobjid) ON DELETE 
CASCADE
\p\g
alter table harpasswordpolicy add constraint 
harpasswordpolicy_modid_fk  FOREIGN KEY (modifierid) REFERENCES 
"mdbadmin".harallusers(usrobjid)
\p\g
alter table harpasswordhistory add constraint harpasswordhistory_pk  
PRIMARY KEY(usrobjid)
\p\g
alter table haruserdata add constraint haruserdata_usrid_fk  FOREIGN 
KEY (usrobjid) REFERENCES "mdbadmin".haruser(usrobjid) ON DELETE 
CASCADE
\p\g
alter table harpasswordhistory add constraint harpasswordhistory_fk  
FOREIGN KEY (usrobjid) REFERENCES "mdbadmin".haruser(usrobjid) ON 
DELETE CASCADE
\p\g
alter table harswitchpkgproc add constraint harswitchpkgproc_pk  
PRIMARY KEY(processobjid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table harswitchpkgproc add constraint harswitchpkgproc_spid_fk  
FOREIGN KEY (stateobjid, processobjid) REFERENCES "mdbadmin"
.harstateprocess(stateobjid, processobjid) ON DELETE CASCADE WITH 
(INDEX = "harswitchpkgproc_spid_ind")
\p\g
alter table report_pki add  PRIMARY KEY(buttontext) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table crltable add  PRIMARY KEY(sernum) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table profile_pki add  PRIMARY KEY(name, version) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table crepository add  UNIQUE(regno) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table crepository add  UNIQUE(mackey)
\p\g
alter table certificate add  PRIMARY KEY(serno) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table actiontype add  PRIMARY KEY(actiontype) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table action add  PRIMARY KEY(actionid) WITH (INDEX = BASE TABLE
STRUCTURE)
\p\g
alter table externalaction add  PRIMARY KEY(actionid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table actiongroup add  PRIMARY KEY(actiongroupid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table revocationrequest add  PRIMARY KEY(requestid) WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table emailaction add  PRIMARY KEY(actionid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table approvalaction add  PRIMARY KEY(actionid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table racaction add  PRIMARY KEY(actionid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table keys add  PRIMARY KEY(keyid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table renewalrequest add  PRIMARY KEY(requestid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table recoverrequest add  PRIMARY KEY(requestid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table requesttype add  PRIMARY KEY(requesttype) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table request_pki add  PRIMARY KEY(requestid) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table certificaterequest add  PRIMARY KEY(requestid) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table certificaterequest add  FOREIGN KEY (requestid) REFERENCES
"mdbadmin".request_pki(requestid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table action add  FOREIGN KEY (actiongroupid) REFERENCES 
"mdbadmin".actiongroup(actiongroupid)
\p\g
alter table action add  FOREIGN KEY (actiontype) REFERENCES "mdbadmin"
.actiontype(actiontype)
\p\g
alter table request_pki add  FOREIGN KEY (requesttype) REFERENCES 
"mdbadmin".requesttype(requesttype)
\p\g
alter table recoverrequest add  FOREIGN KEY (requestid) REFERENCES 
"mdbadmin".request_pki(requestid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table renewalrequest add  FOREIGN KEY (requestid) REFERENCES 
"mdbadmin".request_pki(requestid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table racaction add  FOREIGN KEY (actionid) REFERENCES 
"mdbadmin".action(actionid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table approvalaction add  FOREIGN KEY (actionid) REFERENCES 
"mdbadmin".action(actionid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table emailaction add  FOREIGN KEY (actionid) REFERENCES 
"mdbadmin".action(actionid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table revocationrequest add  FOREIGN KEY (requestid) REFERENCES 
"mdbadmin".request_pki(requestid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table actiongroup add  FOREIGN KEY (requestid) REFERENCES 
"mdbadmin".request_pki(requestid)
\p\g
alter table externalaction add  FOREIGN KEY (actionid) REFERENCES 
"mdbadmin".action(actionid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table eventseverity add constraint pk_eventseverity  PRIMARY 
KEY(eventseverityid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table eventseverity add  UNIQUE(eventseverityname)
\p\g
alter table eventtype add constraint pk_eventtype  PRIMARY 
KEY(eventtypeid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table eventtype add  UNIQUE(eventtypename)
\p\g
alter table connectortype add constraint pk_connectortype  PRIMARY 
KEY(connectortypeid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table connectortype add  UNIQUE(connectortypename)
\p\g
alter table server_collector add constraint pk_server_collector  
PRIMARY KEY(collectorid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table server_collector add  FOREIGN KEY (parentcollectorid) 
REFERENCES "mdbadmin".server_collector
\p\g
alter table server_collector add  UNIQUE(collectorname)
\p\g
alter table sourcelocale add constraint pk_sourcelocale  PRIMARY 
KEY(localeid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table sourcelocale add  UNIQUE(localename)
\p\g
alter table sourcelocale add  UNIQUE(langcode)
\p\g
alter table cluster add constraint pk_cluster  PRIMARY KEY(clusterid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table cluster add  UNIQUE(clustername)
\p\g
alter table mailorganisation add constraint pk_mailorganisation  
PRIMARY KEY(mailorgid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mailorganisation add  UNIQUE(organisationname)
\p\g
alter table server_site add constraint pk_server_site  PRIMARY 
KEY(siteid, mailorgid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table server_site add  FOREIGN KEY (mailorgid) REFERENCES 
"mdbadmin".mailorganisation
\p\g
alter table server_site add  UNIQUE(sitename)
\p\g
alter table countersource add constraint pk_countersource  PRIMARY 
KEY(sourceid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table countersource add  FOREIGN KEY (collectorid) REFERENCES 
"mdbadmin".server_collector
\p\g
alter table countersource add  FOREIGN KEY (localeid) REFERENCES 
"mdbadmin".sourcelocale
\p\g
alter table countersource add  FOREIGN KEY (clusterid) REFERENCES 
"mdbadmin".cluster
\p\g
alter table countersource add  FOREIGN KEY (siteid, mailorgid) 
REFERENCES "mdbadmin".server_site
\p\g
alter table countersource add  UNIQUE(sourcename)
\p\g
alter table maildomain add constraint pk_maildomain  PRIMARY 
KEY(sourceid, maildomainid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table maildomain add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table maildomain add  UNIQUE(sourceid, maildomainname)
\p\g
alter table mailobject add constraint pk_mailobject  PRIMARY 
KEY(sourceid, mailobjectid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mailobject add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table mailobject add  UNIQUE(sourceid, mailobjectname, 
mailobjecttype)
\p\g
alter table unit add constraint pk_unit  PRIMARY KEY(unitid) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table unit add  UNIQUE(unitname)
\p\g
alter table server_collectoraction add constraint 
pk_server_collectoraction  PRIMARY KEY(actionid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table server_collectoraction add  UNIQUE(actionname)
\p\g
alter table server_collectoraction add  UNIQUE(actiontype)
\p\g
alter table server_schedule add constraint pk_server_schedule  PRIMARY
KEY(collectorid, actionid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table server_schedule add  FOREIGN KEY (actionid) REFERENCES 
"mdbadmin".server_collectoraction
\p\g
alter table server_schedule add  FOREIGN KEY (collectorid) REFERENCES 
"mdbadmin".server_collector
\p\g
alter table reporttabledefinition add constraint 
pk_reporttabledefinition  PRIMARY KEY(reporttableid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table counterdefinition add constraint pk_counterdefinition  
PRIMARY KEY(counterid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table counterdefinition add  FOREIGN KEY (unitid) REFERENCES 
"mdbadmin".unit
\p\g
alter table counterdefinition add  UNIQUE(fullcountername)
\p\g
alter table reporttable add constraint pk_reporttable  PRIMARY 
KEY(counterid, reporttableid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table reporttable add  FOREIGN KEY (reporttableid) REFERENCES 
"mdbadmin".reporttabledefinition
\p\g
alter table reporttable add  FOREIGN KEY (counterid) REFERENCES 
"mdbadmin".counterdefinition
\p\g
alter table management_report add constraint pk_management_report  
PRIMARY KEY(reportid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table management_report add  UNIQUE(title)
\p\g
alter table reportcolumn add constraint pk_reportcolumn  PRIMARY 
KEY(columnid, reportid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table reportcolumn add  FOREIGN KEY (reportid) REFERENCES 
"mdbadmin".management_report
\p\g
alter table reportcolumn add  FOREIGN KEY (thresholdcolumnid, 
thresholdreportid) REFERENCES "mdbadmin".reportcolumn
\p\g
alter table reportcolumn add  FOREIGN KEY (unitid) REFERENCES 
"mdbadmin".unit
\p\g
alter table management_product add constraint pk_management_product  
PRIMARY KEY(prodname) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table server_person add constraint pk_server_person  PRIMARY 
KEY(sourceid, personid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table server_person add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table server_person add  UNIQUE(personname, sourceid)
\p\g
alter table mailservice add constraint pk_mailservice  PRIMARY 
KEY(sourceid, mailserviceid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mailservice add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table mailservice add  UNIQUE(mailservicename, sourceid)
\p\g
alter table mailconnector add constraint pk_mailconnector  PRIMARY 
KEY(sourceid, mailconnectorid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mailconnector add  FOREIGN KEY (connectortypeid) 
REFERENCES "mdbadmin".connectortype
\p\g
alter table mailconnector add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table mailconnector add  UNIQUE(mailconnectorname, 
connectortypeid, sourceid)
\p\g
alter table maildisk add constraint pk_maildisk  PRIMARY KEY(sourceid,
maildiskid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table maildisk add  FOREIGN KEY (sourceid) REFERENCES "mdbadmin"
.countersource
\p\g
alter table maildisk add  UNIQUE(maildiskname, sourceid)
\p\g
alter table dominoeventtype add constraint pk_dominoeventtype  PRIMARY
KEY(dominoeventtypeid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table dominoeventtype add  UNIQUE(dominoeventtypename)
\p\g
alter table dominologeventtype add constraint pk_dominologeventtype  
PRIMARY KEY(dominologeventtypeid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table dominologeventtype add  UNIQUE(dominologeventtypename)
\p\g
alter table mailevent add constraint pk_mailevent  PRIMARY 
KEY(sourceid, maileventid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mailevent add  FOREIGN KEY (eventtypeid) REFERENCES 
"mdbadmin".eventtype
\p\g
alter table mailevent add  FOREIGN KEY (eventseverityid) REFERENCES 
"mdbadmin".eventseverity
\p\g
alter table mailevent add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table mailevent add  FOREIGN KEY (dominologeventtypeid) 
REFERENCES "mdbadmin".dominologeventtype
\p\g
alter table mailevent add  FOREIGN KEY (dominoeventtypeid) REFERENCES 
"mdbadmin".dominoeventtype
\p\g
alter table mailevent add  UNIQUE(sourceid, eventtypeid, 
maileventname)
\p\g
alter table maildb add constraint pk_maildb  PRIMARY KEY(sourceid, 
maildbid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table maildb add  FOREIGN KEY (sourceid) REFERENCES "mdbadmin"
.countersource
\p\g
alter table maildb add  UNIQUE(maildbname, sourceid)
\p\g
alter table mailqueue add constraint pk_mailqueue  PRIMARY 
KEY(sourceid, mailqueueid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mailqueue add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table mailqueue add  UNIQUE(mailqueuename, queuetype, sourceid)
\p\g
alter table objects add constraint pk_objects  PRIMARY KEY(objectid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table objects add  FOREIGN KEY (objectsourceid, mailobjectid) 
REFERENCES "mdbadmin".mailobject
\p\g
alter table objects add  FOREIGN KEY (queuesourceid, mailqueueid) 
REFERENCES "mdbadmin".mailqueue
\p\g
alter table objects add  FOREIGN KEY (dbsourceid, maildbid) REFERENCES
"mdbadmin".maildb
\p\g
alter table objects add  FOREIGN KEY (eventsourceid, maileventid) 
REFERENCES "mdbadmin".mailevent
\p\g
alter table objects add  FOREIGN KEY (domainsourceid, maildomainid) 
REFERENCES "mdbadmin".maildomain
\p\g
alter table objects add  FOREIGN KEY (disksourceid, maildiskid) 
REFERENCES "mdbadmin".maildisk
\p\g
alter table objects add  FOREIGN KEY (connectorsourceid, 
mailconnectorid) REFERENCES "mdbadmin".mailconnector
\p\g
alter table objects add  FOREIGN KEY (servicesourceid, mailserviceid) 
REFERENCES "mdbadmin".mailservice
\p\g
alter table objects add  FOREIGN KEY (clusterid) REFERENCES "mdbadmin"
.cluster
\p\g
alter table countertitle add constraint pk_countertitle  PRIMARY 
KEY(localeid, counterid, sourcetype) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table countertitle add  FOREIGN KEY (localeid) REFERENCES 
"mdbadmin".sourcelocale
\p\g
alter table countertitle add  FOREIGN KEY (counterid) REFERENCES 
"mdbadmin".counterdefinition
\p\g
alter table counterpolling add constraint pk_counterpolling  PRIMARY 
KEY(sourceid, counterid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table counterpolling add  FOREIGN KEY (counterid) REFERENCES 
"mdbadmin".counterdefinition
\p\g
alter table counterpolling add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table counterdata add constraint pk_counterdata  PRIMARY 
KEY(counterid, sourceid, counterdataid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table counterdata add  FOREIGN KEY (counterid) REFERENCES 
"mdbadmin".counterdefinition
\p\g
alter table counterdata add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table counterdata add  FOREIGN KEY (objectid) REFERENCES 
"mdbadmin".objects
\p\g
alter table counterdata add  FOREIGN KEY (personsourceid, personid) 
REFERENCES "mdbadmin".server_person
\p\g
alter table collectorpolling add constraint pk_collectorpolling  
PRIMARY KEY(collectorid, counterid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table collectorpolling add  FOREIGN KEY (collectorid) REFERENCES
"mdbadmin".server_collector
\p\g
alter table collectorpolling add  FOREIGN KEY (counterid) REFERENCES 
"mdbadmin".counterdefinition
\p\g
alter table management_alert add constraint pk_management_alert  
PRIMARY KEY(counterid, sourceid, alertid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table management_alert add  FOREIGN KEY (counterid) REFERENCES 
"mdbadmin".counterdefinition
\p\g
alter table management_alert add  FOREIGN KEY (sourceid) REFERENCES 
"mdbadmin".countersource
\p\g
alter table management_alert add  FOREIGN KEY (objectid) REFERENCES 
"mdbadmin".objects
\p\g
alter table management_alert add  FOREIGN KEY (personsourceid, 
personid) REFERENCES "mdbadmin".server_person
\p\g
alter table errormessage add constraint pk_errormessage  PRIMARY 
KEY(errormessageid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table solutiondescription add constraint pk_solutiondescription 
PRIMARY KEY(solutiondescriptionid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table errorsolution add constraint pk_errorsolution  PRIMARY 
KEY(errormessageid, solutiondescriptionid) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table errorsolution add  FOREIGN KEY (solutiondescriptionid) 
REFERENCES "mdbadmin".solutiondescription
\p\g
alter table errorsolution add  FOREIGN KEY (errormessageid) REFERENCES
"mdbadmin".errormessage
\p\g
alter table process_type add  PRIMARY KEY(process_type_id) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table process_schedule add  PRIMARY KEY(process_schedule_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table protection_level add  PRIMARY KEY(protection_level_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table language add  PRIMARY KEY(language_id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table application_type add  PRIMARY KEY(application_type_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table system_configuration add  PRIMARY KEY(unit_id) WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table vuln_management_configuration add  PRIMARY KEY(unit_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table evm_appliance_configuration add  PRIMARY KEY(unit_id) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table vunerability_asset_group add  PRIMARY KEY(asset_group_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table asset_group_process_schedule add  PRIMARY 
KEY(asset_grp_proc_sched_rec_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table vuln_management_backup_config add  PRIMARY KEY(unit_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table applied_remediation_status add  PRIMARY 
KEY(applied_remed_status_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table inventory_profile add  PRIMARY KEY(inventory_profile_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table remediation_profile add  PRIMARY KEY(remed_profile_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table release add  PRIMARY KEY(sw_def_uuid) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table asset_detection_profile_status add  PRIMARY 
KEY(asset_detect_profile_status_id) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table global_status_event add  PRIMARY KEY(global_status_rec_id)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table evm_discovered_software add  PRIMARY KEY(dis_sw_uuid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table discovered_list add  PRIMARY KEY(discovered_list_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table vulnerability add  PRIMARY KEY(vuln_id) WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table configuration_standard_vuln add  PRIMARY KEY(vuln_id) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table evm_company add  PRIMARY KEY(company_uuid) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table evm_discovered_hardware add  PRIMARY KEY(dis_hw_uuid) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table asset_work_archive add  PRIMARY KEY(archive_rec_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table asset_detection_profile add  PRIMARY 
KEY(asset_detection_profile_rec_id) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table applied_remediation add  PRIMARY 
KEY(applied_remediation_rec_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table application_option add  PRIMARY KEY(application_option_id)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table reference_group add  PRIMARY KEY(reference_group_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table reference_source add  PRIMARY KEY(reference_source_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table reference_source_vuln_matrix add  PRIMARY 
KEY(reference_source_vuln_rec_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ref_ref_source_matrix add  PRIMARY KEY(ref_ref_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table configuration_standard_set add  PRIMARY 
KEY(config_standard_set_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table bp_standard_category add  PRIMARY 
KEY(bp_standard_category_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table config_vuln_category_matrix add  PRIMARY 
KEY(config_vuln_cat_rec_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table detection_profile add  PRIMARY KEY(inventory_profile_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table remed_prof_detect_prof_matrix add  PRIMARY 
KEY(remed_detect_profile_rec_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table root_cause add  PRIMARY KEY(root_cause_id) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table software_vulnerability add  PRIMARY KEY(vuln_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table validation_method add  PRIMARY KEY(validation_method_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table vulnerability_vailidation_method add  PRIMARY 
KEY(vuln_validation_rec_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table profile_expression_step add  PRIMARY 
KEY(profile_expression_step_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table user_acct_asset_group_matrix add  PRIMARY 
KEY(user_account_asset_group_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table process_schedule add  FOREIGN KEY (process_type_id) 
REFERENCES "mdbadmin".process_type ON DELETE SET NULL ON UPDATE SET 
NULL
\p\g
alter table system_configuration add  FOREIGN KEY 
(application_type_id) REFERENCES "mdbadmin".application_type ON DELETE
SET NULL ON UPDATE SET NULL
\p\g
alter table vuln_management_configuration add  FOREIGN KEY 
(preferred_language_id) REFERENCES "mdbadmin".language ON DELETE SET 
NULL ON UPDATE SET NULL
\p\g
alter table vuln_management_configuration add  FOREIGN KEY (unit_id) 
REFERENCES "mdbadmin".system_configuration ON DELETE CASCADE ON UPDATE
CASCADE WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table evm_appliance_configuration add  FOREIGN KEY (unit_id) 
REFERENCES "mdbadmin".vuln_management_configuration WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table vunerability_asset_group add  FOREIGN KEY 
(protection_level_id) REFERENCES "mdbadmin".protection_level
\p\g
alter table vunerability_asset_group add  FOREIGN KEY (unit_id) 
REFERENCES "mdbadmin".evm_appliance_configuration
\p\g
alter table asset_group_process_schedule add  FOREIGN KEY 
(process_schedule_id) REFERENCES "mdbadmin".process_schedule
\p\g
alter table asset_group_process_schedule add  FOREIGN KEY 
(asset_group_id) REFERENCES "mdbadmin".vunerability_asset_group
\p\g
alter table vuln_management_backup_config add  FOREIGN KEY (unit_id) 
REFERENCES "mdbadmin".vuln_management_configuration WITH (INDEX = BASE
TABLE STRUCTURE)
\p\g
alter table remediation_profile add  FOREIGN KEY (remed_profile_id) 
REFERENCES "mdbadmin".inventory_profile WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table release add  FOREIGN KEY (sw_def_uuid) REFERENCES 
"mdbadmin".ca_software_def
\p\g
alter table global_status_event add  FOREIGN KEY (old_status_id) 
REFERENCES "mdbadmin".asset_detection_profile_status
\p\g
alter table global_status_event add  FOREIGN KEY (new_status_id) 
REFERENCES "mdbadmin".asset_detection_profile_status
\p\g
alter table evm_discovered_software add  FOREIGN KEY (dis_sw_uuid) 
REFERENCES "mdbadmin".ca_discovered_software
\p\g
alter table configuration_standard_vuln add  FOREIGN KEY (vuln_id) 
REFERENCES "mdbadmin".vulnerability WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table evm_company add  FOREIGN KEY (company_uuid) REFERENCES 
"mdbadmin".ca_company
\p\g
alter table evm_discovered_hardware add  FOREIGN KEY (dis_hw_uuid) 
REFERENCES "mdbadmin".ca_discovered_hardware
\p\g
alter table evm_discovered_hardware add  FOREIGN KEY (asset_group_id) 
REFERENCES "mdbadmin".vunerability_asset_group
\p\g
alter table asset_detection_profile add  FOREIGN KEY (dis_hw_uuid) 
REFERENCES "mdbadmin".evm_discovered_hardware
\p\g
alter table asset_detection_profile add  FOREIGN KEY 
(asset_detect_profile_status_id) REFERENCES "mdbadmin"
.asset_detection_profile_status
\p\g
alter table asset_detection_profile add  FOREIGN KEY 
(global_status_rec_id) REFERENCES "mdbadmin".global_status_event
\p\g
alter table applied_remediation add  FOREIGN KEY 
(applied_remed_status_id) REFERENCES "mdbadmin"
.applied_remediation_status
\p\g
alter table applied_remediation add  FOREIGN KEY 
(asset_detection_profile_rec_id) REFERENCES "mdbadmin"
.asset_detection_profile
\p\g
alter table applied_remediation add  FOREIGN KEY 
(remediation_profile_id) REFERENCES "mdbadmin".remediation_profile
\p\g
alter table application_option add  FOREIGN KEY (unit_id) REFERENCES 
"mdbadmin".system_configuration
\p\g
alter table reference_source add  FOREIGN KEY (reference_group_id) 
REFERENCES "mdbadmin".reference_group
\p\g
alter table reference_source_vuln_matrix add  FOREIGN KEY (vuln_id) 
REFERENCES "mdbadmin".vulnerability
\p\g
alter table reference_source_vuln_matrix add  FOREIGN KEY 
(reference_source_id) REFERENCES "mdbadmin".reference_source
\p\g
alter table ref_ref_source_matrix add  FOREIGN KEY 
(reference_source_id_2) REFERENCES "mdbadmin".reference_source
\p\g
alter table ref_ref_source_matrix add  FOREIGN KEY 
(reference_source_id_1) REFERENCES "mdbadmin".reference_source
\p\g
alter table bp_standard_category add  FOREIGN KEY 
(config_standard_set_id) REFERENCES "mdbadmin"
.configuration_standard_set
\p\g
alter table config_vuln_category_matrix add  FOREIGN KEY (vuln_id) 
REFERENCES "mdbadmin".configuration_standard_vuln
\p\g
alter table config_vuln_category_matrix add  FOREIGN KEY 
(bp_standard_category_id) REFERENCES "mdbadmin".bp_standard_category
\p\g
alter table detection_profile add  FOREIGN KEY (vuln_id) REFERENCES 
"mdbadmin".vulnerability
\p\g
alter table detection_profile add  FOREIGN KEY (inventory_profile_id) 
REFERENCES "mdbadmin".inventory_profile WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table remed_prof_detect_prof_matrix add  FOREIGN KEY 
(remed_profile_id) REFERENCES "mdbadmin".remediation_profile
\p\g
alter table remed_prof_detect_prof_matrix add  FOREIGN KEY 
(detect_profile_id) REFERENCES "mdbadmin".detection_profile
\p\g
alter table software_vulnerability add  FOREIGN KEY (vuln_id) 
REFERENCES "mdbadmin".vulnerability ON DELETE CASCADE ON UPDATE 
CASCADE WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table software_vulnerability add  FOREIGN KEY (root_cause_id) 
REFERENCES "mdbadmin".root_cause
\p\g
alter table vulnerability_vailidation_method add  FOREIGN KEY 
(vuln_id) REFERENCES "mdbadmin".software_vulnerability
\p\g
alter table vulnerability_vailidation_method add  FOREIGN KEY 
(validation_method_id) REFERENCES "mdbadmin".validation_method
\p\g
alter table profile_expression_step add  FOREIGN KEY 
(inventory_profile_id) REFERENCES "mdbadmin".inventory_profile
\p\g
alter table profile_expression_step add  FOREIGN KEY 
(group_expression_step_id) REFERENCES "mdbadmin"
.profile_expression_step
\p\g
alter table profile_expression_step add  FOREIGN KEY (sw_def_uuid) 
REFERENCES "mdbadmin".ca_software_def
\p\g
alter table user_acct_asset_group_matrix add  FOREIGN KEY 
(asset_group_id) REFERENCES "mdbadmin".vunerability_asset_group ON 
DELETE SET NULL ON UPDATE SET NULL
\p\g
alter table actors add constraint pk_actors  PRIMARY KEY("actor") WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table stats add constraint pk_stats  PRIMARY KEY(workitemid) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table user_roles add constraint pk_user_roles  PRIMARY 
KEY(user_name, role_name) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table users add constraint pk_users  PRIMARY KEY(user_name) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table reorg_part_tables add  PRIMARY KEY(part_key) WITH (INDEX =
BASE TABLE STRUCTURE)
\p\g
alter table tsr_stats add  PRIMARY KEY(job_id, job_run) WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table collect add  PRIMARY KEY(collect_id) WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table tablespace add  PRIMARY KEY("tablespace_id") WITH (INDEX =
BASE TABLE STRUCTURE)
\p\g
alter table scope_head add  PRIMARY KEY("scope_head_id") WITH (INDEX =
BASE TABLE STRUCTURE)
\p\g
alter table user_head add  PRIMARY KEY("user_head_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table filter_head add  PRIMARY KEY("filter_head_id") WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table filter_head add constraint filter_head_and_or CHECK 
(FILTER_AND_OR BETWEEN 0 AND 1)
\p\g
alter table filter_head add constraint filter_ora_version CHECK 
(FILTER_ORA_VERSION BETWEEN 7 AND 8)
\p\g
alter table datafile add  PRIMARY KEY("datafile_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table datafile add  FOREIGN KEY ("collect_id") REFERENCES 
"mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table report_view add  PRIMARY KEY("report_view_id") WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table role_priv add  PRIMARY KEY("role_priv_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table role_priv add  FOREIGN KEY ("collect_id") REFERENCES 
"mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table scope_det add  PRIMARY KEY("scope_det_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table scope_det add constraint scope_det_incl_excl CHECK 
(INCL_EXCL BETWEEN 0 AND 1)
\p\g
alter table scope_det add constraint scope_det_type CHECK (OBJECT_TYPE
BETWEEN 0 AND 6)
\p\g
alter table sid add  PRIMARY KEY("sid_id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table sid add constraint unq_collect_sid  UNIQUE("collect_id", 
"sid_id")
\p\g
alter table sid add constraint unq_collect_id  UNIQUE("collect_id")
\p\g
alter table sid_param add  PRIMARY KEY("sid_param_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table sid_param add  FOREIGN KEY ("collect_id") REFERENCES 
"mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table tab_priv add  PRIMARY KEY("tab_priv_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table tab_priv add  FOREIGN KEY ("collect_id") REFERENCES 
"mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table ts_quota add  PRIMARY KEY("ts_quota_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table type add  PRIMARY KEY("type_id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table common_extent add  PRIMARY KEY("common_extent_id") WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table common_extent add  FOREIGN KEY ("collect_id") REFERENCES 
"mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table compare add  PRIMARY KEY("compare_id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table constants add  PRIMARY KEY("constant_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table constants add constraint constant_unique  
UNIQUE("constant_name", "created_by")
\p\g
alter table analyzer_event add  PRIMARY KEY("event_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table analyzer_event add  UNIQUE("event_name")
\p\g
alter table filter_compare add  PRIMARY KEY("filter_compare_id") WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table hist_det add  PRIMARY KEY("hist_det_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table report_head add  PRIMARY KEY("report_head_id") WITH (INDEX
= BASE TABLE STRUCTURE)
\p\g
alter table ref add  PRIMARY KEY("ref_id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table output_head add  UNIQUE("output_head_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table output_head add  FOREIGN KEY ("collect_id") REFERENCES 
"mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table segment_dict add  PRIMARY KEY("collect_id", "object_id") 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table segment_dict add  FOREIGN KEY ("collect_id") REFERENCES 
"mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table hist_head add  PRIMARY KEY("hist_head_id") WITH (INDEX = 
BASE TABLE STRUCTURE)
\p\g
alter table lob add  PRIMARY KEY("lob_id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table lob_fast add  PRIMARY KEY("lob_id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table analyzer_metric add  PRIMARY KEY("metric_id") WITH (INDEX 
= BASE TABLE STRUCTURE)
\p\g
alter table analyzer_metric add constraint metric_name_ver  
UNIQUE("metric_name", "metric_version")
\p\g
alter table analyzer_metric add constraint metric_name  
UNIQUE("metric_name")
\p\g
alter table output_repository add  PRIMARY KEY("output_repository_id")
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table analyzer_part_tables add  PRIMARY KEY("part_key") WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table printer add  PRIMARY KEY("printer_id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table analyzer_profile add  PRIMARY KEY("profile_id") WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table analyzer_profile add  FOREIGN KEY ("collect_id") 
REFERENCES "mdbadmin".collect("collect_id") ON DELETE CASCADE
\p\g
alter table query add  PRIMARY KEY("query_id") WITH (INDEX = BASE 
TABLE STRUCTURE)
\p\g
alter table query add constraint query_name_ver  UNIQUE("query_name", 
"query_version")
\p\g
alter table query add constraint query_scope CHECK (QUERY_SCOPE 
BETWEEN 0 AND 4)
\p\g
alter table query add constraint query_type CHECK (QUERY_TYPE BETWEEN 
0 AND 6)
\p\g
alter table rbs add  PRIMARY KEY("rbs_id") WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table rbs add  FOREIGN KEY ("collect_id") REFERENCES "mdbadmin"
.collect("collect_id") ON DELETE CASCADE
\p\g
alter table report_category add  PRIMARY KEY("report_category_id") 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mitjas_job add constraint pk_mitjas_job  PRIMARY KEY(joid)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mitjas_jobhist add constraint pk_mitjas_jobhist  PRIMARY 
KEY(joid, run_num) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mitjas_jobparms add constraint pk_mitjas_jobparms  PRIMARY
KEY(joid, parmname) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mitjas_calendar add constraint pk_mitjas_calendar  PRIMARY
KEY(id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mitjas_calen_date add constraint pk_mitjas_calen_date  
PRIMARY KEY(calendarid, rundate) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mitjas_group add constraint pk_mitjas_group  PRIMARY 
KEY(strid, groupid) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mitjas_calen_node add constraint pk_mitjas_calen_node  
PRIMARY KEY(calendarid, node) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_host add constraint pk_mit_host  PRIMARY KEY(host_id) 
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_product add constraint pk_mit_product  PRIMARY 
KEY(host_id, component_code) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_repository add constraint pk_mit_repository  PRIMARY 
KEY(keynum) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_server add constraint pk_mit_server  PRIMARY 
KEY(server_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_server_parm add constraint pk_mit_server_parm  PRIMARY
KEY(server_id, keyword) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_host_parm add constraint pk_mit_host_parm  PRIMARY 
KEY(host_id, keyword) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_server_type add constraint pk_mit_server_type  PRIMARY
KEY(server_type) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_server_user add constraint pk_mit_server_user  PRIMARY
KEY(user_id, server_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table mit_identifier add constraint pk_mit_identifier  PRIMARY 
KEY(id_type) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table contact add constraint pk_contact  PRIMARY KEY(contact_id)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table contact_list add constraint pk_contact_list  PRIMARY 
KEY(contact_list_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_user add constraint fk_ca_user_1  FOREIGN KEY 
(contact_id) REFERENCES "mdbadmin".contact(contact_id)
\p\g
alter table ca_user add constraint pk_ca_user  PRIMARY KEY(ca_user_id)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_user_preference add constraint fk_ca_user_preference_1 
FOREIGN KEY (ca_user_id) REFERENCES "mdbadmin".ca_user(ca_user_id)
\p\g
alter table ca_user_preference add constraint pk_ca_user_preference  
PRIMARY KEY(ca_user_preference_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ext_command add constraint pk_ext_command  PRIMARY 
KEY(ext_command_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table snmp_console add constraint pk_snmp_console  PRIMARY 
KEY(snmp_manager_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ca_user_principal add constraint fk_ca_user_principal_1  
FOREIGN KEY (ca_user_id) REFERENCES "mdbadmin".ca_user(ca_user_id)
\p\g
alter table ca_user_principal add constraint pk_ca_user_principal  
PRIMARY KEY(ca_user_principal_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table registered_observer add constraint pk_registered_observer 
PRIMARY KEY(observer_key) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table contact_list_contact add constraint 
fk_contact_list_contact_1  FOREIGN KEY (contact_id) REFERENCES 
"mdbadmin".contact(contact_id)
\p\g
alter table contact_list_contact add constraint 
fk_contact_list_contact_2  FOREIGN KEY (contact_list_id) REFERENCES 
"mdbadmin".contact_list(contact_list_id)
\p\g
alter table contact_list_contact add constraint 
pk_contact_list_contact  PRIMARY KEY(contact_list_contact_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table change_log add constraint pk_change_log  PRIMARY 
KEY(change_log_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table wsdl_catalog add constraint pk_wsdl_catalog  PRIMARY 
KEY(wsdl_catalog_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table wsdl_file add constraint fk_wsdl_file_1  FOREIGN KEY 
(wsdl_catalog_id) REFERENCES "mdbadmin".wsdl_catalog(wsdl_catalog_id)
\p\g
alter table wsdl_file add constraint pk_wsdl_file  PRIMARY 
KEY(wsdl_file_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table wsdl_operation add constraint fk_wsdl_operation_1  FOREIGN
KEY (wsdl_catalog_id) REFERENCES "mdbadmin"
.wsdl_catalog(wsdl_catalog_id)
\p\g
alter table wsdl_operation add constraint pk_wsdl_operation  PRIMARY 
KEY(wsdl_operation_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table time_period add constraint pk_time_period  PRIMARY 
KEY(time_period_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table time_period_attribute add constraint 
fk_time_period_attribute_1  FOREIGN KEY (time_period_id) REFERENCES 
"mdbadmin".time_period(time_period_id)
\p\g
alter table time_period_attribute add constraint 
pk_time_period_attribute  PRIMARY KEY(time_period_attribute_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table operation_group add constraint fk_operation_group_1  
FOREIGN KEY (time_period_id) REFERENCES "mdbadmin"
.time_period(time_period_id)
\p\g
alter table operation_group add constraint pk_operation_group  PRIMARY
KEY(operation_group_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ata_result add constraint fk_ata_result_1  FOREIGN KEY 
(operation_group_id) REFERENCES "mdbadmin"
.operation_group(operation_group_id)
\p\g
alter table ata_result add constraint pk_ata_result  PRIMARY 
KEY(ata_result_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table ata_result_entry add constraint fk_ata_result_entry_1  
FOREIGN KEY (ata_result_id) REFERENCES "mdbadmin"
.ata_result(ata_result_id)
\p\g
alter table ata_result_entry add constraint pk_ata_result_entry  
PRIMARY KEY(ata_result_entry_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table operation add constraint fk_operation_1  FOREIGN KEY 
(operation_group_id) REFERENCES "mdbadmin"
.operation_group(operation_group_id)
\p\g
alter table operation add constraint fk_operation_2  FOREIGN KEY 
(wsdl_operation_id) REFERENCES "mdbadmin"
.wsdl_operation(wsdl_operation_id)
\p\g
alter table operation add constraint pk_operation  PRIMARY 
KEY(operation_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table severity add constraint fk_severity_1  FOREIGN KEY 
(operation_group_id) REFERENCES "mdbadmin"
.operation_group(operation_group_id)
\p\g
alter table severity add constraint pk_severity  PRIMARY 
KEY(severity_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table monitor add constraint fk_monitor_1  FOREIGN KEY 
(operation_id) REFERENCES "mdbadmin".operation(operation_id)
\p\g
alter table monitor add constraint fk_monitor_2  FOREIGN KEY 
(operation_group_id) REFERENCES "mdbadmin"
.operation_group(operation_group_id)
\p\g
alter table monitor add constraint fk_monitor_3  FOREIGN KEY 
(severity_id) REFERENCES "mdbadmin".severity(severity_id)
\p\g
alter table monitor add constraint pk_monitor  PRIMARY KEY(monitor_id)
WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table monitor_notification add constraint 
fk_monitor_notification_1  FOREIGN KEY (contact_id) REFERENCES 
"mdbadmin".contact(contact_id)
\p\g
alter table monitor_notification add constraint 
fk_monitor_notification_2  FOREIGN KEY (contact_list_id) REFERENCES 
"mdbadmin".contact_list(contact_list_id)
\p\g
alter table monitor_notification add constraint 
fk_monitor_notification_3  FOREIGN KEY (ext_command_id) REFERENCES 
"mdbadmin".ext_command(ext_command_id)
\p\g
alter table monitor_notification add constraint 
fk_monitor_notification_4  FOREIGN KEY (severity_id) REFERENCES 
"mdbadmin".severity(severity_id)
\p\g
alter table monitor_notification add constraint 
fk_monitor_notification_5  FOREIGN KEY (snmp_manager_id) REFERENCES 
"mdbadmin".snmp_console(snmp_manager_id)
\p\g
alter table monitor_notification add constraint 
pk_monitor_notification  PRIMARY KEY(monitor_notification_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table alert_message add constraint fk_alert_message_1  FOREIGN 
KEY (monitor_id) REFERENCES "mdbadmin".monitor(monitor_id)
\p\g
alter table alert_message add constraint pk_alert_message  PRIMARY 
KEY(alert_message_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table alert_transaction add constraint fk_alert_transaction_1  
FOREIGN KEY (alert_message_id) REFERENCES "mdbadmin"
.alert_message(alert_message_id)
\p\g
alter table alert_transaction add constraint pk_alert_transaction  
PRIMARY KEY(alert_transaction_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table operation_group_monitor_type add constraint 
fk_op_group_monitor_type_1  FOREIGN KEY (operation_group_id) 
REFERENCES "mdbadmin".operation_group(operation_group_id)
\p\g
alter table operation_group_monitor_type add constraint 
pk_operation_group_monitor_type  PRIMARY 
KEY(operation_group_monitor_type_id) WITH (INDEX = BASE TABLE 
STRUCTURE)
\p\g
alter table alert_action_history add constraint 
fk_alert_action_history_1  FOREIGN KEY (alert_message_id) REFERENCES 
"mdbadmin".alert_message(alert_message_id)
\p\g
alter table alert_action_history add constraint 
pk_alert_action_history  PRIMARY KEY(alert_action_history_id) WITH 
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table alert_message_property add constraint 
fk_alert_message_property_1  FOREIGN KEY (alert_message_id) REFERENCES
"mdbadmin".alert_message(alert_message_id)
\p\g
alter table alert_message_property add constraint 
pk_alert_message_property  PRIMARY KEY(alert_message_property_id) WITH
(INDEX = BASE TABLE STRUCTURE)
\p\g
alter table monitor_property add constraint fk_monitor_property_1  
FOREIGN KEY (monitor_id) REFERENCES "mdbadmin".monitor(monitor_id)
\p\g
alter table monitor_property add constraint pk_monitor_property  
PRIMARY KEY(monitor_property_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table alert_recipient add constraint fk_alert_recipient_1  
FOREIGN KEY (alert_message_id) REFERENCES "mdbadmin"
.alert_message(alert_message_id)
\p\g
alter table alert_recipient add constraint fk_alert_recipient_2  
FOREIGN KEY (contact_id) REFERENCES "mdbadmin".contact(contact_id)
\p\g
alter table alert_recipient add constraint fk_alert_recipient_3  
FOREIGN KEY (contact_list_id) REFERENCES "mdbadmin"
.contact_list(contact_list_id)
\p\g
alter table alert_recipient add constraint fk_alert_recipient_4  
FOREIGN KEY (ext_command_id) REFERENCES "mdbadmin"
.ext_command(ext_command_id)
\p\g
alter table alert_recipient add constraint fk_alert_recipient_5  
FOREIGN KEY (snmp_manager_id) REFERENCES "mdbadmin"
.snmp_console(snmp_manager_id)
\p\g
alter table alert_recipient add constraint pk_alert_recipient  PRIMARY
KEY(alert_recipient_id) WITH (INDEX = BASE TABLE STRUCTURE)
\p\g
alter table access_policy_identity_asc add  PRIMARY 
KEY(user_group_identity_asc_id)
\p\g
alter table address add  PRIMARY KEY(location_id)
\p\g
alter table application_instance add  PRIMARY KEY(product_instance_id)
\p\g
alter table security_cal_time_block add  PRIMARY KEY(time_block_id)
\p\g
alter table extended_user_attribute_def add  PRIMARY 
KEY(extended_attribute_def_id)
\p\g
alter table iam_object add  PRIMARY KEY(object_guid)
\p\g
alter table password_history add  PRIMARY KEY(password_id)
\p\g
alter table security_person add  PRIMARY KEY(person_id)
\p\g
alter table security_policy add  PRIMARY KEY(policy_uuid)
\p\g
alter table security_policy_action_asc add  PRIMARY 
KEY(policy_action_uuid, access_policy_uuid)
\p\g
alter table security_policy_action_type add  PRIMARY 
KEY(policy_action_uuid)
\p\g
alter table policy_resource_class_asc add  PRIMARY 
KEY(access_policy_uuid, resource_class_uuid)
\p\g
alter table resource_class add  PRIMARY KEY(resource_class_uuid)
\p\g
alter table security_calendar add  PRIMARY KEY(calendar_id)
\p\g
alter table "user" add  PRIMARY KEY(user_uuid)
\p\g
alter table security_user_group add  PRIMARY KEY(security_group_id)
\p\g
alter table user_group_identity_asc add  PRIMARY 
KEY(user_group_identity_asc_id)
\p\g
alter table access_policy_identity_asc add  FOREIGN KEY 
(access_policy_uuid) REFERENCES "mdbadmin".security_policy
\p\g
alter table address add  FOREIGN KEY (person_uuid) REFERENCES 
"mdbadmin".security_person
\p\g
alter table password_history add  FOREIGN KEY (user_uuid) REFERENCES 
"mdbadmin".user
\p\g
alter table security_policy_action_asc add  FOREIGN KEY 
(access_policy_uuid) REFERENCES "mdbadmin".security_policy
\p\g
alter table security_policy_action_asc add  FOREIGN KEY 
(policy_action_uuid) REFERENCES "mdbadmin".security_policy_action_type
\p\g
alter table security_policy_action_type add  FOREIGN KEY 
(resource_class_uuid) REFERENCES "mdbadmin".resource_class
\p\g
alter table policy_resource_class_asc add  FOREIGN KEY 
(access_policy_uuid) REFERENCES "mdbadmin".security_policy
\p\g
alter table policy_resource_class_asc add  FOREIGN KEY 
(resource_class_uuid) REFERENCES "mdbadmin".resource_class
\p\g
alter table "user" add  FOREIGN KEY (person_id) REFERENCES "mdbadmin"
.security_person
\p\g
alter table user_group_identity_asc add  FOREIGN KEY 
(security_group_id) REFERENCES "mdbadmin".security_user_group
\p\g
alter table security_cal_time_block add  FOREIGN KEY (calendar_id) 
REFERENCES "mdbadmin".security_calendar
\p\g
alter table resource_class add  FOREIGN KEY (product_instance_id) 
REFERENCES "mdbadmin".application_instance
\p\g
alter table resource_class add  FOREIGN KEY (product_instance_id) 
REFERENCES "mdbadmin".application_instance
\p\g
alter table tau_product add  PRIMARY KEY(productname, 
productmajorversion, productminorversion)
\p\g
alter table tau_mdb add  PRIMARY KEY(mdbmajorversion, mdbminorversion)
\p\g
alter table tau_mdb_product add  PRIMARY KEY(mdbmajorversion, 
mdbminorversion, productname, productmajorversion, 
productminorversion)
\p\g
alter table tau_mdb_product add  FOREIGN KEY (productname, 
productmajorversion, productminorversion) REFERENCES "mdbadmin"
.tau_product
\p\g
alter table tau_mdb_product add  FOREIGN KEY (mdbmajorversion, 
mdbminorversion) REFERENCES "mdbadmin".tau_mdb
\p\g

	/* PERMISSIONS */
grant   select   on "mdbadmin".alertdrillmap to public
\p\g
grant   update   on "mdbadmin".alertdrillmap to public
\p\g
grant   delete   on "mdbadmin".alertdrillmap to public
\p\g
grant   insert   on "mdbadmin".alertdrillmap to public
\p\g
grant references on "mdbadmin".alertdrillmap to public
\p\g
grant  copy_into on "mdbadmin".alertdrillmap to public
\p\g
grant  copy_from on "mdbadmin".alertdrillmap to public
\p\g
grant   select   on "mdbadmin".applicationgroups to public
\p\g
grant   update   on "mdbadmin".applicationgroups to public
\p\g
grant   delete   on "mdbadmin".applicationgroups to public
\p\g
grant   insert   on "mdbadmin".applicationgroups to public
\p\g
grant references on "mdbadmin".applicationgroups to public
\p\g
grant  copy_into on "mdbadmin".applicationgroups to public
\p\g
grant  copy_from on "mdbadmin".applicationgroups to public
\p\g
grant   select   on "mdbadmin".baselinebgp4 to public
\p\g
grant   update   on "mdbadmin".baselinebgp4 to public
\p\g
grant   delete   on "mdbadmin".baselinebgp4 to public
\p\g
grant   insert   on "mdbadmin".baselinebgp4 to public
\p\g
grant references on "mdbadmin".baselinebgp4 to public
\p\g
grant  copy_into on "mdbadmin".baselinebgp4 to public
\p\g
grant  copy_from on "mdbadmin".baselinebgp4 to public
\p\g
grant   select   on "mdbadmin".baselinecisco to public
\p\g
grant   update   on "mdbadmin".baselinecisco to public
\p\g
grant   delete   on "mdbadmin".baselinecisco to public
\p\g
grant   insert   on "mdbadmin".baselinecisco to public
\p\g
grant references on "mdbadmin".baselinecisco to public
\p\g
grant  copy_into on "mdbadmin".baselinecisco to public
\p\g
grant  copy_from on "mdbadmin".baselinecisco to public
\p\g
grant   select   on "mdbadmin".baselineciscotemp to public
\p\g
grant   update   on "mdbadmin".baselineciscotemp to public
\p\g
grant   delete   on "mdbadmin".baselineciscotemp to public
\p\g
grant   insert   on "mdbadmin".baselineciscotemp to public
\p\g
grant references on "mdbadmin".baselineciscotemp to public
\p\g
grant  copy_into on "mdbadmin".baselineciscotemp to public
\p\g
grant  copy_from on "mdbadmin".baselineciscotemp to public
\p\g
grant   select   on "mdbadmin".baselineciscovolt to public
\p\g
grant   update   on "mdbadmin".baselineciscovolt to public
\p\g
grant   delete   on "mdbadmin".baselineciscovolt to public
\p\g
grant   insert   on "mdbadmin".baselineciscovolt to public
\p\g
grant references on "mdbadmin".baselineciscovolt to public
\p\g
grant  copy_into on "mdbadmin".baselineciscovolt to public
\p\g
grant  copy_from on "mdbadmin".baselineciscovolt to public
\p\g
grant   select   on "mdbadmin".baselineconfig to public
\p\g
grant   update   on "mdbadmin".baselineconfig to public
\p\g
grant   delete   on "mdbadmin".baselineconfig to public
\p\g
grant   insert   on "mdbadmin".baselineconfig to public
\p\g
grant references on "mdbadmin".baselineconfig to public
\p\g
grant  copy_into on "mdbadmin".baselineconfig to public
\p\g
grant  copy_from on "mdbadmin".baselineconfig to public
\p\g
grant   select   on "mdbadmin".baselineetherstats to public
\p\g
grant   update   on "mdbadmin".baselineetherstats to public
\p\g
grant   delete   on "mdbadmin".baselineetherstats to public
\p\g
grant   insert   on "mdbadmin".baselineetherstats to public
\p\g
grant references on "mdbadmin".baselineetherstats to public
\p\g
grant  copy_into on "mdbadmin".baselineetherstats to public
\p\g
grant  copy_from on "mdbadmin".baselineetherstats to public
\p\g
grant   select   on "mdbadmin".baselinefr to public
\p\g
grant   update   on "mdbadmin".baselinefr to public
\p\g
grant   delete   on "mdbadmin".baselinefr to public
\p\g
grant   insert   on "mdbadmin".baselinefr to public
\p\g
grant references on "mdbadmin".baselinefr to public
\p\g
grant  copy_into on "mdbadmin".baselinefr to public
\p\g
grant  copy_from on "mdbadmin".baselinefr to public
\p\g
grant   select   on "mdbadmin".baselinefs to public
\p\g
grant   update   on "mdbadmin".baselinefs to public
\p\g
grant   delete   on "mdbadmin".baselinefs to public
\p\g
grant   insert   on "mdbadmin".baselinefs to public
\p\g
grant references on "mdbadmin".baselinefs to public
\p\g
grant  copy_into on "mdbadmin".baselinefs to public
\p\g
grant  copy_from on "mdbadmin".baselinefs to public
\p\g
grant   select   on "mdbadmin".baselineif to public
\p\g
grant   update   on "mdbadmin".baselineif to public
\p\g
grant   delete   on "mdbadmin".baselineif to public
\p\g
grant   insert   on "mdbadmin".baselineif to public
\p\g
grant references on "mdbadmin".baselineif to public
\p\g
grant  copy_into on "mdbadmin".baselineif to public
\p\g
grant  copy_from on "mdbadmin".baselineif to public
\p\g
grant   select   on "mdbadmin".baselineip to public
\p\g
grant   update   on "mdbadmin".baselineip to public
\p\g
grant   delete   on "mdbadmin".baselineip to public
\p\g
grant   insert   on "mdbadmin".baselineip to public
\p\g
grant references on "mdbadmin".baselineip to public
\p\g
grant  copy_into on "mdbadmin".baselineip to public
\p\g
grant  copy_from on "mdbadmin".baselineip to public
\p\g
grant   select   on "mdbadmin".baselinelp to public
\p\g
grant   update   on "mdbadmin".baselinelp to public
\p\g
grant   delete   on "mdbadmin".baselinelp to public
\p\g
grant   insert   on "mdbadmin".baselinelp to public
\p\g
grant references on "mdbadmin".baselinelp to public
\p\g
grant  copy_into on "mdbadmin".baselinelp to public
\p\g
grant  copy_from on "mdbadmin".baselinelp to public
\p\g
grant   select   on "mdbadmin".baselinelu to public
\p\g
grant   update   on "mdbadmin".baselinelu to public
\p\g
grant   delete   on "mdbadmin".baselinelu to public
\p\g
grant   insert   on "mdbadmin".baselinelu to public
\p\g
grant references on "mdbadmin".baselinelu to public
\p\g
grant  copy_into on "mdbadmin".baselinelu to public
\p\g
grant  copy_from on "mdbadmin".baselinelu to public
\p\g
grant   select   on "mdbadmin".baselinenbar to public
\p\g
grant   update   on "mdbadmin".baselinenbar to public
\p\g
grant   delete   on "mdbadmin".baselinenbar to public
\p\g
grant   insert   on "mdbadmin".baselinenbar to public
\p\g
grant references on "mdbadmin".baselinenbar to public
\p\g
grant  copy_into on "mdbadmin".baselinenbar to public
\p\g
grant  copy_from on "mdbadmin".baselinenbar to public
\p\g
grant   select   on "mdbadmin".baselinermon2proto to public
\p\g
grant   update   on "mdbadmin".baselinermon2proto to public
\p\g
grant   delete   on "mdbadmin".baselinermon2proto to public
\p\g
grant   insert   on "mdbadmin".baselinermon2proto to public
\p\g
grant references on "mdbadmin".baselinermon2proto to public
\p\g
grant  copy_into on "mdbadmin".baselinermon2proto to public
\p\g
grant  copy_from on "mdbadmin".baselinermon2proto to public
\p\g
grant   select   on "mdbadmin".baselinerttcapture to public
\p\g
grant   update   on "mdbadmin".baselinerttcapture to public
\p\g
grant   delete   on "mdbadmin".baselinerttcapture to public
\p\g
grant   insert   on "mdbadmin".baselinerttcapture to public
\p\g
grant references on "mdbadmin".baselinerttcapture to public
\p\g
grant  copy_into on "mdbadmin".baselinerttcapture to public
\p\g
grant  copy_from on "mdbadmin".baselinerttcapture to public
\p\g
grant   select   on "mdbadmin".baselinerttcoll to public
\p\g
grant   update   on "mdbadmin".baselinerttcoll to public
\p\g
grant   delete   on "mdbadmin".baselinerttcoll to public
\p\g
grant   insert   on "mdbadmin".baselinerttcoll to public
\p\g
grant references on "mdbadmin".baselinerttcoll to public
\p\g
grant  copy_into on "mdbadmin".baselinerttcoll to public
\p\g
grant  copy_from on "mdbadmin".baselinerttcoll to public
\p\g
grant   select   on "mdbadmin".baselinerttjitter to public
\p\g
grant   update   on "mdbadmin".baselinerttjitter to public
\p\g
grant   delete   on "mdbadmin".baselinerttjitter to public
\p\g
grant   insert   on "mdbadmin".baselinerttjitter to public
\p\g
grant references on "mdbadmin".baselinerttjitter to public
\p\g
grant  copy_into on "mdbadmin".baselinerttjitter to public
\p\g
grant  copy_from on "mdbadmin".baselinerttjitter to public
\p\g
grant   select   on "mdbadmin".baselinets to public
\p\g
grant   update   on "mdbadmin".baselinets to public
\p\g
grant   delete   on "mdbadmin".baselinets to public
\p\g
grant   insert   on "mdbadmin".baselinets to public
\p\g
grant references on "mdbadmin".baselinets to public
\p\g
grant  copy_into on "mdbadmin".baselinets to public
\p\g
grant  copy_from on "mdbadmin".baselinets to public
\p\g
grant   select   on "mdbadmin".bgp4peerentry to public
\p\g
grant   update   on "mdbadmin".bgp4peerentry to public
\p\g
grant   delete   on "mdbadmin".bgp4peerentry to public
\p\g
grant   insert   on "mdbadmin".bgp4peerentry to public
\p\g
grant references on "mdbadmin".bgp4peerentry to public
\p\g
grant  copy_into on "mdbadmin".bgp4peerentry to public
\p\g
grant  copy_from on "mdbadmin".bgp4peerentry to public
\p\g
grant   select   on "mdbadmin".bgp4peerentrymessage to public
\p\g
grant   update   on "mdbadmin".bgp4peerentrymessage to public
\p\g
grant   delete   on "mdbadmin".bgp4peerentrymessage to public
\p\g
grant   insert   on "mdbadmin".bgp4peerentrymessage to public
\p\g
grant references on "mdbadmin".bgp4peerentrymessage to public
\p\g
grant  copy_into on "mdbadmin".bgp4peerentrymessage to public
\p\g
grant  copy_from on "mdbadmin".bgp4peerentrymessage to public
\p\g
grant   select   on "mdbadmin".ciscostats to public
\p\g
grant   update   on "mdbadmin".ciscostats to public
\p\g
grant   delete   on "mdbadmin".ciscostats to public
\p\g
grant   insert   on "mdbadmin".ciscostats to public
\p\g
grant references on "mdbadmin".ciscostats to public
\p\g
grant  copy_into on "mdbadmin".ciscostats to public
\p\g
grant  copy_from on "mdbadmin".ciscostats to public
\p\g
grant   select   on "mdbadmin".ciscotemperature_cfg to public
\p\g
grant   update   on "mdbadmin".ciscotemperature_cfg to public
\p\g
grant   delete   on "mdbadmin".ciscotemperature_cfg to public
\p\g
grant   insert   on "mdbadmin".ciscotemperature_cfg to public
\p\g
grant references on "mdbadmin".ciscotemperature_cfg to public
\p\g
grant  copy_into on "mdbadmin".ciscotemperature_cfg to public
\p\g
grant  copy_from on "mdbadmin".ciscotemperature_cfg to public
\p\g
grant   select   on "mdbadmin".ciscotemperature_stat to public
\p\g
grant   update   on "mdbadmin".ciscotemperature_stat to public
\p\g
grant   delete   on "mdbadmin".ciscotemperature_stat to public
\p\g
grant   insert   on "mdbadmin".ciscotemperature_stat to public
\p\g
grant references on "mdbadmin".ciscotemperature_stat to public
\p\g
grant  copy_into on "mdbadmin".ciscotemperature_stat to public
\p\g
grant  copy_from on "mdbadmin".ciscotemperature_stat to public
\p\g
grant   select   on "mdbadmin".ciscovoltage_cfg to public
\p\g
grant   update   on "mdbadmin".ciscovoltage_cfg to public
\p\g
grant   delete   on "mdbadmin".ciscovoltage_cfg to public
\p\g
grant   insert   on "mdbadmin".ciscovoltage_cfg to public
\p\g
grant references on "mdbadmin".ciscovoltage_cfg to public
\p\g
grant  copy_into on "mdbadmin".ciscovoltage_cfg to public
\p\g
grant  copy_from on "mdbadmin".ciscovoltage_cfg to public
\p\g
grant   select   on "mdbadmin".ciscovoltage_stat to public
\p\g
grant   update   on "mdbadmin".ciscovoltage_stat to public
\p\g
grant   delete   on "mdbadmin".ciscovoltage_stat to public
\p\g
grant   insert   on "mdbadmin".ciscovoltage_stat to public
\p\g
grant references on "mdbadmin".ciscovoltage_stat to public
\p\g
grant  copy_into on "mdbadmin".ciscovoltage_stat to public
\p\g
grant  copy_from on "mdbadmin".ciscovoltage_stat to public
\p\g
grant select on "mdbadmin".codefragment to group infopump_user
\p\g
grant update on "mdbadmin".codefragment to group infopump_user
\p\g
grant delete on "mdbadmin".codefragment to group infopump_user
\p\g
grant insert on "mdbadmin".codefragment to group infopump_user
\p\g
grant select on "mdbadmin".codefragment to group infopump_admin
\p\g
grant update on "mdbadmin".codefragment to group infopump_admin
\p\g
grant delete on "mdbadmin".codefragment to group infopump_admin
\p\g
grant insert on "mdbadmin".codefragment to group infopump_admin
\p\g
grant references on "mdbadmin".codefragment to group infopump_admin
\p\g
grant copy_into on "mdbadmin".codefragment to group infopump_admin
\p\g
grant copy_from on "mdbadmin".codefragment to group infopump_admin
\p\g
grant   select   on "mdbadmin".collectionparmgroups to public
\p\g
grant   update   on "mdbadmin".collectionparmgroups to public
\p\g
grant   delete   on "mdbadmin".collectionparmgroups to public
\p\g
grant   insert   on "mdbadmin".collectionparmgroups to public
\p\g
grant references on "mdbadmin".collectionparmgroups to public
\p\g
grant  copy_into on "mdbadmin".collectionparmgroups to public
\p\g
grant  copy_from on "mdbadmin".collectionparmgroups to public
\p\g
grant   select   on "mdbadmin".collectionparms to public
\p\g
grant   update   on "mdbadmin".collectionparms to public
\p\g
grant   delete   on "mdbadmin".collectionparms to public
\p\g
grant   insert   on "mdbadmin".collectionparms to public
\p\g
grant references on "mdbadmin".collectionparms to public
\p\g
grant  copy_into on "mdbadmin".collectionparms to public
\p\g
grant  copy_from on "mdbadmin".collectionparms to public
\p\g
grant   select   on "mdbadmin".collectserver to public
\p\g
grant   update   on "mdbadmin".collectserver to public
\p\g
grant   delete   on "mdbadmin".collectserver to public
\p\g
grant   insert   on "mdbadmin".collectserver to public
\p\g
grant references on "mdbadmin".collectserver to public
\p\g
grant  copy_into on "mdbadmin".collectserver to public
\p\g
grant  copy_from on "mdbadmin".collectserver to public
\p\g
grant   select   on "mdbadmin".columndefinition to public
\p\g
grant   update   on "mdbadmin".columndefinition to public
\p\g
grant   delete   on "mdbadmin".columndefinition to public
\p\g
grant   insert   on "mdbadmin".columndefinition to public
\p\g
grant references on "mdbadmin".columndefinition to public
\p\g
grant  copy_into on "mdbadmin".columndefinition to public
\p\g
grant  copy_from on "mdbadmin".columndefinition to public
\p\g
grant   select   on "mdbadmin".componentofindex to public
\p\g
grant   update   on "mdbadmin".componentofindex to public
\p\g
grant   delete   on "mdbadmin".componentofindex to public
\p\g
grant   insert   on "mdbadmin".componentofindex to public
\p\g
grant references on "mdbadmin".componentofindex to public
\p\g
grant  copy_into on "mdbadmin".componentofindex to public
\p\g
grant  copy_from on "mdbadmin".componentofindex to public
\p\g
grant   select   on "mdbadmin".consult_57 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".consult_57 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".consult_57 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".consult_57 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".consult_57 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".consult_57 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".consult_57 to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".consult_62 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".consult_62 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".consult_62 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".consult_62 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".consult_62 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".consult_62 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".consult_62 to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".consult_aux_57 to neugentsahd with 
grant option
\p\g
grant   update   on "mdbadmin".consult_aux_57 to neugentsahd with 
grant option
\p\g
grant   delete   on "mdbadmin".consult_aux_57 to neugentsahd with 
grant option
\p\g
grant   insert   on "mdbadmin".consult_aux_57 to neugentsahd with 
grant option
\p\g
grant references on "mdbadmin".consult_aux_57 to neugentsahd with 
grant option
\p\g
grant  copy_into on "mdbadmin".consult_aux_57 to neugentsahd with 
grant option
\p\g
grant  copy_from on "mdbadmin".consult_aux_57 to neugentsahd with 
grant option
\p\g
grant   select   on "mdbadmin".consult_aux_62 to neugentsahd with 
grant option
\p\g
grant   update   on "mdbadmin".consult_aux_62 to neugentsahd with 
grant option
\p\g
grant   delete   on "mdbadmin".consult_aux_62 to neugentsahd with 
grant option
\p\g
grant   insert   on "mdbadmin".consult_aux_62 to neugentsahd with 
grant option
\p\g
grant references on "mdbadmin".consult_aux_62 to neugentsahd with 
grant option
\p\g
grant  copy_into on "mdbadmin".consult_aux_62 to neugentsahd with 
grant option
\p\g
grant  copy_from on "mdbadmin".consult_aux_62 to neugentsahd with 
grant option
\p\g
grant   select   on "mdbadmin".consultable_57 to neugentsahd with 
grant option
\p\g
grant   update   on "mdbadmin".consultable_57 to neugentsahd with 
grant option
\p\g
grant   delete   on "mdbadmin".consultable_57 to neugentsahd with 
grant option
\p\g
grant   insert   on "mdbadmin".consultable_57 to neugentsahd with 
grant option
\p\g
grant references on "mdbadmin".consultable_57 to neugentsahd with 
grant option
\p\g
grant  copy_into on "mdbadmin".consultable_57 to neugentsahd with 
grant option
\p\g
grant  copy_from on "mdbadmin".consultable_57 to neugentsahd with 
grant option
\p\g
grant   select   on "mdbadmin".consultable_62 to neugentsahd with 
grant option
\p\g
grant   update   on "mdbadmin".consultable_62 to neugentsahd with 
grant option
\p\g
grant   delete   on "mdbadmin".consultable_62 to neugentsahd with 
grant option
\p\g
grant   insert   on "mdbadmin".consultable_62 to neugentsahd with 
grant option
\p\g
grant references on "mdbadmin".consultable_62 to neugentsahd with 
grant option
\p\g
grant  copy_into on "mdbadmin".consultable_62 to neugentsahd with 
grant option
\p\g
grant  copy_from on "mdbadmin".consultable_62 to neugentsahd with 
grant option
\p\g
grant   select   on "mdbadmin".datarolldate to public
\p\g
grant   update   on "mdbadmin".datarolldate to public
\p\g
grant   delete   on "mdbadmin".datarolldate to public
\p\g
grant   insert   on "mdbadmin".datarolldate to public
\p\g
grant references on "mdbadmin".datarolldate to public
\p\g
grant  copy_into on "mdbadmin".datarolldate to public
\p\g
grant  copy_from on "mdbadmin".datarolldate to public
\p\g
grant   select   on "mdbadmin".datarollup to public
\p\g
grant   update   on "mdbadmin".datarollup to public
\p\g
grant   delete   on "mdbadmin".datarollup to public
\p\g
grant   insert   on "mdbadmin".datarollup to public
\p\g
grant references on "mdbadmin".datarollup to public
\p\g
grant  copy_into on "mdbadmin".datarollup to public
\p\g
grant  copy_from on "mdbadmin".datarollup to public
\p\g
grant select on "mdbadmin".db_application to group infopump_user
\p\g
grant update on "mdbadmin".db_application to group infopump_user
\p\g
grant delete on "mdbadmin".db_application to group infopump_user
\p\g
grant insert on "mdbadmin".db_application to group infopump_user
\p\g
grant select on "mdbadmin".db_application to group infopump_admin
\p\g
grant update on "mdbadmin".db_application to group infopump_admin
\p\g
grant delete on "mdbadmin".db_application to group infopump_admin
\p\g
grant insert on "mdbadmin".db_application to group infopump_admin
\p\g
grant references on "mdbadmin".db_application to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_application to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_application to group infopump_admin
\p\g
grant select on "mdbadmin".db_column to group infopump_user
\p\g
grant update on "mdbadmin".db_column to group infopump_user
\p\g
grant delete on "mdbadmin".db_column to group infopump_user
\p\g
grant insert on "mdbadmin".db_column to group infopump_user
\p\g
grant select on "mdbadmin".db_column to group infopump_admin
\p\g
grant update on "mdbadmin".db_column to group infopump_admin
\p\g
grant delete on "mdbadmin".db_column to group infopump_admin
\p\g
grant insert on "mdbadmin".db_column to group infopump_admin
\p\g
grant references on "mdbadmin".db_column to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_column to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_column to group infopump_admin
\p\g
grant select on "mdbadmin".db_datatype to group infopump_user
\p\g
grant update on "mdbadmin".db_datatype to group infopump_user
\p\g
grant delete on "mdbadmin".db_datatype to group infopump_user
\p\g
grant insert on "mdbadmin".db_datatype to group infopump_user
\p\g
grant select on "mdbadmin".db_datatype to group infopump_admin
\p\g
grant update on "mdbadmin".db_datatype to group infopump_admin
\p\g
grant delete on "mdbadmin".db_datatype to group infopump_admin
\p\g
grant insert on "mdbadmin".db_datatype to group infopump_admin
\p\g
grant references on "mdbadmin".db_datatype to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_datatype to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_datatype to group infopump_admin
\p\g
grant select on "mdbadmin".db_field to group infopump_user
\p\g
grant update on "mdbadmin".db_field to group infopump_user
\p\g
grant delete on "mdbadmin".db_field to group infopump_user
\p\g
grant insert on "mdbadmin".db_field to group infopump_user
\p\g
grant select on "mdbadmin".db_field to group infopump_admin
\p\g
grant update on "mdbadmin".db_field to group infopump_admin
\p\g
grant delete on "mdbadmin".db_field to group infopump_admin
\p\g
grant insert on "mdbadmin".db_field to group infopump_admin
\p\g
grant references on "mdbadmin".db_field to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_field to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_field to group infopump_admin
\p\g
grant select on "mdbadmin".db_gator to group infopump_user
\p\g
grant update on "mdbadmin".db_gator to group infopump_user
\p\g
grant delete on "mdbadmin".db_gator to group infopump_user
\p\g
grant insert on "mdbadmin".db_gator to group infopump_user
\p\g
grant select on "mdbadmin".db_gator to group infopump_admin
\p\g
grant update on "mdbadmin".db_gator to group infopump_admin
\p\g
grant delete on "mdbadmin".db_gator to group infopump_admin
\p\g
grant insert on "mdbadmin".db_gator to group infopump_admin
\p\g
grant references on "mdbadmin".db_gator to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_gator to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_gator to group infopump_admin
\p\g
grant select on "mdbadmin".db_gatorstar to group infopump_user
\p\g
grant update on "mdbadmin".db_gatorstar to group infopump_user
\p\g
grant delete on "mdbadmin".db_gatorstar to group infopump_user
\p\g
grant insert on "mdbadmin".db_gatorstar to group infopump_user
\p\g
grant select on "mdbadmin".db_gatorstar to group infopump_admin
\p\g
grant update on "mdbadmin".db_gatorstar to group infopump_admin
\p\g
grant delete on "mdbadmin".db_gatorstar to group infopump_admin
\p\g
grant insert on "mdbadmin".db_gatorstar to group infopump_admin
\p\g
grant references on "mdbadmin".db_gatorstar to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_gatorstar to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_gatorstar to group infopump_admin
\p\g
grant select on "mdbadmin".db_index to group infopump_user
\p\g
grant update on "mdbadmin".db_index to group infopump_user
\p\g
grant delete on "mdbadmin".db_index to group infopump_user
\p\g
grant insert on "mdbadmin".db_index to group infopump_user
\p\g
grant select on "mdbadmin".db_index to group infopump_admin
\p\g
grant update on "mdbadmin".db_index to group infopump_admin
\p\g
grant delete on "mdbadmin".db_index to group infopump_admin
\p\g
grant insert on "mdbadmin".db_index to group infopump_admin
\p\g
grant references on "mdbadmin".db_index to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_index to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_index to group infopump_admin
\p\g
grant select on "mdbadmin".db_indexcol to group infopump_user
\p\g
grant update on "mdbadmin".db_indexcol to group infopump_user
\p\g
grant delete on "mdbadmin".db_indexcol to group infopump_user
\p\g
grant insert on "mdbadmin".db_indexcol to group infopump_user
\p\g
grant select on "mdbadmin".db_indexcol to group infopump_admin
\p\g
grant update on "mdbadmin".db_indexcol to group infopump_admin
\p\g
grant delete on "mdbadmin".db_indexcol to group infopump_admin
\p\g
grant insert on "mdbadmin".db_indexcol to group infopump_admin
\p\g
grant references on "mdbadmin".db_indexcol to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_indexcol to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_indexcol to group infopump_admin
\p\g
grant select on "mdbadmin".db_infoblob to group infopump_user
\p\g
grant update on "mdbadmin".db_infoblob to group infopump_user
\p\g
grant delete on "mdbadmin".db_infoblob to group infopump_user
\p\g
grant insert on "mdbadmin".db_infoblob to group infopump_user
\p\g
grant select on "mdbadmin".db_infoblob to group infopump_admin
\p\g
grant update on "mdbadmin".db_infoblob to group infopump_admin
\p\g
grant delete on "mdbadmin".db_infoblob to group infopump_admin
\p\g
grant insert on "mdbadmin".db_infoblob to group infopump_admin
\p\g
grant references on "mdbadmin".db_infoblob to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_infoblob to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_infoblob to group infopump_admin
\p\g
grant select on "mdbadmin".db_layout to group infopump_user
\p\g
grant update on "mdbadmin".db_layout to group infopump_user
\p\g
grant delete on "mdbadmin".db_layout to group infopump_user
\p\g
grant insert on "mdbadmin".db_layout to group infopump_user
\p\g
grant select on "mdbadmin".db_layout to group infopump_admin
\p\g
grant update on "mdbadmin".db_layout to group infopump_admin
\p\g
grant delete on "mdbadmin".db_layout to group infopump_admin
\p\g
grant insert on "mdbadmin".db_layout to group infopump_admin
\p\g
grant references on "mdbadmin".db_layout to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_layout to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_layout to group infopump_admin
\p\g
grant select on "mdbadmin".db_object to group infopump_user
\p\g
grant update on "mdbadmin".db_object to group infopump_user
\p\g
grant delete on "mdbadmin".db_object to group infopump_user
\p\g
grant insert on "mdbadmin".db_object to group infopump_user
\p\g
grant select on "mdbadmin".db_object to group infopump_admin
\p\g
grant update on "mdbadmin".db_object to group infopump_admin
\p\g
grant delete on "mdbadmin".db_object to group infopump_admin
\p\g
grant insert on "mdbadmin".db_object to group infopump_admin
\p\g
grant references on "mdbadmin".db_object to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_object to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_object to group infopump_admin
\p\g
grant select on "mdbadmin".db_op to group infopump_user
\p\g
grant update on "mdbadmin".db_op to group infopump_user
\p\g
grant delete on "mdbadmin".db_op to group infopump_user
\p\g
grant insert on "mdbadmin".db_op to group infopump_user
\p\g
grant select on "mdbadmin".db_op to group infopump_admin
\p\g
grant update on "mdbadmin".db_op to group infopump_admin
\p\g
grant delete on "mdbadmin".db_op to group infopump_admin
\p\g
grant insert on "mdbadmin".db_op to group infopump_admin
\p\g
grant references on "mdbadmin".db_op to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_op to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_op to group infopump_admin
\p\g
grant select on "mdbadmin".db_opsegment to group infopump_user
\p\g
grant update on "mdbadmin".db_opsegment to group infopump_user
\p\g
grant delete on "mdbadmin".db_opsegment to group infopump_user
\p\g
grant insert on "mdbadmin".db_opsegment to group infopump_user
\p\g
grant select on "mdbadmin".db_opsegment to group infopump_admin
\p\g
grant update on "mdbadmin".db_opsegment to group infopump_admin
\p\g
grant delete on "mdbadmin".db_opsegment to group infopump_admin
\p\g
grant insert on "mdbadmin".db_opsegment to group infopump_admin
\p\g
grant references on "mdbadmin".db_opsegment to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_opsegment to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_opsegment to group infopump_admin
\p\g
grant select on "mdbadmin".db_parameter to group infopump_user
\p\g
grant update on "mdbadmin".db_parameter to group infopump_user
\p\g
grant delete on "mdbadmin".db_parameter to group infopump_user
\p\g
grant insert on "mdbadmin".db_parameter to group infopump_user
\p\g
grant select on "mdbadmin".db_parameter to group infopump_admin
\p\g
grant update on "mdbadmin".db_parameter to group infopump_admin
\p\g
grant delete on "mdbadmin".db_parameter to group infopump_admin
\p\g
grant insert on "mdbadmin".db_parameter to group infopump_admin
\p\g
grant references on "mdbadmin".db_parameter to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_parameter to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_parameter to group infopump_admin
\p\g
grant select on "mdbadmin".db_program to group infopump_user
\p\g
grant update on "mdbadmin".db_program to group infopump_user
\p\g
grant delete on "mdbadmin".db_program to group infopump_user
\p\g
grant insert on "mdbadmin".db_program to group infopump_user
\p\g
grant select on "mdbadmin".db_program to group infopump_admin
\p\g
grant update on "mdbadmin".db_program to group infopump_admin
\p\g
grant delete on "mdbadmin".db_program to group infopump_admin
\p\g
grant insert on "mdbadmin".db_program to group infopump_admin
\p\g
grant references on "mdbadmin".db_program to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_program to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_program to group infopump_admin
\p\g
grant select on "mdbadmin".db_programinstance to group infopump_user
\p\g
grant update on "mdbadmin".db_programinstance to group infopump_user
\p\g
grant delete on "mdbadmin".db_programinstance to group infopump_user
\p\g
grant insert on "mdbadmin".db_programinstance to group infopump_user
\p\g
grant select on "mdbadmin".db_programinstance to group infopump_admin
\p\g
grant update on "mdbadmin".db_programinstance to group infopump_admin
\p\g
grant delete on "mdbadmin".db_programinstance to group infopump_admin
\p\g
grant insert on "mdbadmin".db_programinstance to group infopump_admin
\p\g
grant references on "mdbadmin".db_programinstance to group 
infopump_admin
\p\g
grant copy_into on "mdbadmin".db_programinstance to group 
infopump_admin
\p\g
grant copy_from on "mdbadmin".db_programinstance to group 
infopump_admin
\p\g
grant select on "mdbadmin".db_programtype to group infopump_user
\p\g
grant update on "mdbadmin".db_programtype to group infopump_user
\p\g
grant delete on "mdbadmin".db_programtype to group infopump_user
\p\g
grant insert on "mdbadmin".db_programtype to group infopump_user
\p\g
grant select on "mdbadmin".db_programtype to group infopump_admin
\p\g
grant update on "mdbadmin".db_programtype to group infopump_admin
\p\g
grant delete on "mdbadmin".db_programtype to group infopump_admin
\p\g
grant insert on "mdbadmin".db_programtype to group infopump_admin
\p\g
grant references on "mdbadmin".db_programtype to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_programtype to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_programtype to group infopump_admin
\p\g
grant select on "mdbadmin".db_programtypemisc to group infopump_user
\p\g
grant update on "mdbadmin".db_programtypemisc to group infopump_user
\p\g
grant delete on "mdbadmin".db_programtypemisc to group infopump_user
\p\g
grant insert on "mdbadmin".db_programtypemisc to group infopump_user
\p\g
grant select on "mdbadmin".db_programtypemisc to group infopump_admin
\p\g
grant update on "mdbadmin".db_programtypemisc to group infopump_admin
\p\g
grant delete on "mdbadmin".db_programtypemisc to group infopump_admin
\p\g
grant insert on "mdbadmin".db_programtypemisc to group infopump_admin
\p\g
grant references on "mdbadmin".db_programtypemisc to group 
infopump_admin
\p\g
grant copy_into on "mdbadmin".db_programtypemisc to group 
infopump_admin
\p\g
grant copy_from on "mdbadmin".db_programtypemisc to group 
infopump_admin
\p\g
grant select on "mdbadmin".db_psafile to group infopump_user
\p\g
grant update on "mdbadmin".db_psafile to group infopump_user
\p\g
grant delete on "mdbadmin".db_psafile to group infopump_user
\p\g
grant insert on "mdbadmin".db_psafile to group infopump_user
\p\g
grant select on "mdbadmin".db_psafile to group infopump_admin
\p\g
grant update on "mdbadmin".db_psafile to group infopump_admin
\p\g
grant delete on "mdbadmin".db_psafile to group infopump_admin
\p\g
grant insert on "mdbadmin".db_psafile to group infopump_admin
\p\g
grant references on "mdbadmin".db_psafile to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_psafile to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_psafile to group infopump_admin
\p\g
grant select on "mdbadmin".db_seqcolumn to group infopump_user
\p\g
grant update on "mdbadmin".db_seqcolumn to group infopump_user
\p\g
grant delete on "mdbadmin".db_seqcolumn to group infopump_user
\p\g
grant insert on "mdbadmin".db_seqcolumn to group infopump_user
\p\g
grant select on "mdbadmin".db_seqcolumn to group infopump_admin
\p\g
grant update on "mdbadmin".db_seqcolumn to group infopump_admin
\p\g
grant delete on "mdbadmin".db_seqcolumn to group infopump_admin
\p\g
grant insert on "mdbadmin".db_seqcolumn to group infopump_admin
\p\g
grant references on "mdbadmin".db_seqcolumn to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_seqcolumn to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_seqcolumn to group infopump_admin
\p\g
grant select on "mdbadmin".db_seqtable to group infopump_user
\p\g
grant update on "mdbadmin".db_seqtable to group infopump_user
\p\g
grant delete on "mdbadmin".db_seqtable to group infopump_user
\p\g
grant insert on "mdbadmin".db_seqtable to group infopump_user
\p\g
grant select on "mdbadmin".db_seqtable to group infopump_admin
\p\g
grant update on "mdbadmin".db_seqtable to group infopump_admin
\p\g
grant delete on "mdbadmin".db_seqtable to group infopump_admin
\p\g
grant insert on "mdbadmin".db_seqtable to group infopump_admin
\p\g
grant references on "mdbadmin".db_seqtable to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_seqtable to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_seqtable to group infopump_admin
\p\g
grant select on "mdbadmin".db_servertype to group infopump_user
\p\g
grant update on "mdbadmin".db_servertype to group infopump_user
\p\g
grant delete on "mdbadmin".db_servertype to group infopump_user
\p\g
grant insert on "mdbadmin".db_servertype to group infopump_user
\p\g
grant select on "mdbadmin".db_servertype to group infopump_admin
\p\g
grant update on "mdbadmin".db_servertype to group infopump_admin
\p\g
grant delete on "mdbadmin".db_servertype to group infopump_admin
\p\g
grant insert on "mdbadmin".db_servertype to group infopump_admin
\p\g
grant references on "mdbadmin".db_servertype to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_servertype to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_servertype to group infopump_admin
\p\g
grant select on "mdbadmin".db_star to group infopump_user
\p\g
grant update on "mdbadmin".db_star to group infopump_user
\p\g
grant delete on "mdbadmin".db_star to group infopump_user
\p\g
grant insert on "mdbadmin".db_star to group infopump_user
\p\g
grant select on "mdbadmin".db_star to group infopump_admin
\p\g
grant update on "mdbadmin".db_star to group infopump_admin
\p\g
grant delete on "mdbadmin".db_star to group infopump_admin
\p\g
grant insert on "mdbadmin".db_star to group infopump_admin
\p\g
grant references on "mdbadmin".db_star to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_star to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_star to group infopump_admin
\p\g
grant select on "mdbadmin".db_startable to group infopump_user
\p\g
grant update on "mdbadmin".db_startable to group infopump_user
\p\g
grant delete on "mdbadmin".db_startable to group infopump_user
\p\g
grant insert on "mdbadmin".db_startable to group infopump_user
\p\g
grant select on "mdbadmin".db_startable to group infopump_admin
\p\g
grant update on "mdbadmin".db_startable to group infopump_admin
\p\g
grant delete on "mdbadmin".db_startable to group infopump_admin
\p\g
grant insert on "mdbadmin".db_startable to group infopump_admin
\p\g
grant references on "mdbadmin".db_startable to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_startable to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_startable to group infopump_admin
\p\g
grant select on "mdbadmin".db_table to group infopump_user
\p\g
grant update on "mdbadmin".db_table to group infopump_user
\p\g
grant delete on "mdbadmin".db_table to group infopump_user
\p\g
grant insert on "mdbadmin".db_table to group infopump_user
\p\g
grant select on "mdbadmin".db_table to group infopump_admin
\p\g
grant update on "mdbadmin".db_table to group infopump_admin
\p\g
grant delete on "mdbadmin".db_table to group infopump_admin
\p\g
grant insert on "mdbadmin".db_table to group infopump_admin
\p\g
grant references on "mdbadmin".db_table to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_table to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_table to group infopump_admin
\p\g
grant select on "mdbadmin".db_wkf to group infopump_user
\p\g
grant update on "mdbadmin".db_wkf to group infopump_user
\p\g
grant delete on "mdbadmin".db_wkf to group infopump_user
\p\g
grant insert on "mdbadmin".db_wkf to group infopump_user
\p\g
grant select on "mdbadmin".db_wkf to group infopump_admin
\p\g
grant update on "mdbadmin".db_wkf to group infopump_admin
\p\g
grant delete on "mdbadmin".db_wkf to group infopump_admin
\p\g
grant insert on "mdbadmin".db_wkf to group infopump_admin
\p\g
grant references on "mdbadmin".db_wkf to group infopump_admin
\p\g
grant copy_into on "mdbadmin".db_wkf to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_wkf to group infopump_admin
\p\g
grant select on "mdbadmin".db_wkfconnection to group infopump_user
\p\g
grant update on "mdbadmin".db_wkfconnection to group infopump_user
\p\g
grant delete on "mdbadmin".db_wkfconnection to group infopump_user
\p\g
grant insert on "mdbadmin".db_wkfconnection to group infopump_user
\p\g
grant select on "mdbadmin".db_wkfconnection to group infopump_admin
\p\g
grant update on "mdbadmin".db_wkfconnection to group infopump_admin
\p\g
grant delete on "mdbadmin".db_wkfconnection to group infopump_admin
\p\g
grant insert on "mdbadmin".db_wkfconnection to group infopump_admin
\p\g
grant references on "mdbadmin".db_wkfconnection to group 
infopump_admin
\p\g
grant copy_into on "mdbadmin".db_wkfconnection to group infopump_admin
\p\g
grant copy_from on "mdbadmin".db_wkfconnection to group infopump_admin
\p\g
grant select on "mdbadmin".ddcolumn to group infopump_user
\p\g
grant delete on "mdbadmin".ddcolumn to group infopump_user
\p\g
grant select on "mdbadmin".ddcolumn to public
\p\g
grant select on "mdbadmin".ddcolumn to group infopump_admin
\p\g
grant update on "mdbadmin".ddcolumn to group infopump_admin
\p\g
grant delete on "mdbadmin".ddcolumn to group infopump_admin
\p\g
grant insert on "mdbadmin".ddcolumn to group infopump_admin
\p\g
grant references on "mdbadmin".ddcolumn to group infopump_admin
\p\g
grant copy_into on "mdbadmin".ddcolumn to group infopump_admin
\p\g
grant copy_from on "mdbadmin".ddcolumn to group infopump_admin
\p\g
grant select on "mdbadmin".ddtable to group infopump_user
\p\g
grant delete on "mdbadmin".ddtable to group infopump_user
\p\g
grant select on "mdbadmin".ddtable to public
\p\g
grant select on "mdbadmin".ddtable to group infopump_admin
\p\g
grant update on "mdbadmin".ddtable to group infopump_admin
\p\g
grant delete on "mdbadmin".ddtable to group infopump_admin
\p\g
grant insert on "mdbadmin".ddtable to group infopump_admin
\p\g
grant references on "mdbadmin".ddtable to group infopump_admin
\p\g
grant copy_into on "mdbadmin".ddtable to group infopump_admin
\p\g
grant copy_from on "mdbadmin".ddtable to group infopump_admin
\p\g
grant select on "mdbadmin".ddtablemodify to group infopump_user
\p\g
grant delete on "mdbadmin".ddtablemodify to group infopump_user
\p\g
grant select on "mdbadmin".ddtablemodify to public
\p\g
grant select on "mdbadmin".ddtablemodify to group infopump_admin
\p\g
grant update on "mdbadmin".ddtablemodify to group infopump_admin
\p\g
grant delete on "mdbadmin".ddtablemodify to group infopump_admin
\p\g
grant insert on "mdbadmin".ddtablemodify to group infopump_admin
\p\g
grant references on "mdbadmin".ddtablemodify to group infopump_admin
\p\g
grant copy_into on "mdbadmin".ddtablemodify to group infopump_admin
\p\g
grant copy_from on "mdbadmin".ddtablemodify to group infopump_admin
\p\g
grant   select   on "mdbadmin".discoveryvariable to public
\p\g
grant   update   on "mdbadmin".discoveryvariable to public
\p\g
grant   delete   on "mdbadmin".discoveryvariable to public
\p\g
grant   insert   on "mdbadmin".discoveryvariable to public
\p\g
grant references on "mdbadmin".discoveryvariable to public
\p\g
grant  copy_into on "mdbadmin".discoveryvariable to public
\p\g
grant  copy_from on "mdbadmin".discoveryvariable to public
\p\g
grant   select   on "mdbadmin".emevt_mib to public
\p\g
grant   update   on "mdbadmin".emevt_mib to public
\p\g
grant   delete   on "mdbadmin".emevt_mib to public
\p\g
grant   insert   on "mdbadmin".emevt_mib to public
\p\g
grant references on "mdbadmin".emevt_mib to public
\p\g
grant  copy_into on "mdbadmin".emevt_mib to public
\p\g
grant  copy_from on "mdbadmin".emevt_mib to public
\p\g
grant   select   on "mdbadmin".emevt_trap to public
\p\g
grant   update   on "mdbadmin".emevt_trap to public
\p\g
grant   delete   on "mdbadmin".emevt_trap to public
\p\g
grant   insert   on "mdbadmin".emevt_trap to public
\p\g
grant references on "mdbadmin".emevt_trap to public
\p\g
grant  copy_into on "mdbadmin".emevt_trap to public
\p\g
grant  copy_from on "mdbadmin".emevt_trap to public
\p\g
grant select on "mdbadmin".error to group infopump_user
\p\g
grant delete on "mdbadmin".error to group infopump_user
\p\g
grant select on "mdbadmin".error to group infopump_admin
\p\g
grant update on "mdbadmin".error to group infopump_admin
\p\g
grant delete on "mdbadmin".error to group infopump_admin
\p\g
grant insert on "mdbadmin".error to group infopump_admin
\p\g
grant references on "mdbadmin".error to group infopump_admin
\p\g
grant copy_into on "mdbadmin".error to group infopump_admin
\p\g
grant copy_from on "mdbadmin".error to group infopump_admin
\p\g
grant   select   on "mdbadmin".event_alert_log to neugentsahd with 
grant option
\p\g
grant   update   on "mdbadmin".event_alert_log to neugentsahd with 
grant option
\p\g
grant   delete   on "mdbadmin".event_alert_log to neugentsahd with 
grant option
\p\g
grant   insert   on "mdbadmin".event_alert_log to neugentsahd with 
grant option
\p\g
grant references on "mdbadmin".event_alert_log to neugentsahd with 
grant option
\p\g
grant  copy_into on "mdbadmin".event_alert_log to neugentsahd with 
grant option
\p\g
grant  copy_from on "mdbadmin".event_alert_log to neugentsahd with 
grant option
\p\g
grant   select   on "mdbadmin".event_type_performance to neugentsahd 
with grant option
\p\g
grant   update   on "mdbadmin".event_type_performance to neugentsahd 
with grant option
\p\g
grant   delete   on "mdbadmin".event_type_performance to neugentsahd 
with grant option
\p\g
grant   insert   on "mdbadmin".event_type_performance to neugentsahd 
with grant option
\p\g
grant references on "mdbadmin".event_type_performance to neugentsahd 
with grant option
\p\g
grant  copy_into on "mdbadmin".event_type_performance to neugentsahd 
with grant option
\p\g
grant  copy_from on "mdbadmin".event_type_performance to neugentsahd 
with grant option
\p\g
grant select on "mdbadmin".execution to group infopump_user
\p\g
grant delete on "mdbadmin".execution to group infopump_user
\p\g
grant select on "mdbadmin".execution to group infopump_admin
\p\g
grant update on "mdbadmin".execution to group infopump_admin
\p\g
grant delete on "mdbadmin".execution to group infopump_admin
\p\g
grant insert on "mdbadmin".execution to group infopump_admin
\p\g
grant references on "mdbadmin".execution to group infopump_admin
\p\g
grant copy_into on "mdbadmin".execution to group infopump_admin
\p\g
grant copy_from on "mdbadmin".execution to group infopump_admin
\p\g
grant   select   on "mdbadmin".frcircuitid to public
\p\g
grant   update   on "mdbadmin".frcircuitid to public
\p\g
grant   delete   on "mdbadmin".frcircuitid to public
\p\g
grant   insert   on "mdbadmin".frcircuitid to public
\p\g
grant references on "mdbadmin".frcircuitid to public
\p\g
grant  copy_into on "mdbadmin".frcircuitid to public
\p\g
grant  copy_from on "mdbadmin".frcircuitid to public
\p\g
grant   select   on "mdbadmin".frcircuitstats to public
\p\g
grant   update   on "mdbadmin".frcircuitstats to public
\p\g
grant   delete   on "mdbadmin".frcircuitstats to public
\p\g
grant   insert   on "mdbadmin".frcircuitstats to public
\p\g
grant references on "mdbadmin".frcircuitstats to public
\p\g
grant  copy_into on "mdbadmin".frcircuitstats to public
\p\g
grant  copy_from on "mdbadmin".frcircuitstats to public
\p\g
grant   select   on "mdbadmin".frdlcmiid to public
\p\g
grant   update   on "mdbadmin".frdlcmiid to public
\p\g
grant   delete   on "mdbadmin".frdlcmiid to public
\p\g
grant   insert   on "mdbadmin".frdlcmiid to public
\p\g
grant references on "mdbadmin".frdlcmiid to public
\p\g
grant  copy_into on "mdbadmin".frdlcmiid to public
\p\g
grant  copy_from on "mdbadmin".frdlcmiid to public
\p\g
grant   select   on "mdbadmin".gdcdiscovery to public
\p\g
grant   update   on "mdbadmin".gdcdiscovery to public
\p\g
grant   delete   on "mdbadmin".gdcdiscovery to public
\p\g
grant   insert   on "mdbadmin".gdcdiscovery to public
\p\g
grant references on "mdbadmin".gdcdiscovery to public
\p\g
grant  copy_into on "mdbadmin".gdcdiscovery to public
\p\g
grant  copy_from on "mdbadmin".gdcdiscovery to public
\p\g
grant select on "mdbadmin".globalvariable to group infopump_user
\p\g
grant update on "mdbadmin".globalvariable to group infopump_user
\p\g
grant delete on "mdbadmin".globalvariable to group infopump_user
\p\g
grant insert on "mdbadmin".globalvariable to group infopump_user
\p\g
grant select on "mdbadmin".globalvariable to group infopump_admin
\p\g
grant update on "mdbadmin".globalvariable to group infopump_admin
\p\g
grant delete on "mdbadmin".globalvariable to group infopump_admin
\p\g
grant insert on "mdbadmin".globalvariable to group infopump_admin
\p\g
grant references on "mdbadmin".globalvariable to group infopump_admin
\p\g
grant copy_into on "mdbadmin".globalvariable to group infopump_admin
\p\g
grant copy_from on "mdbadmin".globalvariable to group infopump_admin
\p\g
grant   select   on "mdbadmin".hex2decimal to public
\p\g
grant   update   on "mdbadmin".hex2decimal to public
\p\g
grant   delete   on "mdbadmin".hex2decimal to public
\p\g
grant   insert   on "mdbadmin".hex2decimal to public
\p\g
grant references on "mdbadmin".hex2decimal to public
\p\g
grant  copy_into on "mdbadmin".hex2decimal to public
\p\g
grant  copy_from on "mdbadmin".hex2decimal to public
\p\g
grant   select   on table "mdbadmin".iam_attribute to public
\p\g
grant   update   on table "mdbadmin".iam_attribute to public
\p\g
grant   delete   on table "mdbadmin".iam_attribute to public
\p\g
grant   insert   on table "mdbadmin".iam_attribute to public
\p\g
grant references on table "mdbadmin".iam_attribute to public
\p\g
grant  copy_into on table "mdbadmin".iam_attribute to public
\p\g
grant  copy_from on table "mdbadmin".iam_attribute to public
\p\g
grant   select   on table "mdbadmin".iam_object to public
\p\g
grant   update   on table "mdbadmin".iam_object to public
\p\g
grant   delete   on table "mdbadmin".iam_object to public
\p\g
grant   insert   on table "mdbadmin".iam_object to public
\p\g
grant references on table "mdbadmin".iam_object to public
\p\g
grant  copy_into on table "mdbadmin".iam_object to public
\p\g
grant  copy_from on table "mdbadmin".iam_object to public
\p\g
grant   select   on "mdbadmin".indextable to public
\p\g
grant   update   on "mdbadmin".indextable to public
\p\g
grant   delete   on "mdbadmin".indextable to public
\p\g
grant   insert   on "mdbadmin".indextable to public
\p\g
grant references on "mdbadmin".indextable to public
\p\g
grant  copy_into on "mdbadmin".indextable to public
\p\g
grant  copy_from on "mdbadmin".indextable to public
\p\g
grant select on "mdbadmin".ipobject to group infopump_user
\p\g
grant update on "mdbadmin".ipobject to group infopump_user
\p\g
grant delete on "mdbadmin".ipobject to group infopump_user
\p\g
grant insert on "mdbadmin".ipobject to group infopump_user
\p\g
grant select on "mdbadmin".ipobject to group infopump_admin
\p\g
grant update on "mdbadmin".ipobject to group infopump_admin
\p\g
grant delete on "mdbadmin".ipobject to group infopump_admin
\p\g
grant insert on "mdbadmin".ipobject to group infopump_admin
\p\g
grant references on "mdbadmin".ipobject to group infopump_admin
\p\g
grant copy_into on "mdbadmin".ipobject to group infopump_admin
\p\g
grant copy_from on "mdbadmin".ipobject to group infopump_admin
\p\g
grant select on "mdbadmin".ipprovider to group infopump_user
\p\g
grant update on "mdbadmin".ipprovider to group infopump_user
\p\g
grant delete on "mdbadmin".ipprovider to group infopump_user
\p\g
grant insert on "mdbadmin".ipprovider to group infopump_user
\p\g
grant select on "mdbadmin".ipprovider to group infopump_admin
\p\g
grant update on "mdbadmin".ipprovider to group infopump_admin
\p\g
grant delete on "mdbadmin".ipprovider to group infopump_admin
\p\g
grant insert on "mdbadmin".ipprovider to group infopump_admin
\p\g
grant references on "mdbadmin".ipprovider to group infopump_admin
\p\g
grant copy_into on "mdbadmin".ipprovider to group infopump_admin
\p\g
grant copy_from on "mdbadmin".ipprovider to group infopump_admin
\p\g
grant select on "mdbadmin".iprequest to group infopump_user
\p\g
grant update on "mdbadmin".iprequest to group infopump_user
\p\g
grant delete on "mdbadmin".iprequest to group infopump_user
\p\g
grant insert on "mdbadmin".iprequest to group infopump_user
\p\g
grant select on "mdbadmin".iprequest to group infopump_admin
\p\g
grant update on "mdbadmin".iprequest to group infopump_admin
\p\g
grant delete on "mdbadmin".iprequest to group infopump_admin
\p\g
grant insert on "mdbadmin".iprequest to group infopump_admin
\p\g
grant references on "mdbadmin".iprequest to group infopump_admin
\p\g
grant copy_into on "mdbadmin".iprequest to group infopump_admin
\p\g
grant copy_from on "mdbadmin".iprequest to group infopump_admin
\p\g
grant select on "mdbadmin".iprequestcode to group infopump_user
\p\g
grant update on "mdbadmin".iprequestcode to group infopump_user
\p\g
grant delete on "mdbadmin".iprequestcode to group infopump_user
\p\g
grant insert on "mdbadmin".iprequestcode to group infopump_user
\p\g
grant select on "mdbadmin".iprequestcode to group infopump_admin
\p\g
grant update on "mdbadmin".iprequestcode to group infopump_admin
\p\g
grant delete on "mdbadmin".iprequestcode to group infopump_admin
\p\g
grant insert on "mdbadmin".iprequestcode to group infopump_admin
\p\g
grant references on "mdbadmin".iprequestcode to group infopump_admin
\p\g
grant copy_into on "mdbadmin".iprequestcode to group infopump_admin
\p\g
grant copy_from on "mdbadmin".iprequestcode to group infopump_admin
\p\g
grant select on "mdbadmin".ipuser to group infopump_user
\p\g
grant update on "mdbadmin".ipuser to group infopump_user
\p\g
grant select on "mdbadmin".ipuser to group infopump_admin
\p\g
grant update on "mdbadmin".ipuser to group infopump_admin
\p\g
grant delete on "mdbadmin".ipuser to group infopump_admin
\p\g
grant insert on "mdbadmin".ipuser to group infopump_admin
\p\g
grant references on "mdbadmin".ipuser to group infopump_admin
\p\g
grant copy_into on "mdbadmin".ipuser to group infopump_admin
\p\g
grant copy_from on "mdbadmin".ipuser to group infopump_admin
\p\g
grant   select   on "mdbadmin".itfcconfig to public
\p\g
grant   update   on "mdbadmin".itfcconfig to public
\p\g
grant   delete   on "mdbadmin".itfcconfig to public
\p\g
grant   insert   on "mdbadmin".itfcconfig to public
\p\g
grant references on "mdbadmin".itfcconfig to public
\p\g
grant  copy_into on "mdbadmin".itfcconfig to public
\p\g
grant  copy_from on "mdbadmin".itfcconfig to public
\p\g
grant   select   on "mdbadmin".lac_filenames to public
\p\g
grant   update   on "mdbadmin".lac_filenames to public
\p\g
grant   delete   on "mdbadmin".lac_filenames to public
\p\g
grant   insert   on "mdbadmin".lac_filenames to public
\p\g
grant references on "mdbadmin".lac_filenames to public
\p\g
grant  copy_into on "mdbadmin".lac_filenames to public
\p\g
grant  copy_from on "mdbadmin".lac_filenames to public
\p\g
grant   select   on "mdbadmin".lac_filter_names to public
\p\g
grant   update   on "mdbadmin".lac_filter_names to public
\p\g
grant   delete   on "mdbadmin".lac_filter_names to public
\p\g
grant   insert   on "mdbadmin".lac_filter_names to public
\p\g
grant references on "mdbadmin".lac_filter_names to public
\p\g
grant  copy_into on "mdbadmin".lac_filter_names to public
\p\g
grant  copy_from on "mdbadmin".lac_filter_names to public
\p\g
grant   select   on "mdbadmin".lac_filter_objects to public
\p\g
grant   update   on "mdbadmin".lac_filter_objects to public
\p\g
grant   delete   on "mdbadmin".lac_filter_objects to public
\p\g
grant   insert   on "mdbadmin".lac_filter_objects to public
\p\g
grant references on "mdbadmin".lac_filter_objects to public
\p\g
grant  copy_into on "mdbadmin".lac_filter_objects to public
\p\g
grant  copy_from on "mdbadmin".lac_filter_objects to public
\p\g
grant   select   on "mdbadmin".lac_job_output to public
\p\g
grant   update   on "mdbadmin".lac_job_output to public
\p\g
grant   delete   on "mdbadmin".lac_job_output to public
\p\g
grant   insert   on "mdbadmin".lac_job_output to public
\p\g
grant references on "mdbadmin".lac_job_output to public
\p\g
grant  copy_into on "mdbadmin".lac_job_output to public
\p\g
grant  copy_from on "mdbadmin".lac_job_output to public
\p\g
grant   select   on "mdbadmin".lac_job_parms to public
\p\g
grant   update   on "mdbadmin".lac_job_parms to public
\p\g
grant   delete   on "mdbadmin".lac_job_parms to public
\p\g
grant   insert   on "mdbadmin".lac_job_parms to public
\p\g
grant references on "mdbadmin".lac_job_parms to public
\p\g
grant  copy_into on "mdbadmin".lac_job_parms to public
\p\g
grant  copy_from on "mdbadmin".lac_job_parms to public
\p\g
grant   select   on "mdbadmin".lac_strategy_parms to public
\p\g
grant   update   on "mdbadmin".lac_strategy_parms to public
\p\g
grant   delete   on "mdbadmin".lac_strategy_parms to public
\p\g
grant   insert   on "mdbadmin".lac_strategy_parms to public
\p\g
grant references on "mdbadmin".lac_strategy_parms to public
\p\g
grant  copy_into on "mdbadmin".lac_strategy_parms to public
\p\g
grant  copy_from on "mdbadmin".lac_strategy_parms to public
\p\g
grant   select   on "mdbadmin".lac_transactions to public
\p\g
grant   update   on "mdbadmin".lac_transactions to public
\p\g
grant   delete   on "mdbadmin".lac_transactions to public
\p\g
grant   insert   on "mdbadmin".lac_transactions to public
\p\g
grant references on "mdbadmin".lac_transactions to public
\p\g
grant  copy_into on "mdbadmin".lac_transactions to public
\p\g
grant  copy_from on "mdbadmin".lac_transactions to public
\p\g
grant select on "mdbadmin".lookoutcontrol to group infopump_user
\p\g
grant select on "mdbadmin".lookoutcontrol to group infopump_admin
\p\g
grant update on "mdbadmin".lookoutcontrol to group infopump_admin
\p\g
grant delete on "mdbadmin".lookoutcontrol to group infopump_admin
\p\g
grant insert on "mdbadmin".lookoutcontrol to group infopump_admin
\p\g
grant references on "mdbadmin".lookoutcontrol to group infopump_admin
\p\g
grant copy_into on "mdbadmin".lookoutcontrol to group infopump_admin
\p\g
grant copy_from on "mdbadmin".lookoutcontrol to group infopump_admin
\p\g
grant select on "mdbadmin".lookoutidcontrol to group infopump_user
\p\g
grant update on "mdbadmin".lookoutidcontrol to group infopump_user
\p\g
grant delete on "mdbadmin".lookoutidcontrol to group infopump_user
\p\g
grant insert on "mdbadmin".lookoutidcontrol to group infopump_user
\p\g
grant select on "mdbadmin".lookoutidcontrol to group infopump_admin
\p\g
grant update on "mdbadmin".lookoutidcontrol to group infopump_admin
\p\g
grant delete on "mdbadmin".lookoutidcontrol to group infopump_admin
\p\g
grant insert on "mdbadmin".lookoutidcontrol to group infopump_admin
\p\g
grant references on "mdbadmin".lookoutidcontrol to group 
infopump_admin
\p\g
grant copy_into on "mdbadmin".lookoutidcontrol to group infopump_admin
\p\g
grant copy_from on "mdbadmin".lookoutidcontrol to group infopump_admin
\p\g
grant select on "mdbadmin".lookoutserver to group infopump_user
\p\g
grant select on "mdbadmin".lookoutserver to group infopump_admin
\p\g
grant update on "mdbadmin".lookoutserver to group infopump_admin
\p\g
grant delete on "mdbadmin".lookoutserver to group infopump_admin
\p\g
grant insert on "mdbadmin".lookoutserver to group infopump_admin
\p\g
grant references on "mdbadmin".lookoutserver to group infopump_admin
\p\g
grant copy_into on "mdbadmin".lookoutserver to group infopump_admin
\p\g
grant copy_from on "mdbadmin".lookoutserver to group infopump_admin
\p\g
grant   select   on "mdbadmin".lsyfileserverclients to public
\p\g
grant   update   on "mdbadmin".lsyfileserverclients to public
\p\g
grant   delete   on "mdbadmin".lsyfileserverclients to public
\p\g
grant   insert   on "mdbadmin".lsyfileserverclients to public
\p\g
grant references on "mdbadmin".lsyfileserverclients to public
\p\g
grant  copy_into on "mdbadmin".lsyfileserverclients to public
\p\g
grant  copy_from on "mdbadmin".lsyfileserverclients to public
\p\g
grant   select   on "mdbadmin".lsyfileserverid to public
\p\g
grant   update   on "mdbadmin".lsyfileserverid to public
\p\g
grant   delete   on "mdbadmin".lsyfileserverid to public
\p\g
grant   insert   on "mdbadmin".lsyfileserverid to public
\p\g
grant references on "mdbadmin".lsyfileserverid to public
\p\g
grant  copy_into on "mdbadmin".lsyfileserverid to public
\p\g
grant  copy_from on "mdbadmin".lsyfileserverid to public
\p\g
grant   select   on "mdbadmin".lsyfileserverstats to public
\p\g
grant   update   on "mdbadmin".lsyfileserverstats to public
\p\g
grant   delete   on "mdbadmin".lsyfileserverstats to public
\p\g
grant   insert   on "mdbadmin".lsyfileserverstats to public
\p\g
grant references on "mdbadmin".lsyfileserverstats to public
\p\g
grant  copy_into on "mdbadmin".lsyfileserverstats to public
\p\g
grant  copy_from on "mdbadmin".lsyfileserverstats to public
\p\g
grant   select   on "mdbadmin".lsylanprotocols to public
\p\g
grant   update   on "mdbadmin".lsylanprotocols to public
\p\g
grant   delete   on "mdbadmin".lsylanprotocols to public
\p\g
grant   insert   on "mdbadmin".lsylanprotocols to public
\p\g
grant references on "mdbadmin".lsylanprotocols to public
\p\g
grant  copy_into on "mdbadmin".lsylanprotocols to public
\p\g
grant  copy_from on "mdbadmin".lsylanprotocols to public
\p\g
grant   select   on "mdbadmin".lsylanutilization to public
\p\g
grant   update   on "mdbadmin".lsylanutilization to public
\p\g
grant   delete   on "mdbadmin".lsylanutilization to public
\p\g
grant   insert   on "mdbadmin".lsylanutilization to public
\p\g
grant references on "mdbadmin".lsylanutilization to public
\p\g
grant  copy_into on "mdbadmin".lsylanutilization to public
\p\g
grant  copy_from on "mdbadmin".lsylanutilization to public
\p\g
grant   select   on "mdbadmin".lsynetnames to public
\p\g
grant   update   on "mdbadmin".lsynetnames to public
\p\g
grant   delete   on "mdbadmin".lsynetnames to public
\p\g
grant   insert   on "mdbadmin".lsynetnames to public
\p\g
grant references on "mdbadmin".lsynetnames to public
\p\g
grant  copy_into on "mdbadmin".lsynetnames to public
\p\g
grant  copy_from on "mdbadmin".lsynetnames to public
\p\g
grant   select   on "mdbadmin".lsyprobeid to public
\p\g
grant   update   on "mdbadmin".lsyprobeid to public
\p\g
grant   delete   on "mdbadmin".lsyprobeid to public
\p\g
grant   insert   on "mdbadmin".lsyprobeid to public
\p\g
grant references on "mdbadmin".lsyprobeid to public
\p\g
grant  copy_into on "mdbadmin".lsyprobeid to public
\p\g
grant  copy_from on "mdbadmin".lsyprobeid to public
\p\g
grant   select   on "mdbadmin".lsyprotocoltypes to public
\p\g
grant   update   on "mdbadmin".lsyprotocoltypes to public
\p\g
grant   delete   on "mdbadmin".lsyprotocoltypes to public
\p\g
grant   insert   on "mdbadmin".lsyprotocoltypes to public
\p\g
grant references on "mdbadmin".lsyprotocoltypes to public
\p\g
grant  copy_into on "mdbadmin".lsyprotocoltypes to public
\p\g
grant  copy_from on "mdbadmin".lsyprotocoltypes to public
\p\g
grant   select   on "mdbadmin".lsytermserverclients to public
\p\g
grant   update   on "mdbadmin".lsytermserverclients to public
\p\g
grant   delete   on "mdbadmin".lsytermserverclients to public
\p\g
grant   insert   on "mdbadmin".lsytermserverclients to public
\p\g
grant references on "mdbadmin".lsytermserverclients to public
\p\g
grant  copy_into on "mdbadmin".lsytermserverclients to public
\p\g
grant  copy_from on "mdbadmin".lsytermserverclients to public
\p\g
grant   select   on "mdbadmin".lsytermserverid to public
\p\g
grant   update   on "mdbadmin".lsytermserverid to public
\p\g
grant   delete   on "mdbadmin".lsytermserverid to public
\p\g
grant   insert   on "mdbadmin".lsytermserverid to public
\p\g
grant references on "mdbadmin".lsytermserverid to public
\p\g
grant  copy_into on "mdbadmin".lsytermserverid to public
\p\g
grant  copy_from on "mdbadmin".lsytermserverid to public
\p\g
grant   select   on "mdbadmin".lsytermserverstats to public
\p\g
grant   update   on "mdbadmin".lsytermserverstats to public
\p\g
grant   delete   on "mdbadmin".lsytermserverstats to public
\p\g
grant   insert   on "mdbadmin".lsytermserverstats to public
\p\g
grant references on "mdbadmin".lsytermserverstats to public
\p\g
grant  copy_into on "mdbadmin".lsytermserverstats to public
\p\g
grant  copy_from on "mdbadmin".lsytermserverstats to public
\p\g
grant   select   on "mdbadmin".lsytopncast to public
\p\g
grant   update   on "mdbadmin".lsytopncast to public
\p\g
grant   delete   on "mdbadmin".lsytopncast to public
\p\g
grant   insert   on "mdbadmin".lsytopncast to public
\p\g
grant references on "mdbadmin".lsytopncast to public
\p\g
grant  copy_into on "mdbadmin".lsytopncast to public
\p\g
grant  copy_from on "mdbadmin".lsytopncast to public
\p\g
grant   select   on "mdbadmin".lsytopnlinkerr to public
\p\g
grant   update   on "mdbadmin".lsytopnlinkerr to public
\p\g
grant   delete   on "mdbadmin".lsytopnlinkerr to public
\p\g
grant   insert   on "mdbadmin".lsytopnlinkerr to public
\p\g
grant references on "mdbadmin".lsytopnlinkerr to public
\p\g
grant  copy_into on "mdbadmin".lsytopnlinkerr to public
\p\g
grant  copy_from on "mdbadmin".lsytopnlinkerr to public
\p\g
grant   select   on "mdbadmin".lsytopnmatrix to public
\p\g
grant   update   on "mdbadmin".lsytopnmatrix to public
\p\g
grant   delete   on "mdbadmin".lsytopnmatrix to public
\p\g
grant   insert   on "mdbadmin".lsytopnmatrix to public
\p\g
grant references on "mdbadmin".lsytopnmatrix to public
\p\g
grant  copy_into on "mdbadmin".lsytopnmatrix to public
\p\g
grant  copy_from on "mdbadmin".lsytopnmatrix to public
\p\g
grant   select   on "mdbadmin".lsytopnnetrsp to public
\p\g
grant   update   on "mdbadmin".lsytopnnetrsp to public
\p\g
grant   delete   on "mdbadmin".lsytopnnetrsp to public
\p\g
grant   insert   on "mdbadmin".lsytopnnetrsp to public
\p\g
grant references on "mdbadmin".lsytopnnetrsp to public
\p\g
grant  copy_into on "mdbadmin".lsytopnnetrsp to public
\p\g
grant  copy_from on "mdbadmin".lsytopnnetrsp to public
\p\g
grant   select   on "mdbadmin".lsytopnroute to public
\p\g
grant   update   on "mdbadmin".lsytopnroute to public
\p\g
grant   delete   on "mdbadmin".lsytopnroute to public
\p\g
grant   insert   on "mdbadmin".lsytopnroute to public
\p\g
grant references on "mdbadmin".lsytopnroute to public
\p\g
grant  copy_into on "mdbadmin".lsytopnroute to public
\p\g
grant  copy_from on "mdbadmin".lsytopnroute to public
\p\g
grant   select   on "mdbadmin".lsytopnroutedelay to public
\p\g
grant   update   on "mdbadmin".lsytopnroutedelay to public
\p\g
grant   delete   on "mdbadmin".lsytopnroutedelay to public
\p\g
grant   insert   on "mdbadmin".lsytopnroutedelay to public
\p\g
grant references on "mdbadmin".lsytopnroutedelay to public
\p\g
grant  copy_into on "mdbadmin".lsytopnroutedelay to public
\p\g
grant  copy_from on "mdbadmin".lsytopnroutedelay to public
\p\g
grant   select   on "mdbadmin".m2if to public
\p\g
grant   update   on "mdbadmin".m2if to public
\p\g
grant   delete   on "mdbadmin".m2if to public
\p\g
grant   insert   on "mdbadmin".m2if to public
\p\g
grant references on "mdbadmin".m2if to public
\p\g
grant  copy_into on "mdbadmin".m2if to public
\p\g
grant  copy_from on "mdbadmin".m2if to public
\p\g
grant   select   on "mdbadmin".m2ifstats to public
\p\g
grant   update   on "mdbadmin".m2ifstats to public
\p\g
grant   delete   on "mdbadmin".m2ifstats to public
\p\g
grant   insert   on "mdbadmin".m2ifstats to public
\p\g
grant references on "mdbadmin".m2ifstats to public
\p\g
grant  copy_into on "mdbadmin".m2ifstats to public
\p\g
grant  copy_from on "mdbadmin".m2ifstats to public
\p\g
grant   select   on "mdbadmin".m2ipstats to public
\p\g
grant   update   on "mdbadmin".m2ipstats to public
\p\g
grant   delete   on "mdbadmin".m2ipstats to public
\p\g
grant   insert   on "mdbadmin".m2ipstats to public
\p\g
grant references on "mdbadmin".m2ipstats to public
\p\g
grant  copy_into on "mdbadmin".m2ipstats to public
\p\g
grant  copy_from on "mdbadmin".m2ipstats to public
\p\g
grant   select   on "mdbadmin".mactoip to public
\p\g
grant   update   on "mdbadmin".mactoip to public
\p\g
grant   delete   on "mdbadmin".mactoip to public
\p\g
grant   insert   on "mdbadmin".mactoip to public
\p\g
grant references on "mdbadmin".mactoip to public
\p\g
grant  copy_into on "mdbadmin".mactoip to public
\p\g
grant  copy_from on "mdbadmin".mactoip to public
\p\g
grant   select   on "mdbadmin".mibdefinition to public
\p\g
grant   update   on "mdbadmin".mibdefinition to public
\p\g
grant   delete   on "mdbadmin".mibdefinition to public
\p\g
grant   insert   on "mdbadmin".mibdefinition to public
\p\g
grant references on "mdbadmin".mibdefinition to public
\p\g
grant  copy_into on "mdbadmin".mibdefinition to public
\p\g
grant  copy_from on "mdbadmin".mibdefinition to public
\p\g
grant   select   on "mdbadmin".mibstructure to public
\p\g
grant   update   on "mdbadmin".mibstructure to public
\p\g
grant   delete   on "mdbadmin".mibstructure to public
\p\g
grant   insert   on "mdbadmin".mibstructure to public
\p\g
grant references on "mdbadmin".mibstructure to public
\p\g
grant  copy_into on "mdbadmin".mibstructure to public
\p\g
grant  copy_from on "mdbadmin".mibstructure to public
\p\g
grant   select   on "mdbadmin".mibvariabletype to public
\p\g
grant   update   on "mdbadmin".mibvariabletype to public
\p\g
grant   delete   on "mdbadmin".mibvariabletype to public
\p\g
grant   insert   on "mdbadmin".mibvariabletype to public
\p\g
grant references on "mdbadmin".mibvariabletype to public
\p\g
grant  copy_into on "mdbadmin".mibvariabletype to public
\p\g
grant  copy_from on "mdbadmin".mibvariabletype to public
\p\g
grant   select   on "mdbadmin".monitorappl to public
\p\g
grant   update   on "mdbadmin".monitorappl to public
\p\g
grant   delete   on "mdbadmin".monitorappl to public
\p\g
grant   insert   on "mdbadmin".monitorappl to public
\p\g
grant references on "mdbadmin".monitorappl to public
\p\g
grant  copy_into on "mdbadmin".monitorappl to public
\p\g
grant  copy_from on "mdbadmin".monitorappl to public
\p\g
grant   select   on "mdbadmin".nahd_hist_settings to neugentsahd with 
grant option
\p\g
grant   update   on "mdbadmin".nahd_hist_settings to neugentsahd with 
grant option
\p\g
grant   delete   on "mdbadmin".nahd_hist_settings to neugentsahd with 
grant option
\p\g
grant   insert   on "mdbadmin".nahd_hist_settings to neugentsahd with 
grant option
\p\g
grant references on "mdbadmin".nahd_hist_settings to neugentsahd with 
grant option
\p\g
grant  copy_into on "mdbadmin".nahd_hist_settings to neugentsahd with 
grant option
\p\g
grant  copy_from on "mdbadmin".nahd_hist_settings to neugentsahd with 
grant option
\p\g
grant   select   on "mdbadmin".nbarprotocol_cfg to public
\p\g
grant   update   on "mdbadmin".nbarprotocol_cfg to public
\p\g
grant   delete   on "mdbadmin".nbarprotocol_cfg to public
\p\g
grant   insert   on "mdbadmin".nbarprotocol_cfg to public
\p\g
grant references on "mdbadmin".nbarprotocol_cfg to public
\p\g
grant  copy_into on "mdbadmin".nbarprotocol_cfg to public
\p\g
grant  copy_from on "mdbadmin".nbarprotocol_cfg to public
\p\g
grant   select   on "mdbadmin".nbarprotocol_stat to public
\p\g
grant   update   on "mdbadmin".nbarprotocol_stat to public
\p\g
grant   delete   on "mdbadmin".nbarprotocol_stat to public
\p\g
grant   insert   on "mdbadmin".nbarprotocol_stat to public
\p\g
grant references on "mdbadmin".nbarprotocol_stat to public
\p\g
grant  copy_into on "mdbadmin".nbarprotocol_stat to public
\p\g
grant  copy_from on "mdbadmin".nbarprotocol_stat to public
\p\g
grant   select   on "mdbadmin".nbarprotocolstatus_cfg to public
\p\g
grant   update   on "mdbadmin".nbarprotocolstatus_cfg to public
\p\g
grant   delete   on "mdbadmin".nbarprotocolstatus_cfg to public
\p\g
grant   insert   on "mdbadmin".nbarprotocolstatus_cfg to public
\p\g
grant references on "mdbadmin".nbarprotocolstatus_cfg to public
\p\g
grant  copy_into on "mdbadmin".nbarprotocolstatus_cfg to public
\p\g
grant  copy_from on "mdbadmin".nbarprotocolstatus_cfg to public
\p\g
grant   select   on "mdbadmin".nbarprotocolstatus_stat to public
\p\g
grant   update   on "mdbadmin".nbarprotocolstatus_stat to public
\p\g
grant   delete   on "mdbadmin".nbarprotocolstatus_stat to public
\p\g
grant   insert   on "mdbadmin".nbarprotocolstatus_stat to public
\p\g
grant references on "mdbadmin".nbarprotocolstatus_stat to public
\p\g
grant  copy_into on "mdbadmin".nbarprotocolstatus_stat to public
\p\g
grant  copy_from on "mdbadmin".nbarprotocolstatus_stat to public
\p\g
grant   select   on "mdbadmin".network_alert to public
\p\g
grant   update   on "mdbadmin".network_alert to public
\p\g
grant   delete   on "mdbadmin".network_alert to public
\p\g
grant   insert   on "mdbadmin".network_alert to public
\p\g
grant references on "mdbadmin".network_alert to public
\p\g
grant  copy_into on "mdbadmin".network_alert to public
\p\g
grant  copy_from on "mdbadmin".network_alert to public
\p\g
grant   select   on "mdbadmin".network_groupid to public
\p\g
grant   update   on "mdbadmin".network_groupid to public
\p\g
grant   delete   on "mdbadmin".network_groupid to public
\p\g
grant   insert   on "mdbadmin".network_groupid to public
\p\g
grant references on "mdbadmin".network_groupid to public
\p\g
grant  copy_into on "mdbadmin".network_groupid to public
\p\g
grant  copy_from on "mdbadmin".network_groupid to public
\p\g
grant   select   on "mdbadmin".network_groups to public
\p\g
grant   update   on "mdbadmin".network_groups to public
\p\g
grant   delete   on "mdbadmin".network_groups to public
\p\g
grant   insert   on "mdbadmin".network_groups to public
\p\g
grant references on "mdbadmin".network_groups to public
\p\g
grant  copy_into on "mdbadmin".network_groups to public
\p\g
grant  copy_from on "mdbadmin".network_groups to public
\p\g
grant   select   on "mdbadmin".network_mib to public
\p\g
grant   update   on "mdbadmin".network_mib to public
\p\g
grant   delete   on "mdbadmin".network_mib to public
\p\g
grant   insert   on "mdbadmin".network_mib to public
\p\g
grant references on "mdbadmin".network_mib to public
\p\g
grant  copy_into on "mdbadmin".network_mib to public
\p\g
grant  copy_from on "mdbadmin".network_mib to public
\p\g
grant   select   on "mdbadmin".network_probe to public
\p\g
grant   update   on "mdbadmin".network_probe to public
\p\g
grant   delete   on "mdbadmin".network_probe to public
\p\g
grant   insert   on "mdbadmin".network_probe to public
\p\g
grant references on "mdbadmin".network_probe to public
\p\g
grant  copy_into on "mdbadmin".network_probe to public
\p\g
grant  copy_from on "mdbadmin".network_probe to public
\p\g
grant   select   on "mdbadmin".neug_mo_list to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".neug_mo_list to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".neug_mo_list to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".neug_mo_list to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".neug_mo_list to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".neug_mo_list to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".neug_mo_list to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".nonavail to public
\p\g
grant   update   on "mdbadmin".nonavail to public
\p\g
grant   delete   on "mdbadmin".nonavail to public
\p\g
grant   insert   on "mdbadmin".nonavail to public
\p\g
grant references on "mdbadmin".nonavail to public
\p\g
grant  copy_into on "mdbadmin".nonavail to public
\p\g
grant  copy_from on "mdbadmin".nonavail to public
\p\g
grant   select   on "mdbadmin".nonhealth to public
\p\g
grant   update   on "mdbadmin".nonhealth to public
\p\g
grant   delete   on "mdbadmin".nonhealth to public
\p\g
grant   insert   on "mdbadmin".nonhealth to public
\p\g
grant references on "mdbadmin".nonhealth to public
\p\g
grant  copy_into on "mdbadmin".nonhealth to public
\p\g
grant  copy_from on "mdbadmin".nonhealth to public
\p\g
grant   select   on table "mdbadmin".pd_bpv to public
\p\g
grant   update   on table "mdbadmin".pd_bpv to public
\p\g
grant   delete   on table "mdbadmin".pd_bpv to public
\p\g
grant   insert   on table "mdbadmin".pd_bpv to public
\p\g
grant references on table "mdbadmin".pd_bpv to public
\p\g
grant  copy_into on table "mdbadmin".pd_bpv to public
\p\g
grant  copy_from on table "mdbadmin".pd_bpv to public
\p\g
grant   select   on table "mdbadmin".pd_bpv_def to public
\p\g
grant   update   on table "mdbadmin".pd_bpv_def to public
\p\g
grant   delete   on table "mdbadmin".pd_bpv_def to public
\p\g
grant   insert   on table "mdbadmin".pd_bpv_def to public
\p\g
grant references on table "mdbadmin".pd_bpv_def to public
\p\g
grant  copy_into on table "mdbadmin".pd_bpv_def to public
\p\g
grant  copy_from on table "mdbadmin".pd_bpv_def to public
\p\g
grant   select   on table "mdbadmin".pd_cluster_def to public
\p\g
grant   update   on table "mdbadmin".pd_cluster_def to public
\p\g
grant   delete   on table "mdbadmin".pd_cluster_def to public
\p\g
grant   insert   on table "mdbadmin".pd_cluster_def to public
\p\g
grant references on table "mdbadmin".pd_cluster_def to public
\p\g
grant  copy_into on table "mdbadmin".pd_cluster_def to public
\p\g
grant  copy_from on table "mdbadmin".pd_cluster_def to public
\p\g
grant   select   on table "mdbadmin".pd_day to public
\p\g
grant   update   on table "mdbadmin".pd_day to public
\p\g
grant   delete   on table "mdbadmin".pd_day to public
\p\g
grant   insert   on table "mdbadmin".pd_day to public
\p\g
grant references on table "mdbadmin".pd_day to public
\p\g
grant  copy_into on table "mdbadmin".pd_day to public
\p\g
grant  copy_from on table "mdbadmin".pd_day to public
\p\g
grant   select   on table "mdbadmin".pd_global to public
\p\g
grant   update   on table "mdbadmin".pd_global to public
\p\g
grant   delete   on table "mdbadmin".pd_global to public
\p\g
grant   insert   on table "mdbadmin".pd_global to public
\p\g
grant references on table "mdbadmin".pd_global to public
\p\g
grant  copy_into on table "mdbadmin".pd_global to public
\p\g
grant  copy_from on table "mdbadmin".pd_global to public
\p\g
grant   select   on table "mdbadmin".pd_machine to public
\p\g
grant   update   on table "mdbadmin".pd_machine to public
\p\g
grant   delete   on table "mdbadmin".pd_machine to public
\p\g
grant   insert   on table "mdbadmin".pd_machine to public
\p\g
grant references on table "mdbadmin".pd_machine to public
\p\g
grant  copy_into on table "mdbadmin".pd_machine to public
\p\g
grant  copy_from on table "mdbadmin".pd_machine to public
\p\g
grant   select   on table "mdbadmin".pd_machine_ext to public
\p\g
grant   update   on table "mdbadmin".pd_machine_ext to public
\p\g
grant   delete   on table "mdbadmin".pd_machine_ext to public
\p\g
grant   insert   on table "mdbadmin".pd_machine_ext to public
\p\g
grant references on table "mdbadmin".pd_machine_ext to public
\p\g
grant  copy_into on table "mdbadmin".pd_machine_ext to public
\p\g
grant  copy_from on table "mdbadmin".pd_machine_ext to public
\p\g
grant   select   on table "mdbadmin".pd_max_bpv to public
\p\g
grant   update   on table "mdbadmin".pd_max_bpv to public
\p\g
grant   delete   on table "mdbadmin".pd_max_bpv to public
\p\g
grant   insert   on table "mdbadmin".pd_max_bpv to public
\p\g
grant references on table "mdbadmin".pd_max_bpv to public
\p\g
grant  copy_into on table "mdbadmin".pd_max_bpv to public
\p\g
grant  copy_from on table "mdbadmin".pd_max_bpv to public
\p\g
grant   select   on table "mdbadmin".pd_max_day to public
\p\g
grant   update   on table "mdbadmin".pd_max_day to public
\p\g
grant   delete   on table "mdbadmin".pd_max_day to public
\p\g
grant   insert   on table "mdbadmin".pd_max_day to public
\p\g
grant references on table "mdbadmin".pd_max_day to public
\p\g
grant  copy_into on table "mdbadmin".pd_max_day to public
\p\g
grant  copy_from on table "mdbadmin".pd_max_day to public
\p\g
grant   select   on table "mdbadmin".pd_max_machine to public
\p\g
grant   update   on table "mdbadmin".pd_max_machine to public
\p\g
grant   delete   on table "mdbadmin".pd_max_machine to public
\p\g
grant   insert   on table "mdbadmin".pd_max_machine to public
\p\g
grant references on table "mdbadmin".pd_max_machine to public
\p\g
grant  copy_into on table "mdbadmin".pd_max_machine to public
\p\g
grant  copy_from on table "mdbadmin".pd_max_machine to public
\p\g
grant   select   on table "mdbadmin".pd_max_resource to public
\p\g
grant   update   on table "mdbadmin".pd_max_resource to public
\p\g
grant   delete   on table "mdbadmin".pd_max_resource to public
\p\g
grant   insert   on table "mdbadmin".pd_max_resource to public
\p\g
grant references on table "mdbadmin".pd_max_resource to public
\p\g
grant  copy_into on table "mdbadmin".pd_max_resource to public
\p\g
grant  copy_from on table "mdbadmin".pd_max_resource to public
\p\g
grant   select   on table "mdbadmin".pd_resource to public
\p\g
grant   update   on table "mdbadmin".pd_resource to public
\p\g
grant   delete   on table "mdbadmin".pd_resource to public
\p\g
grant   insert   on table "mdbadmin".pd_resource to public
\p\g
grant references on table "mdbadmin".pd_resource to public
\p\g
grant  copy_into on table "mdbadmin".pd_resource to public
\p\g
grant  copy_from on table "mdbadmin".pd_resource to public
\p\g
grant   select   on table "mdbadmin".pd_time to public
\p\g
grant   update   on table "mdbadmin".pd_time to public
\p\g
grant   delete   on table "mdbadmin".pd_time to public
\p\g
grant   insert   on table "mdbadmin".pd_time to public
\p\g
grant references on table "mdbadmin".pd_time to public
\p\g
grant  copy_into on table "mdbadmin".pd_time to public
\p\g
grant  copy_from on table "mdbadmin".pd_time to public
\p\g
grant   select   on table "mdbadmin".pd_val_10min to public
\p\g
grant   update   on table "mdbadmin".pd_val_10min to public
\p\g
grant   delete   on table "mdbadmin".pd_val_10min to public
\p\g
grant   insert   on table "mdbadmin".pd_val_10min to public
\p\g
grant references on table "mdbadmin".pd_val_10min to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_10min to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_10min to public
\p\g
grant   select   on table "mdbadmin".pd_val_12hr to public
\p\g
grant   update   on table "mdbadmin".pd_val_12hr to public
\p\g
grant   delete   on table "mdbadmin".pd_val_12hr to public
\p\g
grant   insert   on table "mdbadmin".pd_val_12hr to public
\p\g
grant references on table "mdbadmin".pd_val_12hr to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_12hr to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_12hr to public
\p\g
grant   select   on table "mdbadmin".pd_val_15min to public
\p\g
grant   update   on table "mdbadmin".pd_val_15min to public
\p\g
grant   delete   on table "mdbadmin".pd_val_15min to public
\p\g
grant   insert   on table "mdbadmin".pd_val_15min to public
\p\g
grant references on table "mdbadmin".pd_val_15min to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_15min to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_15min to public
\p\g
grant   select   on table "mdbadmin".pd_val_1day to public
\p\g
grant   update   on table "mdbadmin".pd_val_1day to public
\p\g
grant   delete   on table "mdbadmin".pd_val_1day to public
\p\g
grant   insert   on table "mdbadmin".pd_val_1day to public
\p\g
grant references on table "mdbadmin".pd_val_1day to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_1day to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_1day to public
\p\g
grant   select   on table "mdbadmin".pd_val_1hr to public
\p\g
grant   update   on table "mdbadmin".pd_val_1hr to public
\p\g
grant   delete   on table "mdbadmin".pd_val_1hr to public
\p\g
grant   insert   on table "mdbadmin".pd_val_1hr to public
\p\g
grant references on table "mdbadmin".pd_val_1hr to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_1hr to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_1hr to public
\p\g
grant   select   on table "mdbadmin".pd_val_1min to public
\p\g
grant   update   on table "mdbadmin".pd_val_1min to public
\p\g
grant   delete   on table "mdbadmin".pd_val_1min to public
\p\g
grant   insert   on table "mdbadmin".pd_val_1min to public
\p\g
grant references on table "mdbadmin".pd_val_1min to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_1min to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_1min to public
\p\g
grant   select   on table "mdbadmin".pd_val_1month to public
\p\g
grant   update   on table "mdbadmin".pd_val_1month to public
\p\g
grant   delete   on table "mdbadmin".pd_val_1month to public
\p\g
grant   insert   on table "mdbadmin".pd_val_1month to public
\p\g
grant references on table "mdbadmin".pd_val_1month to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_1month to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_1month to public
\p\g
grant   select   on table "mdbadmin".pd_val_1week to public
\p\g
grant   update   on table "mdbadmin".pd_val_1week to public
\p\g
grant   delete   on table "mdbadmin".pd_val_1week to public
\p\g
grant   insert   on table "mdbadmin".pd_val_1week to public
\p\g
grant references on table "mdbadmin".pd_val_1week to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_1week to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_1week to public
\p\g
grant   select   on table "mdbadmin".pd_val_1year to public
\p\g
grant   update   on table "mdbadmin".pd_val_1year to public
\p\g
grant   delete   on table "mdbadmin".pd_val_1year to public
\p\g
grant   insert   on table "mdbadmin".pd_val_1year to public
\p\g
grant references on table "mdbadmin".pd_val_1year to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_1year to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_1year to public
\p\g
grant   select   on table "mdbadmin".pd_val_20min to public
\p\g
grant   update   on table "mdbadmin".pd_val_20min to public
\p\g
grant   delete   on table "mdbadmin".pd_val_20min to public
\p\g
grant   insert   on table "mdbadmin".pd_val_20min to public
\p\g
grant references on table "mdbadmin".pd_val_20min to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_20min to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_20min to public
\p\g
grant   select   on table "mdbadmin".pd_val_2hr to public
\p\g
grant   update   on table "mdbadmin".pd_val_2hr to public
\p\g
grant   delete   on table "mdbadmin".pd_val_2hr to public
\p\g
grant   insert   on table "mdbadmin".pd_val_2hr to public
\p\g
grant references on table "mdbadmin".pd_val_2hr to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_2hr to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_2hr to public
\p\g
grant   select   on table "mdbadmin".pd_val_30min to public
\p\g
grant   update   on table "mdbadmin".pd_val_30min to public
\p\g
grant   delete   on table "mdbadmin".pd_val_30min to public
\p\g
grant   insert   on table "mdbadmin".pd_val_30min to public
\p\g
grant references on table "mdbadmin".pd_val_30min to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_30min to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_30min to public
\p\g
grant   select   on table "mdbadmin".pd_val_4hr to public
\p\g
grant   update   on table "mdbadmin".pd_val_4hr to public
\p\g
grant   delete   on table "mdbadmin".pd_val_4hr to public
\p\g
grant   insert   on table "mdbadmin".pd_val_4hr to public
\p\g
grant references on table "mdbadmin".pd_val_4hr to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_4hr to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_4hr to public
\p\g
grant   select   on table "mdbadmin".pd_val_5min to public
\p\g
grant   update   on table "mdbadmin".pd_val_5min to public
\p\g
grant   delete   on table "mdbadmin".pd_val_5min to public
\p\g
grant   insert   on table "mdbadmin".pd_val_5min to public
\p\g
grant references on table "mdbadmin".pd_val_5min to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_5min to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_5min to public
\p\g
grant   select   on table "mdbadmin".pd_val_6hr to public
\p\g
grant   update   on table "mdbadmin".pd_val_6hr to public
\p\g
grant   delete   on table "mdbadmin".pd_val_6hr to public
\p\g
grant   insert   on table "mdbadmin".pd_val_6hr to public
\p\g
grant references on table "mdbadmin".pd_val_6hr to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_6hr to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_6hr to public
\p\g
grant   select   on table "mdbadmin".pd_val_8hr to public
\p\g
grant   update   on table "mdbadmin".pd_val_8hr to public
\p\g
grant   delete   on table "mdbadmin".pd_val_8hr to public
\p\g
grant   insert   on table "mdbadmin".pd_val_8hr to public
\p\g
grant references on table "mdbadmin".pd_val_8hr to public
\p\g
grant  copy_into on table "mdbadmin".pd_val_8hr to public
\p\g
grant  copy_from on table "mdbadmin".pd_val_8hr to public
\p\g
grant select on "mdbadmin".permissions to group infopump_user
\p\g
grant update on "mdbadmin".permissions to group infopump_user
\p\g
grant delete on "mdbadmin".permissions to group infopump_user
\p\g
grant insert on "mdbadmin".permissions to group infopump_user
\p\g
grant select on "mdbadmin".permissions to group infopump_admin
\p\g
grant update on "mdbadmin".permissions to group infopump_admin
\p\g
grant delete on "mdbadmin".permissions to group infopump_admin
\p\g
grant insert on "mdbadmin".permissions to group infopump_admin
\p\g
grant references on "mdbadmin".permissions to group infopump_admin
\p\g
grant copy_into on "mdbadmin".permissions to group infopump_admin
\p\g
grant copy_from on "mdbadmin".permissions to group infopump_admin
\p\g
grant   select   on "mdbadmin".pollrowdefinition to public
\p\g
grant   update   on "mdbadmin".pollrowdefinition to public
\p\g
grant   delete   on "mdbadmin".pollrowdefinition to public
\p\g
grant   insert   on "mdbadmin".pollrowdefinition to public
\p\g
grant references on "mdbadmin".pollrowdefinition to public
\p\g
grant  copy_into on "mdbadmin".pollrowdefinition to public
\p\g
grant  copy_from on "mdbadmin".pollrowdefinition to public
\p\g
grant   select   on "mdbadmin".probeaccesslist to public
\p\g
grant   update   on "mdbadmin".probeaccesslist to public
\p\g
grant   delete   on "mdbadmin".probeaccesslist to public
\p\g
grant   insert   on "mdbadmin".probeaccesslist to public
\p\g
grant references on "mdbadmin".probeaccesslist to public
\p\g
grant  copy_into on "mdbadmin".probeaccesslist to public
\p\g
grant  copy_from on "mdbadmin".probeaccesslist to public
\p\g
grant select on "mdbadmin".providerversion to group infopump_user
\p\g
grant select on "mdbadmin".providerversion to group infopump_admin
\p\g
grant update on "mdbadmin".providerversion to group infopump_admin
\p\g
grant delete on "mdbadmin".providerversion to group infopump_admin
\p\g
grant insert on "mdbadmin".providerversion to group infopump_admin
\p\g
grant references on "mdbadmin".providerversion to group infopump_admin
\p\g
grant copy_into on "mdbadmin".providerversion to group infopump_admin
\p\g
grant copy_from on "mdbadmin".providerversion to group infopump_admin
\p\g
grant select on "mdbadmin".rdbms_provider to group infopump_user
\p\g
grant update on "mdbadmin".rdbms_provider to group infopump_user
\p\g
grant delete on "mdbadmin".rdbms_provider to group infopump_user
\p\g
grant insert on "mdbadmin".rdbms_provider to group infopump_user
\p\g
grant select on "mdbadmin".rdbms_provider to group infopump_admin
\p\g
grant update on "mdbadmin".rdbms_provider to group infopump_admin
\p\g
grant delete on "mdbadmin".rdbms_provider to group infopump_admin
\p\g
grant insert on "mdbadmin".rdbms_provider to group infopump_admin
\p\g
grant references on "mdbadmin".rdbms_provider to group infopump_admin
\p\g
grant copy_into on "mdbadmin".rdbms_provider to group infopump_admin
\p\g
grant copy_from on "mdbadmin".rdbms_provider to group infopump_admin
\p\g
grant   select   on "mdbadmin".reportdescr to public
\p\g
grant   update   on "mdbadmin".reportdescr to public
\p\g
grant   delete   on "mdbadmin".reportdescr to public
\p\g
grant   insert   on "mdbadmin".reportdescr to public
\p\g
grant references on "mdbadmin".reportdescr to public
\p\g
grant  copy_into on "mdbadmin".reportdescr to public
\p\g
grant  copy_from on "mdbadmin".reportdescr to public
\p\g
grant select on "mdbadmin".requestprovider to group infopump_user
\p\g
grant update on "mdbadmin".requestprovider to group infopump_user
\p\g
grant delete on "mdbadmin".requestprovider to group infopump_user
\p\g
grant insert on "mdbadmin".requestprovider to group infopump_user
\p\g
grant select on "mdbadmin".requestprovider to group infopump_admin
\p\g
grant update on "mdbadmin".requestprovider to group infopump_admin
\p\g
grant delete on "mdbadmin".requestprovider to group infopump_admin
\p\g
grant insert on "mdbadmin".requestprovider to group infopump_admin
\p\g
grant references on "mdbadmin".requestprovider to group infopump_admin
\p\g
grant copy_into on "mdbadmin".requestprovider to group infopump_admin
\p\g
grant copy_from on "mdbadmin".requestprovider to group infopump_admin
\p\g
grant select on "mdbadmin".requestqueue to group infopump_user
\p\g
grant update on "mdbadmin".requestqueue to group infopump_user
\p\g
grant delete on "mdbadmin".requestqueue to group infopump_user
\p\g
grant insert on "mdbadmin".requestqueue to group infopump_user
\p\g
grant select on "mdbadmin".requestqueue to group infopump_admin
\p\g
grant update on "mdbadmin".requestqueue to group infopump_admin
\p\g
grant delete on "mdbadmin".requestqueue to group infopump_admin
\p\g
grant insert on "mdbadmin".requestqueue to group infopump_admin
\p\g
grant references on "mdbadmin".requestqueue to group infopump_admin
\p\g
grant copy_into on "mdbadmin".requestqueue to group infopump_admin
\p\g
grant copy_from on "mdbadmin".requestqueue to group infopump_admin
\p\g
grant   select   on "mdbadmin".resnonhealth to public
\p\g
grant   update   on "mdbadmin".resnonhealth to public
\p\g
grant   delete   on "mdbadmin".resnonhealth to public
\p\g
grant   insert   on "mdbadmin".resnonhealth to public
\p\g
grant references on "mdbadmin".resnonhealth to public
\p\g
grant  copy_into on "mdbadmin".resnonhealth to public
\p\g
grant  copy_from on "mdbadmin".resnonhealth to public
\p\g
grant   select   on "mdbadmin".resourcemonitoring to public
\p\g
grant   update   on "mdbadmin".resourcemonitoring to public
\p\g
grant   delete   on "mdbadmin".resourcemonitoring to public
\p\g
grant   insert   on "mdbadmin".resourcemonitoring to public
\p\g
grant references on "mdbadmin".resourcemonitoring to public
\p\g
grant  copy_into on "mdbadmin".resourcemonitoring to public
\p\g
grant  copy_from on "mdbadmin".resourcemonitoring to public
\p\g
grant   select   on "mdbadmin".resourcename to public
\p\g
grant   update   on "mdbadmin".resourcename to public
\p\g
grant   delete   on "mdbadmin".resourcename to public
\p\g
grant   insert   on "mdbadmin".resourcename to public
\p\g
grant references on "mdbadmin".resourcename to public
\p\g
grant  copy_into on "mdbadmin".resourcename to public
\p\g
grant  copy_from on "mdbadmin".resourcename to public
\p\g
grant   select   on "mdbadmin".resourcetype to public
\p\g
grant   update   on "mdbadmin".resourcetype to public
\p\g
grant   delete   on "mdbadmin".resourcetype to public
\p\g
grant   insert   on "mdbadmin".resourcetype to public
\p\g
grant references on "mdbadmin".resourcetype to public
\p\g
grant  copy_into on "mdbadmin".resourcetype to public
\p\g
grant  copy_from on "mdbadmin".resourcetype to public
\p\g
grant   select   on "mdbadmin".rmconfiguration to public
\p\g
grant   update   on "mdbadmin".rmconfiguration to public
\p\g
grant   delete   on "mdbadmin".rmconfiguration to public
\p\g
grant   insert   on "mdbadmin".rmconfiguration to public
\p\g
grant references on "mdbadmin".rmconfiguration to public
\p\g
grant  copy_into on "mdbadmin".rmconfiguration to public
\p\g
grant  copy_from on "mdbadmin".rmconfiguration to public
\p\g
grant   select   on "mdbadmin".rmon2addressmap to public
\p\g
grant   update   on "mdbadmin".rmon2addressmap to public
\p\g
grant   delete   on "mdbadmin".rmon2addressmap to public
\p\g
grant   insert   on "mdbadmin".rmon2addressmap to public
\p\g
grant references on "mdbadmin".rmon2addressmap to public
\p\g
grant  copy_into on "mdbadmin".rmon2addressmap to public
\p\g
grant  copy_from on "mdbadmin".rmon2addressmap to public
\p\g
grant   select   on "mdbadmin".rmon2alhost to public
\p\g
grant   update   on "mdbadmin".rmon2alhost to public
\p\g
grant   delete   on "mdbadmin".rmon2alhost to public
\p\g
grant   insert   on "mdbadmin".rmon2alhost to public
\p\g
grant references on "mdbadmin".rmon2alhost to public
\p\g
grant  copy_into on "mdbadmin".rmon2alhost to public
\p\g
grant  copy_from on "mdbadmin".rmon2alhost to public
\p\g
grant   select   on "mdbadmin".rmon2nlmatrix to public
\p\g
grant   update   on "mdbadmin".rmon2nlmatrix to public
\p\g
grant   delete   on "mdbadmin".rmon2nlmatrix to public
\p\g
grant   insert   on "mdbadmin".rmon2nlmatrix to public
\p\g
grant references on "mdbadmin".rmon2nlmatrix to public
\p\g
grant  copy_into on "mdbadmin".rmon2nlmatrix to public
\p\g
grant  copy_from on "mdbadmin".rmon2nlmatrix to public
\p\g
grant   select   on "mdbadmin".rmon2protocoldist to public
\p\g
grant   update   on "mdbadmin".rmon2protocoldist to public
\p\g
grant   delete   on "mdbadmin".rmon2protocoldist to public
\p\g
grant   insert   on "mdbadmin".rmon2protocoldist to public
\p\g
grant references on "mdbadmin".rmon2protocoldist to public
\p\g
grant  copy_into on "mdbadmin".rmon2protocoldist to public
\p\g
grant  copy_from on "mdbadmin".rmon2protocoldist to public
\p\g
grant   select   on "mdbadmin".rmon2protocoldistcontrol to public
\p\g
grant   update   on "mdbadmin".rmon2protocoldistcontrol to public
\p\g
grant   delete   on "mdbadmin".rmon2protocoldistcontrol to public
\p\g
grant   insert   on "mdbadmin".rmon2protocoldistcontrol to public
\p\g
grant references on "mdbadmin".rmon2protocoldistcontrol to public
\p\g
grant  copy_into on "mdbadmin".rmon2protocoldistcontrol to public
\p\g
grant  copy_from on "mdbadmin".rmon2protocoldistcontrol to public
\p\g
grant   select   on "mdbadmin".rmon2protocolid to public
\p\g
grant   update   on "mdbadmin".rmon2protocolid to public
\p\g
grant   delete   on "mdbadmin".rmon2protocolid to public
\p\g
grant   insert   on "mdbadmin".rmon2protocolid to public
\p\g
grant references on "mdbadmin".rmon2protocolid to public
\p\g
grant  copy_into on "mdbadmin".rmon2protocolid to public
\p\g
grant  copy_from on "mdbadmin".rmon2protocolid to public
\p\g
grant   select   on "mdbadmin".rmon2protocolproperties to public
\p\g
grant   update   on "mdbadmin".rmon2protocolproperties to public
\p\g
grant   delete   on "mdbadmin".rmon2protocolproperties to public
\p\g
grant   insert   on "mdbadmin".rmon2protocolproperties to public
\p\g
grant references on "mdbadmin".rmon2protocolproperties to public
\p\g
grant  copy_into on "mdbadmin".rmon2protocolproperties to public
\p\g
grant  copy_from on "mdbadmin".rmon2protocolproperties to public
\p\g
grant   select   on "mdbadmin".rmonetherstatsid to public
\p\g
grant   update   on "mdbadmin".rmonetherstatsid to public
\p\g
grant   delete   on "mdbadmin".rmonetherstatsid to public
\p\g
grant   insert   on "mdbadmin".rmonetherstatsid to public
\p\g
grant references on "mdbadmin".rmonetherstatsid to public
\p\g
grant  copy_into on "mdbadmin".rmonetherstatsid to public
\p\g
grant  copy_from on "mdbadmin".rmonetherstatsid to public
\p\g
grant   select   on "mdbadmin".rmonetherstatsstats to public
\p\g
grant   update   on "mdbadmin".rmonetherstatsstats to public
\p\g
grant   delete   on "mdbadmin".rmonetherstatsstats to public
\p\g
grant   insert   on "mdbadmin".rmonetherstatsstats to public
\p\g
grant references on "mdbadmin".rmonetherstatsstats to public
\p\g
grant  copy_into on "mdbadmin".rmonetherstatsstats to public
\p\g
grant  copy_from on "mdbadmin".rmonetherstatsstats to public
\p\g
grant   select   on "mdbadmin".rmonhostcontrol to public
\p\g
grant   update   on "mdbadmin".rmonhostcontrol to public
\p\g
grant   delete   on "mdbadmin".rmonhostcontrol to public
\p\g
grant   insert   on "mdbadmin".rmonhostcontrol to public
\p\g
grant references on "mdbadmin".rmonhostcontrol to public
\p\g
grant  copy_into on "mdbadmin".rmonhostcontrol to public
\p\g
grant  copy_from on "mdbadmin".rmonhostcontrol to public
\p\g
grant   select   on "mdbadmin".rmonhosttopnstat to public
\p\g
grant   update   on "mdbadmin".rmonhosttopnstat to public
\p\g
grant   delete   on "mdbadmin".rmonhosttopnstat to public
\p\g
grant   insert   on "mdbadmin".rmonhosttopnstat to public
\p\g
grant references on "mdbadmin".rmonhosttopnstat to public
\p\g
grant  copy_into on "mdbadmin".rmonhosttopnstat to public
\p\g
grant  copy_from on "mdbadmin".rmonhosttopnstat to public
\p\g
grant   select   on "mdbadmin".rmonrptquerydata to public
\p\g
grant   update   on "mdbadmin".rmonrptquerydata to public
\p\g
grant   delete   on "mdbadmin".rmonrptquerydata to public
\p\g
grant   insert   on "mdbadmin".rmonrptquerydata to public
\p\g
grant references on "mdbadmin".rmonrptquerydata to public
\p\g
grant  copy_into on "mdbadmin".rmonrptquerydata to public
\p\g
grant  copy_from on "mdbadmin".rmonrptquerydata to public
\p\g
grant   select   on "mdbadmin".rmonrptquerytempdata to public
\p\g
grant   update   on "mdbadmin".rmonrptquerytempdata to public
\p\g
grant   delete   on "mdbadmin".rmonrptquerytempdata to public
\p\g
grant   insert   on "mdbadmin".rmonrptquerytempdata to public
\p\g
grant references on "mdbadmin".rmonrptquerytempdata to public
\p\g
grant  copy_into on "mdbadmin".rmonrptquerytempdata to public
\p\g
grant  copy_from on "mdbadmin".rmonrptquerytempdata to public
\p\g
grant   select   on "mdbadmin".rolluptimestamp to public
\p\g
grant   update   on "mdbadmin".rolluptimestamp to public
\p\g
grant   delete   on "mdbadmin".rolluptimestamp to public
\p\g
grant   insert   on "mdbadmin".rolluptimestamp to public
\p\g
grant references on "mdbadmin".rolluptimestamp to public
\p\g
grant  copy_into on "mdbadmin".rolluptimestamp to public
\p\g
grant  copy_from on "mdbadmin".rolluptimestamp to public
\p\g
grant   select   on "mdbadmin".rolluptypes to public
\p\g
grant   update   on "mdbadmin".rolluptypes to public
\p\g
grant   delete   on "mdbadmin".rolluptypes to public
\p\g
grant   insert   on "mdbadmin".rolluptypes to public
\p\g
grant references on "mdbadmin".rolluptypes to public
\p\g
grant  copy_into on "mdbadmin".rolluptypes to public
\p\g
grant  copy_from on "mdbadmin".rolluptypes to public
\p\g
grant   select   on "mdbadmin".rttctrladmin_cfg to public
\p\g
grant   update   on "mdbadmin".rttctrladmin_cfg to public
\p\g
grant   delete   on "mdbadmin".rttctrladmin_cfg to public
\p\g
grant   insert   on "mdbadmin".rttctrladmin_cfg to public
\p\g
grant references on "mdbadmin".rttctrladmin_cfg to public
\p\g
grant  copy_into on "mdbadmin".rttctrladmin_cfg to public
\p\g
grant  copy_from on "mdbadmin".rttctrladmin_cfg to public
\p\g
grant   select   on "mdbadmin".rttechoadmin_cfg to public
\p\g
grant   update   on "mdbadmin".rttechoadmin_cfg to public
\p\g
grant   delete   on "mdbadmin".rttechoadmin_cfg to public
\p\g
grant   insert   on "mdbadmin".rttechoadmin_cfg to public
\p\g
grant references on "mdbadmin".rttechoadmin_cfg to public
\p\g
grant  copy_into on "mdbadmin".rttechoadmin_cfg to public
\p\g
grant  copy_from on "mdbadmin".rttechoadmin_cfg to public
\p\g
grant   select   on "mdbadmin".rttjitter_stat to public
\p\g
grant   update   on "mdbadmin".rttjitter_stat to public
\p\g
grant   delete   on "mdbadmin".rttjitter_stat to public
\p\g
grant   insert   on "mdbadmin".rttjitter_stat to public
\p\g
grant references on "mdbadmin".rttjitter_stat to public
\p\g
grant  copy_into on "mdbadmin".rttjitter_stat to public
\p\g
grant  copy_from on "mdbadmin".rttjitter_stat to public
\p\g
grant   select   on "mdbadmin".rttstatscapture_stat to public
\p\g
grant   update   on "mdbadmin".rttstatscapture_stat to public
\p\g
grant   delete   on "mdbadmin".rttstatscapture_stat to public
\p\g
grant   insert   on "mdbadmin".rttstatscapture_stat to public
\p\g
grant references on "mdbadmin".rttstatscapture_stat to public
\p\g
grant  copy_into on "mdbadmin".rttstatscapture_stat to public
\p\g
grant  copy_from on "mdbadmin".rttstatscapture_stat to public
\p\g
grant   select   on "mdbadmin".rttstatscoll_stat to public
\p\g
grant   update   on "mdbadmin".rttstatscoll_stat to public
\p\g
grant   delete   on "mdbadmin".rttstatscoll_stat to public
\p\g
grant   insert   on "mdbadmin".rttstatscoll_stat to public
\p\g
grant references on "mdbadmin".rttstatscoll_stat to public
\p\g
grant  copy_into on "mdbadmin".rttstatscoll_stat to public
\p\g
grant  copy_from on "mdbadmin".rttstatscoll_stat to public
\p\g
grant   select   on "mdbadmin".saved_57 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".saved_57 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".saved_57 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".saved_57 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".saved_57 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".saved_57 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".saved_57 to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".saved_62 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".saved_62 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".saved_62 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".saved_62 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".saved_62 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".saved_62 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".saved_62 to neugentsahd with grant 
option
\p\g
grant select on "mdbadmin".scriptmessagelog to group infopump_user
\p\g
grant delete on "mdbadmin".scriptmessagelog to group infopump_user
\p\g
grant select on "mdbadmin".scriptmessagelog to group infopump_admin
\p\g
grant update on "mdbadmin".scriptmessagelog to group infopump_admin
\p\g
grant delete on "mdbadmin".scriptmessagelog to group infopump_admin
\p\g
grant insert on "mdbadmin".scriptmessagelog to group infopump_admin
\p\g
grant references on "mdbadmin".scriptmessagelog to group 
infopump_admin
\p\g
grant copy_into on "mdbadmin".scriptmessagelog to group infopump_admin
\p\g
grant copy_from on "mdbadmin".scriptmessagelog to group infopump_admin
\p\g
grant   select   on "mdbadmin".sessionlength to public
\p\g
grant   update   on "mdbadmin".sessionlength to public
\p\g
grant   delete   on "mdbadmin".sessionlength to public
\p\g
grant   insert   on "mdbadmin".sessionlength to public
\p\g
grant references on "mdbadmin".sessionlength to public
\p\g
grant  copy_into on "mdbadmin".sessionlength to public
\p\g
grant  copy_from on "mdbadmin".sessionlength to public
\p\g
grant select on "mdbadmin".simplerequest to group infopump_user
\p\g
grant update on "mdbadmin".simplerequest to group infopump_user
\p\g
grant delete on "mdbadmin".simplerequest to group infopump_user
\p\g
grant insert on "mdbadmin".simplerequest to group infopump_user
\p\g
grant select on "mdbadmin".simplerequest to group infopump_admin
\p\g
grant update on "mdbadmin".simplerequest to group infopump_admin
\p\g
grant delete on "mdbadmin".simplerequest to group infopump_admin
\p\g
grant insert on "mdbadmin".simplerequest to group infopump_admin
\p\g
grant references on "mdbadmin".simplerequest to group infopump_admin
\p\g
grant copy_into on "mdbadmin".simplerequest to group infopump_admin
\p\g
grant copy_from on "mdbadmin".simplerequest to group infopump_admin
\p\g
grant select on "mdbadmin".systemparameter to group infopump_user
\p\g
grant update on "mdbadmin".systemparameter to group infopump_user
\p\g
grant select on "mdbadmin".systemparameter to group infopump_admin
\p\g
grant update on "mdbadmin".systemparameter to group infopump_admin
\p\g
grant delete on "mdbadmin".systemparameter to group infopump_admin
\p\g
grant insert on "mdbadmin".systemparameter to group infopump_admin
\p\g
grant references on "mdbadmin".systemparameter to group infopump_admin
\p\g
grant copy_into on "mdbadmin".systemparameter to group infopump_admin
\p\g
grant copy_from on "mdbadmin".systemparameter to group infopump_admin
\p\g
grant   select   on "mdbadmin".tabledefinition to public
\p\g
grant   update   on "mdbadmin".tabledefinition to public
\p\g
grant   delete   on "mdbadmin".tabledefinition to public
\p\g
grant   insert   on "mdbadmin".tabledefinition to public
\p\g
grant references on "mdbadmin".tabledefinition to public
\p\g
grant  copy_into on "mdbadmin".tabledefinition to public
\p\g
grant  copy_from on "mdbadmin".tabledefinition to public
\p\g
grant   select   on "mdbadmin".tableindex to public
\p\g
grant   update   on "mdbadmin".tableindex to public
\p\g
grant   delete   on "mdbadmin".tableindex to public
\p\g
grant   insert   on "mdbadmin".tableindex to public
\p\g
grant references on "mdbadmin".tableindex to public
\p\g
grant  copy_into on "mdbadmin".tableindex to public
\p\g
grant  copy_from on "mdbadmin".tableindex to public
\p\g
grant   select   on "mdbadmin".tablejoins to public
\p\g
grant   update   on "mdbadmin".tablejoins to public
\p\g
grant   delete   on "mdbadmin".tablejoins to public
\p\g
grant   insert   on "mdbadmin".tablejoins to public
\p\g
grant references on "mdbadmin".tablejoins to public
\p\g
grant  copy_into on "mdbadmin".tablejoins to public
\p\g
grant  copy_from on "mdbadmin".tablejoins to public
\p\g
grant   select   on "mdbadmin".tablesdescription to public
\p\g
grant   update   on "mdbadmin".tablesdescription to public
\p\g
grant   delete   on "mdbadmin".tablesdescription to public
\p\g
grant   insert   on "mdbadmin".tablesdescription to public
\p\g
grant references on "mdbadmin".tablesdescription to public
\p\g
grant  copy_into on "mdbadmin".tablesdescription to public
\p\g
grant  copy_from on "mdbadmin".tablesdescription to public
\p\g
grant   select   on "mdbadmin".tempbaselinefields to public
\p\g
grant   update   on "mdbadmin".tempbaselinefields to public
\p\g
grant   delete   on "mdbadmin".tempbaselinefields to public
\p\g
grant   insert   on "mdbadmin".tempbaselinefields to public
\p\g
grant references on "mdbadmin".tempbaselinefields to public
\p\g
grant  copy_into on "mdbadmin".tempbaselinefields to public
\p\g
grant  copy_from on "mdbadmin".tempbaselinefields to public
\p\g
grant   select   on "mdbadmin".tempstats to public
\p\g
grant   update   on "mdbadmin".tempstats to public
\p\g
grant   delete   on "mdbadmin".tempstats to public
\p\g
grant   insert   on "mdbadmin".tempstats to public
\p\g
grant references on "mdbadmin".tempstats to public
\p\g
grant  copy_into on "mdbadmin".tempstats to public
\p\g
grant  copy_from on "mdbadmin".tempstats to public
\p\g
grant   select   on "mdbadmin".thresholdconst to public
\p\g
grant   update   on "mdbadmin".thresholdconst to public
\p\g
grant   delete   on "mdbadmin".thresholdconst to public
\p\g
grant   insert   on "mdbadmin".thresholdconst to public
\p\g
grant references on "mdbadmin".thresholdconst to public
\p\g
grant  copy_into on "mdbadmin".thresholdconst to public
\p\g
grant  copy_from on "mdbadmin".thresholdconst to public
\p\g
grant   select   on "mdbadmin".thresholddesc to public
\p\g
grant   update   on "mdbadmin".thresholddesc to public
\p\g
grant   delete   on "mdbadmin".thresholddesc to public
\p\g
grant   insert   on "mdbadmin".thresholddesc to public
\p\g
grant references on "mdbadmin".thresholddesc to public
\p\g
grant  copy_into on "mdbadmin".thresholddesc to public
\p\g
grant  copy_from on "mdbadmin".thresholddesc to public
\p\g
grant   select   on "mdbadmin".thresholdformula to public
\p\g
grant   update   on "mdbadmin".thresholdformula to public
\p\g
grant   delete   on "mdbadmin".thresholdformula to public
\p\g
grant   insert   on "mdbadmin".thresholdformula to public
\p\g
grant references on "mdbadmin".thresholdformula to public
\p\g
grant  copy_into on "mdbadmin".thresholdformula to public
\p\g
grant  copy_from on "mdbadmin".thresholdformula to public
\p\g
grant   select   on "mdbadmin".thresholds to public
\p\g
grant   update   on "mdbadmin".thresholds to public
\p\g
grant   delete   on "mdbadmin".thresholds to public
\p\g
grant   insert   on "mdbadmin".thresholds to public
\p\g
grant references on "mdbadmin".thresholds to public
\p\g
grant  copy_into on "mdbadmin".thresholds to public
\p\g
grant  copy_from on "mdbadmin".thresholds to public
\p\g
grant select on "mdbadmin".tng_address_type to group tngadmin
\p\g
grant insert on "mdbadmin".tng_address_type to group tngadmin
\p\g
grant delete on "mdbadmin".tng_address_type to group tngadmin
\p\g
grant update on "mdbadmin".tng_address_type to group tngadmin
\p\g
grant select on "mdbadmin".tng_address_type to group tnguser
\p\g
grant select on "mdbadmin".tng_adminstatus to group tngadmin
\p\g
grant insert on "mdbadmin".tng_adminstatus to group tngadmin
\p\g
grant delete on "mdbadmin".tng_adminstatus to group tngadmin
\p\g
grant update on "mdbadmin".tng_adminstatus to group tngadmin
\p\g
grant select on "mdbadmin".tng_adminstatus to group tnguser
\p\g
grant select on "mdbadmin".tng_agent_info to group tngadmin
\p\g
grant insert on "mdbadmin".tng_agent_info to group tngadmin
\p\g
grant delete on "mdbadmin".tng_agent_info to group tngadmin
\p\g
grant update on "mdbadmin".tng_agent_info to group tngadmin
\p\g
grant select on "mdbadmin".tng_agent_info to group tnguser
\p\g
grant select on "mdbadmin".tng_alarmset to group tngadmin
\p\g
grant insert on "mdbadmin".tng_alarmset to group tngadmin
\p\g
grant delete on "mdbadmin".tng_alarmset to group tngadmin
\p\g
grant update on "mdbadmin".tng_alarmset to group tngadmin
\p\g
grant select on "mdbadmin".tng_alarmset to group tnguser
\p\g
grant select on "mdbadmin".tng_alarmset_entry to group tngadmin
\p\g
grant insert on "mdbadmin".tng_alarmset_entry to group tngadmin
\p\g
grant delete on "mdbadmin".tng_alarmset_entry to group tngadmin
\p\g
grant update on "mdbadmin".tng_alarmset_entry to group tngadmin
\p\g
grant select on "mdbadmin".tng_alarmset_entry to group tnguser
\p\g
grant select on "mdbadmin".tng_auth to group tngadmin
\p\g
grant insert on "mdbadmin".tng_auth to group tngadmin
\p\g
grant delete on "mdbadmin".tng_auth to group tngadmin
\p\g
grant update on "mdbadmin".tng_auth to group tngadmin
\p\g
grant select on "mdbadmin".tng_auth to group tnguser
\p\g
grant select on "mdbadmin".tng_browser_menu to group tngadmin
\p\g
grant insert on "mdbadmin".tng_browser_menu to group tngadmin
\p\g
grant delete on "mdbadmin".tng_browser_menu to group tngadmin
\p\g
grant update on "mdbadmin".tng_browser_menu to group tngadmin
\p\g
grant select on "mdbadmin".tng_browser_menu to group tnguser
\p\g
grant select on "mdbadmin".tng_browser_method to group tngadmin
\p\g
grant insert on "mdbadmin".tng_browser_method to group tngadmin
\p\g
grant delete on "mdbadmin".tng_browser_method to group tngadmin
\p\g
grant update on "mdbadmin".tng_browser_method to group tngadmin
\p\g
grant select on "mdbadmin".tng_browser_method to group tnguser
\p\g
grant select on "mdbadmin".tng_ca_claim_discovery_tmp to group 
tngadmin
\p\g
grant insert on "mdbadmin".tng_ca_claim_discovery_tmp to group 
tngadmin
\p\g
grant delete on "mdbadmin".tng_ca_claim_discovery_tmp to group 
tngadmin
\p\g
grant update on "mdbadmin".tng_ca_claim_discovery_tmp to group 
tngadmin
\p\g
grant select on "mdbadmin".tng_ca_claim_discovery_tmp to group tnguser
\p\g
grant select on "mdbadmin".tng_change_history to group tngadmin
\p\g
grant insert on "mdbadmin".tng_change_history to group tngadmin
\p\g
grant delete on "mdbadmin".tng_change_history to group tngadmin
\p\g
grant update on "mdbadmin".tng_change_history to group tngadmin
\p\g
grant select on "mdbadmin".tng_change_history to group tnguser
\p\g
grant select on "mdbadmin".tng_city to group tngadmin
\p\g
grant insert on "mdbadmin".tng_city to group tngadmin
\p\g
grant delete on "mdbadmin".tng_city to group tngadmin
\p\g
grant update on "mdbadmin".tng_city to group tngadmin
\p\g
grant select on "mdbadmin".tng_city to group tnguser
\p\g
grant select on "mdbadmin".tng_class to group tngadmin
\p\g
grant insert on "mdbadmin".tng_class to group tngadmin
\p\g
grant delete on "mdbadmin".tng_class to group tngadmin
\p\g
grant update on "mdbadmin".tng_class to group tngadmin
\p\g
grant select on "mdbadmin".tng_class to group tnguser
\p\g
grant select on "mdbadmin".tng_class_addport to group tngadmin
\p\g
grant insert on "mdbadmin".tng_class_addport to group tngadmin
\p\g
grant delete on "mdbadmin".tng_class_addport to group tngadmin
\p\g
grant update on "mdbadmin".tng_class_addport to group tngadmin
\p\g
grant select on "mdbadmin".tng_class_addport to group tnguser
\p\g
grant select on "mdbadmin".tng_class_ext to group tngadmin
\p\g
grant insert on "mdbadmin".tng_class_ext to group tngadmin
\p\g
grant delete on "mdbadmin".tng_class_ext to group tngadmin
\p\g
grant update on "mdbadmin".tng_class_ext to group tngadmin
\p\g
grant select on "mdbadmin".tng_class_ext to group tnguser
\p\g
grant select on "mdbadmin".tng_class_reclass to group tngadmin
\p\g
grant insert on "mdbadmin".tng_class_reclass to group tngadmin
\p\g
grant delete on "mdbadmin".tng_class_reclass to group tngadmin
\p\g
grant update on "mdbadmin".tng_class_reclass to group tngadmin
\p\g
grant select on "mdbadmin".tng_class_reclass to group tnguser
\p\g
grant select on "mdbadmin".tng_class_special to group tngadmin
\p\g
grant insert on "mdbadmin".tng_class_special to group tngadmin
\p\g
grant delete on "mdbadmin".tng_class_special to group tngadmin
\p\g
grant update on "mdbadmin".tng_class_special to group tngadmin
\p\g
grant select on "mdbadmin".tng_conflict_object to group tngadmin
\p\g
grant insert on "mdbadmin".tng_conflict_object to group tngadmin
\p\g
grant delete on "mdbadmin".tng_conflict_object to group tngadmin
\p\g
grant update on "mdbadmin".tng_conflict_object to group tngadmin
\p\g
grant select on "mdbadmin".tng_conflict_object to group tnguser
\p\g
grant select on "mdbadmin".tng_country to group tngadmin
\p\g
grant insert on "mdbadmin".tng_country to group tngadmin
\p\g
grant delete on "mdbadmin".tng_country to group tngadmin
\p\g
grant update on "mdbadmin".tng_country to group tngadmin
\p\g
grant select on "mdbadmin".tng_country to group tnguser
\p\g
grant select on "mdbadmin".tng_dbpv to group tngadmin
\p\g
grant insert on "mdbadmin".tng_dbpv to group tngadmin
\p\g
grant delete on "mdbadmin".tng_dbpv to group tngadmin
\p\g
grant update on "mdbadmin".tng_dbpv to group tngadmin
\p\g
grant select on "mdbadmin".tng_dbpv to group tnguser
\p\g
grant select on "mdbadmin".tng_dhcp_scope to group tngadmin
\p\g
grant insert on "mdbadmin".tng_dhcp_scope to group tngadmin
\p\g
grant delete on "mdbadmin".tng_dhcp_scope to group tngadmin
\p\g
grant update on "mdbadmin".tng_dhcp_scope to group tngadmin
\p\g
grant select on "mdbadmin".tng_dhcp_scope to group tnguser
\p\g
grant select on "mdbadmin".tng_discovery_ipsubnet to group tngadmin
\p\g
grant insert on "mdbadmin".tng_discovery_ipsubnet to group tngadmin
\p\g
grant delete on "mdbadmin".tng_discovery_ipsubnet to group tngadmin
\p\g
grant update on "mdbadmin".tng_discovery_ipsubnet to group tngadmin
\p\g
grant select on "mdbadmin".tng_discovery_ipsubnet to group tnguser
\p\g
grant select on "mdbadmin".tng_discovery_ipsubnet_tmp to group 
tngadmin
\p\g
grant insert on "mdbadmin".tng_discovery_ipsubnet_tmp to group 
tngadmin
\p\g
grant delete on "mdbadmin".tng_discovery_ipsubnet_tmp to group 
tngadmin
\p\g
grant update on "mdbadmin".tng_discovery_ipsubnet_tmp to group 
tngadmin
\p\g
grant select on "mdbadmin".tng_discovery_ipsubnet_tmp to group tnguser
\p\g
grant select on "mdbadmin".tng_discovery_setup to group tngadmin
\p\g
grant insert on "mdbadmin".tng_discovery_setup to group tngadmin
\p\g
grant delete on "mdbadmin".tng_discovery_setup to group tngadmin
\p\g
grant update on "mdbadmin".tng_discovery_setup to group tngadmin
\p\g
grant select on "mdbadmin".tng_discovery_setup to group tnguser
\p\g
grant select on "mdbadmin".tng_discovery_status to group tngadmin
\p\g
grant insert on "mdbadmin".tng_discovery_status to group tngadmin
\p\g
grant delete on "mdbadmin".tng_discovery_status to group tngadmin
\p\g
grant update on "mdbadmin".tng_discovery_status to group tngadmin
\p\g
grant select on "mdbadmin".tng_discovery_status to group tnguser
\p\g
grant select on "mdbadmin".tng_dsm_class_scope to group tngadmin
\p\g
grant insert on "mdbadmin".tng_dsm_class_scope to group tngadmin
\p\g
grant delete on "mdbadmin".tng_dsm_class_scope to group tngadmin
\p\g
grant update on "mdbadmin".tng_dsm_class_scope to group tngadmin
\p\g
grant select on "mdbadmin".tng_dsm_class_scope to group tnguser
\p\g
grant select on "mdbadmin".tng_dsm_comm_scope to group tngadmin
\p\g
grant insert on "mdbadmin".tng_dsm_comm_scope to group tngadmin
\p\g
grant delete on "mdbadmin".tng_dsm_comm_scope to group tngadmin
\p\g
grant update on "mdbadmin".tng_dsm_comm_scope to group tngadmin
\p\g
grant select on "mdbadmin".tng_dsm_comm_scope to group tnguser
\p\g
grant select on "mdbadmin".tng_dsm_ip_scope to group tngadmin
\p\g
grant insert on "mdbadmin".tng_dsm_ip_scope to group tngadmin
\p\g
grant delete on "mdbadmin".tng_dsm_ip_scope to group tngadmin
\p\g
grant update on "mdbadmin".tng_dsm_ip_scope to group tngadmin
\p\g
grant select on "mdbadmin".tng_dsm_ip_scope to group tnguser
\p\g
grant select on "mdbadmin".tng_dsm_mo_scope to group tngadmin
\p\g
grant insert on "mdbadmin".tng_dsm_mo_scope to group tngadmin
\p\g
grant delete on "mdbadmin".tng_dsm_mo_scope to group tngadmin
\p\g
grant update on "mdbadmin".tng_dsm_mo_scope to group tngadmin
\p\g
grant select on "mdbadmin".tng_dsm_mo_scope to group tnguser
\p\g
grant select on "mdbadmin".tng_dsm_poll_scope to group tngadmin
\p\g
grant insert on "mdbadmin".tng_dsm_poll_scope to group tngadmin
\p\g
grant delete on "mdbadmin".tng_dsm_poll_scope to group tngadmin
\p\g
grant update on "mdbadmin".tng_dsm_poll_scope to group tngadmin
\p\g
grant select on "mdbadmin".tng_dsm_poll_scope to group tnguser
\p\g
grant select on "mdbadmin".tng_field_definition to group tngadmin
\p\g
grant insert on "mdbadmin".tng_field_definition to group tngadmin
\p\g
grant delete on "mdbadmin".tng_field_definition to group tngadmin
\p\g
grant update on "mdbadmin".tng_field_definition to group tngadmin
\p\g
grant select on "mdbadmin".tng_field_definition to group tnguser
\p\g
grant select on "mdbadmin".tng_field_storage to group tngadmin
\p\g
grant insert on "mdbadmin".tng_field_storage to group tngadmin
\p\g
grant delete on "mdbadmin".tng_field_storage to group tngadmin
\p\g
grant update on "mdbadmin".tng_field_storage to group tngadmin
\p\g
grant select on "mdbadmin".tng_field_storage to group tnguser
\p\g
grant select on "mdbadmin".tng_geomap to group tngadmin
\p\g
grant insert on "mdbadmin".tng_geomap to group tngadmin
\p\g
grant delete on "mdbadmin".tng_geomap to group tngadmin
\p\g
grant update on "mdbadmin".tng_geomap to group tngadmin
\p\g
grant select on "mdbadmin".tng_geomap to group tnguser
\p\g
grant select on "mdbadmin".tng_icon_2d to group tngadmin
\p\g
grant insert on "mdbadmin".tng_icon_2d to group tngadmin
\p\g
grant delete on "mdbadmin".tng_icon_2d to group tngadmin
\p\g
grant update on "mdbadmin".tng_icon_2d to group tngadmin
\p\g
grant select on "mdbadmin".tng_icon_2d to group tnguser
\p\g
grant select on "mdbadmin".tng_icon_3d to group tngadmin
\p\g
grant insert on "mdbadmin".tng_icon_3d to group tngadmin
\p\g
grant delete on "mdbadmin".tng_icon_3d to group tngadmin
\p\g
grant update on "mdbadmin".tng_icon_3d to group tngadmin
\p\g
grant select on "mdbadmin".tng_icon_3d to group tnguser
\p\g
grant select on "mdbadmin".tng_inclusion to group tngadmin
\p\g
grant insert on "mdbadmin".tng_inclusion to group tngadmin
\p\g
grant delete on "mdbadmin".tng_inclusion to group tngadmin
\p\g
grant update on "mdbadmin".tng_inclusion to group tngadmin
\p\g
grant select on "mdbadmin".tng_inclusion to group tnguser
\p\g
grant select on "mdbadmin".tng_interface_type to group tngadmin
\p\g
grant insert on "mdbadmin".tng_interface_type to group tngadmin
\p\g
grant delete on "mdbadmin".tng_interface_type to group tngadmin
\p\g
grant update on "mdbadmin".tng_interface_type to group tngadmin
\p\g
grant select on "mdbadmin".tng_interface_type to group tnguser
\p\g
grant select on "mdbadmin".tng_ip_discovery_history to group tngadmin
\p\g
grant insert on "mdbadmin".tng_ip_discovery_history to group tngadmin
\p\g
grant delete on "mdbadmin".tng_ip_discovery_history to group tngadmin
\p\g
grant update on "mdbadmin".tng_ip_discovery_history to group tngadmin
\p\g
grant select on "mdbadmin".tng_ip_discovery_history to group tnguser
\p\g
grant select on "mdbadmin".tng_ip_interface to group tngadmin
\p\g
grant insert on "mdbadmin".tng_ip_interface to group tngadmin
\p\g
grant delete on "mdbadmin".tng_ip_interface to group tngadmin
\p\g
grant update on "mdbadmin".tng_ip_interface to group tngadmin
\p\g
grant select on "mdbadmin".tng_ip_interface to group tnguser
\p\g
grant select on "mdbadmin".tng_ip_subnet to group tngadmin
\p\g
grant insert on "mdbadmin".tng_ip_subnet to group tngadmin
\p\g
grant delete on "mdbadmin".tng_ip_subnet to group tngadmin
\p\g
grant update on "mdbadmin".tng_ip_subnet to group tngadmin
\p\g
grant select on "mdbadmin".tng_ip_subnet to group tnguser
\p\g
grant select on "mdbadmin".tng_jasmine_menu_action to group tngadmin
\p\g
grant insert on "mdbadmin".tng_jasmine_menu_action to group tngadmin
\p\g
grant delete on "mdbadmin".tng_jasmine_menu_action to group tngadmin
\p\g
grant update on "mdbadmin".tng_jasmine_menu_action to group tngadmin
\p\g
grant select on "mdbadmin".tng_jasmine_menu_action to group tnguser
\p\g
grant select on "mdbadmin".tng_jasmine_menu_object to group tngadmin
\p\g
grant insert on "mdbadmin".tng_jasmine_menu_object to group tngadmin
\p\g
grant delete on "mdbadmin".tng_jasmine_menu_object to group tngadmin
\p\g
grant update on "mdbadmin".tng_jasmine_menu_object to group tngadmin
\p\g
grant select on "mdbadmin".tng_jasmine_menu_object to group tnguser
\p\g
grant select on "mdbadmin".tng_jii_inclusion to group tngadmin
\p\g
grant insert on "mdbadmin".tng_jii_inclusion to group tngadmin
\p\g
grant delete on "mdbadmin".tng_jii_inclusion to group tngadmin
\p\g
grant update on "mdbadmin".tng_jii_inclusion to group tngadmin
\p\g
grant select on "mdbadmin".tng_jii_inclusion to group tnguser
\p\g
grant select on "mdbadmin".tng_key_change_hist to group tngadmin
\p\g
grant update on "mdbadmin".tng_key_change_hist to group tngadmin
\p\g
grant insert on "mdbadmin".tng_key_change_hist to group tngadmin
\p\g
grant delete on "mdbadmin".tng_key_change_hist to group tngadmin
\p\g
grant select on "mdbadmin".tng_key_class_id to group tngadmin
\p\g
grant update on "mdbadmin".tng_key_class_id to group tngadmin
\p\g
grant insert on "mdbadmin".tng_key_class_id to group tngadmin
\p\g
grant delete on "mdbadmin".tng_key_class_id to group tngadmin
\p\g
grant select on "mdbadmin".tng_key_discovery_ipsubnet_id to group 
tngadmin
\p\g
grant update on "mdbadmin".tng_key_discovery_ipsubnet_id to group 
tngadmin
\p\g
grant insert on "mdbadmin".tng_key_discovery_ipsubnet_id to group 
tngadmin
\p\g
grant delete on "mdbadmin".tng_key_discovery_ipsubnet_id to group 
tngadmin
\p\g
grant select on "mdbadmin".tng_key_id to group tngadmin
\p\g
grant update on "mdbadmin".tng_key_id to group tngadmin
\p\g
grant insert on "mdbadmin".tng_key_id to group tngadmin
\p\g
grant delete on "mdbadmin".tng_key_id to group tngadmin
\p\g
grant select on "mdbadmin".tng_key_prop_status_hist to group tngadmin
\p\g
grant update on "mdbadmin".tng_key_prop_status_hist to group tngadmin
\p\g
grant insert on "mdbadmin".tng_key_prop_status_hist to group tngadmin
\p\g
grant delete on "mdbadmin".tng_key_prop_status_hist to group tngadmin
\p\g
grant select on "mdbadmin".tng_key_status_hist to group tngadmin
\p\g
grant update on "mdbadmin".tng_key_status_hist to group tngadmin
\p\g
grant insert on "mdbadmin".tng_key_status_hist to group tngadmin
\p\g
grant delete on "mdbadmin".tng_key_status_hist to group tngadmin
\p\g
grant select on "mdbadmin".tng_link to group tngadmin
\p\g
grant insert on "mdbadmin".tng_link to group tngadmin
\p\g
grant delete on "mdbadmin".tng_link to group tngadmin
\p\g
grant update on "mdbadmin".tng_link to group tngadmin
\p\g
grant select on "mdbadmin".tng_link to group tnguser
\p\g
grant select on "mdbadmin".tng_locale_info to group tngadmin
\p\g
grant insert on "mdbadmin".tng_locale_info to group tngadmin
\p\g
grant delete on "mdbadmin".tng_locale_info to group tngadmin
\p\g
grant update on "mdbadmin".tng_locale_info to group tngadmin
\p\g
grant select on "mdbadmin".tng_locale_info to group tnguser
\p\g
grant select on "mdbadmin".tng_mac_address to group tngadmin
\p\g
grant insert on "mdbadmin".tng_mac_address to group tngadmin
\p\g
grant delete on "mdbadmin".tng_mac_address to group tngadmin
\p\g
grant update on "mdbadmin".tng_mac_address to group tngadmin
\p\g
grant select on "mdbadmin".tng_mac_address to group tnguser
\p\g
grant select on "mdbadmin".tng_managedobject to group tngadmin
\p\g
grant insert on "mdbadmin".tng_managedobject to group tngadmin
\p\g
grant delete on "mdbadmin".tng_managedobject to group tngadmin
\p\g
grant update on "mdbadmin".tng_managedobject to group tngadmin
\p\g
grant select on "mdbadmin".tng_managedobject to group tnguser
\p\g
grant select on "mdbadmin".tng_map_authority to group tngadmin
\p\g
grant insert on "mdbadmin".tng_map_authority to group tngadmin
\p\g
grant delete on "mdbadmin".tng_map_authority to group tngadmin
\p\g
grant update on "mdbadmin".tng_map_authority to group tngadmin
\p\g
grant select on "mdbadmin".tng_map_authority to group tnguser
\p\g
grant select on "mdbadmin".tng_method to group tngadmin
\p\g
grant insert on "mdbadmin".tng_method to group tngadmin
\p\g
grant delete on "mdbadmin".tng_method to group tngadmin
\p\g
grant update on "mdbadmin".tng_method to group tngadmin
\p\g
grant select on "mdbadmin".tng_method to group tnguser
\p\g
grant select on "mdbadmin".tng_netpc_history to group tngadmin
\p\g
grant insert on "mdbadmin".tng_netpc_history to group tngadmin
\p\g
grant delete on "mdbadmin".tng_netpc_history to group tngadmin
\p\g
grant update on "mdbadmin".tng_netpc_history to group tngadmin
\p\g
grant select on "mdbadmin".tng_netpc_history to group tnguser
\p\g
grant select on "mdbadmin".tng_ov_enum to group tngadmin
\p\g
grant insert on "mdbadmin".tng_ov_enum to group tngadmin
\p\g
grant delete on "mdbadmin".tng_ov_enum to group tngadmin
\p\g
grant update on "mdbadmin".tng_ov_enum to group tngadmin
\p\g
grant select on "mdbadmin".tng_ov_enum to group tnguser
\p\g
grant select on "mdbadmin".tng_ov_field_def to group tngadmin
\p\g
grant insert on "mdbadmin".tng_ov_field_def to group tngadmin
\p\g
grant delete on "mdbadmin".tng_ov_field_def to group tngadmin
\p\g
grant update on "mdbadmin".tng_ov_field_def to group tngadmin
\p\g
grant select on "mdbadmin".tng_ov_field_def to group tnguser
\p\g
grant select on "mdbadmin".tng_overlapinterface to group tngadmin
\p\g
grant insert on "mdbadmin".tng_overlapinterface to group tngadmin
\p\g
grant delete on "mdbadmin".tng_overlapinterface to group tngadmin
\p\g
grant update on "mdbadmin".tng_overlapinterface to group tngadmin
\p\g
grant select on "mdbadmin".tng_overlapinterface to group tnguser
\p\g
grant select on "mdbadmin".tng_pollset to group tngadmin
\p\g
grant insert on "mdbadmin".tng_pollset to group tngadmin
\p\g
grant delete on "mdbadmin".tng_pollset to group tngadmin
\p\g
grant update on "mdbadmin".tng_pollset to group tngadmin
\p\g
grant select on "mdbadmin".tng_pollset to group tnguser
\p\g
grant select on "mdbadmin".tng_popup_menu to group tngadmin
\p\g
grant insert on "mdbadmin".tng_popup_menu to group tngadmin
\p\g
grant delete on "mdbadmin".tng_popup_menu to group tngadmin
\p\g
grant update on "mdbadmin".tng_popup_menu to group tngadmin
\p\g
grant select on "mdbadmin".tng_popup_menu to group tnguser
\p\g
grant select on "mdbadmin".tng_prop_status_history to group tngadmin
\p\g
grant insert on "mdbadmin".tng_prop_status_history to group tngadmin
\p\g
grant delete on "mdbadmin".tng_prop_status_history to group tngadmin
\p\g
grant update on "mdbadmin".tng_prop_status_history to group tngadmin
\p\g
grant select on "mdbadmin".tng_prop_status_history to group tnguser
\p\g
grant select on "mdbadmin".tng_property_definition to group tngadmin
\p\g
grant insert on "mdbadmin".tng_property_definition to group tngadmin
\p\g
grant delete on "mdbadmin".tng_property_definition to group tngadmin
\p\g
grant update on "mdbadmin".tng_property_definition to group tngadmin
\p\g
grant select on "mdbadmin".tng_property_definition to group tnguser
\p\g
grant select on "mdbadmin".tng_severity_propagation to group tngadmin
\p\g
grant insert on "mdbadmin".tng_severity_propagation to group tngadmin
\p\g
grant delete on "mdbadmin".tng_severity_propagation to group tngadmin
\p\g
grant update on "mdbadmin".tng_severity_propagation to group tngadmin
\p\g
grant select on "mdbadmin".tng_severity_propagation to group tnguser
\p\g
grant select on "mdbadmin".tng_status to group tngadmin
\p\g
grant insert on "mdbadmin".tng_status to group tngadmin
\p\g
grant delete on "mdbadmin".tng_status to group tngadmin
\p\g
grant update on "mdbadmin".tng_status to group tngadmin
\p\g
grant select on "mdbadmin".tng_status to group tnguser
\p\g
grant select on "mdbadmin".tng_status_history to group tngadmin
\p\g
grant insert on "mdbadmin".tng_status_history to group tngadmin
\p\g
grant delete on "mdbadmin".tng_status_history to group tngadmin
\p\g
grant update on "mdbadmin".tng_status_history to group tngadmin
\p\g
grant select on "mdbadmin".tng_status_history to group tnguser
\p\g
grant select on "mdbadmin".tng_sysobjid to group tngadmin
\p\g
grant insert on "mdbadmin".tng_sysobjid to group tngadmin
\p\g
grant delete on "mdbadmin".tng_sysobjid to group tngadmin
\p\g
grant update on "mdbadmin".tng_sysobjid to group tngadmin
\p\g
grant select on "mdbadmin".tng_sysobjid to group tnguser
\p\g
grant select on "mdbadmin".tng_tnd_geomap to group tngadmin
\p\g
grant insert on "mdbadmin".tng_tnd_geomap to group tngadmin
\p\g
grant delete on "mdbadmin".tng_tnd_geomap to group tngadmin
\p\g
grant update on "mdbadmin".tng_tnd_geomap to group tngadmin
\p\g
grant select on "mdbadmin".tng_tnd_geomap to group tnguser
\p\g
grant select on "mdbadmin".tng_unclassified_tcp to group tngadmin
\p\g
grant insert on "mdbadmin".tng_unclassified_tcp to group tngadmin
\p\g
grant delete on "mdbadmin".tng_unclassified_tcp to group tngadmin
\p\g
grant update on "mdbadmin".tng_unclassified_tcp to group tngadmin
\p\g
grant select on "mdbadmin".tng_unclassified_tcp to group tnguser
\p\g
grant select on "mdbadmin".tng_user_menu to group tngadmin
\p\g
grant insert on "mdbadmin".tng_user_menu to group tngadmin
\p\g
grant delete on "mdbadmin".tng_user_menu to group tngadmin
\p\g
grant update on "mdbadmin".tng_user_menu to group tngadmin
\p\g
grant select on "mdbadmin".tng_user_menu to group tnguser
\p\g
grant select on "mdbadmin".tng_vendor to group tngadmin
\p\g
grant insert on "mdbadmin".tng_vendor to group tngadmin
\p\g
grant delete on "mdbadmin".tng_vendor to group tngadmin
\p\g
grant update on "mdbadmin".tng_vendor to group tngadmin
\p\g
grant select on "mdbadmin".tng_vendor to group tnguser
\p\g
grant   select   on "mdbadmin".train_57 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".train_57 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".train_57 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".train_57 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".train_57 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".train_57 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".train_57 to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".train_62 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".train_62 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".train_62 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".train_62 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".train_62 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".train_62 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".train_62 to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".trainable_57 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".trainable_57 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".trainable_57 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".trainable_57 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".trainable_57 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".trainable_57 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".trainable_57 to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".trainable_62 to neugentsahd with grant 
option
\p\g
grant   update   on "mdbadmin".trainable_62 to neugentsahd with grant 
option
\p\g
grant   delete   on "mdbadmin".trainable_62 to neugentsahd with grant 
option
\p\g
grant   insert   on "mdbadmin".trainable_62 to neugentsahd with grant 
option
\p\g
grant references on "mdbadmin".trainable_62 to neugentsahd with grant 
option
\p\g
grant  copy_into on "mdbadmin".trainable_62 to neugentsahd with grant 
option
\p\g
grant  copy_from on "mdbadmin".trainable_62 to neugentsahd with grant 
option
\p\g
grant   select   on "mdbadmin".userprofiles to public
\p\g
grant   update   on "mdbadmin".userprofiles to public
\p\g
grant   delete   on "mdbadmin".userprofiles to public
\p\g
grant   insert   on "mdbadmin".userprofiles to public
\p\g
grant references on "mdbadmin".userprofiles to public
\p\g
grant  copy_into on "mdbadmin".userprofiles to public
\p\g
grant  copy_from on "mdbadmin".userprofiles to public
\p\g
grant   select   on "mdbadmin".viewgroups to public
\p\g
grant   update   on "mdbadmin".viewgroups to public
\p\g
grant   delete   on "mdbadmin".viewgroups to public
\p\g
grant   insert   on "mdbadmin".viewgroups to public
\p\g
grant references on "mdbadmin".viewgroups to public
\p\g
grant  copy_into on "mdbadmin".viewgroups to public
\p\g
grant  copy_from on "mdbadmin".viewgroups to public
\p\g
grant   select   on "mdbadmin".viewlanquerydata to public
\p\g
grant   update   on "mdbadmin".viewlanquerydata to public
\p\g
grant   delete   on "mdbadmin".viewlanquerydata to public
\p\g
grant   insert   on "mdbadmin".viewlanquerydata to public
\p\g
grant references on "mdbadmin".viewlanquerydata to public
\p\g
grant  copy_into on "mdbadmin".viewlanquerydata to public
\p\g
grant  copy_from on "mdbadmin".viewlanquerydata to public
\p\g
grant   select   on "mdbadmin".viewquerydata to public
\p\g
grant   update   on "mdbadmin".viewquerydata to public
\p\g
grant   delete   on "mdbadmin".viewquerydata to public
\p\g
grant   insert   on "mdbadmin".viewquerydata to public
\p\g
grant references on "mdbadmin".viewquerydata to public
\p\g
grant  copy_into on "mdbadmin".viewquerydata to public
\p\g
grant  copy_from on "mdbadmin".viewquerydata to public
\p\g
grant   select   on "mdbadmin".viewsettings to public
\p\g
grant   update   on "mdbadmin".viewsettings to public
\p\g
grant   delete   on "mdbadmin".viewsettings to public
\p\g
grant   insert   on "mdbadmin".viewsettings to public
\p\g
grant references on "mdbadmin".viewsettings to public
\p\g
grant  copy_into on "mdbadmin".viewsettings to public
\p\g
grant  copy_from on "mdbadmin".viewsettings to public
\p\g
grant   select   on "mdbadmin".workalert to public
\p\g
grant   update   on "mdbadmin".workalert to public
\p\g
grant   delete   on "mdbadmin".workalert to public
\p\g
grant   insert   on "mdbadmin".workalert to public
\p\g
grant references on "mdbadmin".workalert to public
\p\g
grant  copy_into on "mdbadmin".workalert to public
\p\g
grant  copy_from on "mdbadmin".workalert to public
\p\g

	/* SEQUENCES */
create sequence harbranchseq as integer
    start with 1 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harenvironmentseq as integer
    start with 49 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harformattachmentseq as integer
    start with 1 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harformseq as integer
    start with 1 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence haritemsseq as integer
    start with 2 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harpackagegroupseq as integer
    start with 26 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harpackageseq as integer
    start with 3 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harprocessseq as integer
    start with 1142 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harrepositoryseq as integer
    start with 1 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harstateseq as integer
    start with 191 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harusergroupseq as integer
    start with 21 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence haruserseq as integer
    start with 3 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harversiondataseq as integer
    start with 1 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harversionsseq as integer
    start with 2 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g
create sequence harviewseq as integer
    start with 181 increment by 1
    minvalue 0 maxvalue 2147483647
    cache 10 no cycle no order
\p\g

	/* VIEWS */
create view  harapprovehistview ( envobjid , stateobjid , packageobjid
, usrobjid , actiontime ) AS SELECT DISTINCT envobjid, stateobjid, 
packageobjid, usrobjid, MAX(execdtime) actiontime FROM "mdbadmin". 
harApproveHist GROUP BY envobjid, stateobjid, packageobjid, usrobjid
\p\g
create view  harapprovehistactionview ( envobjid , stateobjid , 
packageobjid , usrobjid , actiontime , action , note ) AS SELECT 
h.envobjid, h.stateobjid, h.packageobjid, h.usrobjid, h.execdtime, 
h.action, h.note FROM "mdbadmin". harApproveHist h, "mdbadmin". 
harApproveHistView v, "mdbadmin". harpackage p WHERE v.packageobjid = 
p.packageobjid AND v.stateobjid = p.stateobjid AND h.envobjid = 
v.envobjid AND h.stateobjid = v.stateobjid AND h.packageobjid = 
v.packageobjid AND h.usrobjid = v.usrobjid AND h.execdtime = 
v.actiontime
\p\g
create view  NotesAlertView AS SELECT A.SourceID, A.CounterID, 
A.TStamp, A.Source, A.ObjectID, A.PersonID, A.Status, A.Description, 
A.CounterValue, A.Threshold, A.PrevStatus, A.IsSent, A.StringValue, 
A.DateValue, S.CollectorID, S.LocaleID, S.ClusterID, S.SiteID, 
S.SourceName, S.SourceType, S.HostName, S.ActiveState, S.UserName, 
S.UserPwd, S.HostName1, S.HostName2, S.HostName3, S.SrcTimeZone, 
C.FullCounterName, C.CounterName, C.DataType, C.Class, C.SubClass, 
C.Instance, C.CounterType, C.ValueType, U.UnitID, U.UnitName, U.Prec, 
U.UnitShortName FROM "mdbadmin". Management_Alert A, "mdbadmin". 
CounterSource S, "mdbadmin". CounterDefinition C, "mdbadmin". Unit U 
WHERE A.SourceID = S.SourceID AND C.UnitID = U.UnitID AND A.CounterID 
= C.CounterID AND (S.SourceName IS NOT NULL) AND ( bit_and 
(byte(S.SourceType), byte(2)) > byte(0))
\p\g
create view  ExchangeAlertView AS SELECT A.SourceID, A.CounterID, 
A.TStamp, A.Source, A.ObjectID, A.PersonID, A.Status, A.Description, 
A.CounterValue, A.Threshold, A.PrevStatus, A.IsSent, A.StringValue, 
A.DateValue, S.CollectorID, S.LocaleID, S.ClusterID, S.SiteID, 
S.SourceName, S.SourceType, S.HostName, S.ActiveState, S.UserName, 
S.UserPwd, S.HostName1, S.HostName2, S.HostName3, S.SrcTimeZone, 
C.FullCounterName, C.CounterName, C.DataType, C.Class, C.SubClass, 
C.Instance, C.CounterType, C.ValueType, U.UnitID, U.UnitName, U.Prec, 
U.UnitShortName FROM "mdbadmin". Management_Alert A, "mdbadmin". 
CounterSource S, "mdbadmin". CounterDefinition C, "mdbadmin". Unit U 
WHERE A.SourceID = S.SourceID AND C.UnitID = U.UnitID AND A.CounterID 
= C.CounterID AND (S.SourceName IS NOT NULL) AND ( bit_and 
(byte(S.SourceType), byte(8)) > byte(0) OR bit_and (byte(S.SourceType)
, byte(32)) > byte(0) OR bit_and (byte(S.SourceType), byte(512)) > 
byte(0) )
\p\g
create view  qmgr_actv (oid, qmname, trptype, hostname, port, 
ip_address, descr, error_code, error_xml, sna_id, qmgr_oid, cmdlevel, 
platform, marked_for_delete) AS SELECT QmgrCfg.QmgrID, 
QmgrCfg.QmgrName, QmgrCfg.ConnTRPTYPE, QmgrCfg.HostName, QmgrCfg.Port,
QmgrCfg.IPAddress, QmgrCfg.ConnDescription, QmgrCfg.CEErrorCode, 
QmgrCfg.CEErrorXML, QmgrCfg.CESNAID, QmgrCfg.CEQmgrOID, 
QmgrCfg.CmdLevel, QmgrCfg.CEPlatformFamily, QmgrCfg.CEMarkedForDelete 
FROM "mdbadmin". QmgrCfg
\p\g
create view  QueueDataMinuteView AS SELECT QueueData.TStamp, 
QueueData.QmgrID, QueueData.QueueID, QueueData.IntvlType, 
QueueData.IntvlDuration, QueueData.Depth, QueueData.DepthPercent, 
QueueData.Residency, QueueData.HighMsgRes, QueueData.Gets, 
QueueData.Puts, QueueData.GetEnabled, QueueData.PutEnabled, 
QueueData.IsSent FROM "mdbadmin". QueueData WHERE IntvlType='I'
\p\g
create view  ChannelAlert AS SELECT AlertData.TStamp, 
AlertData.QmgrID, AlertData.ObjectID, AlertData.ObjectMetric, 
AlertData.ObjectGroup, AlertData.ObjectStatus, 
AlertData.ObjectDescription, AlertData.ObjectMetricUnit, 
AlertData.ObjectMetricType, AlertData.ObjectValue, 
AlertData.ObjectWarn, AlertData.ObjectCrit, AlertData.IsSent FROM 
"mdbadmin". AlertData WHERE ObjectGroup = 'CHANNEL'
\p\g
create view  RouteAlert AS SELECT AlertData.TStamp, AlertData.QmgrID, 
AlertData.ObjectID, AlertData.ObjectMetric, AlertData.ObjectGroup, 
AlertData.ObjectStatus, AlertData.ObjectDescription, 
AlertData.ObjectMetricUnit, AlertData.ObjectMetricType, 
AlertData.ObjectValue, AlertData.ObjectWarn, AlertData.ObjectCrit, 
AlertData.IsSent FROM "mdbadmin". AlertData WHERE ObjectGroup = 'ROUTE
'
\p\g
create view  RouteAlertData (ObjectStatus, resource, TStamp, ObjDescr,
ObjectMetricUnit, ObjMetricType, ObjMetric, ObjectValue, ObjectWarn, 
ObjectCrit, IsSent, ObjectGroup, ObjectID, QmgrName2) AS SELECT 
ra.ObjectStatus, qm.QmgrName + ' ' + r.RouteName, ra.TStamp, 
ra.ObjectDescription, ra.ObjectMetricUnit, ra.ObjectMetricType, 
ra.ObjectMetric, ra.ObjectValue, ra.ObjectWarn, ra.ObjectCrit, 
ra.IsSent, ra.ObjectGroup, ra.ObjectID, qm.QmgrName  FROM "mdbadmin". 
RouteAlert ra, "mdbadmin". QmgrCfg qm, "mdbadmin". RouteCfg r WHERE 
ra.QmgrID = r.QmgrID AND ra.ObjectID = r.RouteID AND r.QmgrID = 
qm.QmgrID
\p\g
create view  LatestRouteAlert AS SELECT a.ObjectStatus, a.resource, 
a.TStamp, a.ObjDescr, a.ObjectMetricUnit, a.ObjMetricType, 
a.ObjMetric, a.ObjectValue, a.ObjectWarn, a.ObjectCrit, a.IsSent, 
a.ObjectGroup, a.ObjectID, a.QmgrName2 FROM "mdbadmin". RouteAlertData
a WHERE TStamp = ( select max(TStamp) from "mdbadmin". RouteAlertData 
b where a.resource = b.resource )
\p\g
create view  ChannelAlertData (ObjectStatus, resource, TStamp, 
ObjDescr, ObjectMetricUnit, ObjMetricType, ObjMetric, ObjectValue, 
ObjectWarn, ObjectCrit, IsSent, ObjectGroup, ObjectID, QmgrName2) AS 
SELECT ca.ObjectStatus, qm.QmgrName + ' ' + c.ChannelName, ca.TStamp, 
ca.ObjectDescription, ca.ObjectMetricUnit, ca.ObjectMetricType, 
ca.ObjectMetric, ca.ObjectValue, ca.ObjectWarn, ca.ObjectCrit, 
ca.IsSent, ca.ObjectGroup, ca.ObjectID, qm.QmgrName  FROM "mdbadmin". 
ChannelAlert ca, "mdbadmin". QmgrCfg qm, "mdbadmin". ChannelCfg c 
WHERE ca.QmgrID = c.QmgrID AND ca.ObjectID = c.ChannelID AND c.QmgrID 
= qm.QmgrID
\p\g
create view  LatestChannelAlert AS SELECT a.ObjectStatus, a.resource, 
a.TStamp, a.ObjDescr, a.ObjectMetricUnit, a.ObjMetricType, 
a.ObjMetric, a.ObjectValue, a.ObjectWarn, a.ObjectCrit, a.IsSent, 
a.ObjectGroup, a.ObjectID, a.QmgrName2 FROM "mdbadmin". 
ChannelAlertData a WHERE TStamp = ( select max(TStamp) from "mdbadmin"
. ChannelAlertData b where a.resource = b.resource )
\p\g
create view  QueueAlert AS SELECT AlertData.TStamp, AlertData.QmgrID, 
AlertData.ObjectID, AlertData.ObjectMetric, AlertData.ObjectGroup, 
AlertData.ObjectStatus, AlertData.ObjectDescription, 
AlertData.ObjectMetricUnit, AlertData.ObjectMetricType, 
AlertData.ObjectValue, AlertData.ObjectWarn, AlertData.ObjectCrit, 
AlertData.IsSent FROM "mdbadmin". AlertData
\p\g
create view  QueueAlertData (ObjectStatus, resource, TStamp, ObjDescr,
ObjectMetricUnit, ObjMetricType, ObjMetric, ObjectValue, ObjectWarn, 
ObjectCrit, IsSent, ObjectGroup, ObjectID, QmgrName2) AS SELECT 
qa.ObjectStatus, qm.QmgrName + ' ' + q.QueueName, qa.TStamp, 
qa.ObjectDescription, qa.ObjectMetricUnit, qa.ObjectMetricType, 
qa.ObjectMetric, qa.ObjectValue, qa.ObjectWarn, qa.ObjectCrit, 
qa.IsSent, qa.ObjectGroup, qa.ObjectID, qm.QmgrName  FROM "mdbadmin". 
QueueAlert qa, "mdbadmin". QmgrCfg qm, "mdbadmin". QueueCfg q WHERE 
qa.QmgrID = q.QmgrID AND qa.ObjectID = q.QueueID AND q.QmgrID = 
qm.QmgrID
\p\g
create view  LatestQueueAlert AS SELECT a.ObjectStatus, a.resource, 
a.TStamp, a.ObjDescr, a.ObjectMetricUnit, a.ObjMetricType, 
a.ObjMetric, a.ObjectValue, a.ObjectWarn, a.ObjectCrit, a.IsSent, 
a.ObjectGroup, a.ObjectID, a.QmgrName2 FROM "mdbadmin". QueueAlertData
a WHERE TStamp = ( select max(TStamp) from "mdbadmin". QueueAlertData 
b where a.resource = b.resource )
\p\g
create view  QueueDataMonthView AS SELECT QueueData.TStamp, 
QueueData.QmgrID, QueueData.QueueID, QueueData.IntvlType, 
QueueData.IntvlDuration, QueueData.Depth, QueueData.DepthPercent, 
QueueData.Residency, QueueData.HighMsgRes, QueueData.Gets, 
QueueData.Puts, QueueData.GetEnabled, QueueData.PutEnabled, 
QueueData.IsSent FROM "mdbadmin". QueueData WHERE IntvlType='M'
\p\g
create view  QueueDataDayView AS SELECT QueueData.TStamp, 
QueueData.QmgrID, QueueData.QueueID, QueueData.IntvlType, 
QueueData.IntvlDuration, QueueData.Depth, QueueData.DepthPercent, 
QueueData.Residency, QueueData.HighMsgRes, QueueData.Gets, 
QueueData.Puts, QueueData.GetEnabled, QueueData.PutEnabled, 
QueueData.IsSent FROM "mdbadmin". QueueData WHERE IntvlType='D'
\p\g
create view  QueueDataHourView AS SELECT QueueData.TStamp, 
QueueData.QmgrID, QueueData.QueueID, QueueData.IntvlType, 
QueueData.IntvlDuration, QueueData.Depth, QueueData.DepthPercent, 
QueueData.Residency, QueueData.HighMsgRes, QueueData.Gets, 
QueueData.Puts, QueueData.GetEnabled, QueueData.PutEnabled, 
QueueData.IsSent FROM "mdbadmin". QueueData WHERE IntvlType='H'
\p\g
create view  RouteDataMonthView AS SELECT RouteData.TStamp, 
RouteData.QmgrID, RouteData.RouteID, RouteData.IntvlType, 
RouteData.IntvlDuration, RouteData.ResponseTime, RouteData.MsgCount, 
RouteData.MsgSize, RouteData.IsSent FROM "mdbadmin". RouteData WHERE 
IntvlType='M'
\p\g
create view  RouteDataDayView AS SELECT RouteData.TStamp, 
RouteData.QmgrID, RouteData.RouteID, RouteData.IntvlType, 
RouteData.IntvlDuration, RouteData.ResponseTime, RouteData.MsgCount, 
RouteData.MsgSize, RouteData.IsSent FROM "mdbadmin". RouteData WHERE 
IntvlType='D'
\p\g
create view  RouteDataHourView AS SELECT RouteData.TStamp, 
RouteData.QmgrID, RouteData.RouteID, RouteData.IntvlType, 
RouteData.IntvlDuration, RouteData.ResponseTime, RouteData.MsgCount, 
RouteData.MsgSize, RouteData.IsSent FROM "mdbadmin". RouteData WHERE 
IntvlType='H'
\p\g
create view  RouteDataMinuteView AS SELECT RouteData.TStamp, 
RouteData.QmgrID, RouteData.RouteID, RouteData.IntvlType, 
RouteData.IntvlDuration, RouteData.ResponseTime, RouteData.MsgCount, 
RouteData.MsgSize, RouteData.IsSent FROM "mdbadmin". RouteData WHERE 
IntvlType='I'
\p\g
create view  COMMON_DICT_VIEW ( COLLECT_ID, OBJECT_ID, USERNAME, 
OBJECT_NAME, TYPE_NO, CREATE_DATE, TABLESPACE_NAME, INI_TRANS, 
MAX_TRANS, INITIAL_EXTENT, NEXT_EXTENT, MIN_EXTENTS, MAX_EXTENTS, 
PCT_INCREASE, SMALLEST_EXT, LARGEST_EXT, FREELISTS, FREELIST_GROUPS, 
NBR_EXTENTS, LOGGING, BACKED_UP, DEGREE, INSTANCES, TEMPORARY, 
PARTITIONED, BUFFER_POOL, CURRENT_BYTES, BLOCK_SIZE, BLOCKS, 
AVG_EXTENT_IN_BLOCKS, ACTUAL_BLOCKS, ACTUAL_MEGA_BYTES, PCT_FREE, 
PCT_USED, TABLE_CACHE, TABLE_LOCK, NESTED, NUM_ROWS, EMPTY_BLOCKS, 
AVG_SPACE, CHAIN_CNT, CHAIN_ROW_CNT, AVG_ROW_LEN, 
AVG_SPACE_FREELIST_BLOCKS, MIGRATE_ROW_CNT, NORMAL_ROW_CNT, 
DELETE_ROW_CNT, AVG_CHAINED_ROW_BYTES, AVG_MIGRATED_ROW_BYTES, 
AVG_NORMAL_ROW_BYTES, AVG_DELETE_ROW_BYTES, FREE_LIST_LENGTH, 
NUM_FREELIST_BLOCKS, SAMPLE_SIZE, IOT_NAME, IOT_TYPE, TABLE_ID, 
INDEX_TYPE, UNIQUENESS, PCT_THRESHOLD, INCLUDE_COLUMN, BLEVEL, 
LEAF_BLOCKS, DISTINCT_KEYS, AVG_LEAF_BLOCKS_PER_KEY, 
AVG_DATA_BLOCKS_PER_KEY, CLUSTERING_FACTOR, STATUS, LAST_ANALYZED, 
GENERATED, KEY_SIZE, AVG_BLOCKS_PER_KEY, CLUSTER_TYPE, 
CLUSTER_FUNCTION, HASH_KEYS, AVG_BYTES_PER_BLOCK, AVG_BLOCK_FILL, 
PCT_BLOCKS_USED, PCT_GROWN_OVER_INIT_EXT, PCT_ROWS_CHAINED ) AS SELECT
CD.COLLECT_ID, CD.OBJECT_ID, CD.OWNER "USERNAME", CD.SEGMENT_NAME 
OBJECT_NAME, CD.TYPE# TYPE_NO, CD.CREATE_DATE, TS.TABLESPACE_NAME, 
CD.INI_TRANS, CD.MAX_TRANS, CD.INITIAL_EXTENT, CD.NEXT_EXTENT, 
CD.MIN_EXTENTS, CD.MAX_EXTENTS, CD.PCT_INCREASE, CD.SMALLEST_EXT, 
CD.LARGEST_EXT, CD.FREELISTS, CD.FREELIST_GROUPS, CD.NBR_EXTENTS, 
CD.LOGGING, CD.BACKED_UP, CD.DEGREE , CD.INSTANCES, CD.TEMPORARY, 
CD.PARTITIONED, CD.BUFFER_POOL, CD.CURRENT_BYTES, TS.BLOCKSIZE 
BLOCK_SIZE, (CD.CURRENT_BYTES/TS.BLOCKSIZE) BLOCKS, 
(CD.CURRENT_BYTES/TS.BLOCKSIZE)/CD.NBR_EXTENTS AVG_EXTENT_IN_BLOCKS, 
CD.TYPE# ACTUAL_BLOCKS, CD.TYPE# ACTUAL_MEGA_BYTES, CD.PCT_FREE, 
CD.PCT_USED, CD.TYPE# TABLE_CACHE, CD.TABLE_LOCK, CD.NESTED NESTED, 
CD.ROW_CNT NUM_ROWS, CD.LEAF_BLOCKS EMPTY_BLOCKS, 
CD.ORA_AVG_FREE_SPACE AVG_SPACE, CD.ORA_CHAINED CHAIN_CNT, 
CD.chain_row_cnt, CD.AVG_ROW_LEN, CD.AVG_SPACE_FREELIST_BLOCKS, 
CD.MIGRATE_ROW_CNT, CD.NORMAL_ROW_CNT NORMAL_ROW_CNT, 
CD.DELETE_ROW_CNT, CD.AVG_CHAINED_ROW_BYTES, 
CD.AVG_MIGRATED_ROW_BYTES, CD.AVG_NORMAL_ROW_BYTES, 
CD.AVG_RELEASED_FREE_SPACE AVG_DELETE_ROW_BYTES, CD.FREE_LIST_LENGTH, 
CD.FREELIST_BLOCK_CNT NUM_FREELIST_BLOCKS, CD.SAMPLE_SIZE, 
CD.IOT_NAME, CD.IOT_TYPE, CD.TABLE_ID, CD.INDEX_TYPE, CD.UNIQUENESS, 
CD.PCT_THRESHOLD, CD.INCLUDE_COLUMN, CD.BLEVEL, CD.LEAF_BLOCKS, 
CD.DISTINCT_KEYS, CD.AVG_LEAF_BLOCKS_PER_KEY, 
CD.AVG_DATA_BLOCKS_PER_KEY, CD.CLUSTERING_FACTOR, CD.STATUS, 
CD.LAST_ANALYZED, CD.GENERATED , CD.KEY_SIZE, CD.AVG_BLOCKS_PER_KEY, 
CD.CLUSTER_TYPE, CD.CLUSTER_FUNCTION, CD.HASH_KEYS, TS.BLOCKSIZE 
AVG_BYTES_PER_BLOCK, TS.BLOCKSIZE AVG_BLOCK_FILL, TS.BLOCKSIZE 
PCT_BLOCKS_USED, CD.INITIAL_EXTENT PCT_GROWN_OVER_INIT_EXT, 
CD.ORA_CHAINED PCT_ROWS_CHAINED FROM "mdbadmin". SEGMENT_DICT CD, 
"mdbadmin". TABLESPACE TS WHERE CD.COLLECT_ID =TS.COLLECT_ID AND 
CD.TABLESPACE_ID = TS.TABLESPACE_ID
\p\g
create view  MASTER_COMMON_VIEW ("COLLECT_ID","OBJECT_ID","USERNAME",
"OBJECT_NAME","TYPE_NO","CREATE_DATE","TABLESPACE_NAME","INI_TRANS",
"MAX_TRANS","INITIAL_EXTENT","NEXT_EXTENT","MIN_EXTENTS","MAX_EXTENTS"
,"PCT_INCREASE","SMALLEST_EXT","LARGEST_EXT","FREELISTS",
"FREELIST_GROUPS","NBR_EXTENTS","LOGGING","BACKED_UP","DEGREE",
"INSTANCES","TEMPORARY","PARTITIONED","BUFFER_POOL","CURRENT_BYTES",
"BLOCK_SIZE","BLOCKS","ACTUAL_MEGA_BYTES","AVG_EXTENT_IN_BLOCKS",
"ACTUAL_BLOCKS","PCT_FREE","PCT_USED","TABLE_CACHE","TABLE_LOCK",
"NESTED","NUM_ROWS","EMPTY_BLOCKS","AVG_SPACE","CHAIN_CNT",
"AVG_ROW_LEN","AVG_SPACE_FREELIST_BLOCKS","CHAIN_ROW_CNT",
"MIGRATE_ROW_CNT","NORMAL_ROW_CNT","DELETE_ROW_CNT",
"AVG_CHAINED_ROW_BYTES","AVG_MIGRATED_ROW_BYTES", 
"AVG_NORMAL_ROW_BYTES","AVG_DELETE_ROW_BYTES","FREE_LIST_LENGTH",
"NUM_FREELIST_BLOCKS","SAMPLE_SIZE","IOT_NAME","IOT_TYPE","INDEX_TYPE"
,"UNIQUENESS","PCT_THRESHOLD","INCLUDE_COLUMN","BLEVEL","LEAF_BLOCKS",
"DISTINCT_KEYS","AVG_LEAF_BLOCKS_PER_KEY","AVG_DATA_BLOCKS_PER_KEY",
"CLUSTERING_FACTOR","STATUS","GENERATED","KEY_SIZE",
"AVG_BLOCKS_PER_KEY","CLUSTER_TYPE","CLUSTER_FUNCTION","HASH_KEYS",
"AVG_BYTES_PER_BLOCK","AVG_BLOCK_FILL","PCT_BLOCKS_USED",
"PCT_GROWN_OVER_INIT_EXT","PCT_ROWS_CHAINED") AS SELECT COLLECT_ID, 
OBJECT_ID, USERNAME, OBJECT_NAME, TYPE_NO, CREATE_DATE, 
TABLESPACE_NAME, INI_TRANS, MAX_TRANS, INITIAL_EXTENT, NEXT_EXTENT, 
MIN_EXTENTS, MAX_EXTENTS, PCT_INCREASE, SMALLEST_EXT, LARGEST_EXT, 
FREELISTS, FREELIST_GROUPS, NBR_EXTENTS, LOGGING, BACKED_UP, DEGREE , 
INSTANCES, TEMPORARY, PARTITIONED, BUFFER_POOL, CURRENT_BYTES, 
BLOCK_SIZE, BLOCKS, ACTUAL_MEGA_BYTES, AVG_EXTENT_IN_BLOCKS, 
ACTUAL_BLOCKS, PCT_FREE, PCT_USED, TABLE_CACHE, TABLE_LOCK, NESTED, 
NUM_ROWS, EMPTY_BLOCKS, AVG_SPACE, CHAIN_CNT, AVG_ROW_LEN, 
AVG_SPACE_FREELIST_BLOCKS, chain_row_cnt, MIGRATE_ROW_CNT, 
NORMAL_ROW_CNT, DELETE_ROW_CNT, AVG_CHAINED_ROW_BYTES, 
AVG_MIGRATED_ROW_BYTES, AVG_NORMAL_ROW_BYTES, AVG_DELETE_ROW_BYTES, 
FREE_LIST_LENGTH, NUM_FREELIST_BLOCKS, SAMPLE_SIZE, IOT_NAME, 
IOT_TYPE, INDEX_TYPE, UNIQUENESS, PCT_THRESHOLD, INCLUDE_COLUMN, 
BLEVEL, LEAF_BLOCKS, DISTINCT_KEYS, AVG_LEAF_BLOCKS_PER_KEY, 
AVG_DATA_BLOCKS_PER_KEY, CLUSTERING_FACTOR, STATUS, GENERATED , 
KEY_SIZE, AVG_BLOCKS_PER_KEY, CLUSTER_TYPE, CLUSTER_FUNCTION, 
HASH_KEYS, AVG_BYTES_PER_BLOCK, AVG_BLOCK_FILL, PCT_BLOCKS_USED, 
PCT_GROWN_OVER_INIT_EXT, PCT_ROWS_CHAINED FROM "mdbadmin". 
COMMON_DICT_VIEW WHERE COLLECT_ID IS NOT NULL
\p\g
create view  RBS_VIEW ( COLLECT_ID, INITIAL_EXTENT, MAX_EXTENTS, 
MIN_EXTENTS, NEXT_EXTENT, PCT_INCREASE, SEGMENT_NAME, OPTSIZE, STATUS,
FILE_NAME, TABLESPACE_NAME, USERNAME ) AS SELECT C.COLLECT_ID, 
R.INITIAL_EXTENT INITIAL_EXTENT, R.MAX_EXTENTS MAX_EXTENTS, 
R.MIN_EXTENTS MIN_EXTENTS, R.NEXT_EXTENT NEXT_EXTENT, R.PCT_INCREASE 
PCT_INCREASE, R.SEGMENT_NAME SEGMENT_NAME, R.OPTSIZE, R.STATUS Status,
D.FILE_NAME, D.TABLESPACE_NAME, R.USER_CODE USERNAME FROM "mdbadmin". 
DATAFILE D, "mdbadmin". RBS R, "mdbadmin". COLLECT C WHERE 
D.DATAFILE_ID = R.DATAFILE_ID AND D.COLLECT_ID = C.COLLECT_ID
\p\g
create view  RBS_DIFF_VIEW ("COMPARE_ID","SEGMENT_NAME","USERNAME",
"MIN_EXTENTS_A","MIN_EXTENTS_B","MAX_EXTENTS_A", "MAX_EXTENTS_B",
"OPTSIZE_A","OPTSIZE_B","TABLESPACE_NAME") AS SELECT CI.COMPARE_ID, 
RA.SEGMENT_NAME, RA.USERNAME, RA.MIN_EXTENTS MIN_EXTENTS_A, 
RB.MIN_EXTENTS MIN_EXTENTS_B, RA.MAX_EXTENTS MAX_EXTENTS_A, 
RB.MAX_EXTENTS MAX_EXTENTS_B, RA.OPTSIZE OPTSIZE_A, RB.OPTSIZE 
OPTSIZE_B, RA.TABLESPACE_NAME FROM "mdbadmin". COMPARE CI, "mdbadmin".
RBS_VIEW RA, "mdbadmin". RBS_VIEW RB WHERE RA.COLLECT_ID = 
CI.FIRST_COLLECT_ID AND RB.COLLECT_ID = CI.LAST_COLLECT_ID AND 
RA.SEGMENT_NAME = RB.SEGMENT_NAME AND RA.USERNAME =RB.USERNAME
\p\g
create view  EXTENT_AVAILABILITY_VIEW_G ("OBJECT_ID","COLLECT_ID",
"TABLESPACE_NAME","OBJECT_NAME","USERNAME","TYPE_NO","NEXT_EXTENT", 
"BLOCKS","SUM_USED_EXTENTS","SUM_FREE_EXTENTS") AS SELECT 
CE.OBJECT_ID, CD.COLLECT_ID COLLECT_ID, CD.TABLESPACE_NAME, 
CD.OBJECT_NAME, CD.USERNAME, CD.TYPE_NO, CD.NEXT_EXTENT NEXT_EXTENT, 
CD.BLOCKS BLOCKS, SUM(CE.BLOCKS) SUM_USED_EXTENTS, CD.BLOCKS 
-SUM(CE.BLOCKS) SUM_FREE_EXTENTS FROM "mdbadmin". COMMON_DICT_VIEW CD,
"mdbadmin". COMMON_EXTENT CE WHERE CD.OBJECT_ID = CE.OBJECT_ID AND 
CD.COLLECT_ID= CE.COLLECT_ID GROUP BY CD.COLLECT_ID,CE.OBJECT_ID, 
CD.OBJECT_NAME, CD.USERNAME, CD.TYPE_NO, CD.TABLESPACE_NAME, 
CD.NEXT_EXTENT,CD.BLOCKS
\p\g
create view  PADDED_OBJECTS_VIEW ("COMPARE_ID","USERNAME",
"OBJECT_NAME","TYPE_NO","TYPE","TABLESPACE_NAME") AS SELECT 
CI.COMPARE_ID, USERNAME, OBJECT_NAME, TYPE_NO, TYPE_NO TYPE, 
TABLESPACE_NAME FROM "mdbadmin". MASTER_COMMON_VIEW CB, "mdbadmin". 
COMPARE CI, "mdbadmin". COMPARE_OBJECT CO WHERE CI.LAST_COLLECT_ID = 
CB.COLLECT_ID AND CI.COMPARE_ID=CO.COMPARE_ID AND CO.LAST_OBJECT_ID = 
CB.OBJECT_ID AND CO.STATUS='A'
\p\g
create view  PDROPPED_OBJECTS_VIEW ("COMPARE_ID","USERNAME",
"OBJECT_NAME","TYPE_NO","TYPE","TABLESPACE_NAME") AS SELECT 
CI.COMPARE_ID, USERNAME, OBJECT_NAME, TYPE_NO, TYPE_NO TYPE, 
TABLESPACE_NAME FROM "mdbadmin". MASTER_COMMON_VIEW CA, "mdbadmin". 
COMPARE CI, "mdbadmin". COMPARE_OBJECT CO WHERE CI.FIRST_COLLECT_ID = 
CA.COLLECT_ID AND CI.COMPARE_ID=CO.COMPARE_ID AND CO.FIRST_OBJECT_ID =
CA.OBJECT_ID AND CO.STATUS='D'
\p\g
create view  OBJECT_DETAIL_CHANGE_VIEW ("COMPARE_ID",
"FIRST_COLLECT_ID","LAST_COLLECT_ID","USERNAME","OBJECT_NAME",
"TABLESPACE_NAME","TYPE","BLOCK_SIZE","CURRENT_MBYTES_A",
"CURRENT_MBYTES_B","CURRENT_BYTES","CHANGED","BLOCKS_ALLOC_A","BLOCKS"
,"LEAF_BLOCKS_A","PCT_FREE", "PCT_USED","NBR_EXTENTS",
"AVG_BYTES_PER_BLOCK","CHAIN_CNT","OLD_BLEVEL",
"OLD_AVG_DATA_BLOCKS_PER_KEY","BLEVEL","AVG_DATA_BLOCKS_PER_KEY",
"INDEX_STATUS","LB_BY_DK_A","NUM_ROWS_A","DISTINCT_KEYS_A",
"NR_BY_DK_A","LEAF_BLOCKS_B","NUM_ROWS_B","DISTINCT_KEYS_B",
"LB_BY_DK_B","NR_BY_DK_B","INITIAL_EXTENT","USED_BLOCKS_A",
"ACTUAL_BLOCKS","NBR_DAYS","USED_ALLOC_CHANGE","PCT_BLOCKS_USED",
"USED_MBYTES_CHANGE","USED_GROWTH_PCT_CHANGE","TYPE_NO","CREATE_DATE",
"PC_INI_TRANS", "PC_MAX_TRANS","PC_INITIAL_EXTENT","PC_NEXT_EXTENT",
"PC_MIN_EXTENTS","PC_MAX_EXTENTS","PC_PCT_INCREASE","PC_SMALLEST_EXT",
"PC_LARGEST_EXT","PC_FREELISTS","PC_FREELIST_GROUPS","PC_NBR_EXTENTS",
"PC_LOGGING","PC_DEGREE","PC_INSTANCES","PC_BACKED_UP",
"PC_PARTITIONED","PC_TEMPORARY","PC_BUFFER_POOL","PC_CURRENT_BYTES",
"PC_PCT_FREE","PC_PCT_USED","PC_BLOCK_SIZE","PC_ACTUAL_BLOCKS",
"PC_TABLE_CACHE","PC_TABLE_LOCK","PC_NESTED","PC_NUM_ROWS","PC_BLOCKS"
,"PC_EMPTY_BLOCKS", "PC_AVG_SPACE","PC_CHAIN_CNT","PC_AVG_ROW_LEN",
"PC_AVG_SPACE_FREELIST_BLOCKS","PC_SAMPLE_SIZE","PC_FREE_LIST_LENGTH",
"PC_PCT_THRESHOLD","PC_BLEVEL","PC_LEAF_BLOCKS","PC_DISTINCT_KEYS",
"PC_AVG_LEAF_BLOCKS_PER_KEY","PC_AVG_DATA_BLOCKS_PER_KEY",
"PC_CLUSTERING_FACTOR","PC_GENERATED","PC_KEY_SIZE",
"PC_AVG_BLOCKS_PER_KEY","PC_HASH_KEYS","PC_AVG_BYTES_PER_BLOCK",
"PC_AVG_BLOCK_FILL","PC_PCT_BLOCKS_USED","PC_PCT_GROWN_OVER_INIT_EXT",
"PC_PCT_ROWS_CHAINED","COMPARE_STATUS") AS SELECT CI.COMPARE_ID 
COMPARE_ID, CI.FIRST_COLLECT_ID FIRST_COLLECT_ID, CI.LAST_COLLECT_ID 
LAST_COLLECT_ID, CB.USERNAME USERNAME, CB.OBJECT_NAME OBJECT_NAME, 
CB.TABLESPACE_NAME TABLESPACE_NAME, CA.TYPE_NO TYPE, CB.BLOCK_SIZE 
BLOCK_SIZE, CA.CURRENT_BYTES/1048576 CURRENT_MBYTES_A, 
CB.CURRENT_BYTES/1048576 CURRENT_MBYTES_B, CB.CURRENT_BYTES 
CURRENT_BYTES, CB.CURRENT_BYTES - CA.CURRENT_BYTES Changed, CA.BLOCKS 
BLOCKS_ALLOC_A, CB.BLOCKS BLOCKS, CA.LEAF_BLOCKS LEAF_BLOCKS_A, 
CB.PCT_FREE, CB.PCT_USED, CB.NBR_EXTENTS, CB.AVG_BYTES_PER_BLOCK, 
CB.CHAIN_CNT, CA.BLEVEL OLD_BLEVEL, CA.AVG_DATA_BLOCKS_PER_KEY 
OLD_AVG_DATA_BLOCKS_PER_KEY, CB.BLEVEL, CB.AVG_DATA_BLOCKS_PER_KEY, 
CB.STATUS INDEX_STATUS, CA.LEAF_BLOCKS/CA.DISTINCT_KEYS LB_BY_DK_A, 
CA.NUM_ROWS NUM_ROWS_A, CA.DISTINCT_KEYS DISTINCT_KEYS_A, 
CA.NUM_ROWS/CA.DISTINCT_KEYS NR_BY_DK_A, CB.LEAF_BLOCKS LEAF_BLOCKS_B,
CB.NUM_ROWS NUM_ROWS_B, CB.DISTINCT_KEYS DISTINCT_KEYS_B, 
CB.LEAF_BLOCKS/CB.DISTINCT_KEYS LB_BY_DK_B, 
CB.NUM_ROWS/CB.DISTINCT_KEYS NR_BY_DK_B, CB.INITIAL_EXTENT 
INITIAL_EXTENT, CA.ACTUAL_BLOCKS USED_BLOCKS_A, CB.ACTUAL_BLOCKS 
ACTUAL_BLOCKS, COLB.START_TIME - COLA.START_TIME NBR_DAYS, 
(CB.ACTUAL_BLOCKS - CA.ACTUAL_BLOCKS) USED_ALLOC_CHANGE , 
(CB.ACTUAL_BLOCKS/CB.BLOCKS)*100 PCT_BLOCKS_USED, (CB.ACTUAL_BLOCKS 
-CA.ACTUAL_BLOCKS)*CB.BLOCK_SIZE/1024/1024 USED_MBYTES_CHANGE, 
((CB.ACTUAL_BLOCKS -CA.ACTUAL_BLOCKS)/CA.ACTUAL_BLOCKS)*100 
USED_GROWTH_PCT_CHANGE, CB.TYPE_NO TYPE_NO, CB.CREATE_DATE, 
((CB.INI_TRANS -CA.INI_TRANS)/CA.INI_TRANS)*100 PC_INI_TRANS, 
((CB.MAX_TRANS - CA.MAX_TRANS)/CA.MAX_TRANS)*100 PC_MAX_TRANS, 
(((CB.INITIAL_EXTENT -CA.INITIAL_EXTENT)/CA.INITIAL_EXTENT)*100) 
PC_INITIAL_EXTENT, (((CB.NEXT_EXTENT- CA.NEXT_EXTENT)/CA.NEXT_EXTENT)
*100) PC_NEXT_EXTENT, (((CB.MIN_EXTENTS - CA.MIN_EXTENTS)
/CA.MIN_EXTENTS)*100) PC_MIN_EXTENTS, (((CB.MAX_EXTENTS 
-CA.MAX_EXTENTS)/CA.MAX_EXTENTS)*100) PC_MAX_EXTENTS, 
(((CB.PCT_INCREASE -CA.PCT_INCREASE)/CA.PCT_INCREASE)*100) 
PC_PCT_INCREASE, (((CB.SMALLEST_EXT -CA.SMALLEST_EXT)/CA.SMALLEST_EXT)
*100) PC_SMALLEST_EXT, (((CB.LARGEST_EXT -CA.LARGEST_EXT)
/CA.LARGEST_EXT)*100) PC_LARGEST_EXT, (((CB.FREELISTS - CA.FREELISTS)
/CA.FREELISTS)*100) PC_FREELISTS, (((CB.FREELIST_GROUPS - 
CA.FREELIST_GROUPS)/CA.FREELIST_GROUPS)*100) PC_FREELIST_GROUPS, 
(((CB.NBR_EXTENTS - CA.NBR_EXTENTS)/CA.NBR_EXTENTS)*100) 
PC_NBR_EXTENTS, (((CB.LOGGING- CA.LOGGING)/CA.LOGGING)*100) 
PC_LOGGING, (((CB.DEGREE- CA.DEGREE)/CA.DEGREE)*100) PC_DEGREE, 
(((CB.INSTANCES - CA.INSTANCES)/CA.INSTANCES)*100) PC_INSTANCES, 
(((CB.BACKED_UP - CA.BACKED_UP)/CA.BACKED_UP)*100) PC_BACKED_UP, 
(((CB.PARTITIONED - CA.PARTITIONED)/CA.PARTITIONED)*100) 
PC_PARTITIONED, (((CB.TEMPORARY - CA.TEMPORARY)/CA.TEMPORARY)*100) 
PC_TEMPORARY, (((CB.BUFFER_POOL - CA.BUFFER_POOL)/CA.BUFFER_POOL)*100)
PC_BUFFER_POOL, (((CB.CURRENT_BYTES -CA.CURRENT_BYTES)
/CA.CURRENT_BYTES)*100) PC_CURRENT_BYTES, (((CB.PCT_FREE -CA.PCT_FREE)
/CA.PCT_FREE)*100) PC_PCT_FREE, (((CB.PCT_USED -CA.PCT_USED)
/CA.PCT_USED)*100) PC_PCT_USED, (((CB.BLOCK_SIZE -CA.BLOCK_SIZE)
/CA.BLOCK_SIZE)*100) PC_BLOCK_SIZE, (((CB.ACTUAL_BLOCKS - 
CA.ACTUAL_BLOCKS)/CA.ACTUAL_BLOCKS)*100) PC_ACTUAL_BLOCKS, 
(((CB.TABLE_CACHE - CA.TABLE_CACHE)/CA.TABLE_CACHE)*100) 
PC_TABLE_CACHE, (((CB.TABLE_LOCK - CA.TABLE_LOCK)/CA.TABLE_LOCK)*100) 
PC_TABLE_LOCK, (((CB.NESTED - CA.NESTED)/CA.NESTED)*100) PC_NESTED, 
(((CB.NUM_ROWS - CA.NUM_ROWS)/CA.NUM_ROWS)*100) PC_NUM_ROWS, 
(((CB.BLOCKS - CA.BLOCKS)/CA.BLOCKS)*100) PC_BLOCKS, 
(((CB.EMPTY_BLOCKS - CA.EMPTY_BLOCKS)/CA.EMPTY_BLOCKS)*100) 
PC_EMPTY_BLOCKS, (((CB.AVG_SPACE - CA.AVG_SPACE)/ CA.AVG_SPACE)*100) 
PC_AVG_SPACE, (((CB.CHAIN_CNT - CA.CHAIN_CNT)/CA.CHAIN_CNT)*100) 
PC_CHAIN_CNT, (((CB.AVG_ROW_LEN - CA.AVG_ROW_LEN)/CA.AVG_ROW_LEN)*100)
PC_AVG_ROW_LEN, (((CB.AVG_SPACE_FREELIST_BLOCKS - 
CA.AVG_SPACE_FREELIST_BLOCKS)/CA.AVG_SPACE_FREELIST_BLOCKS)*100) 
PC_AVG_SPACE_FREELIST_BLOCKS, (((CB.SAMPLE_SIZE - CA.SAMPLE_SIZE)
/CA.SAMPLE_SIZE)*100) PC_SAMPLE_SIZE, (((CB.FREE_LIST_LENGTH - 
CA.FREE_LIST_LENGTH)/CA.FREE_LIST_LENGTH)*100) PC_FREE_LIST_LENGTH, 
(((CB.PCT_THRESHOLD - CA.PCT_THRESHOLD)/CA.PCT_THRESHOLD)*100) 
PC_PCT_THRESHOLD, (((CB.BLEVEL - CA.BLEVEL)/CA.BLEVEL)*100) PC_BLEVEL,
(((CB.LEAF_BLOCKS - CA.LEAF_BLOCKS)/CA.LEAF_BLOCKS)*100) 
PC_LEAF_BLOCKS, (((CB.DISTINCT_KEYS - CA.DISTINCT_KEYS)
/CA.DISTINCT_KEYS)*100) PC_DISTINCT_KEYS, 
(((CB.AVG_LEAF_BLOCKS_PER_KEY - CA.AVG_LEAF_BLOCKS_PER_KEY)
/CA.AVG_LEAF_BLOCKS_PER_KEY)*100) PC_AVG_LEAF_BLOCKS_PER_KEY, 
(((CB.AVG_DATA_BLOCKS_PER_KEY - CA.AVG_DATA_BLOCKS_PER_KEY)
/CA.AVG_DATA_BLOCKS_PER_KEY)*100) PC_AVG_DATA_BLOCKS_PER_KEY, 
(((CB.CLUSTERING_FACTOR - CA.CLUSTERING_FACTOR)/CA.CLUSTERING_FACTOR)
*100) PC_CLUSTERING_FACTOR, (((CB.GENERATED - CA.GENERATED)
/CA.GENERATED)*100) PC_GENERATED, (((CB.KEY_SIZE - CA.KEY_SIZE)
/CA.KEY_SIZE)*100) PC_KEY_SIZE, (((CB.AVG_BLOCKS_PER_KEY - 
CA.AVG_BLOCKS_PER_KEY)/CA.AVG_BLOCKS_PER_KEY)*100) 
PC_AVG_BLOCKS_PER_KEY, (((CB.HASH_KEYS - CA.HASH_KEYS)/ CA.HASH_KEYS)
*100) PC_HASH_KEYS, (((CB.AVG_BYTES_PER_BLOCK - 
CA.AVG_BYTES_PER_BLOCK)/CA.AVG_BYTES_PER_BLOCK)*100) 
PC_AVG_BYTES_PER_BLOCK, (((CB.AVG_BLOCK_FILL - CA.AVG_BLOCK_FILL)
/CA.AVG_BLOCK_FILL)*100) PC_AVG_BLOCK_FILL, (((CB.PCT_BLOCKS_USED - 
CA.PCT_BLOCKS_USED)/CA.PCT_BLOCKS_USED)*100) PC_PCT_BLOCKS_USED, 
(((CB.PCT_GROWN_OVER_INIT_EXT - CA.PCT_GROWN_OVER_INIT_EXT)
/CA.PCT_GROWN_OVER_INIT_EXT)*100) PC_PCT_GROWN_OVER_INIT_EXT, 
(((CB.PCT_ROWS_CHAINED - CA.PCT_ROWS_CHAINED)/CA.PCT_ROWS_CHAINED)
*100) PC_PCT_ROWS_CHAINED, CO.STATUS COMPARE_STATUS FROM "mdbadmin". 
MASTER_COMMON_VIEW CA, "mdbadmin". MASTER_COMMON_VIEW CB, "mdbadmin". 
COMPARE CI, "mdbadmin". COMPARE_OBJECT CO, "mdbadmin". COLLECT COLA, 
"mdbadmin". COLLECT COLB WHERE CI.FIRST_COLLECT_ID = CA.COLLECT_ID AND
CI.LAST_COLLECT_ID = CB.COLLECT_ID AND CI.FIRST_COLLECT_ID = 
COLA.COLLECT_ID AND CI.LAST_COLLECT_ID = COLB.COLLECT_ID AND 
CI.COMPARE_ID=CO.COMPARE_ID AND CO.FIRST_OBJECT_ID = CA.OBJECT_ID AND 
CO.LAST_OBJECT_ID = CB.OBJECT_ID AND CO.STATUS ='B'
\p\g
create view  TABLESPACE_VIEW_G ( COLLECT_ID, TABLESPACE_NAME, AT_DATE,
STATUS, TEMPORARY, LOGGING, TS_SIZE, LARGEST_USED_EXTENT, 
LARGEST_FREE_EXTENT, NBR_USED_EXTENTS, NBR_FREE_EXTENTS ) AS SELECT 
TS.COLLECT_ID, TS.TABLESPACE_NAME , C.END_TIME At_Date, TS.STATUS , 
TS.TEMPORARY , TS.LOGGING , (SUM(F.BYTES) / 1024/1024) TS_Size, 
MAX(F.MAX_USED_SIZE) Largest_Used_Extent, MAX(F.MAX_FREE_SIZE) 
Largest_Free_Extent, COUNT(NBR_USED_EXTENTS) Nbr_Used_Extents, 
COUNT(NBR_FREE_EXTENTS) Nbr_Free_Extents FROM "mdbadmin". TABLESPACE 
TS, "mdbadmin". DATAFILE F, "mdbadmin". COLLECT C WHERE 
TS.TABLESPACE_ID = F.TABLESPACE_ID AND C.COLLECT_ID = TS.COLLECT_ID 
GROUP BY TS.COLLECT_ID, TS.TABLESPACE_NAME, C.END_TIME, TS.STATUS, 
TS.TEMPORARY, TS.LOGGING
\p\g
create view  FILE_CNT_OBJECT_VIEW ( COLLECT_ID, FILE_CNT_OBJECT, 
OBJECT_ID ) AS select collect_id, count( datafile_id) FILE_CNT_OBJECT,
object_id from "mdbadmin". common_extent group by collect_id,object_id
\p\g
create view  EXTENT_FRAG1_VIEW ("COLLECT_ID","NBR_EXTENTS",
"TABLESPACE_NAME","OBJECT_NAME","CURRENT_BYTES","TYPE_NO","USERNAME", 
"OBJECT_ID","BLOCK_SIZE","AVG_EXTENT_BLOCKS","MINMEGTABLE","NBR_CPU",
"MAX_DEGREE","MINMEGINDEX") AS SELECT COLLECT_ID COLLECT_ID, 
NBR_EXTENTS NBR_EXTENTS, TABLESPACE_NAME TABLESPACE_NAME, OBJECT_NAME 
OBJECT_NAME, CURRENT_BYTES CURRENT_BYTES, TYPE_NO, USERNAME, 
OBJECT_ID, BLOCK_SIZE, ((CURRENT_BYTES/BLOCK_SIZE)/NBR_EXTENTS) 
AVG_EXTENT_BLOCKS, a.CONSTANT_VALUE Minmegtable, b.CONSTANT_VALUE 
Nbr_cpu, c.CONSTANT_VALUE max_degree, d.CONSTANT_VALUE MinmegIndex 
FROM "mdbadmin". MASTER_COMMON_VIEW, "mdbadmin". CONSTANTS a, 
"mdbadmin". CONSTANTS b, "mdbadmin". CONSTANTS c, "mdbadmin". 
CONSTANTS d WHERE a.constant_name='MIN_MEG_TABLE_PARALLEL' and 
b.constant_name='NBR_CPU' and c.constant_name='MAX_DEGREE' and 
d.constant_name='MIN_MEG_INDEX_PARALLEL'
\p\g
create view  FILE_CNT_TS_VIEW ( COLLECT_ID, FILE_CNT_TS, TSNAME ) AS 
select collect_id, count(datafile_id) FILE_CNT_TS, tablespace_name 
TSNAME from "mdbadmin". datafile group by collect_id,tablespace_name
\p\g
create view  EXTENT_FRAG2_VIEW ("COLLECT_ID","NBR_EXTENTS",
"TABLESPACE_NAME","OBJECT_NAME","CURRENT_BYTES","TYPE_NO","USERNAME", 
"OBJECT_ID","BLOCK_SIZE","AVG_EXTENT_BLOCKS","MINMEGTABLE","NBR_CPU",
"MAX_DEGREE","MINMEGINDEX", "FILE_CNT_OBJECT","FILE_CNT_TS") AS SELECT
A.COLLECT_ID, NBR_EXTENTS, TABLESPACE_NAME, OBJECT_NAME, 
CURRENT_BYTES, TYPE_NO, USERNAME, A.OBJECT_ID, BLOCK_SIZE, 
AVG_EXTENT_BLOCKS, Minmegtable, Nbr_cpu, max_degree, MinmegIndex, 
FILE_CNT_OBJECT, FILE_CNT_TS FROM "mdbadmin". EXTENT_FRAG1_VIEW A, 
"mdbadmin". FILE_CNT_TS_VIEW B, "mdbadmin". FILE_CNT_OBJECT_VIEW C 
WHERE A.COLLECT_ID=C.COLLECT_ID AND A.OBJECT_ID =C.OBJECT_ID AND 
A.COLLECT_ID=B.COLLECT_ID AND A.TABLESPACE_NAME = B.TSNAME
\p\g
create view  INDEX_VS_TABLE_DEGREE_VIEW ("COLLECT_ID","USERNAME",
"TABLESPACE_NAME","OBJECT_NAME","TABLE_NAME","INDEX_DEGREE",
"TABLE_DEGREE") AS SELECT C.COLLECT_ID, C.USERNAME, C.TABLESPACE_NAME,
C.OBJECT_NAME OBJECT_NAME, B.OBJECT_NAME TABLE_NAME, C.DEGREE 
INDEX_DEGREE, B.DEGREE TABLE_DEGREE FROM "mdbadmin". COMMON_DICT_VIEW 
C, "mdbadmin". COMMON_DICT_VIEW B WHERE C.COLLECT_ID = B.COLLECT_ID 
AND C.TABLE_ID = B.OBJECT_ID AND C.TYPE_NO=1
\p\g
create view  REF_VIEW ("COLLECT_ID","OBJECT_NAME","USERNAME",
"TABLESPACE_NAME","COLUMN_NAME","IS_SCOPED","REF_ID", 
"SCOPE_TABLE_NAME","TABLE_ID","WITH_ROWID","SCOPE_TABLE_OWNER") AS 
SELECT C.COLLECT_ID COLLECT_ID, C.OBJECT_NAME OBJECT_NAME, C.USERNAME,
C.TABLESPACE_NAME, R.COLUMN_NAME COLUMN_NAME, R.IS_SCOPED IS_SCOPED, 
R.REF_ID REF_ID, CDB.OBJECT_NAME SCOPE_TABLE_NAME, R.TABLE_ID 
TABLE_ID, R.WITH_ROWID WITH_ROWID, U.USERNAME SCOPE_TABLE_OWNER FROM 
"mdbadmin". REF R, "mdbadmin". COMMON_DICT_VIEW C, "mdbadmin". 
COMMON_DICT_VIEW CDB, "mdbadmin". USER_HEAD U WHERE R.TABLE_ID = 
C.OBJECT_ID AND R.COLLECT_ID = C.COLLECT_ID AND R.SCOPE_USER_ID = 
U.USER_HEAD_ID AND R.SCOPE_TABLE_ID =CDB.OBJECT_ID
\p\g
create view  INDEX_DICT_ANAL_VIEW ("COLLECT_ID","USERNAME","OBJECT_ID"
,"TABLE_ID","OBJECT_NAME","INDEX_DEGREE","TABLESPACE_NAME",
"TABLE_NAME","TABLE_DEGREE","INDEX_TYPE","UNIQUENESS","PCT_THRESHOLD",
"INCLUDE_COLUMN","PCT_FREE","BLEVEL","LEAF_BLOCKS","BLOCKS",
"BLOCK_SIZE","DISTINCT_KEYS","AVG_LEAF_BLOCKS_PER_KEY",
"AVG_DATA_BLOCKS_PER_KEY","CLUSTERING_FACTOR","STATUS","NUM_ROWS",
"SAMPLE_SIZE","GENERATED","LAST_ANALYZED") AS SELECT I.COLLECT_ID, 
I.USERNAME, IB.OBJECT_ID, I.TABLE_ID, I.OBJECT_NAME, I.DEGREE 
INDEX_DEGREE, I.TABLESPACE_NAME TABLESPACE_NAME, IB.OBJECT_NAME 
TABLE_NAME, IB.DEGREE TABLE_DEGREE, I.INDEX_TYPE, I.UNIQUENESS, 
I.PCT_THRESHOLD, I.INCLUDE_COLUMN, I.PCT_FREE, I.BLEVEL, 
I.LEAF_BLOCKS, I.BLOCKS BLOCKS, I.BLOCK_SIZE, I.DISTINCT_KEYS, 
I.AVG_LEAF_BLOCKS_PER_KEY, I.AVG_DATA_BLOCKS_PER_KEY, 
I.CLUSTERING_FACTOR, I.STATUS, I.NUM_ROWS, I.SAMPLE_SIZE, I.GENERATED,
I.LAST_ANALYZED FROM "mdbadmin". COMMON_DICT_VIEW I, "mdbadmin". 
COMMON_DICT_VIEW IB WHERE I.COLLECT_ID = IB.COLLECT_ID AND I.TABLE_ID 
= IB.OBJECT_ID AND I.TYPE_NO =1
\p\g
create view  MASTER_DETAIL_CHANGE_VIEW ( COMPARE_ID, USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, TYPE, BLOCK_SIZE, CURRENT_MBYTES_A, 
CURRENT_MBYTES_B, CURRENT_BYTES, CHANGED, BLOCKS_ALLOC_A, 
BLOCKS_ALLOC_B, LEAF_BLOCKS_A, PCT_FREE, PCT_USED, NBR_EXTENTS, 
AVG_BYTES_PER_BLOCK, CHAIN_CNT, OLD_BLEVEL, 
OLD_AVG_DATA_BLOCKS_PER_KEY, BLEVEL, AVG_DATA_BLOCKS_PER_KEY, 
INDEX_STATUS, LB_BY_DK_A, NUM_ROWS_A, DISTINCT_KEYS_A, NR_BY_DK_A, 
LEAF_BLOCKS_B, NUM_ROWS_B, DISTINCT_KEYS_B, LB_BY_DK_B, NR_BY_DK_B, 
INITIAL_EXTENT, USED_BLOCKS_A, ACTUAL_BLOCKS_B, NBR_DAYS, 
USED_ALLOC_CHANGE, PCT_BLOCKS_USED, USED_MBYTES_CHANGE, 
USED_GROWTH_PCT_CHANGE, TYPE_NO, PC_INI_TRANS, PC_MAX_TRANS, 
PC_INITIAL_EXTENT, PC_NEXT_EXTENT, PC_MIN_EXTENTS, PC_MAX_EXTENTS, 
PC_PCT_INCREASE, PC_SMALLEST_EXT, PC_LARGEST_EXT, PC_FREELISTS, 
PC_FREELIST_GROUPS, PC_NBR_EXTENTS, PC_LOGGING, PC_DEGREE, 
PC_INSTANCES, PC_BACKED_UP, PC_PARTITIONED, PC_TEMPORARY, 
PC_BUFFER_POOL, PC_CURRENT_BYTES, PC_PCT_FREE, PC_PCT_USED, 
PC_BLOCK_SIZE, PC_ACTUAL_BLOCKS, PC_TABLE_CACHE, PC_TABLE_LOCK, 
PC_NESTED, PC_NUM_ROWS, PC_BLOCKS, PC_EMPTY_BLOCKS, PC_AVG_SPACE, 
PC_CHAIN_CNT, PC_AVG_ROW_LEN, PC_AVG_SPACE_FREELIST_BLOCKS, 
PC_SAMPLE_SIZE, PC_FREE_LIST_LENGTH, PC_PCT_THRESHOLD, PC_BLEVEL, 
PC_LEAF_BLOCKS, PC_DISTINCT_KEYS, PC_AVG_LEAF_BLOCKS_PER_KEY, 
PC_AVG_DATA_BLOCKS_PER_KEY, PC_CLUSTERING_FACTOR, PC_GENERATED, 
PC_KEY_SIZE, PC_AVG_BLOCKS_PER_KEY, PC_HASH_KEYS, 
PC_AVG_BYTES_PER_BLOCK, PC_AVG_BLOCK_FILL, PC_PCT_BLOCKS_USED, 
PC_PCT_GROWN_OVER_INIT_EXT, PC_PCT_ROWS_CHAINED, COMPARE_STATUS ) AS 
SELECT COMPARE_ID, USERNAME, OBJECT_NAME, TABLESPACE_NAME, TYPE, 
BLOCK_SIZE, CURRENT_MBYTES_A, CURRENT_MBYTES_B, CURRENT_BYTES, 
Changed, BLOCKS_ALLOC_A, BLOCKS BLOCKS_ALLOC_B, LEAF_BLOCKS_A, 
PCT_FREE, PCT_USED, NBR_EXTENTS, AVG_BYTES_PER_BLOCK, CHAIN_CNT, 
OLD_BLEVEL, OLD_AVG_DATA_BLOCKS_PER_KEY, BLEVEL, 
AVG_DATA_BLOCKS_PER_KEY, INDEX_STATUS, LB_BY_DK_A, NUM_ROWS_A, 
DISTINCT_KEYS_A, NR_BY_DK_A, LEAF_BLOCKS_B, NUM_ROWS_B, 
DISTINCT_KEYS_B, LB_BY_DK_B, NR_BY_DK_B, INITIAL_EXTENT, 
USED_BLOCKS_A, ACTUAL_BLOCKS ACTUAL_BLOCKS_B, NBR_DAYS, 
USED_ALLOC_CHANGE , PCT_BLOCKS_USED, USED_MBYTES_CHANGE, 
USED_GROWTH_PCT_CHANGE, TYPE_NO, PC_INI_TRANS, PC_MAX_TRANS, 
PC_INITIAL_EXTENT, PC_NEXT_EXTENT, PC_MIN_EXTENTS, PC_MAX_EXTENTS, 
PC_PCT_INCREASE, PC_SMALLEST_EXT, PC_LARGEST_EXT, PC_FREELISTS, 
PC_FREELIST_GROUPS, PC_NBR_EXTENTS, PC_LOGGING, PC_DEGREE, 
PC_INSTANCES, PC_BACKED_UP, PC_PARTITIONED, PC_TEMPORARY, 
PC_BUFFER_POOL, PC_CURRENT_BYTES, PC_PCT_FREE, PC_PCT_USED, 
PC_BLOCK_SIZE, PC_ACTUAL_BLOCKS, PC_TABLE_CACHE, PC_TABLE_LOCK, 
PC_NESTED, PC_NUM_ROWS, PC_BLOCKS, PC_EMPTY_BLOCKS, PC_AVG_SPACE, 
PC_CHAIN_CNT, PC_AVG_ROW_LEN, PC_AVG_SPACE_FREELIST_BLOCKS, 
PC_SAMPLE_SIZE, PC_FREE_LIST_LENGTH, PC_PCT_THRESHOLD, PC_BLEVEL, 
PC_LEAF_BLOCKS, PC_DISTINCT_KEYS, PC_AVG_LEAF_BLOCKS_PER_KEY, 
PC_AVG_DATA_BLOCKS_PER_KEY, PC_CLUSTERING_FACTOR, PC_GENERATED, 
PC_KEY_SIZE, PC_AVG_BLOCKS_PER_KEY, PC_HASH_KEYS, 
PC_AVG_BYTES_PER_BLOCK, PC_AVG_BLOCK_FILL, PC_PCT_BLOCKS_USED, 
PC_PCT_GROWN_OVER_INIT_EXT, PC_PCT_ROWS_CHAINED, COMPARE_STATUS FROM 
"mdbadmin". OBJECT_DETAIL_CHANGE_VIEW WHERE COMPARE_ID IS NOT NULL
\p\g
create view  DATAFILE_EXTENT_VIEW ( COLLECT_ID, TABLESPACE_NAME, 
FILE_NAME, SUM_BLOCKS ) AS SELECT DF.COLLECT_ID, TABLESPACE_NAME, 
FILE_NAME, SUM(BLOCKS) Sum_Blocks FROM "mdbadmin". DATAFILE DF, 
"mdbadmin". COMMON_EXTENT E WHERE DF.DATAFILE_ID = E.DATAFILE_ID GROUP
BY DF.COLLECT_ID, FILE_NAME, TABLESPACE_NAME
\p\g
create view  TABLESPACE_DIFF_VIEW ("COMPARE_ID","ORACLE_SID_A",
"TABLESPACE_NAME_A","FILE_NAME_A","SUM_BLOCKS_A","ORACLE_SID_B", 
"TABLESPACE_NAME_B","FILE_NAME_B","SUM_BLOCKS_B","USED_SPACE_DIFF") AS
SELECT CI.COMPARE_ID, S1.ORACLE_SID ORACLE_SID_A, DA.TABLESPACE_NAME 
TABLESPACE_NAME_A, DA.FILE_NAME FILE_NAME_A, DA.Sum_Blocks 
Sum_Blocks_A, S2.ORACLE_SID ORACLE_SID_B, DB.TABLESPACE_NAME 
TABLESPACE_NAME_B, DB.FILE_NAME FILE_NAME_B, DB.Sum_Blocks 
Sum_Blocks_B, DB.Sum_Blocks - DA.Sum_Blocks Used_space_diff FROM 
"mdbadmin". COMPARE CI, "mdbadmin". SID S1, "mdbadmin". SID S2, 
"mdbadmin". DATAFILE_EXTENT_VIEW DA, "mdbadmin". DATAFILE_EXTENT_VIEW 
DB WHERE DA.COLLECT_ID = CI.FIRST_COLLECT_ID AND DB.COLLECT_ID = 
CI.LAST_COLLECT_ID AND S1.COLLECT_ID=CI.FIRST_COLLECT_ID AND 
S2.COLLECT_ID=CI.LAST_COLLECT_ID AND DA.FILE_NAME = DB.FILE_NAME AND 
DA.TABLESPACE_NAME = DB.TABLESPACE_NAME
\p\g
create view  USER_HEAD_VIEW ( COLLECT_ID, USERNAME, ACCOUNT_STATUS, 
"Default Tablespace", "TEMP Tablespace", LOCK_DATE, EXPIRY_DATE, 
CREATED ) AS SELECT C.COLLECT_ID, USERNAME, ACCOUNT_STATUS, 
DTS.TABLESPACE_NAME "Default Tablespace", TTS.TABLESPACE_NAME 
"TEMP Tablespace", LOCK_DATE, EXPIRY_DATE, CREATED FROM "mdbadmin". 
USER_HEAD C, "mdbadmin". TABLESPACE TTS, "mdbadmin". TABLESPACE DTS 
WHERE DTS.TABLESPACE_ID = C.DEFAULT_TS_ID AND TTS.TABLESPACE_ID = 
C.TEMP_TS_ID
\p\g
create view  USER_STAT_VIEW ( COLLECT_ID, USERNAME, NBR_TABLE, 
NBR_BTREE, NBR_BITMAP, NBR_IOT, NBR_CLUSTER, NBR_TRIGGER, 
NBR_PROCEDURE, NBR_FUNCTION, NBR_PACKAGE, NBR_PACKAGE_BODY, NBR_VIEW, 
NBR_SYNONYM, NBR_SEQUENCE, NBR_TYPE, NBR_TYPE_BODY, NBR_OBJECT, 
NBR_LINK, NBR_REF, TOTAL_ALLOC ) AS SELECT C.COLLECT_ID, C.USERNAME 
USERNAME, NBR_TABLE, NBR_BTREE, NBR_BITMAP, NBR_IOT, NBR_CLUSTER, 
NBR_TRIGGER, NBR_PROCEDURE, NBR_FUNCTION, NBR_PACKAGE, 
NBR_PACKAGE_BODY, NBR_VIEW, NBR_SYNONYM, NBR_SEQUENCE, NBR_TYPE, 
NBR_TYPE_BODY, NBR_OBJECT, NBR_LINK, NBR_REF, TOTAL_ALLOC FROM 
"mdbadmin". USER_HEAD C, "mdbadmin". USER_STAT US WHERE C.USER_HEAD_ID
= US.USER_HEAD_ID
\p\g
create view  USER_REP_VIEW ("COLLECT_ID","USERNAME",
"DEFAULT_TABLESPACE","TEMP_TABLESPACE","NBR_TABLE","NBR_BTREE", 
"NBR_CLUSTER","NBR_VIEW","TOTAL_PROCEDURES") AS SELECT U.COLLECT_ID, 
U.USERNAME, "Default Tablespace" Default_Tablespace, "TEMP Tablespace"
TEMP_Tablespace, NBR_TABLE, NBR_BTREE, NBR_CLUSTER, NBR_VIEW, 
SUM(NBR_PROCEDURE)+SUM(NBR_FUNCTION)+ SUM(NBR_PACKAGE) + 
SUM(NBR_PACKAGE_BODY) total_procedures FROM "mdbadmin". USER_HEAD_VIEW
U, "mdbadmin". USER_STAT_VIEW US WHERE U.USERNAME = US.USERNAME AND 
U.COLLECT_ID = US.COLLECT_ID group by u.collect_id,U.USERNAME,
"Default Tablespace", "TEMP Tablespace", NBR_TABLE,NBR_BTREE,
NBR_CLUSTER,NBR_VIEW
\p\g
create view  LOB_VIEW ("COLLECT_ID","OBJECT_ID","OBJECT_NAME",
"USERNAME","TABLESPACE_NAME","CHUNK_BYTES","COLUMN_NAME","BLOCK_SIZE")
AS SELECT C.COLLECT_ID COLLECT_ID, C.OBJECT_ID OBJECT_ID, 
C.OBJECT_NAME OBJECT_NAME, C.USERNAME, C.TABLESPACE_NAME, 
L.CHUNK_BYTES CHUNK_BYTES, L.COLUMN_NAME COLUMN_NAME, S.BLOCK_SIZE 
BLOCK_SIZE FROM "mdbadmin". COMMON_DICT_VIEW C, "mdbadmin". LOB L, 
"mdbadmin". SID S WHERE L.COLLECT_ID = S.COLLECT_ID AND L.COLLECT_ID =
C.COLLECT_ID AND L.TABLE_ID = C.OBJECT_ID
\p\g
create view  USER_DIFF_VIEW ("COMPARE_ID","USERNAME",
"DEFAULT_TABLESPACE_A","TEMP_TABLESPACE_A","NBR_TABLE_A","NBR_BTREE_A"
, "NBR_CLUSTER_A","NBR_VIEW_A","TOTAL_PROCEDURES_A",
"DEFAULT_TABLESPACE_B","TEMP_TABLESPACE_B", "NBR_TABLE_B",
"NBR_BTREE_B","NBR_CLUSTER_B","NBR_VIEW_B","TOTAL_PROCEDURES_B") AS 
SELECT CI.COMPARE_ID, A.USERNAME, A.Default_Tablespace 
Default_Tablespace_A, A.TEMP_Tablespace TEMP_Tablespace_A, A.NBR_TABLE
NBR_TABLE_A, A.NBR_BTREE NBR_BTREE_A, A.NBR_CLUSTER NBR_CLUSTER_A, 
A.NBR_VIEW NBR_VIEW_A, A.total_procedures total_procedures_A, 
B.Default_Tablespace Default_Tablespace_B, B.TEMP_Tablespace 
TEMP_Tablespace_B, B.NBR_TABLE NBR_TABLE_B, B.NBR_BTREE NBR_BTREE_B, 
B.NBR_CLUSTER NBR_CLUSTER_B, B.NBR_VIEW NBR_VIEW_B, B.total_procedures
total_procedures_B FROM "mdbadmin". COMPARE CI, "mdbadmin". 
USER_REP_VIEW A, "mdbadmin". USER_REP_VIEW B WHERE A.COLLECT_ID = 
CI.FIRST_COLLECT_ID AND B.COLLECT_ID = CI.LAST_COLLECT_ID AND 
A.USERNAME = B.USERNAME
\p\g
create view  TS_QUOTA_VIEW ( COLLECT_ID, USERNAME, TABLESPACE_NAME, 
BYTES, MAX_BYTES ) AS SELECT C.COLLECT_ID, C.USERNAME, 
TS.TABLESPACE_NAME, Q.BYTES, Q.MAX_BYTES FROM "mdbadmin". USER_HEAD C,
"mdbadmin". TS_QUOTA Q, "mdbadmin". TABLESPACE TS WHERE 
TS.TABLESPACE_ID = Q.TABLESPACE_ID AND C.USER_HEAD_ID = Q.USER_HEAD_ID
AND C.COLLECT_ID = TS.COLLECT_ID
\p\g
create view  QUOTAS_ROLES_VIEW ("COLLECT_ID","GRANTEE","DEFAULT_ROLE",
"ROLE_NAME","TABLESPACE_NAME","BYTES","MAX_BYTES") AS SELECT 
R.COLLECT_ID, R.GRANTEE GRANTEE, R.DEFAULT_ROLE DEFAULT_ROLE, 
R.ROLE_NAME ROLE_NAME, TSQ.TABLESPACE_NAME TABLESPACE_NAME, TSQ.BYTES 
BYTES, TSQ.MAX_BYTES MAX_BYTES FROM "mdbadmin". TS_QUOTA_VIEW TSQ, 
"mdbadmin". ROLE_PRIV R WHERE R.COLLECT_ID =TSQ.COLLECT_ID AND 
R.GRANTEE = TSQ.USERNAME
\p\g
create view  QUOTAS_ROLES_DIFF_VIEW ("COMPARE_ID","GRANTEE",
"DEFAULT_ROLE_A","ROLE_NAME_A","TABLESPACE_NAME_A","BYTES_A",
"MAX_BYTES_A", "DEFAULT_ROLE_B","ROLE_NAME_B","TABLESPACE_NAME_B",
"BYTES_B","MAX_BYTES_B") AS SELECT CI.COMPARE_ID, A.GRANTEE GRANTEE, 
A.DEFAULT_ROLE DEFAULT_ROLE_A, A.ROLE_NAME ROLE_NAME_A, 
A.TABLESPACE_NAME TABLESPACE_NAME_A, A.BYTES BYTES_A, A.MAX_BYTES 
MAX_BYTES_A, B.DEFAULT_ROLE DEFAULT_ROLE_B, B.ROLE_NAME ROLE_NAME_B, 
B.TABLESPACE_NAME TABLESPACE_NAME_B, B.BYTES BYTES_B, B.MAX_BYTES 
MAX_BYTES_B FROM "mdbadmin". COMPARE CI, "mdbadmin". QUOTAS_ROLES_VIEW
A, "mdbadmin". QUOTAS_ROLES_VIEW B WHERE A.COLLECT_ID = 
CI.FIRST_COLLECT_ID AND B.COLLECT_ID = CI.LAST_COLLECT_ID AND 
A.GRANTEE = B.GRANTEE
\p\g
create view  FREE_SPACE_VIEW_G ( COLLECT_ID, TABLESPACE_NAME, 
NBR_DATAFILES, NBR_EXTENTS, NBR_FREE_EXTENTS, MIN_FREE_SIZE, 
MAX_FREE_SIZE, AVG_FREE_SIZE ) AS SELECT D.COLLECT_ID, 
D.TABLESPACE_NAME TABLESPACE_NAME, count(FILE_NAME) NBR_DATAFILES, 
sum(D.NBR_FREE_EXTENTS)+sum(D.NBR_USED_EXTENTS) NBR_EXTENTS, 
sum(D.NBR_FREE_EXTENTS) NBR_FREE_EXTENTS, D.MIN_FREE_SIZE 
MIN_FREE_SIZE, D.MAX_FREE_SIZE MAX_FREE_SIZE, D.AVG_FREE_SIZE 
AVG_FREE_SIZE FROM "mdbadmin". DATAFILE D GROUP BY D.COLLECT_ID,
D.TABLESPACE_NAME, D.MIN_FREE_SIZE, D.MAX_FREE_SIZE, D.AVG_FREE_SIZE
\p\g
create view  DAYS_TILL_QUOTA_USED_VIEW_G1 ("COMPARE_ID","COLLECT_ID",
"NBR_OBJECTS","USERNAME","BLOCK_SIZE","SUM_BLOCKS_ALLOC_A", 
"SUM_ACTUAL_BLOCKS_A") AS SELECT CI.COMPARE_ID COMPARE_ID, Collect_ID,
count(OBJECT_ID) NBR_OBJECTS, USERNAME USERNAME, BLOCK_SIZE, 
sum(BLOCKS) SUM_BLOCKS_ALLOC_A, sum(ACTUAL_BLOCKS) sum_actual_blocks_a
FROM "mdbadmin". COMMON_DICT_VIEW, "mdbadmin". COMPARE CI where 
CI.FIRST_COLLECT_ID = COLLECT_ID GROUP BY CI.COMPARE_ID,collect_id,
username,block_size
\p\g
create view  DAYS_TILL_QUOTA_USED_VIEW_G2 ("COMPARE_ID","COLLECT_ID",
"NBR_OBJECTS","USERNAME","BLOCK_SIZE","SUM_BLOCKS_ALLOC_B", 
"SUM_ACTUAL_BLOCKS_B") AS SELECT CI.COMPARE_ID COMPARE_ID, Collect_ID,
count(OBJECT_ID) NBR_OBJECTS, USERNAME USERNAME, BLOCK_SIZE, 
sum(BLOCKS) SUM_BLOCKS_ALLOC_B, sum(ACTUAL_BLOCKS) sum_actual_blocks_b
FROM "mdbadmin". COMMON_DICT_VIEW, "mdbadmin". COMPARE CI where 
CI.LAST_COLLECT_ID = COLLECT_ID GROUP BY CI.COMPARE_ID,collect_id,
username,block_size
\p\g
create view  DAYS_TILL_QUOTA_USED_VIEW_G ("COMPARE_ID","NBR_OBJECTS",
"TABLESPACE_NAME","MAX_BYTES","USERNAME","BLOCK_SIZE", 
"SUM_BLOCKS_ALLOC_A","SUM_BLOCKS_ALLOC_B","SUM_ACTUAL_BLOCKS_A",
"SUM_ACTUAL_BLOCKS_B","SUM_USED_ALLOC_CHANGE","NBR_DAYS") AS SELECT 
G1.COMPARE_ID, G1.NBR_OBJECTS, TQ.TABLESPACE_NAME TABLESPACE_NAME, 
TQ.MAX_BYTES MAX_BYTES, G1.USERNAME USERNAME, G1.BLOCK_SIZE, 
G1.SUM_BLOCKS_ALLOC_A, G2.SUM_BLOCKS_ALLOC_B, G1.sum_actual_blocks_a, 
G2.sum_actual_blocks_b, (G2.sum_actual_blocks_b - 
G1.sum_actual_blocks_a) SUM_USED_ALLOC_CHANGE, COLB.START_TIME - 
COLA.START_TIME NBR_DAYS FROM "mdbadmin". DAYS_TILL_QUOTA_USED_VIEW_G1
G1, "mdbadmin". DAYS_TILL_QUOTA_USED_VIEW_G2 G2, "mdbadmin". 
TS_QUOTA_VIEW TQ, "mdbadmin". COMPARE C, "mdbadmin". COLLECT COLA, 
"mdbadmin". COLLECT COLB WHERE G1.COMPARE_ID = G2.COMPARE_ID AND 
C.COMPARE_ID = G2.COMPARE_ID AND G1.USERNAME = G2.USERNAME AND 
G1.USERNAME = TQ.USERNAME AND TQ.COLLECT_ID=C.LAST_COLLECT_ID AND 
C.FIRST_COLLECT_ID = COLA.COLLECT_ID AND C.LAST_COLLECT_ID = 
COLB.COLLECT_ID
\p\g
create view  EXTENT_VIEW ( COLLECT_ID, USERNAME, OBJECT_NAME, 
TABLESPACE_NAME, FILE_NAME, OFFSET, BLOCKS, Meg ) AS SELECT 
C.COLLECT_ID, U.USERNAME USERNAME, Segment_name OBJECT_NAME, 
TABLESPACE_NAME, FILE_NAME, OFFSET, BLOCKS, S.BLOCK_SIZE * BLOCKS / 
1024 / 1024 "Meg " FROM "mdbadmin". USER_HEAD U, "mdbadmin". DATAFILE 
DF, "mdbadmin". SEGMENT_DICT C, "mdbadmin". COMMON_EXTENT E, 
"mdbadmin". SID S WHERE U.USER_HEAD_ID = C.OWNER_ID AND C.COLLECT_ID =
E.COLLECT_ID AND C.OBJECT_ID = E.OBJECT_ID AND DF.DATAFILE_ID = 
E.DATAFILE_ID AND S.COLLECT_ID = U.COLLECT_ID
\p\g
create view  EXTENT_SIZE_STAT_VIEW_G ("COLLECT_ID","USERNAME",
"OBJECT_NAME","TABLESPACE_NAME","FILE_NAME","OFFSET","MIN_EXT_SIZE", 
"MAX_EXT_SIZE","AVG_EXT_SIZE") AS SELECT COLLECT_ID, USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, FILE_NAME, OFFSET, MIN(BLOCKS) 
MIN_EXT_SIZE, MAX(BLOCKS) MAX_EXT_SIZE, AVG(BLOCKS) AVG_EXT_SIZE FROM 
"mdbadmin". EXTENT_VIEW GROUP BY COLLECT_ID,OBJECT_NAME,USERNAME,
TABLESPACE_NAME, FILE_NAME,OFFSET
\p\g
create view  TABLESPACE_GROWTH_VIEW_G ("COMPARE_ID","TABLESPACE_NAME",
"BLOCK_SIZE","SUM_BLOCKS_ALLOCS_A","SUM_BLOCKS_ALLOC_B", 
"SUM_INITIAL_EXTENT","SUM_BLOCKS_A","SUM_BLOCKS_B","NBR_DAYS",
"SUM_USED_ALLOC_CHANGE","SUM_MB_CHANGE","PCT_ALLOC_USED") AS SELECT 
COMPARE_ID COMPARE_ID, TABLESPACE_NAME TABLESPACE_NAME, BLOCK_SIZE 
BLOCK_SIZE, SUM(BLOCKS_ALLOC_A) SUM_BLOCKS_ALLOCS_A, SUM(BLOCKS) 
SUM_BLOCKS_ALLOC_B, SUM(INITIAL_EXTENT) SUM_INITIAL_EXTENT, 
SUM(USED_BLOCKS_A) SUM_BLOCKS_A, SUM(ACTUAL_BLOCKS) SUM_BLOCKS_B, 
NBR_DAYS, (SUM(ACTUAL_BLOCKS) -SUM(USED_BLOCKS_A)) 
SUM_USED_ALLOC_CHANGE, (SUM(ACTUAL_BLOCKS) -SUM(USED_BLOCKS_A))* 
BLOCK_SIZE/1024/1024 SUM_MB_CHANGE, (SUM(ACTUAL_BLOCKS)/SUM(BLOCKS))
*100 PCT_ALLOC_USED FROM "mdbadmin". OBJECT_DETAIL_CHANGE_VIEW GROUP 
BY COMPARE_ID,TABLESPACE_NAME,NBR_DAYS,BLOCK_SIZE
\p\g
create view  TABLESPACE_VIEW ( COLLECT_ID, TABLESPACE_NAME, AT_DATE, 
STATUS, TEMPORARY, LOGGING, TS_MB_SIZE, LARGEST_USED_EXTENT, 
LARGEST_FREE_EXTENT, NBR_USED_EXTENTS, NBR_FREE_EXTENTS ) AS SELECT 
C.COLLECT_ID, TABLESPACE_NAME, At_Date, Status, Temporary, Logging, 
TS_Size TS_MB_SIZE, Largest_Used_Extent, Largest_Free_Extent, 
Nbr_Used_Extents, Nbr_Free_Extents FROM "mdbadmin". TABLESPACE_VIEW_G 
C WHERE C.COLLECT_ID IS NOT NULL
\p\g
create view  TABLESPACE_GROWTH_A_VIEW ("COMPARE_ID","TABLESPACE_NAME",
"BLOCK_SIZE","SUM_BLOCKS_ALLOCS_A","SUM_BLOCKS_ALLOC_B", 
"SUM_INITIAL_EXTENT","SUM_BLOCKS_A","SUM_BLOCKS_B","NBR_DAYS",
"SUM_USED_ALLOC_CHANGE", "SUM_MB_CHANGE",PCT_ALLOC_USED,"TS_MB_SIZE") 
AS SELECT O.COMPARE_ID COMPARE_ID, O.TABLESPACE_NAME TABLESPACE_NAME, 
O.BLOCK_SIZE BLOCK_SIZE, SUM_BLOCKS_ALLOCS_A, SUM_BLOCKS_ALLOC_B, 
SUM_INITIAL_EXTENT, SUM_BLOCKS_A, SUM_BLOCKS_B, O.NBR_DAYS, 
SUM_USED_ALLOC_CHANGE, SUM_MB_CHANGE, PCT_ALLOC_USED, TS.TS_MB_SIZE 
TS_MB_SIZE FROM "mdbadmin". TABLESPACE_GROWTH_VIEW_G O, "mdbadmin". 
TABLESPACE_VIEW TS, "mdbadmin". COMPARE CI WHERE O.TABLESPACE_NAME = 
TS.TABLESPACE_NAME AND O.COMPARE_ID=CI.COMPARE_ID AND 
TS.COLLECT_ID=CI.LAST_COLLECT_ID
\p\g
create view  ADDED_USERS_VIEW_G2 ("COMPARE_ID","USERNAME",
"NBR_OBJECTS","TOTAL_MEG") AS SELECT CI.COMPARE_ID, B.USERNAME 
"USERNAME", COUNT(B.OBJECT_NAME) NBR_OBJECTS, 
SUM(B.CURRENT_BYTES/1024/1024) TOTAL_MEG FROM "mdbadmin". 
COMMON_DICT_VIEW B, "mdbadmin". COMPARE CI WHERE CI.LAST_COLLECT_ID = 
B.COLLECT_ID group by b.username,ci.compare_id
\p\g
create view  ADDED_USERS_VIEW_G11 ("COMPARE_ID","USERNAME") AS SELECT 
ci.compare_id, B.USERNAME "USERNAME" FROM "mdbadmin". COMMON_DICT_VIEW
B, "mdbadmin". COMPARE CI WHERE CI.LAST_COLLECT_ID = B.COLLECT_ID 
group by B.USERNAME,ci.compare_id
\p\g
create view  ADDED_USERS_VIEW_G13 ("COMPARE_ID","USERNAME") AS SELECT 
compare_id, USERNAME "USERNAME" FROM "mdbadmin". ADDED_USERS_VIEW_G11
\p\g
create view  ADDED_USERS_VIEW_G ("COMPARE_ID","USERNAME","NBR_OBJECTS"
,"TOTAL_MEG") AS SELECT G2.COMPARE_ID, G2.USERNAME , G2.NBR_OBJECTS, 
G2.TOTAL_MEG FROM "mdbadmin". ADDED_USERS_VIEW_G2 G2, "mdbadmin". 
ADDED_USERS_VIEW_G13 G13 WHERE G2.COMPARE_ID = G13.COMPARE_ID AND 
G2.USERNAME = G13.USERNAME
\p\g
create view  DROPPED_USERS_VIEW_G2 ("COMPARE_ID","USERNAME",
"NBR_OBJECTS","TOTAL_MEG") AS SELECT CI.COMPARE_ID, A.USERNAME, 
COUNT(A.OBJECT_NAME) NBR_OBJECTS, SUM(A.CURRENT_BYTES/1024/1024) 
TOTAL_MEG FROM "mdbadmin". COMMON_DICT_VIEW A, "mdbadmin". COMPARE CI 
WHERE CI.FIRST_COLLECT_ID = A.COLLECT_ID group by a.username,
ci.compare_id
\p\g
create view  DROPPED_USERS_VIEW_G11 ("COMPARE_ID","USERNAME") AS 
SELECT CI.COMPARE_ID, A.USERNAME FROM "mdbadmin". COMMON_DICT_VIEW A, 
"mdbadmin". COMPARE CI WHERE CI.FIRST_COLLECT_ID = A.COLLECT_ID group 
by A.USERNAME,CI.COMPARE_ID
\p\g
create view  DROPPED_USERS_VIEW_G13 ("COMPARE_ID","USERNAME") AS 
SELECT COMPARE_ID, USERNAME FROM "mdbadmin". DROPPED_USERS_VIEW_G11
\p\g
create view  DROPPED_USERS_VIEW_G ("COMPARE_ID","USERNAME",
"NBR_OBJECTS","TOTAL_MEG") AS SELECT G2.COMPARE_ID, G2.USERNAME, 
G2.NBR_OBJECTS, G2.TOTAL_MEG FROM "mdbadmin". DROPPED_USERS_VIEW_G2 
G2, "mdbadmin". DROPPED_USERS_VIEW_G13 G13 WHERE G2.COMPARE_ID = 
G13.COMPARE_ID AND G2.USERNAME = G13.USERNAME
\p\g
create view  DAO_REP10_VIEW ("TIMESTAMP","TABLESPACE","ALLOC_MB",
"USED_MB","BLEVEL","CLUSTERING_FACTOR","TEMP_MB") AS select c.end_time
"TIMESTAMP", co.tablespace_name "TABLESPACE", co.CURRENT_BYTES/1048576
"ALLOC_MB", co.ACTUAL_MEGA_BYTES "USED_MB", co.blevel "BLEVEL", 
co.CLUSTERING_FACTOR "CLUSTERING_FACTOR", ((co.ACTUAL_BLOCKS)*110/100)
*co.block_size/1048576 "TEMP_MB" from "mdbadmin". COMMON_DICT_VIEW co,
"mdbadmin". COLLECT c where c.collect_id =co.collect_id
\p\g
create view  TS_CHANGE_VIEW ("COLLECT_ID","TIMESTAMP",
"TABLESPACE_NAME","EXTENTS","BLOCKS","TOTAL_ROWS","ACTUAL_BLOCKS", 
"CHAINED_ROWS","EMPTY_BLOCKS","ACTUAL_MEGA_BYTES") AS select 
a.COLLECT_ID, C.END_TIME "TIMESTAMP", TABLESPACE_NAME 
"TABLESPACE_NAME", sum(NBR_EXTENTS) "EXTENTS", sum(BLOCKS) "BLOCKS", 
sum(NUM_ROWS) "TOTAL_ROWS", sum(ACTUAL_BLOCKS) "ACTUAL_BLOCKS", 
sum(CHAIN_CNT) "CHAINED_ROWS", sum(EMPTY_BLOCKS) "EMPTY_BLOCKS", 
sum(ACTUAL_BLOCKS*BLOCK_SIZE/1048576) "ACTUAL_MEGA_BYTES" from 
"mdbadmin". master_common_view a, "mdbadmin". collect c where 
a.collect_id=c.collect_id group by a.collect_id, c.end_time,
tablespace_name
\p\g
create view  MASTER_FAST_STAT_VIEW ( COLLECT_ID, USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, NORMAL_ROW_CNT, MIGRATE_ROW_CNT, 
CHAIN_ROW_CNT, MIGRATE_AND_CHAIN_ROW_CNT, DELETE_ROW_CNT, 
FREE_BLOCK_CNT, FREE_LIST_LENGTH, EMB_CNT, AVG_BLOCK_HEADER_BYTES, 
AVG_BLOCK_DATA_BYTES, AVG_UNUSED_FREE_SPACE, AVG_RELEASED_FREE_SPACE, 
AVG_NORMAL_ROW_BYTES, AVG_MIGRATED_ROW_BYTES, AVG_CHAINED_ROW_BYTES, 
AVG_MIG_AND_CHAINED_ROW_BYTES, MIN_ROW_LEN, MAX_ROW_LEN, AVG_ROW_LEN, 
MIN_SCN, MAX_SCN, AVG_ROW_DIR_ENTRIES, TOTAL_ROW_DIR_ENTRIES, 
EMPTY_ROW_DIR_ENTRIES, MIN_CHAIN_BLOCKSPAN_OFFSET, 
AVG_CHAIN_BLOCKSPAN_OFFSET, MAX_CHAIN_BLOCKSPAN_OFFSET, 
MIN_MIGRATED_BLOCKSPAN_OFFSET, AVG_MIGRATED_BLOCKSPAN_OFFSET, 
MAX_MIGRATED_BLOCKSPAN_OFFSET, CHAINED_ROWS_THAT_SPAN_FILES, 
MIGRATED_ROWS_THAT_SPAN_FILES, USED_BLOCK_FILL_PERCENTAGE, 
HOME_ROW_READS, MIGRATED_ROW_READS, CHAINED_ROW_READS, 
BLOCK_FILL_MORE_PCTFREE, BLOCK_FILL_LESS_PCTUSED, 
AVG_SPACE_FREELIST_BLOCKS, FREELIST_BLOCK_CNT ) AS select 
a.collect_id, owner username, segment_name object_name, 
ts.tablespace_name, normal_row_cnt, migrate_row_cnt, chain_row_cnt, 
migrate_and_chain_row_cnt, delete_row_cnt, free_block_cnt, 
free_list_length, emb_cnt, avg_block_header_bytes, 
avg_block_data_bytes, avg_unused_free_space, avg_released_free_space, 
avg_normal_row_bytes, avg_migrated_row_bytes, avg_chained_row_bytes, 
avg_mig_and_chained_row_bytes, min_row_len, max_row_len, avg_row_len, 
min_scn, max_scn, AVG_ROW_DIR_ENTRIES, TOTAL_ROW_DIR_ENTRIES, 
EMPTY_ROW_DIR_ENTRIES, MIN_CHAIN_BLOCKSPAN_OFFSET, 
AVG_CHAIN_BLOCKSPAN_OFFSET, MAX_CHAIN_BLOCKSPAN_OFFSET, 
MIN_MIGRATED_BLOCKSPAN_OFFSET, AVG_MIGRATED_BLOCKSPAN_OFFSET, 
MAX_MIGRATED_BLOCKSPAN_OFFSET, CHAINED_ROWS_THAT_SPAN_FILES, 
MIGRATED_ROWS_THAT_SPAN_FILES, USED_BLOCK_FILL_PERCENTAGE, 
HOME_ROW_READS, MIGRATED_ROW_READS, CHAINED_ROW_READS, 
BLOCK_FILL_MORE_PCTFREE, BLOCK_FILL_LESS_PCTUSED, 
AVG_SPACE_FREELIST_BLOCKS, FREELIST_BLOCK_CNT from "mdbadmin". 
segment_dict a, "mdbadmin". tablespace ts where a.type#=2 and 
a.tablespace_id = ts.tablespace_id
\p\g
create view  FILTER_COMPARE_VIEW ( FILTER_HEAD_ID, Name , Version , 
"At Date", "Oracle Version", INCLUSIVE, METRIC_NAME, METRIC_INTERNAL, 
"Low Pct", "High Pct" ) AS SELECT H.FILTER_HEAD_ID, H.FILTER_NAME 
"Name ", H.FILTER_VERSION "Version ", H.CREATED_DATE "At Date", 
H.FILTER_ORA_VERSION "Oracle Version", H.FILTER_AND_OR Inclusive, 
M.METRIC_NAME, M.METRIC_INTERNAL, C.PCT_CHANGE_MIN "Low Pct", 
C.PCT_CHANGE_MAX "High Pct" FROM "mdbadmin". FILTER_HEAD H, "mdbadmin"
. FILTER_COMPARE C, "mdbadmin". ANALYZER_METRIC M WHERE 
C.FILTER_HEAD_ID = H.FILTER_HEAD_ID AND C.METRIC_ID = M.METRIC_ID
\p\g
create view  TABLE_DICT_ANAL_VIEW ( COLLECT_ID, USERNAME, 
TABLESPACE_NAME, OBJECT_NAME, TABLE_ID, AVG_ROW_LEN, AVG_SPACE, 
AVG_SPACE_FREELIST_BLOCKS, BLOCKS, CACHE, CHAIN_CNT, EMPTY_BLOCKS, 
IOT_NAME, IOT_TYPE, NESTED, NUM_FREELIST_BLOCKS, NUM_ROWS, PCT_FREE, 
PCT_USED, SAMPLE_SIZE, TABLE_LOCK, EMB_CNT, MIN_SCN, MAX_SCN, 
CURRENT_BYTES, NBR_EXTENTS, BLOCK_SIZE ) AS SELECT T.COLLECT_ID , 
T.OWNER USERNAME, TS.TABLESPACE_NAME, T.SEGMENT_NAME OBJECT_NAME, 
T.TABLE_ID, T.AVG_ROW_LEN , T.ORA_AVG_FREE_SPACE AVG_SPACE, 
T.AVG_SPACE_FREELIST_BLOCKS , T.USED_BLOCK_CNT+T.EMPTY_BLOCK_CNT 
"BLOCKS", T.CACHE , T.ORA_CHAINED CHAIN_CNT, T.FREE_BLOCK_CNT 
EMPTY_BLOCKS, T.IOT_NAME , T.IOT_TYPE , T.NESTED , 
T.FREELIST_BLOCK_CNT NUM_FREELIST_BLOCKS, T.ROW_CNT NUM_ROWS, 
T.PCT_FREE , T.PCT_USED , T.SAMPLE_SIZE , T.TABLE_LOCK , T.EMB_CNT, 
T.MIN_SCN, T.MAX_SCN, T.CURRENT_BYTES, T.NBR_EXTENTS, TS.BLOCKSIZE 
FROM "mdbadmin". SEGMENT_DICT T, "mdbadmin". TABLESPACE TS WHERE 
T.COLLECT_ID = TS.COLLECT_ID AND T.TABLESPACE_ID=TS.TABLESPACE_ID AND 
T.TYPE# =2
\p\g
create view  COMPARE_VIEW ( "SCOPE 1", SID_1, SID_1_HOSTNAME, 
SID_1_END, "SCOPE 2", SID_2, SID_2_HOSTNAME, SID_2_END, SID_1_START, 
SID_2_START, NBR_DATAPOINTS, "Auto Compare", COMPARE_ID, 
COMPARE_START_TIME, COMPARE_END_TIME, sid1_id, sid2_id ) AS SELECT 
S1.SCOPE_NAME "SCOPE 1", SID1.ORACLE_SID "SID_1", SID1.HOSTNAME 
"SID_1_HOSTNAME", C1.END_TIME "SID_1_END", S2.SCOPE_NAME "SCOPE 2", 
SID2.ORACLE_SID "SID_2", SID2.HOSTNAME "SID_2_HOSTNAME", C2.END_TIME 
"SID_2_END", C1.START_TIME "SID_1_START", C2.START_TIME "SID_2_START",
CI.NBR_DATAPOINTS, CI.AUTO_COMPARE "Auto Compare", CI.COMPARE_ID, 
CI.START_TIME "COMPARE_START_TIME", CI.END_TIME "COMPARE_END_TIME", 
sid1.sid_id "sid1_id", sid2.sid_id "sid2_id" FROM "mdbadmin". SID 
SID1, "mdbadmin". SID SID2, "mdbadmin". COMPARE CI, "mdbadmin". 
COLLECT C1, "mdbadmin". COLLECT C2, "mdbadmin". SCOPE_HEAD S1, 
"mdbadmin". SCOPE_HEAD S2 WHERE C1.COLLECT_ID = SID1.COLLECT_ID AND 
C2.COLLECT_ID = SID2.COLLECT_ID AND CI.FIRST_COLLECT_ID = 
C1.COLLECT_ID AND CI.LAST_COLLECT_ID = C2.COLLECT_ID AND C1.SCOPE_ID =
S1.SCOPE_HEAD_ID AND C2.SCOPE_ID = S2.SCOPE_HEAD_ID
\p\g
create view  FILTER_COLLECT_VIEW ( FILTER_HEAD_ID, Name , Version , 
"At Date", METRIC_NAME, METRIC_INTERNAL, MIN_VAL, MAX_VAL, 
PATTERN_MATCH, "Oracle Version", Inclusive ) AS SELECT 
H.FILTER_HEAD_ID, H.FILTER_NAME "Name ", H.FILTER_VERSION "Version ", 
H.CREATED_DATE "At Date", M.METRIC_NAME, M.METRIC_INTERNAL, C.MIN_VAL,
C.MAX_VAL, C.PATTERN_MATCH, H.FILTER_ORA_VERSION "Oracle Version", 
H.FILTER_AND_OR "Inclusive " FROM "mdbadmin". FILTER_HEAD H, 
"mdbadmin". FILTER_COLLECT C, "mdbadmin". ANALYZER_METRIC M WHERE 
C.FILTER_HEAD_ID = H.FILTER_HEAD_ID AND C.METRIC_ID = M.METRIC_ID
\p\g
create view  wvUnclassified_TCP AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time, b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_unclassified_tcp
b where a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvunclassified_tcp to tngadmin
\p\g
grant select on "mdbadmin".wvunclassified_tcp to tnguser
\p\g
create view  wvConflict_Object AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time,b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_conflict_object 
b where a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvconflict_object to tngadmin
\p\g
grant select on "mdbadmin".wvconflict_object to tnguser
\p\g
create view  wvCountry AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time, b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_country b where 
a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvcountry to tngadmin
\p\g
grant select on "mdbadmin".wvcountry to tnguser
\p\g
create view  wvCity AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time, b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_city b where 
a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvcity to tngadmin
\p\g
grant select on "mdbadmin".wvcity to tnguser
\p\g
create view  wvIP_Interface AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time, b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_ip_interface b 
where a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvip_interface to tngadmin
\p\g
grant select on "mdbadmin".wvip_interface to tnguser
\p\g
create view  wvOverlapInterface AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time, b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_overlapinterface
b where a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvoverlapinterface to tngadmin
\p\g
grant select on "mdbadmin".wvoverlapinterface to tnguser
\p\g
create view  wvDynamicBPV AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time, b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_dbpv b where 
a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvdynamicbpv to tngadmin
\p\g
grant select on "mdbadmin".wvdynamicbpv to tnguser
\p\g
create view  wvIP_Subnet AS select a.name, a.label, a.address, 
a.class_name, a.interface_type, a.autoarrange_type, a.hidden, 
a.propagate_status, a.status_no, a.severity, a.tng_delete_flag, 
a.posted, a.acknowledge, a.ip_address_hex, a.mac_address, 
a.subnet_mask, a.date_ins, a.date_modify, a.alarmset_name, 
a.code_page, a.admin_status, a.DSM_Server, a.propagated_status_no, 
a.propagated_sev, a.DSM_Address, a.license_machine_type, a.create_bpv,
a.override_imagelarge, a.override_imagesmall, a.override_imagedecal, 
a.override_imagetintbool, a.override_model, a.background_image, 
a.weight, a.reserved, a.weighted_severity, a.Max_Sev, a.user_reclass, 
a.Asset_uuid, a.source_repository, a.dnsname, a.last_seen_time, b.* 
from "mdbadmin". tng_managedobject a, "mdbadmin". tng_IP_Subnet b 
where a.uuid = b.uuid
\p\g
grant select on "mdbadmin".wvip_subnet to tngadmin
\p\g
grant select on "mdbadmin".wvip_subnet to tnguser
\p\g
create view  wvFolder AS select * from "mdbadmin". tng_managedobject 
where class_name = 'Folder'
\p\g
grant select on "mdbadmin".wvfolder to tngadmin
\p\g
grant select on "mdbadmin".wvfolder to tnguser
\p\g
create view  wvManagedObjectRoot AS select * from "mdbadmin". 
tng_managedobject where class_name = 'ManagedObjectRoot'
\p\g
grant select on "mdbadmin".wvmanagedobjectroot to tngadmin
\p\g
grant select on "mdbadmin".wvmanagedobjectroot to tnguser
\p\g
create view  wvNode AS select * from "mdbadmin". tng_managedobject 
where class_name = 'Node'
\p\g
grant select on "mdbadmin".wvnode to tngadmin
\p\g
grant select on "mdbadmin".wvnode to tnguser
\p\g
create view  wvUnispace AS select * from "mdbadmin". tng_managedobject
where class_name = 'Unispace'
\p\g
grant select on "mdbadmin".wvunispace to tngadmin
\p\g
grant select on "mdbadmin".wvunispace to tnguser
\p\g
create view  wvNetwork AS select * from "mdbadmin". tng_managedobject 
where class_name = 'Network'
\p\g
grant select on "mdbadmin".wvnetwork to tngadmin
\p\g
grant select on "mdbadmin".wvnetwork to tnguser
\p\g
create view  wvIP_Network AS select * from "mdbadmin". 
tng_managedobject where class_name = 'IP_Network'
\p\g
grant select on "mdbadmin".wvip_network to tngadmin
\p\g
grant select on "mdbadmin".wvip_network to tnguser
\p\g
create view  wvSubnet AS select * from "mdbadmin". tng_managedobject 
where class_name = 'Subnet'
\p\g
grant select on "mdbadmin".wvsubnet to tngadmin
\p\g
grant select on "mdbadmin".wvsubnet to tnguser
\p\g
create view  wvCities As Select m.uuid,m.name, m.label,m.address,
m.address_type,m.status_no,m.hidden, m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name, m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page, m.admin_status, m.DSM_Server,
m.propagated_status_no,m.propagated_sev, m.DSM_Address, 
m.license_machine_type,m.create_bpv, m.override_imagelarge,
m.override_imagesmall, m.override_imagedecal, 
m.override_imagetintbool,m.override_model,m.background_image, 
m.class_name,r.latitude,r.longitude,r.background,r.geomap from 
"mdbadmin". tng_managedobject m, "mdbadmin". tng_city r where m.uuid =
r.uuid
\p\g
grant select on "mdbadmin".wvcities to tngadmin
\p\g
grant select on "mdbadmin".wvcities to tnguser
\p\g
create view  wvSw56Kbps As select * from "mdbadmin". tng_link where 
class_name ='Sw56Kbps'
\p\g
grant select on "mdbadmin".wvsw56kbps to tngadmin
\p\g
grant select on "mdbadmin".wvsw56kbps to tnguser
\p\g
create view  wvT1 As select * from "mdbadmin". tng_link where 
class_name ='T1'
\p\g
grant select on "mdbadmin".wvt1 to tngadmin
\p\g
grant select on "mdbadmin".wvt1 to tnguser
\p\g
create view  wvDigital As select * from "mdbadmin". tng_link where 
class_name ='Digital'
\p\g
grant select on "mdbadmin".wvdigital to tngadmin
\p\g
grant select on "mdbadmin".wvdigital to tnguser
\p\g
create view  wvWireless As select * from "mdbadmin". tng_link where 
class_name ='Wireless'
\p\g
grant select on "mdbadmin".wvwireless to tngadmin
\p\g
grant select on "mdbadmin".wvwireless to tnguser
\p\g
create view  wvFuture As select * from "mdbadmin". tng_link where 
class_name ='Future'
\p\g
grant select on "mdbadmin".wvfuture to tngadmin
\p\g
grant select on "mdbadmin".wvfuture to tnguser
\p\g
create view  wvFlowChart As select * from "mdbadmin". tng_link where 
class_name ='FlowChart'
\p\g
grant select on "mdbadmin".wvflowchart to tngadmin
\p\g
grant select on "mdbadmin".wvflowchart to tnguser
\p\g
create view  wvGanttChart As select * from "mdbadmin". tng_link where 
class_name ='GanttChart'
\p\g
grant select on "mdbadmin".wvganttchart to tngadmin
\p\g
grant select on "mdbadmin".wvganttchart to tnguser
\p\g
create view  wvPertChart As select * from "mdbadmin". tng_link where 
class_name ='PertChart'
\p\g
grant select on "mdbadmin".wvpertchart to tngadmin
\p\g
grant select on "mdbadmin".wvpertchart to tnguser
\p\g
create view  wvChannel_Link As select * from "mdbadmin". tng_link 
where class_name ='Channel_Link'
\p\g
grant select on "mdbadmin".wvchannel_link to tngadmin
\p\g
grant select on "mdbadmin".wvchannel_link to tnguser
\p\g
create view  wvSDLC_Link As select * from "mdbadmin". tng_link where 
class_name ='SDLC_Link'
\p\g
grant select on "mdbadmin".wvsdlc_link to tngadmin
\p\g
grant select on "mdbadmin".wvsdlc_link to tnguser
\p\g
create view  wvTokenRing_Link As select * from "mdbadmin". tng_link 
where class_name ='TokenRing_Link'
\p\g
grant select on "mdbadmin".wvtokenring_link to tngadmin
\p\g
grant select on "mdbadmin".wvtokenring_link to tnguser
\p\g
create view  wvFrameRelay_Link As select * from "mdbadmin". tng_link 
where class_name ='FrameRelay_Link'
\p\g
grant select on "mdbadmin".wvframerelay_link to tngadmin
\p\g
grant select on "mdbadmin".wvframerelay_link to tnguser
\p\g
create view  wvDiscovered_Link As select * from "mdbadmin". tng_link 
where class_name ='Discovered_Link'
\p\g
grant select on "mdbadmin".wvdiscovered_link to tngadmin
\p\g
grant select on "mdbadmin".wvdiscovered_link to tnguser
\p\g
create view  wvProfileDomainServer AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtProfileDomainServer r where m.uuid 
= r.uuid
\p\g
create view  MANAGEMENT_WBR( wbr_stid, wbr_groupid, wbr_node, 
wbr_type, wbr_timz, wbr_dsc ) as Select s.ID, g.ID, s.CCI_NODE, 
s.TYPE, s.TIME_ZONE, s.DESCR From ( "mdbadmin".STATION s left join 
"mdbadmin". MANAGEMENT_GROUPS g on s.ID = g.STATIONID)
\p\g
create view  proc_eventvu as select eoid, stamp, evt_num, joid, 
job_name, box_name, AUTOSERV, event, ev.text eventtxt, status, s.text 
statustxt, alarm, a.text alarmtxt, event_time_gmt, exit_code, 
que_status, que_status_stamp, run_num, ntry, e.text text, machine from
"mdbadmin". proc_event e, "mdbadmin". intcodes ev, "mdbadmin". 
intcodes s, "mdbadmin". intcodes a where e.event = ev.code and 
ev.fld='event' and e.status = s.code and s.fld='status' and e.alarm = 
a.code and a.fld='alarm'
\p\g
create view  jobst AS SELECT j.*, status, status_time, run_num, ntry, 
appl_ntry, last_start, last_end,next_start,exit_code,run_machine, 
que_name, run_priority, next_priority, pid, jc_pid,time_ok, 
last_heartbeat FROM "mdbadmin". job_job j, "mdbadmin". job_status 
WHERE j.joid = job_status.joid
\p\g
create view  eventvu as select eoid, stamp, evt_num, joid, job_name, 
box_name, AUTOSERV, event, ev.text eventtxt, status, s.text statustxt,
alarm, a.text alarmtxt, event_time_gmt, exit_code, que_status, 
que_status_stamp, run_num, ntry, e.text text, machine from "mdbadmin".
job_event e, "mdbadmin". intcodes ev, "mdbadmin". intcodes s, 
"mdbadmin". intcodes a where e.event = ev.code and ev.fld ='event' and
e.status = s.code and s.fld ='status' and e.alarm = a.code and a.fld 
='alarm'
\p\g
create view  eventview (eventid, timestamp, source, fullname, dept, 
mscreenname, cscreenname, bscreenname) as select secure_event.id, 
secure_event.timestamp, secure_event.source, secure_person.fullname, 
secure_person.department, secure_machine.screenname, 
category.screenname, building.screenname from "mdbadmin". 
secure_event, "mdbadmin". secure_person, "mdbadmin". secure_machine, 
"mdbadmin". category, "mdbadmin". personalias, "mdbadmin". 
machinealias, "mdbadmin". building where secure_event.personaliasid = 
personalias.id and personalias.personid = secure_person.id and 
secure_event.machinealiasid = machinealias.id and 
machinealias.machineid = secure_machine.id and 
(secure_machine.buildingid IS NULL or secure_machine.buildingid = 
building.id) and secure_event.categoryid = category.id
\p\g
create view  personview as select a.name, b.*, c.screenname as 
"source" from "mdbadmin". personalias a, "mdbadmin". secure_person b, 
"mdbadmin". datasource c where a.personid = b.id and a.createdby = 
c.id
\p\g
create view  machineview as select a.*, b.screenname as "building", 
c.name, d.screenname as "source" from "mdbadmin". secure_machine a, 
"mdbadmin". building b, "mdbadmin". machinealias c, "mdbadmin". 
datasource d where c.machineid = a.id and a.buildingid = b.id and 
c.createdby = d.id
\p\g
create view  anomalyview as select a.id, a.ruleid, e.fullname, 
min(b.timestamp) as "FirstEvent", max(b.timestamp) as "LastEvent", 
g.screenname, h.screenname as "building" from "mdbadmin". anomaly a, 
"mdbadmin". secure_event b, "mdbadmin". anomalylinkobject c, 
"mdbadmin". personalias d, "mdbadmin". secure_person e, "mdbadmin". 
machinealias f, "mdbadmin". secure_machine g, "mdbadmin". building h 
where c.anomalyid=a.id and b.id=c.objectid and d.id=b.personaliasid 
and e.id=d.personid and f.id=b.machinealiasid and g.id=f.machineid and
c.objecttable='event' and g.buildingid = h.id group by 1, 2, 3, 6, 7
\p\g
create view  anomalycommentview as select a.ruleid, b.fullname, 
c.comment, c.score, c.active, a.id from "mdbadmin". anomaly a, 
"mdbadmin". secure_person b, "mdbadmin". anomalychange c, "mdbadmin". 
anomalylinkobject d, "mdbadmin". personalias e where a.id = 
d.anomalyid and d.objecttable = 'person' and d.objectid = e.id and 
e.personid = b.id and c.anomalyid = a.id
\p\g
create view  buildingview as select screenname, description from 
"mdbadmin". building
\p\g
create view  jobview (name, starttime, repeats, delay, state) as 
select secure_job.name, varchar(secure_job.start_time), 
secure_job.repeats, varchar(secure_job.delay), secure_job.state from 
"mdbadmin". secure_job
\p\g
create view  jobhistoryview as select job_history.* from "mdbadmin". 
job_history
\p\g
create view  investigationview as select investigation.* from 
"mdbadmin". investigation
\p\g
create view  investigationhistoryview as select 
investigation_history.* from "mdbadmin". investigation_history
\p\g
create view  statview as select d.fullname, c.dayorhour, c.average, 
char(_time(int4(c.average + 0.5))) as avg, mod(c.average + 0.5, 60) as
avgseconds, c.stddeviation, char(_time(int4(c.stddeviation + 0.5))) as
stddev, mod(c.stddeviation + 0.5, 60) as stddevseconds, c.totalcount, 
c.periodendts, a.name, e.id as "weekdayid" from "mdbadmin". statistic 
a, "mdbadmin". statisticgrouping b, "mdbadmin". statisticaverages c, 
"mdbadmin". secure_person d, "mdbadmin". weekday e WHERE 
c.statisticgroupingid = b.id AND b.personid = d.id AND b.statisticid =
a.id AND c.dayorhour = e.name
\p\g
create view  rate_person_day as select fullname as person, 
category.screenname as category, date_trunc('day',timestamp) as Day, 
count(categoryid) as Count from "mdbadmin". secure_event, "mdbadmin". 
personalias, "mdbadmin". secure_person, "mdbadmin". category where 
personalias.id=personaliasid and secure_person.id=personid and 
category.id=categoryid group by 1,2,3
\p\g
create view  rate_person_hour as select fullname as person, 
category.screenname as category, date_trunc('hour',timestamp) as Hour,
count(categoryid) as Count from "mdbadmin". secure_event, "mdbadmin". 
personalias, "mdbadmin". secure_person, "mdbadmin". category where 
personalias.id=personaliasid and secure_person.id=personid and 
category.id=categoryid group by 1,2,3
\p\g
create view  rate_machine_day as select secure_machine.screenname as 
machine, category.screenname as category, date_trunc('day',timestamp) 
as Day, count(categoryid) as Count from "mdbadmin". secure_event, 
"mdbadmin". machinealias, "mdbadmin". secure_machine, "mdbadmin". 
category where machinealias.id=machinealiasid and 
secure_machine.id=machineid and category.id=categoryid group by 1,2,3
\p\g
create view  rate_machine_hour as select secure_machine.screenname as 
machine, category.screenname as category, date_trunc('hour',timestamp)
as Hour, count(categoryid) as Count from "mdbadmin". secure_event, 
"mdbadmin". machinealias, "mdbadmin". secure_machine, "mdbadmin". 
category where machinealias.id=machinealiasid and 
secure_machine.id=machineid and category.id=categoryid group by 1,2,3
\p\g
create view  HARAPPROVEACTIONVIEW ( ENVOBJID, STATEOBJID, 
PACKAGEOBJID, USROBJID, ACTIONTIME, ACTION, USRGRPOBJID, PROCESSOBJID 
) AS SELECT v.envobjid, v.stateobjid, v.packageobjid, v.usrobjid, 
v.actiontime, v.action, l.usrgrpobjid, l.processobjid FROM "mdbadmin".
harApproveHistActionView v, "mdbadmin". harApproveList l WHERE 
v.stateobjid = l.stateobjid AND ( ( l.isgroup = 'N' AND l.usrobjid = 
v.usrobjid) OR ( l.isgroup = 'Y' AND l.usrgrpobjid IN (SELECT 
usrgrpobjid FROM "mdbadmin". harusersingroup g WHERE v.usrobjid = 
g.usrobjid)))
\p\g
create view  ReportColumnView (ColumnID, ReportID, ColumnName, 
IsVisible, SortBy, Formula, IsDistinct, IsGroup, Title, Presentation, 
InWorkSpace, TColumnName, TFormula, TTitle, UnitShortName, Prec) AS 
SELECT Col.ColumnID, Col.ReportID, Col.ColumnName, Col.IsVisible, 
Col.SortBy, Col.Formula, Col.IsDistinct, Col.IsGroup, Col.Title, 
Col.Presentation, Col.InWorkSpace, Thre.ColumnName, Thre.Formula, 
Thre.Title, Unit.UnitShortName, Unit.Prec FROM "mdbadmin". 
ReportColumn Col, "mdbadmin". ReportColumn Thre, "mdbadmin". Unit 
WHERE (Col.ReportID=Thre.ReportID and Col.UnitID=Unit.UnitID and 
Col.ThresholdColumnID=Thre.ColumnID ) UNION SELECT Col.ColumnID, 
Col.ReportID, Col.ColumnName, Col.IsVisible, Col.SortBy, Col.Formula, 
Col.IsDistinct, Col.IsGroup, Col.Title, Col.Presentation, 
Col.InWorkSpace, NULL AS TColumnName, NULL AS TFormula, NULL AS TTitle
, Unit.UnitShortName, Unit.Prec FROM "mdbadmin". ReportColumn Col, 
"mdbadmin". Unit WHERE (Col.UnitID=Unit.UnitID and 
Col.ThresholdColumnID IS NULL) UNION SELECT Col.ColumnID, 
Col.ReportID, Col.ColumnName, Col.IsVisible, Col.SortBy, Col.Formula, 
Col.IsDistinct, Col.IsGroup, Col.Title, Col.Presentation, 
Col.InWorkSpace, NULL AS TColumnName, NULL AS TFormula, NULL AS TTitle
, NULL AS UnitShortName, NULL AS Prec FROM "mdbadmin". ReportColumn 
Col WHERE (Col.UnitID IS NULL and Col.ThresholdColumnID IS NULL) UNION
SELECT Col.ColumnID, Col.ReportID, Col.ColumnName, Col.IsVisible, 
Col.SortBy, Col.Formula, Col.IsDistinct, Col.IsGroup, Col.Title, 
Col.Presentation, Col.InWorkSpace, Thre.ColumnName, Thre.Formula, 
Thre.Title , NULL AS UnitShortName, NULL AS Prec FROM "mdbadmin". 
ReportColumn Col, "mdbadmin". ReportColumn Thre WHERE (Col.UnitID IS 
NULL and Col.ReportID=Thre.ReportID and 
Col.ThresholdColumnID=Thre.ColumnID)
\p\g
create view  NotesOutstandingAlertV AS SELECT a.SourceID, a.CounterID,
a.TStamp, a.Source, a.ObjectID, a.PersonID, a.Status, a.Description, 
a.CounterValue, a.Threshold, a.PrevStatus, a.IsSent, a.StringValue, 
a.DateValue, a.CollectorID, a.LocaleID, a.ClusterID, a.SiteID, 
a.SourceName, a.SourceType, a.HostName, a.ActiveState, a.UserName, 
a.UserPwd, a.HostName1, a.HostName2, a.HostName3, a.SrcTimeZone, 
a.FullCounterName, a.CounterName, a.DataType, a.Class, a.SubClass, 
a.Instance, a.CounterType, a.ValueType, a.UnitID, a.UnitName, a.Prec, 
a.UnitShortName FROM "mdbadmin". NotesAlertView a WHERE (TStamp = 
(SELECT MAX(TStamp) FROM "mdbadmin". NotesAlertView b WHERE 
a.CounterID = b.CounterID AND a.SourceID = b.SourceID AND a.Source = 
b.Source)) AND Status <> 1
\p\g
create view  ExchOutstandingAlertV AS SELECT a.SourceID, a.CounterID, 
a.TStamp, a.Source, a.ObjectID, a.PersonID, a.Status, a.Description, 
a.CounterValue, a.Threshold, a.PrevStatus, a.IsSent, a.StringValue, 
a.DateValue, a.CollectorID, a.LocaleID, a.ClusterID, a.SiteID, 
a.SourceName, a.SourceType, a.HostName, a.ActiveState, a.UserName, 
a.UserPwd, a.HostName1, a.HostName2, a.HostName3, a.SrcTimeZone, 
a.FullCounterName, a.CounterName, a.DataType, a.Class, a.SubClass, 
a.Instance, a.CounterType, a.ValueType, a.UnitID, a.UnitName, a.Prec, 
a.UnitShortName FROM "mdbadmin". ExchangeAlertView a WHERE (TStamp = 
(SELECT MAX(TStamp) FROM "mdbadmin". ExchangeAlertView b WHERE 
a.CounterID = b.CounterID AND a.SourceID = b.SourceID AND a.Source = 
b.Source)) AND Status <> 1
\p\g
create view  vrsn_max (oid, qmset_oid, user_name, create_date, 
create_time, vrsn_num, descr, qmset_label, qmset_descr) AS SELECT 
v.oid, v.qmset_oid, v.user_name, v.create_date, v.create_time, 
v.vrsn_num, v.descr, q.qmset_label, q.descr FROM "mdbadmin". vrsn v, 
"mdbadmin". qmset q WHERE q.oid = v.qmset_oid AND v.vrsn_num = (SELECT
MAX(s.vrsn_num) FROM "mdbadmin". vrsn s WHERE s.qmset_oid = 
v.qmset_oid)
\p\g
create view  sdr_xmitq (qmgr_oid, channel, oid, xmitq, xmitq_oid, put,
get, triggerx, trigtype, curdepth, maxdepth, capacity) AS SELECT 
c.qmgr_oid, c.channel, c.oid, c.xmitq, q.oid, q.put, q.get, 
q.triggerx, q.trigtype, q.curdepth, q.maxdepth, q.curdepth * 1000.0 / 
q.maxdepth / 10.0  FROM "mdbadmin". channel c, "mdbadmin". queue q 
WHERE q.qmgr_oid = c.qmgr_oid AND q.queue = c.xmitq AND c.chltype IN 
('SDR', 'SVR')
\p\g
create view  qremote_xmitq (qmgr_oid, queue, oid, xmitq, xmitq_oid, 
put, get, triggerx, trigtype, curdepth, maxdepth, capacity) AS SELECT 
x.qmgr_oid, x.queue, x.oid, x.xmitq, r.oid, r.put, r.get, r.triggerx, 
r.trigtype, r.curdepth, r.maxdepth, x.curdepth * 1000.0 / x.maxdepth /
10.0  FROM "mdbadmin". queue x, "mdbadmin". queue r WHERE r.type = 'QR
EMOTE' AND x.qmgr_oid = r.qmgr_oid AND x.queue = r.xmitq
\p\g
create view  qremote (oid, qmgr_oid, defprty, defpsist, descr, put, 
queue, type, rname, rqmname, scope, xmitq, qsgdisp) AS SELECT 
queue.oid, queue.qmgr_oid, queue.defprty, queue.defpsist, queue.descr,
queue.put, queue.queue, queue.type, queue.rname, queue.rqmname, 
queue.scope, queue.xmitq, queue.qsgdisp FROM "mdbadmin". queue WHERE 
type = 'QREMOTE'
\p\g
create view  qmodel (oid, qmgr_oid, defprty, defpsist, descr, put, 
queue, type, boqname, bothresh, crdate, crtime, defsopt, deftype, 
distl, get, hardenbo, initq, maxdepth, maxmsgl, msgdlvsq, process, 
qdepthhi, qdepthlo, qdphiev, qdploev, qdpmaxev, qsvciev, qsvcint, 
retintvl, sharex, trigdata, trigdpth, triggerx, trigmpri, trigtype, 
usagex, stgclass, qsgdisp) AS SELECT queue.oid, queue.qmgr_oid, 
queue.defprty, queue.defpsist, queue.descr, queue.put, queue.queue, 
queue.type, queue.boqname, queue.bothresh, queue.crdate, queue.crtime,
queue.defsopt, queue.deftype, queue.distl, queue.get, queue.hardenbo, 
queue.initq, queue.maxdepth, queue.maxmsgl, queue.msgdlvsq, 
queue.process, queue.qdepthhi, queue.qdepthlo, queue.qdphiev, 
queue.qdploev, queue.qdpmaxev, queue.qsvciev, queue.qsvcint, 
queue.retintvl, queue.sharex, queue.trigdata, queue.trigdpth, 
queue.triggerx, queue.trigmpri, queue.trigtype, queue.usagex, 
queue.stgclass, queue.qsgdisp FROM "mdbadmin". queue WHERE type = 'QMO
DEL'
\p\g
create view  qmgr_wip_view (wip_oid, hub_oid, oid, authorev, ccsid, 
chad, chadev, chadexit, cmdlevel, commandq, cpilevel, deadq, defxmitq,
descr, distl, inhibtev, localev, maxhands, maxmsgl, maxprty, maxumsgs,
perfmev, platform, qmname, remoteev, strstpev, syncpt, trigint, 
altdate, alttime, clwldata, clwlexit, clwllen, crdate, crtime, qmid, 
repos, reposnl) AS SELECT a.wip_oid, a.hub_oid, b.oid, b.authorev, 
b.ccsid, b.chad, b.chadev, b.chadexit, b.cmdlevel, b.commandq, 
b.cpilevel, b.deadq, b.defxmitq, b.descr, b.distl, b.inhibtev, 
b.localev, b.maxhands, b.maxmsgl, b.maxprty, b.maxumsgs, b.perfmev, 
b.platform, b.qmname, b.remoteev, b.strstpev, b.syncpt, b.trigint, 
b.altdate, b.alttime, b.clwldata, b.clwlexit, b.clwllen, b.crdate, 
b.crtime, b.qmid, b.repos, b.reposnl FROM "mdbadmin". qmgr_wip a, 
"mdbadmin". qmgr b WHERE a.qmgr_oid = b.oid
\p\g
create view  qmgr_vrsn_view (vrsn_oid, hub_oid, oid, authorev, ccsid, 
chad, chadev, chadexit, cmdlevel, commandq, cpilevel, deadq, defxmitq,
descr, distl, inhibtev, localev, maxhands, maxmsgl, maxprty, maxumsgs,
perfmev, platform, qmname, remoteev, strstpev, syncpt, trigint, 
altdate, alttime, clwldata, clwlexit, clwllen, crdate, crtime, qmid, 
repos, reposnl) AS SELECT a.vrsn_oid, a.hub_oid, b.oid, b.authorev, 
b.ccsid, b.chad, b.chadev, b.chadexit, b.cmdlevel, b.commandq, 
b.cpilevel, b.deadq, b.defxmitq, b.descr, b.distl, b.inhibtev, 
b.localev, b.maxhands, b.maxmsgl, b.maxprty, b.maxumsgs, b.perfmev, 
b.platform, b.qmname, b.remoteev, b.strstpev, b.syncpt, b.trigint, 
b.altdate, b.alttime, b.clwldata, b.clwlexit, b.clwllen, b.crdate, 
b.crtime, b.qmid, b.repos, b.reposnl FROM "mdbadmin". qmgr_vrsn a, 
"mdbadmin". qmgr b WHERE a.qmgr_oid = b.oid
\p\g
create view  qlocal (oid, qmgr_oid, defprty, defpsist, descr, put, 
queue, type, boqname, bothresh, crdate, crtime, curdepth, defsopt, 
deftype, distl, get, hardenbo, initq, ipprocs, maxdepth, maxmsgl, 
msgdlvsq, opprocs, process, qdepthhi, qdepthlo, qdphiev, qdploev, 
qdpmaxev, qsvciev, qsvcint, retintvl, scope, sharex, trigdata, 
trigdpth, triggerx, trigmpri, trigtype, usagex, qsgdisp, capacity) AS 
SELECT queue.oid, queue.qmgr_oid, queue.defprty, queue.defpsist, 
queue.descr, queue.put, queue.queue, queue.type, queue.boqname, 
queue.bothresh, queue.crdate, queue.crtime, queue.curdepth, 
queue.defsopt, queue.deftype, queue.distl, queue.get, queue.hardenbo, 
queue.initq, queue.ipprocs, queue.maxdepth, queue.maxmsgl, 
queue.msgdlvsq, queue.opprocs, queue.process, queue.qdepthhi, 
queue.qdepthlo, queue.qdphiev, queue.qdploev, queue.qdpmaxev, 
queue.qsvciev, queue.qsvcint, queue.retintvl, queue.scope, 
queue.sharex, queue.trigdata, queue.trigdpth, queue.triggerx, 
queue.trigmpri, queue.trigtype, queue.usagex, queue.qsgdisp, curdepth 
* 1000.0 / maxdepth / 10.0  FROM "mdbadmin". queue WHERE type = 'QLOCA
L'
\p\g
create view  qalias (oid, qmgr_oid, defprty, defpsist, descr, put, 
queue, type, get, scope, targq, qsgdisp) AS SELECT queue.oid, 
queue.qmgr_oid, queue.defprty, queue.defpsist, queue.descr, queue.put,
queue.queue, queue.type, queue.get, queue.scope, queue.targq, 
queue.qsgdisp FROM "mdbadmin". queue WHERE type = 'QALIAS'
\p\g
create view  pair_wip (channel, w_oid, sq_oid, sc_oid, xq_oid, xp_oid,
rq_oid, rc_oid, s_qmname, s_cmdlevel, s_platform, s_chltype, 
s_trptype, s_conname, s_xmitq, s_usage, s_trigdata, s_process, 
s_appltype, s_userdata, s_applicid, r_qmname, r_chltype, r_trptype, 
r_conname) AS SELECT sc.channel, w.oid, sq.oid, sc.oid, xq.oid, 
xp.oid, rq.oid, rc.oid, sq.qmname, sq.cmdlevel, sq.platform, 
sc.chltype, sc.trptype, sc.conname, sc.xmitq, xq.usagex, xq.trigdata, 
xp.process, xp.appltype, xp.userdata, xp.applicid, rq.qmname, 
rc.chltype, rc.trptype, rc.conname FROM "mdbadmin". wip w, "mdbadmin".
qmgr_wip sv, "mdbadmin". qmgr sq, "mdbadmin". channel sc, "mdbadmin". 
queue xq, "mdbadmin". process xp, "mdbadmin". qmgr_wip rv, "mdbadmin".
qmgr rq, "mdbadmin". channel rc WHERE sv.wip_oid = w.oid AND sq.oid = 
sv.qmgr_oid AND sc.qmgr_oid = sq.oid AND sc.chltype IN ('SDR', 'SVR') 
AND xq.qmgr_oid = sq.oid AND xq.queue = sc.xmitq AND xq.usagex = ('XMI
TQ') AND rv.wip_oid = w.oid AND rq.oid = rv.qmgr_oid AND rc.qmgr_oid =
rq.oid AND rc.chltype IN ('RCVR', 'RQSTR') AND sc.channel = rc.channel
AND xp.qmgr_oid = xq.qmgr_oid AND ((xp.process = xq.process AND 
xp.userdata = sc.channel AND xp.appltype = 'DEF' AND xp.applicid IS 
NULL) OR (xq.process IS NULL AND xq.trigdata = sc.channel AND 
xp.process = 'SYSTEM.DEF.PROCESS'))
\p\g
create view  conn_wip (wip_oid, local_qmgr_oid, local_qmname, 
local_channel, local_chltype, remote_qmgr_oid, remote_qmname, 
remote_channel, remote_chltype) AS SELECT lw.wip_oid, lq.oid, 
lq.qmname, lc.channel, lc.chltype, rq.oid, rq.qmname, rc.channel, 
rc.chltype FROM "mdbadmin". qmgr_wip lw, "mdbadmin". qmgr_actv la, 
"mdbadmin". qmgr lq, "mdbadmin". channel lc, "mdbadmin". qmgr_wip rw, 
"mdbadmin". qmgr_actv ra, "mdbadmin". qmgr rq, "mdbadmin". channel rc 
WHERE lw.wip_oid = rw.wip_oid AND lq.oid = lw.qmgr_oid AND rq.oid = 
rw.qmgr_oid AND lq.qmname = la.qmname AND lc.qmgr_oid = lq.oid AND 
ra.oid = lc.rqmgr_actv_oid AND rq.qmname = ra.qmname AND rc.qmgr_oid =
rq.oid AND lc.channel = rc.channel AND lc.chltype IN ('SDR', 'RQSTR', 
'SVR') AND ((lc.chltype = 'SDR' AND rc.chltype = 'RCVR') OR 
(lc.chltype = 'SVR' AND rc.chltype = 'RCVR') OR (lc.chltype = 'RQSTR' 
AND rc.chltype = 'SDR') OR (lc.chltype = 'RQSTR' AND rc.chltype = 'SVR
'))
\p\g
create view  conn_vrsn (vrsn_oid, local_qmgr_oid, local_qmname, 
local_channel, local_chltype, remote_qmgr_oid, remote_qmname, 
remote_channel, remote_chltype) AS SELECT lv.vrsn_oid, lq.oid, 
lq.qmname, lc.channel, lc.chltype, rq.oid, rq.qmname, rc.channel, 
rc.chltype FROM "mdbadmin". qmgr_vrsn lv, "mdbadmin". qmgr_actv la, 
"mdbadmin". qmgr lq, "mdbadmin". channel lc, "mdbadmin". qmgr_vrsn rv,
"mdbadmin". qmgr_actv ra, "mdbadmin". qmgr rq, "mdbadmin". channel rc 
WHERE lv.vrsn_oid = rv.vrsn_oid AND lq.oid = lv.qmgr_oid AND rq.oid = 
rv.qmgr_oid AND lq.qmname = la.qmname AND lc.qmgr_oid = lq.oid AND 
ra.oid = lc.rqmgr_actv_oid AND rq.qmname = ra.qmname AND rc.qmgr_oid =
rq.oid AND lc.channel = rc.channel AND lc.chltype IN ('SDR', 'RQSTR', 
'SVR') AND ((lc.chltype = 'SDR' AND rc.chltype = 'RCVR') OR 
(lc.chltype = 'SVR' AND rc.chltype = 'RCVR') OR (lc.chltype = 'RQSTR' 
AND rc.chltype = 'SDR') OR (lc.chltype = 'RQSTR' AND rc.chltype = 'SVR
'))
\p\g
create view  AppQMinuteView (ApplicationName, ResponseTime, QueueName,
ObjectID, QmgrID, ObjectType, ApplicationID) AS SELECT 
ApplicationCfg.ApplicationName, QueueDataMinuteView.Residency, 
QueueCfg.QueueName, ApplicationItems.ObjectID, 
ApplicationItems.QmgrID, ApplicationItems.ObjectType, 
ApplicationItems.ApplicationID FROM "mdbadmin". ApplicationCfg, 
"mdbadmin". ApplicationItems, "mdbadmin". QueueCfg, "mdbadmin". 
QueueDataMinuteView WHERE (ApplicationCfg.ApplicationID = 
ApplicationItems.ApplicationID and ApplicationItems.QmgrID = 
QueueDataMinuteView.QmgrID and ApplicationItems.ObjectID = 
QueueDataMinuteView.QueueID and QueueCfg.QmgrID = 
QueueDataMinuteView.QmgrID and QueueCfg.QueueID = 
QueueDataMinuteView.QueueID and ApplicationItems.ObjectType = 'QUEUE')
\p\g
create view  RouteNodeDataMonthView AS SELECT RouteNodeData.TStamp, 
RouteNodeData.QmgrID, RouteNodeData.RouteID, RouteNodeData.NodeQmgrID,
RouteNodeData.IntvlType, RouteNodeData.IntvlDuration, 
RouteNodeData.OutboundTime, RouteNodeData.InboundTime, 
RouteNodeData.TotalTime, RouteNodeData.IsSent FROM "mdbadmin". 
RouteNodeData WHERE IntvlType='M'
\p\g
create view  RouteNodeDataDayView AS SELECT RouteNodeData.TStamp, 
RouteNodeData.QmgrID, RouteNodeData.RouteID, RouteNodeData.NodeQmgrID,
RouteNodeData.IntvlType, RouteNodeData.IntvlDuration, 
RouteNodeData.OutboundTime, RouteNodeData.InboundTime, 
RouteNodeData.TotalTime, RouteNodeData.IsSent FROM "mdbadmin". 
RouteNodeData WHERE IntvlType='D'
\p\g
create view  RouteNodeDataHourView AS SELECT RouteNodeData.TStamp, 
RouteNodeData.QmgrID, RouteNodeData.RouteID, RouteNodeData.NodeQmgrID,
RouteNodeData.IntvlType, RouteNodeData.IntvlDuration, 
RouteNodeData.OutboundTime, RouteNodeData.InboundTime, 
RouteNodeData.TotalTime, RouteNodeData.IsSent FROM "mdbadmin". 
RouteNodeData WHERE IntvlType='H'
\p\g
create view  RouteNodeDataMinuteView AS SELECT RouteNodeData.TStamp, 
RouteNodeData.QmgrID, RouteNodeData.RouteID, RouteNodeData.NodeQmgrID,
RouteNodeData.IntvlType, RouteNodeData.IntvlDuration, 
RouteNodeData.OutboundTime, RouteNodeData.InboundTime, 
RouteNodeData.TotalTime, RouteNodeData.IsSent FROM "mdbadmin". 
RouteNodeData WHERE IntvlType='I'
\p\g
create view  OutstandingRouteAlert AS SELECT 
LatestRouteAlert.ObjectStatus, LatestRouteAlert.resource, 
LatestRouteAlert.TStamp, LatestRouteAlert.ObjDescr, 
LatestRouteAlert.ObjectMetricUnit, LatestRouteAlert.ObjMetricType, 
LatestRouteAlert.ObjMetric, LatestRouteAlert.ObjectValue, 
LatestRouteAlert.ObjectWarn, LatestRouteAlert.ObjectCrit, 
LatestRouteAlert.IsSent, LatestRouteAlert.ObjectGroup, 
LatestRouteAlert.ObjectID, LatestRouteAlert.QmgrName2 FROM "mdbadmin".
LatestRouteAlert WHERE ObjectStatus <> 1
\p\g
create view  OutstandingChannelAlert AS SELECT 
LatestChannelAlert.ObjectStatus, LatestChannelAlert.resource, 
LatestChannelAlert.TStamp, LatestChannelAlert.ObjDescr, 
LatestChannelAlert.ObjectMetricUnit, LatestChannelAlert.ObjMetricType,
LatestChannelAlert.ObjMetric, LatestChannelAlert.ObjectValue, 
LatestChannelAlert.ObjectWarn, LatestChannelAlert.ObjectCrit, 
LatestChannelAlert.IsSent, LatestChannelAlert.ObjectGroup, 
LatestChannelAlert.ObjectID, LatestChannelAlert.QmgrName2 FROM 
"mdbadmin". LatestChannelAlert WHERE ObjectStatus <> 1
\p\g
create view  OutstandingQueueAlert AS SELECT 
LatestQueueAlert.ObjectStatus, LatestQueueAlert.resource, 
LatestQueueAlert.TStamp, LatestQueueAlert.ObjDescr, 
LatestQueueAlert.ObjectMetricUnit, LatestQueueAlert.ObjMetricType, 
LatestQueueAlert.ObjMetric, LatestQueueAlert.ObjectValue, 
LatestQueueAlert.ObjectWarn, LatestQueueAlert.ObjectCrit, 
LatestQueueAlert.IsSent, LatestQueueAlert.ObjectGroup, 
LatestQueueAlert.ObjectID, LatestQueueAlert.QmgrName2 FROM "mdbadmin".
LatestQueueAlert WHERE ObjectStatus <> 1
\p\g
create view  AppQMonthView (ApplicationName, ResponseTime, QueueName, 
ObjectID, QmgrID, ObjectType, ApplicationID, TStamp) AS SELECT 
ApplicationCfg.ApplicationName, QueueDataMonthView.Residency, 
QueueCfg.QueueName, ApplicationItems.ObjectID, 
ApplicationItems.QmgrID, ApplicationItems.ObjectType, 
ApplicationItems.ApplicationID, QueueDataMonthView.TStamp FROM 
"mdbadmin". ApplicationCfg, "mdbadmin". ApplicationItems, "mdbadmin". 
QueueCfg, "mdbadmin". QueueDataMonthView WHERE 
(ApplicationCfg.ApplicationID = ApplicationItems.ApplicationID and 
ApplicationItems.QmgrID = QueueDataMonthView.QmgrID and 
ApplicationItems.ObjectID = QueueDataMonthView.QueueID and 
QueueCfg.QmgrID = QueueDataMonthView.QmgrID and QueueCfg.QueueID = 
QueueDataMonthView.QueueID and ApplicationItems.ObjectType = 'QUEUE')
\p\g
create view  AppQDayView (ApplicationName, ResponseTime, QueueName, 
ObjectID, QmgrID, ObjectType, ApplicationID, TStamp) AS SELECT 
ApplicationCfg.ApplicationName, QueueDataDayView.Residency, 
QueueCfg.QueueName, ApplicationItems.ObjectID, 
ApplicationItems.QmgrID, ApplicationItems.ObjectType, 
ApplicationItems.ApplicationID, QueueDataDayView.TStamp FROM 
"mdbadmin". ApplicationCfg, "mdbadmin". ApplicationItems, "mdbadmin". 
QueueCfg, "mdbadmin". QueueDataDayView WHERE 
(ApplicationCfg.ApplicationID = ApplicationItems.ApplicationID and 
ApplicationItems.QmgrID = QueueDataDayView.QmgrID and 
ApplicationItems.ObjectID = QueueDataDayView.QueueID and 
QueueCfg.QmgrID = QueueDataDayView.QmgrID and QueueCfg.QueueID = 
QueueDataDayView.QueueID and ApplicationItems.ObjectType = 'QUEUE')
\p\g
create view  AppQHourView (ApplicationName, ResponseTime, QueueName, 
ObjectID, QmgrID, ObjectType, ApplicationID, TStamp) AS SELECT 
ApplicationCfg.ApplicationName, QueueDataHourView.Residency, 
QueueCfg.QueueName, ApplicationItems.ObjectID, 
ApplicationItems.QmgrID, ApplicationItems.ObjectType, 
ApplicationItems.ApplicationID, QueueDataHourView.TStamp FROM 
"mdbadmin". ApplicationCfg, "mdbadmin". ApplicationItems, "mdbadmin". 
QueueCfg, "mdbadmin". QueueDataHourView WHERE 
(ApplicationCfg.ApplicationID = ApplicationItems.ApplicationID and 
ApplicationItems.QmgrID = QueueDataHourView.QmgrID and 
ApplicationItems.ObjectID = QueueDataHourView.QueueID and 
QueueCfg.QmgrID = QueueDataHourView.QmgrID and QueueCfg.QueueID = 
QueueDataHourView.QueueID and ApplicationItems.ObjectType = 'QUEUE')
\p\g
create view  ChannelDataMonthView AS SELECT ChannelData.TStamp, 
ChannelData.ChannelID, ChannelData.QmgrID, ChannelData.IntvlType, 
ChannelData.IntvlDuration, ChannelData.MsgCount, 
ChannelData.BuffersRead, ChannelData.BuffersWrite, 
ChannelData.BytesRead, ChannelData.BytesWrite, ChannelData.IsSent FROM
"mdbadmin". ChannelData WHERE IntvlType='M'
\p\g
create view  ChannelDataDayView AS SELECT ChannelData.TStamp, 
ChannelData.ChannelID, ChannelData.QmgrID, ChannelData.IntvlType, 
ChannelData.IntvlDuration, ChannelData.MsgCount, 
ChannelData.BuffersRead, ChannelData.BuffersWrite, 
ChannelData.BytesRead, ChannelData.BytesWrite, ChannelData.IsSent FROM
"mdbadmin". ChannelData WHERE IntvlType='D'
\p\g
create view  ChannelDataHourView AS SELECT ChannelData.TStamp, 
ChannelData.ChannelID, ChannelData.QmgrID, ChannelData.IntvlType, 
ChannelData.IntvlDuration, ChannelData.MsgCount, 
ChannelData.BuffersRead, ChannelData.BuffersWrite, 
ChannelData.BytesRead, ChannelData.BytesWrite, ChannelData.IsSent FROM
"mdbadmin". ChannelData WHERE IntvlType='H'
\p\g
create view  ChannelDataMinuteView AS SELECT ChannelData.TStamp, 
ChannelData.ChannelID, ChannelData.QmgrID, ChannelData.IntvlType, 
ChannelData.IntvlDuration, ChannelData.MsgCount, 
ChannelData.BuffersRead, ChannelData.BuffersWrite, 
ChannelData.BytesRead, ChannelData.BytesWrite, ChannelData.IsSent FROM
"mdbadmin". ChannelData WHERE IntvlType='I'
\p\g
create view  AppRtMonthView (ApplicationName, ResponseTime, RouteName,
ObjectID, QmgrID, ObjectType, ApplicationID, TStamp) AS SELECT 
ApplicationCfg.ApplicationName, RouteDataMonthView.ResponseTime, 
RouteCfg.RouteName, ApplicationItems.ObjectID, 
ApplicationItems.QmgrID, ApplicationItems.ObjectType, 
ApplicationItems.ApplicationID, RouteDataMonthView.TStamp FROM 
"mdbadmin". ApplicationCfg, "mdbadmin". ApplicationItems, "mdbadmin". 
RouteCfg, "mdbadmin". RouteDataMonthView WHERE 
(ApplicationCfg.ApplicationID = ApplicationItems.ApplicationID and 
ApplicationItems.QmgrID = RouteDataMonthView.QmgrID and 
ApplicationItems.ObjectID = RouteDataMonthView.RouteID and 
RouteCfg.QmgrID = RouteDataMonthView.QmgrID and RouteCfg.RouteID = 
RouteDataMonthView.RouteID and ApplicationItems.ObjectType = 'ROUTE')
\p\g
create view  AppRtDayView (ApplicationName, ResponseTime, RouteName, 
ObjectID, QmgrID, ObjectType, ApplicationID, TStamp) AS SELECT 
ApplicationCfg.ApplicationName, RouteDataDayView.ResponseTime, 
RouteCfg.RouteName, ApplicationItems.ObjectID, 
ApplicationItems.QmgrID, ApplicationItems.ObjectType, 
ApplicationItems.ApplicationID, RouteDataDayView.TStamp FROM 
"mdbadmin". ApplicationCfg, "mdbadmin". ApplicationItems, "mdbadmin". 
RouteCfg, "mdbadmin". RouteDataDayView WHERE 
(ApplicationCfg.ApplicationID = ApplicationItems.ApplicationID and 
ApplicationItems.QmgrID = RouteDataDayView.QmgrID and 
ApplicationItems.ObjectID = RouteDataDayView.RouteID and 
RouteCfg.QmgrID = RouteDataDayView.QmgrID and RouteCfg.RouteID = 
RouteDataDayView.RouteID and ApplicationItems.ObjectType = 'ROUTE')
\p\g
create view  AppRtHourView (ApplicationName, ResponseTime, RouteName, 
ObjectID, QmgrID, ObjectType, ApplicationID, TStamp) AS SELECT 
ApplicationCfg.ApplicationName, RouteDataHourView.ResponseTime, 
RouteCfg.RouteName, ApplicationItems.ObjectID, 
ApplicationItems.QmgrID, ApplicationItems.ObjectType, 
ApplicationItems.ApplicationID, RouteDataHourView.TStamp FROM 
"mdbadmin". ApplicationCfg, "mdbadmin". ApplicationItems, "mdbadmin". 
RouteCfg, "mdbadmin". RouteDataHourView WHERE 
(ApplicationCfg.ApplicationID = ApplicationItems.ApplicationID and 
ApplicationItems.QmgrID = RouteDataHourView.QmgrID and 
ApplicationItems.ObjectID = RouteDataHourView.RouteID and 
RouteCfg.QmgrID = RouteDataHourView.QmgrID and RouteCfg.RouteID = 
RouteDataHourView.RouteID and ApplicationItems.ObjectType = 'ROUTE')
\p\g
create view  AppRtMinuteView (ApplicationName, ResponseTime, 
RouteName, ObjectID, QmgrID, ObjectType, ApplicationID, TStamp) AS 
SELECT ApplicationCfg.ApplicationName, 
RouteDataMinuteView.ResponseTime, RouteCfg.RouteName, 
ApplicationItems.ObjectID, ApplicationItems.QmgrID, 
ApplicationItems.ObjectType, ApplicationItems.ApplicationID, 
RouteDataMinuteView.TStamp FROM "mdbadmin". ApplicationCfg, "mdbadmin"
. ApplicationItems, "mdbadmin". RouteCfg, "mdbadmin". 
RouteDataMinuteView WHERE (ApplicationCfg.ApplicationID = 
ApplicationItems.ApplicationID and ApplicationItems.QmgrID = 
RouteDataMinuteView.QmgrID and ApplicationItems.ObjectID = 
RouteDataMinuteView.RouteID and RouteCfg.QmgrID = 
RouteDataMinuteView.QmgrID and RouteCfg.RouteID = 
RouteDataMinuteView.RouteID and ApplicationItems.ObjectType = 'ROUTE')
\p\g
create view  wvRouter AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtRouter r where m.uuid = r.uuid
\p\g
create view  wv_3COM AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wt_3COM r where m.uuid = r.uuid
\p\g
create view  wvCISCO AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtCISCO r where m.uuid = r.uuid
\p\g
create view  wvMultiNet AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtMultiNet r where m.uuid = r.uuid
\p\g
create view  wvFoundry AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtFoundry r where m.uuid = r.uuid
\p\g
create view  wvHub AS Select m.name,m.label,m.address,m.address_type,
m.class_name,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtHub r where m.uuid = r.uuid
\p\g
create view  wvUBEMPower AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtUBEMPower r where m.uuid = r.uuid
\p\g
create view  wvAccessStax AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtAccessStax r where m.uuid = r.uuid
\p\g
create view  wvCabletron AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtCabletron r where m.uuid = r.uuid
\p\g
create view  wvChipcom AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtChipcom r where m.uuid = r.uuid
\p\g
create view  wvETSMIM AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtETSMIM r where m.uuid = r.uuid
\p\g
create view  wvGatorStar AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtGatorStar r where m.uuid = r.uuid
\p\g
create view  wvIRM2SNMP AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtIRM2SNMP r where m.uuid = r.uuid
\p\g
create view  wvMicom AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtMicom r where m.uuid = r.uuid
\p\g
create view  wvNetWorth AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtNetWorth r where m.uuid = r.uuid
\p\g
create view  wvNovellHub AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtNovellHub r where m.uuid = r.uuid
\p\g
create view  wvSynOptics AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtSynOptics r where m.uuid = r.uuid
\p\g
create view  wvTelebit AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtTelebit r where m.uuid = r.uuid
\p\g
create view  wvVCP_1000 AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtVCP_1000 r where m.uuid = r.uuid
\p\g
create view  wvVitalink AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtVitalink r where m.uuid = r.uuid
\p\g
create view  wvBridge AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtBridge r where m.uuid = r.uuid
\p\g
create view  wvSwitch AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtSwitch r where m.uuid = r.uuid
\p\g
create view  wvCISCO_SWITCH AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'CISCO_SWITCH'
\p\g
create view  wvHost AS Select m.name,m.label,m.address,m.address_type,
m.class_name,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtHost r where m.uuid = r.uuid
\p\g
create view  wvUnixWare AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtUnixWare r where m.uuid = r.uuid
\p\g
create view  wvSequent_Server AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtSequent_Server r where m.uuid = r.uuid
\p\g
create view  wvBull AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtBull r where m.uuid = r.uuid
\p\g
create view  wvLinux AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtLinux r where m.uuid = r.uuid
\p\g
create view  wvDG_UX AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtDG_UX r where m.uuid = r.uuid
\p\g
create view  wvFUJIUxp AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtFUJIUxp r where m.uuid = r.uuid
\p\g
create view  wvHPServer AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtHPServer r where m.uuid = r.uuid
\p\g
create view  wvHPUnix AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtHPUnix r where m.uuid = r.uuid
\p\g
create view  wvIBM3090 AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtIBM3090 r where m.uuid = r.uuid
\p\g
create view  wvRISC6000 AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtRISC6000 r where m.uuid = r.uuid
\p\g
create view  wvICLUnix AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtICLUnix r where m.uuid = r.uuid
\p\g
create view  wvNCRUnix AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtNCRUnix r where m.uuid = r.uuid
\p\g
create view  wvNovell AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtNovell r where m.uuid = r.uuid
\p\g
create view  wvSiemenUX AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtSiemenUX r where m.uuid = r.uuid
\p\g
create view  wvSilicon AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtSilicon r where m.uuid = r.uuid
\p\g
create view  wvSolaris AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtSolaris r where m.uuid = r.uuid
\p\g
create view  wvUnisys AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtUnisys r where m.uuid = r.uuid
\p\g
create view  wvInformix AS Select * from "mdbadmin". tng_managedobject
where class_name = 'Informix'
\p\g
create view  wvIngres AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'Ingres'
\p\g
create view  wvMSSQLServer AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'MSSQLServer'
\p\g
create view  wvOracle AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'Oracle'
\p\g
create view  wvSybase AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'Sybase'
\p\g
create view  wvDevice_Tape AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape'
\p\g
create view  wvDevice_Tape_4MM AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape_4MM'
\p\g
create view  wvDevice_Tape_8MM AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape_8MM'
\p\g
create view  wvDevice_Tape_REEL AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape_REEL'
\p\g
create view  wvDevice_Tape_CART AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape_CART'
\p\g
create view  wvDevice_Tape_QIC AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape_QIC'
\p\g
create view  wvDevice_Tape_DAT AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape_DAT'
\p\g
create view  wvDevice_Optical AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Optical'
\p\g
create view  wvDevice_Optical_Floptical AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Optical_Floptical'
\p\g
create view  wvDevice_Optical_CDR AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Optical_CDR'
\p\g
create view  wvDevice_Optical_WORM AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Optical_WORM'
\p\g
create view  wvDevice_Optical_CDROM AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Optical_CDROM'
\p\g
create view  wvDevice_Disk AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Disk'
\p\g
create view  wvDevice_Disk_350Diskette AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Disk_350Diskette'
\p\g
create view  wvDevice_Disk_525Diskette AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Disk_525Diskette'
\p\g
create view  wvDevice_Disk_IDE AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.weight,m.class_name,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtDevice_Disk_IDE r where m.uuid = 
r.uuid
\p\g
create view  wvDevice_Disk_SCSI AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.weight,m.class_name,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtDevice_Disk_SCSI r where m.uuid = 
r.uuid
\p\g
create view  wvLargeCity AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'LargeCity'
\p\g
create view  wvMediumCity AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'MediumCity'
\p\g
create view  wvSmallCity AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SmallCity'
\p\g
create view  wvClassical_Medium_Skyscraper AS Select * from "mdbadmin"
. tng_managedobject where class_name = 'Classical_Medium_Skyscraper'
\p\g
create view  wvClassical_Tall_Skyscraper AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Classical_Tall_Skyscraper'
\p\g
create view  wvContemporary_Low_Skyscraper AS Select * from "mdbadmin"
. tng_managedobject where class_name = 'Contemporary_Low_Skyscraper'
\p\g
create view  wvContemporary_Tall_Skyscraper AS Select * from 
"mdbadmin". tng_managedobject where class_name = 'Contemporary_Tall_Sk
yscraper'
\p\g
create view  wvContemporary_Medium_Skyscraper AS Select * from 
"mdbadmin". tng_managedobject where class_name = 'Contemporary_Medium_
Skyscraper'
\p\g
create view  wvLarge_Factory AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Large_Factory'
\p\g
create view  wvLarge_Warehouse AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Large_Warehouse'
\p\g
create view  wvMedium_Warehouse AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Medium_Warehouse'
\p\g
create view  wvSmall_Warehouse AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Small_Warehouse'
\p\g
create view  wvWhite_Office_Park AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'White_Office_Park'
\p\g
create view  wvGray_Office_Park AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Gray_Office_Park'
\p\g
create view  wvLarge_Brownstone AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Large_Brownstone'
\p\g
create view  wvMedium_Brownstone AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Medium_Brownstone'
\p\g
create view  wvSmall_Brownstone AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Small_Brownstone'
\p\g
create view  wvWorkstation AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtWorkstation r where m.uuid = r.uuid
\p\g
create view  wvXterm AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtXterm r where m.uuid = r.uuid
\p\g
create view  wvAsante AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtAsante r where m.uuid = r.uuid
\p\g
create view  wvCmuTek AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtCmuTek r where m.uuid = r.uuid
\p\g
create view  wvDECSystem AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtDECSystem r where m.uuid = r.uuid
\p\g
create view  wvICSSNMP AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtICSSNMP r where m.uuid = r.uuid
\p\g
create view  wvInterActive AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtInterActive r where m.uuid = r.uuid
\p\g
create view  wvMacintosh AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtMacintosh r where m.uuid = r.uuid
\p\g
create view  wvNetGeneral AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtNetGeneral r where m.uuid = r.uuid
\p\g
create view  wvNetSNMP AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtNetSNMP r where m.uuid = r.uuid
\p\g
create view  wvNGSniffer AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtNGSniffer r where m.uuid = r.uuid
\p\g
create view  wvPCNIU AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtPCNIU r where m.uuid = r.uuid
\p\g
create view  wvSamsung AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtSamsung r where m.uuid = r.uuid
\p\g
create view  wvSCOUnix AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtSCOUnix r where m.uuid = r.uuid
\p\g
create view  wvSunOS AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtSunOS r where m.uuid = r.uuid
\p\g
create view  wvUBNIU AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtUBNIU r where m.uuid = r.uuid
\p\g
create view  wvWindowsNT AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindowsNT r where m.uuid = r.uuid
\p\g
create view  wvManagedPC AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtManagedPC r where m.uuid = r.uuid
\p\g
create view  wvWindowsNT_ManagedPC AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'WindowsNT_ManagedPC'
\p\g
create view  wvWindows9x_ManagedPC AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Windows9x_ManagedPC'
\p\g
create view  wvWindowsNT_Server AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindowsNT_Server r where m.uuid = r.uuid
\p\g
create view  wvWindows2000 AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindows2000 r where m.uuid = r.uuid
\p\g
create view  wvWindows2000_Server AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindows2000_Server r where m.uuid = r.uuid
\p\g
create view  wvWindowsXP AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindowsXP r where m.uuid = r.uuid
\p\g
create view  wvWindows_NetServer AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindows_NetServer r where m.uuid = r.uuid
\p\g
create view  wvNCD17c AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'NCD17c'
\p\g
create view  wvNCR_Xterm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'NCR_Xterm'
\p\g
create view  wvSUN AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'SUN'
\p\g
create view  wvPrinters AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtPrinters r where m.uuid = r.uuid
\p\g
create view  wvHP_Printer AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtHP_Printer r where m.uuid = r.uuid
\p\g
create view  wvLaserPrinter AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtLaserPrinter r where m.uuid = 
r.uuid
\p\g
create view  wvProbe AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtProbe r where m.uuid = r.uuid
\p\g
create view  wvRMON_Probe AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'RMON_Probe'
\p\g
create view  wvLanProbe AS Select * from "mdbadmin". tng_managedobject
where class_name = 'LanProbe'
\p\g
create view  wvOS2 AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtOS2 r where m.uuid = r.uuid
\p\g
create view  wvWindows9x AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindows9x r where m.uuid = r.uuid
\p\g
create view  wvAS400 AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtAS400 r where m.uuid = r.uuid
\p\g
create view  wvMulti_Port AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtMulti_Port r where m.uuid = r.uuid
\p\g
create view  wvDECHub AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtDECHub r where m.uuid = r.uuid
\p\g
create view  wvDECBridge AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtDECBridge r where m.uuid = r.uuid
\p\g
create view  wvDECRouter AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtDECRouter r where m.uuid = r.uuid
\p\g
create view  wvHPHub AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtHPHub r where m.uuid = r.uuid
\p\g
create view  wvHPBridge AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtHPBridge r where m.uuid = r.uuid
\p\g
create view  wvWellfleet AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWellfleet r where m.uuid = r.uuid
\p\g
create view  wvNetJet_PrinterServer AS Select m.name,m.label,
m.address,m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtNetJet_PrinterServer r where m.uuid
= r.uuid
\p\g
create view  wvNetQue_PrinterServer AS Select m.name,m.label,
m.address,m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtNetQue_PrinterServer r where m.uuid
= r.uuid
\p\g
create view  wvGenericPC AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtGenericPC r where m.uuid = r.uuid
\p\g
create view  wvNovell_Probe AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Novell_Probe'
\p\g
create view  wvUPS AS Select m.name,m.label,m.address,m.address_type,
m.class_name,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtUPS r where m.uuid = r.uuid
\p\g
create view  wvAPC_UPS AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtAPC_UPS r where m.uuid = r.uuid
\p\g
create view  wvOtherDevices AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtOtherDevices r where m.uuid = r.uuid
\p\g
create view  wvIBM_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'IBM_Device'
\p\g
create view  wvHP_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'HP_Device'
\p\g
create view  wvXylogics_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Xylogics_Device'
\p\g
create view  wvIntergraph_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Intergraph_Device'
\p\g
create view  wvVitalink_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Vitalink_Device'
\p\g
create view  wvXyplex_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Xyplex_Device'
\p\g
create view  wvSUN_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SUN_Device'
\p\g
create view  wv_3COM_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = '_3COM_Device'
\p\g
create view  wvSynOptics_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SynOptics_Device'
\p\g
create view  wvApple_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Apple_Device'
\p\g
create view  wvATT_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ATT_Device'
\p\g
create view  wvUB_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'UB_Device'
\p\g
create view  wvLANManager_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'LANManager_Device'
\p\g
create view  wvNCD_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'NCD_Device'
\p\g
create view  wvHitachi_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Hitachi_Device'
\p\g
create view  wvNEC_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'NEC_Device'
\p\g
create view  wvTektronix_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Tektronix_Device'
\p\g
create view  wvBanyan_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Banyan_Device'
\p\g
create view  wvTandem_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Tandem_Device'
\p\g
create view  wvIntel_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Intel_Device'
\p\g
create view  wvCA_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'CA_Device'
\p\g
create view  wvXerox_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Xerox_Device'
\p\g
create view  wvOracle_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Oracle_Device'
\p\g
create view  wvNovell_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Novell_Device'
\p\g
create view  wvPerformance AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtPerformance r where m.uuid = r.uuid
\p\g
create view  wvPerformanceTrend AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtPerformanceTrend r where m.uuid = 
r.uuid
\p\g
create view  wvPerformanceScope AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'PerformanceScope'
\p\g
create view  wvPerformanceConfig AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'PerformanceConfig'
\p\g
create view  wvChargeback AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtChargeback r where m.uuid = r.uuid
\p\g
create view  wvIPX_Network AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'IPX_Network'
\p\g
create view  wvIPX_Domain AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'IPX_Domain'
\p\g
create view  wvIPX_Bus AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'IPX_Bus'
\p\g
create view  wvIPX_PrintServer AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtIPX_PrintServer r where m.uuid = 
r.uuid
\p\g
create view  wvIPX_Host AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.date_ins,m.date_modify,m.code_page,m.admin_status,
m.DSM_Server,m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtIPX_Host r where m.uuid = r.uuid
\p\g
create view  wvIPX_Generic_Interface AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtIPX_Generic_Interface r where m.uuid = r.uuid
\p\g
create view  wvMulti_Protocol_Host AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Multi_Protocol_Host'
\p\g
create view  wvWindows AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtWindows r where m.uuid = r.uuid
\p\g
create view  wvWBEM AS Select m.name,m.label,m.address,m.address_type,
m.class_name,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtWBEM r where m.uuid = r.uuid
\p\g
create view  wvSynOptics_Bridge AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtSynOptics_Bridge r where m.uuid = 
r.uuid
\p\g
create view  wvSynOptics_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SynOptics_Switch'
\p\g
create view  wv_3COM_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = '_3COM_Switch'
\p\g
create view  wvNetScout AS Select * from "mdbadmin". tng_managedobject
where class_name = 'NetScout'
\p\g
create view  wvTandem AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtTandem r where m.uuid = r.uuid
\p\g
create view  wvCPU AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'CPU'
\p\g
create view  wvIntel_PSN AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Intel_PSN'
\p\g
create view  wvAggregate_CPU AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Aggregate_CPU'
\p\g
create view  wvCISCO_LocalDirector AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'CISCO_LocalDirector'
\p\g
create view  wvBayBridge AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtBayBridge r where m.uuid = r.uuid
\p\g
create view  wvBayHub AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtBayHub r where m.uuid = r.uuid
\p\g
create view  wvIBM AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtIBM r where m.uuid = r.uuid
\p\g
create view  wvBay_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Bay_Switch'
\p\g
create view  wvCabletron_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Cabletron_Switch'
\p\g
create view  wvExtreme_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Extreme_Switch'
\p\g
create view  wvFore_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Fore_Switch'
\p\g
create view  wvFoundry_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Foundry_Switch'
\p\g
create view  wvHP_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'HP_Switch'
\p\g
create view  wvNBase_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'NBase_Switch'
\p\g
create view  wvBay_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Bay_Device'
\p\g
create view  wvMultiNet_Device AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'MultiNet_Device'
\p\g
create view  wvXylan_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Xylan_Switch'
\p\g
create view  wvOpenVMS AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtOpenVMS r where m.uuid = r.uuid
\p\g
create view  wvDevice_TapeLibrary AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.weight,m.class_name,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtDevice_TapeLibrary r where m.uuid =
r.uuid
\p\g
create view  wvDevice_Tape_DLT AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Device_Tape_DLT'
\p\g
create view  wvAcer_Switch AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Acer_Switch'
\p\g
create view  wvUnicenter_OpenVMS AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtUnicenter_OpenVMS r where m.uuid = r.uuid
\p\g
create view  wvOpenVMS_CommonMgr AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_CommonMgr'
\p\g
create view  wvUnicenter_OpenVMS_Workload AS Select * from "mdbadmin".
tng_managedobject where class_name = 'Unicenter_OpenVMS_Workload'
\p\g
create view  wvUnicenter_OpenVMS_Performance AS Select * from 
"mdbadmin". tng_managedobject where class_name = 'Unicenter_OpenVMS_Pe
rformance'
\p\g
create view  wvUnicenter_OpenVMS_Console AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Unicenter_OpenVMS_Console'
\p\g
create view  wvOpenVMS_System_Monitor AS Select m.name,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.label,m.class_name,
m.alarmset_name,m.autoarrange_type,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtOpenVMS_System_Monitor r where 
m.uuid = r.uuid
\p\g
create view  wvUnicenter_OpenVMSManagedObject AS Select m.name,
m.label,m.address,m.address_type,m.class_name,m.status_no,m.hidden,
m.propagate_status,m.severity,m.posted,m.acknowledge,m.alarmset_name,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtUnicenter_OpenVMSManagedObject r 
where m.uuid = r.uuid
\p\g
create view  wvOpenVMS_ENF AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_ENF'
\p\g
create view  wvOpenVMS_CCI AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_CCI'
\p\g
create view  wvOpenVMS_EventManagementDaemon AS Select * from 
"mdbadmin". tng_managedobject where class_name = 'OpenVMS_EventManagem
entDaemon'
\p\g
create view  wvOpenVMS_WorkloadMgr AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_WorkloadMgr'
\p\g
create view  wvOpenVMS_WorkloadAgent AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_WorkloadAgent'
\p\g
create view  wvOpenVMS_WorkloadAgentX AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_WorkloadAgentX'
\p\g
create view  wvWorkload_EventDaemon AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Workload_EventDaemon'
\p\g
create view  wvOpenVMS_JobflowDaemon AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_JobflowDaemon'
\p\g
create view  wvOpenVMS_SystemMonitor AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_SystemMonitor'
\p\g
create view  wvOpenVMS_EventLinksDaemon AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_EventLinksDaemon'
\p\g
create view  wvOpenVMS_ConsoleMgr AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_ConsoleMgr'
\p\g
create view  wvOpenVMS_ConsoleEventDaemon AS Select * from "mdbadmin".
tng_managedobject where class_name = 'OpenVMS_ConsoleEventDaemon'
\p\g
create view  wvOpenVMS_PerformanceMgr AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_PerformanceMgr'
\p\g
create view  wvOpenVMS_PerformanceCubeDaemon AS Select * from 
"mdbadmin". tng_managedobject where class_name = 'OpenVMS_PerformanceC
ubeDaemon'
\p\g
create view  wvOpenVMS_PerformanceAgent AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_PerformanceAgent'
\p\g
create view  wvOpenVMS_GatewayDaemon AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OpenVMS_GatewayDaemon'
\p\g
create view  wvUnicenterMessageDaemon AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'UnicenterMessageDaemon'
\p\g
create view  wvUnicenterFileTransferDaemon AS Select * from "mdbadmin"
. tng_managedobject where class_name = 'UnicenterFileTransferDaemon'
\p\g
create view  wvMobileDevice AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtMobileDevice r where m.uuid = r.uuid
\p\g
create view  wvPocketPC AS Select * from "mdbadmin". tng_managedobject
where class_name = 'PocketPC'
\p\g
create view  wvPalm AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'Palm'
\p\g
create view  wvZone AS Select m.name,m.label,m.address,m.address_type,
m.class_name,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtZone r where m.uuid = r.uuid
\p\g
create view  wvZoneSet AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtZoneSet r where m.uuid = r.uuid
\p\g
create view  wvTapeSubsystem AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtTapeSubsystem r where m.uuid = r.uuid
\p\g
create view  wvStorageSubsystem AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtStorageSubsystem r where m.uuid = r.uuid
\p\g
create view  wvCiprico AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtCiprico r where m.uuid = r.uuid
\p\g
create view  wvClariion_DAE AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtClariion_DAE r where m.uuid = 
r.uuid
\p\g
create view  wvClariion_DPE AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtClariion_DPE r where m.uuid = 
r.uuid
\p\g
create view  wvEMC AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'EMC'
\p\g
create view  wvHDS AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'HDS'
\p\g
create view  wvQLogic_Switch AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.address_type,
m.class_name,m.alarmset_name,m.weight,m.interface_type,
m.ip_address_hex,m.mac_address,m.subnet_mask,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtQLogic_Switch r where m.uuid = 
r.uuid
\p\g
create view  wvPV705N AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtPV705N r where m.uuid = r.uuid
\p\g
create view  wvXIOtech AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.weight,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtXIOtech r where m.uuid = r.uuid
\p\g
create view  wvLUN AS Select m.name,m.label,m.address,m.address_type,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.weight,m.class_name,r.* from "mdbadmin". 
tng_managedobject m, "mdbadmin". wtLUN r where m.uuid = r.uuid
\p\g
create view  wvMcData_EFCManager AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'McData_EFCManager'
\p\g
create view  wvBattery AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtBattery r where m.uuid = r.uuid
\p\g
create view  wvUnix AS Select m.name,m.label,m.address,m.status_no,
m.hidden,m.propagate_status,m.severity,m.posted,m.acknowledge,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.address_type,m.class_name,m.alarmset_name,
m.autoarrange_type,m.weight,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtUnix r where m.uuid = r.uuid
\p\g
create view  wvBillboard AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtBillboard r where m.uuid = r.uuid
\p\g
create view  wvDomain AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'Domain'
\p\g
create view  wvAgent AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtAgent r where m.uuid = r.uuid
\p\g
create view  wvAppResponse AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'AppResponse'
\p\g
create view  wvAWsadmin AS Select * from "mdbadmin". tng_managedobject
where class_name = 'AWsadmin'
\p\g
create view  wvcaiDb2mvsAgt AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiDb2mvsAgt'
\p\g
create view  wvcaiDb2mvsAgtInst AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiDb2mvsAgtInst'
\p\g
create view  wvCaiIngA2 AS Select * from "mdbadmin". tng_managedobject
where class_name = 'CaiIngA2'
\p\g
create view  wvCaiIngA2Inst AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'CaiIngA2Inst'
\p\g
create view  wvcaiLogA2 AS Select * from "mdbadmin". tng_managedobject
where class_name = 'caiLogA2'
\p\g
create view  wvcaiNt4Os AS Select * from "mdbadmin". tng_managedobject
where class_name = 'caiNt4Os'
\p\g
create view  wvcaiOraA2 AS Select * from "mdbadmin". tng_managedobject
where class_name = 'caiOraA2'
\p\g
create view  wvcaiOraA2Inst AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiOraA2Inst'
\p\g
create view  wvcaiSybA2 AS Select * from "mdbadmin". tng_managedobject
where class_name = 'caiSybA2'
\p\g
create view  wvcaiSybA2Inst AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiSybA2Inst'
\p\g
create view  wvcaiSysAgtCics AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiSysAgtCics'
\p\g
create view  wvCicsInstance AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'CicsInstance'
\p\g
create view  wvcaiSysAgtHDS AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiSysAgtHDS'
\p\g
create view  wvcaiSysAgtMqs AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiSysAgtMqs'
\p\g
create view  wvMqsInstance AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqsInstance r where m.uuid = r.uuid
\p\g
create view  wvMqMgr AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqMgr r where m.uuid = r.uuid
\p\g
create view  wvMqMgrInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqMgrInst r where m.uuid = r.uuid
\p\g
create view  wvMqQueue AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqQueue r where m.uuid = r.uuid
\p\g
create view  wvMqQueueInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqQueueInst r where m.uuid = r.uuid
\p\g
create view  wvMqDLQ AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqDLQ r where m.uuid = r.uuid
\p\g
create view  wvMqDLQInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqDLQInst r where m.uuid = r.uuid
\p\g
create view  wvMqRemoteQ AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqRemoteQ r where m.uuid = r.uuid
\p\g
create view  wvMqRemoteQInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqRemoteQInst r where m.uuid = r.uuid
\p\g
create view  wvMqAliasQ AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqAliasQ r where m.uuid = r.uuid
\p\g
create view  wvMqAliasQInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqAliasQInst r where m.uuid = r.uuid
\p\g
create view  wvMqModelQ AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqModelQ r where m.uuid = r.uuid
\p\g
create view  wvMqModelQInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqModelQInst r where m.uuid = r.uuid
\p\g
create view  wvMqChannel AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqChannel r where m.uuid = r.uuid
\p\g
create view  wvMqChannelInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqChannelInst r where m.uuid = r.uuid
\p\g
create view  wvMqProcess AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqProcess r where m.uuid = r.uuid
\p\g
create view  wvMqProcessInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqProcessInst r where m.uuid = r.uuid
\p\g
create view  wvMqPSID AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqPSID r where m.uuid = r.uuid
\p\g
create view  wvMqPSIDInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqPSIDInst r where m.uuid = r.uuid
\p\g
create view  wvMqChanInit AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqChanInit r where m.uuid = r.uuid
\p\g
create view  wvMqChanInitInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtMqChanInitInst r where m.uuid = r.uuid
\p\g
create view  wvcaiSysAgtMvs AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'caiSysAgtMvs'
\p\g
create view  wvMvsInstance AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'MvsInstance'
\p\g
create view  wvCaiUxOs AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'CaiUxOs'
\p\g
create view  wvcaiW2kOs AS Select * from "mdbadmin". tng_managedobject
where class_name = 'caiW2kOs'
\p\g
create view  wvCISCO_Manager AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'CISCO_Manager'
\p\g
create view  wvDatacomAgt AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'DatacomAgt'
\p\g
create view  wvDatacomAgtInst AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtDatacomAgtInst r where m.uuid = r.uuid
\p\g
create view  wvdb2Agent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'db2Agent'
\p\g
create view  wvdb2Manager AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'db2Manager'
\p\g
create view  wvdb2AgentDB2Status AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'db2AgentDB2Status'
\p\g
create view  wvdb2ManagerGenDBMemoryStatus AS Select * from "mdbadmin"
. tng_managedobject where class_name = 'db2ManagerGenDBMemoryStatus'
\p\g
create view  wvdb2ManagerGenSortHeap AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'db2ManagerGenSortHeap'
\p\g
create view  wvDBMonitors AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'DBMonitors'
\p\g
create view  wvBackupStatus AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'BackupStatus'
\p\g
create view  wvdatabaseSQLTable AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'databaseSQLTable'
\p\g
create view  wvdatabaseCounting AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'databaseCounting'
\p\g
create view  wvdatabaseSort AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'databaseSort'
\p\g
create view  wvDBCacheStatus AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'DBCacheStatus'
\p\g
create view  wvcacheOverFlow AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'cacheOverFlow'
\p\g
create view  wvcacheHeapFull AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'cacheHeapFull'
\p\g
create view  wvdatabaseHeapLog AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'databaseHeapLog'
\p\g
create view  wvmaxHeapUsed AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'maxHeapUsed'
\p\g
create view  wvsecondaryLog AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'secondaryLog'
\p\g
create view  wvmaxTotalLog AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'maxTotalLog'
\p\g
create view  wvsecondaryLogAlloc AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'secondaryLogAlloc'
\p\g
create view  wvlocking AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'locking'
\p\g
create view  wvlockCurrentHeld AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'lockCurrentHeld'
\p\g
create view  wvlockMemStatus AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'lockMemStatus'
\p\g
create view  wvlockEscStatus AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'lockEscStatus'
\p\g
create view  wvlockXEscStatus AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'lockXEscStatus'
\p\g
create view  wvlockTimeOut AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'lockTimeOut'
\p\g
create view  wvapplLock AS Select * from "mdbadmin". tng_managedobject
where class_name = 'applLock'
\p\g
create view  wvintegrity AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'integrity'
\p\g
create view  wvAPMonitors AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'APMonitors'
\p\g
create view  wvApplStatus AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplStatus'
\p\g
create view  wvApplSortStatus AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplSortStatus'
\p\g
create view  wvApplSQLTable AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplSQLTable'
\p\g
create view  wvApplCache AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplCache'
\p\g
create view  wvApplCacheOf AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplCacheOf'
\p\g
create view  wvApplCacheHf AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplCacheHf'
\p\g
create view  wvApplCursor AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplCursor'
\p\g
create view  wvApplCursorBc AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplCursorBc'
\p\g
create view  wvApplCursorRb AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplCursorRb'
\p\g
create view  wvApplLocks AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplLocks'
\p\g
create view  wvApplLocksEsc AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplLocksEsc'
\p\g
create view  wvApplLocksXEsc AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplLocksXEsc'
\p\g
create view  wvApplDeadLock AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplDeadLock'
\p\g
create view  wvApplLockTimeOut AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ApplLockTimeOut'
\p\g
create view  wvTSMonitors AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'TSMonitors'
\p\g
create view  wvTSBufferWrites AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'TSBufferWrites'
\p\g
create view  wvTSBufferIndexWrites AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'TSBufferIndexWrites'
\p\g
create view  wvTSioWrittenDirect AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'TSioWrittenDirect'
\p\g
create view  wvTSioDirectWriteREQ AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'TSioDirectWriteREQ'
\p\g
create view  wvTSPhysicalSpace AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'TSPhysicalSpace'
\p\g
create view  wvdceStatAgent AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'dceStatAgent'
\p\g
create view  wvcellAgent AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'cellAgent'
\p\g
create view  wvHpeNgent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'HpeNgent'
\p\g
create view  wvHpxAgent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'HpxAgent'
\p\g
create view  wvIdmsAgent AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'IdmsAgent'
\p\g
create view  wvIdmsInstance AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtIdmsInstance r where m.uuid = r.uuid
\p\g
create view  wvImxAgent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'ImxAgent'
\p\g
create view  wvImxAgentInst AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ImxAgentInst'
\p\g
create view  wvIngAgent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'IngAgent'
\p\g
create view  wvIP AS Select * from "mdbadmin". tng_managedobject where
class_name = 'IP'
\p\g
create view  wvLogAgentNT_v30 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'LogAgentNT_v30'
\p\g
create view  wvLogAgent_v30 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'LogAgent_v30'
\p\g
create view  wvMib2 AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'Mib2'
\p\g
create view  wvmkAgent AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtmkAgent r where m.uuid = r.uuid
\p\g
create view  wvmkLateCustPay AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'mkLateCustPay'
\p\g
create view  wvmkExpInv AS Select * from "mdbadmin". tng_managedobject
where class_name = 'mkExpInv'
\p\g
create view  wvmkLateProdOrd AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'mkLateProdOrd'
\p\g
create view  wvmkLateVendShip AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'mkLateVendShip'
\p\g
create view  wvmkLateCustShip AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'mkLateCustShip'
\p\g
create view  wvmkInvExp AS Select * from "mdbadmin". tng_managedobject
where class_name = 'mkInvExp'
\p\g
create view  wvMmoAgent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'MmoAgent'
\p\g
create view  wvMmoAgentInst AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'MmoAgentInst'
\p\g
create view  wvMmsAgent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'MmsAgent'
\p\g
create view  wvMmsAgentInst AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'MmsAgentInst'
\p\g
create view  wvOraAgtVMS AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OraAgtVMS'
\p\g
create view  wvOsAgent_v30 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OsAgent_v30'
\p\g
create view  wvPing AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'Ping'
\p\g
create view  wvPingIP AS Select * from "mdbadmin". tng_managedobject 
where class_name = 'PingIP'
\p\g
create view  wvpplAgent AS Select * from "mdbadmin". tng_managedobject
where class_name = 'pplAgent'
\p\g
create view  wvpplInstance AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'pplInstance'
\p\g
create view  wvProAgent_v30 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ProAgent_v30'
\p\g
create view  wvsapAgent AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtsapAgent r where m.uuid = r.uuid
\p\g
create view  wvMMsapAgent AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'MMsapAgent'
\p\g
create view  wvSapInstance AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.autoarrange_type,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.alarmset_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtSapInstance r where m.uuid = r.uuid
\p\g
create view  wvSQLServerAgt AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SQLServerAgt'
\p\g
create view  wvSybaseAgt AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SybaseAgt'
\p\g
create view  wvSysAgtAS400 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SysAgtAS400'
\p\g
create view  wvSysAgtNetWare AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SysAgtNetWare'
\p\g
create view  wvSysAgtNT AS Select * from "mdbadmin". tng_managedobject
where class_name = 'SysAgtNT'
\p\g
create view  wvSysAgtVMS AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SysAgtVMS'
\p\g
create view  wvSysAgtWin9x AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'SysAgtWin9x'
\p\g
create view  wvProAgentTand_v30 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'ProAgentTand_v30'
\p\g
create view  wvOsAgentTand_v30 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'OsAgentTand_v30'
\p\g
create view  wvLogAgentTand_v30 AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'LogAgentTand_v30'
\p\g
create view  RBS_CHANGE_VIEW ("COLLECT_ID","timestamp","SEGMENT_NAME",
"BLOCKS_ALLOC","EXTENTS_ALLOC") AS select a.collect_id, c.end_time 
"timestamp", segment_name, blocks_alloc, extents_alloc from "mdbadmin"
. rbs a, "mdbadmin". collect c where a.collect_id = c.collect_id
\p\g
create view  ADDED_USERS_VIEW_G1 ("COMPARE_ID","USERNAME") AS SELECT 
ci.compare_id, B.USERNAME "USERNAME" FROM "mdbadmin". COMMON_DICT_VIEW
B, "mdbadmin". COMPARE CI WHERE CI.LAST_COLLECT_ID = B.COLLECT_ID 
group by B.USERNAME,ci.compare_id
\p\g
create view  INSTANCE_PARAM_VIEW ("COLLECT_ID","ORACLE_SID",
"PARAM_NAME","PARAM_TYPE","PARAM_VALUE") AS SELECT S.COLLECT_ID 
COLLECT_ID, S.ORACLE_SID ORACLE_SID, SP.PARAM_NAME PARAM_NAME, 
SP.PARAM_TYPE PARAM_TYPE, SP.PARAM_VALUE PARAM_VALUE FROM "mdbadmin". 
SID S, "mdbadmin". SID_PARAM SP WHERE S.SID_ID = SP.SID_ID
\p\g
create view  MASTER_TABLESPACE_DIFF_VIEW ( COMPARE_ID, ORACLE_SID_A, 
TABLESPACE_NAME_A, FILE_NAME_A, SUM_BLOCKS_A, ORACLE_SID_B, 
TABLESPACE_NAME_B, FILE_NAME_B, SUM_BLOCKS_B, USED_SPACE_DIFF ) AS 
SELECT COMPARE_ID, ORACLE_SID_A, TABLESPACE_NAME_A, FILE_NAME_A, 
Sum_Blocks_A, ORACLE_SID_B, TABLESPACE_NAME_B, FILE_NAME_B, 
Sum_Blocks_B, Used_space_diff FROM "mdbadmin". TABLESPACE_DIFF_VIEW 
WHERE COMPARE_ID IS NOT NULL
\p\g
create view  LOB_DIFF_VIEW ("COMPARE_ID","OBJECT_NAME","USERNAME",
"TABLESPACE_NAME","CHUNK_BYTES_A","COLUMN_NAME_A","CHUNK_BYTES_B",
"COLUMN_NAME_B") AS SELECT CI.COMPARE_ID, LA.OBJECT_NAME OBJECT_NAME, 
LA.USERNAME USERNAME, LA.TABLESPACE_NAME, LA.CHUNK_BYTES 
CHUNK_BYTES_A, LA.COLUMN_NAME COLUMN_NAME_A, LB.CHUNK_BYTES 
CHUNK_BYTES_B, LB.COLUMN_NAME COLUMN_NAME_B FROM "mdbadmin". COMPARE 
CI, "mdbadmin". LOB_VIEW LA, "mdbadmin". LOB_VIEW LB WHERE 
LA.COLLECT_ID = CI.FIRST_COLLECT_ID AND LB.COLLECT_ID = 
CI.LAST_COLLECT_ID AND LA.OBJECT_NAME = LB.OBJECT_NAME AND LA.USERNAME
= LB.USERNAME
\p\g
create view  MASTER_USER_DIFF_VIEW ( COMPARE_ID, USERNAME, 
DEFAULT_TABLESPACE_A, TEMP_TABLESPACE_A, NBR_TABLE_A, NBR_BTREE_A, 
NBR_CLUSTER_A, NBR_VIEW_A, TOTAL_PROCEDURES_A, DEFAULT_TABLESPACE_B, 
TEMP_TABLESPACE_B, NBR_TABLE_B, NBR_BTREE_B, NBR_CLUSTER_B, 
NBR_VIEW_B, TOTAL_PROCEDURES_B ) AS SELECT COMPARE_ID, USERNAME, 
Default_Tablespace_A, TEMP_Tablespace_A, NBR_TABLE_A, NBR_BTREE_A, 
NBR_CLUSTER_A, NBR_VIEW_A, total_procedures_A, Default_Tablespace_B, 
TEMP_Tablespace_B, NBR_TABLE_B, NBR_BTREE_B, NBR_CLUSTER_B, 
NBR_VIEW_B, total_procedures_B FROM "mdbadmin". USER_DIFF_VIEW WHERE 
COMPARE_ID IS NOT NULL
\p\g
create view  DAYS_TILL_QUOTA_USED_VIEW_G_O ("COMPARE_ID","NBR_OBJECTS"
,"TABLESPACE_NAME","MAX_BYTES","USERNAME","BLOCK_SIZE",
"SUM_BLOCKS_ALLOC_A","SUM_BLOCKS_ALLOC_B","SUM_USED_BLOCKS_B",
"SUM_USED_ALLOC_CHANGE","NBR_DAYS") AS SELECT CI.COMPARE_ID 
COMPARE_ID, count(CB.OBJECT_ID) NBR_OBJECTS, TQ.TABLESPACE_NAME 
TABLESPACE_NAME, TQ.MAX_BYTES MAX_BYTES, CA.USERNAME USERNAME, 
CB.BLOCK_SIZE, sum(CA.BLOCKS) SUM_BLOCKS_ALLOC_A, sum(CB.BLOCKS) 
SUM_BLOCKS_ALLOC_B, sum(CB.ACTUAL_BLOCKS) SUM_USED_BLOCKS_B, 
(sum(CB.ACTUAL_BLOCKS) - sum(CA.ACTUAL_BLOCKS)) SUM_USED_ALLOC_CHANGE,
COLB.START_TIME - COLA.START_TIME NBR_DAYS FROM "mdbadmin". 
COMMON_DICT_VIEW CA, "mdbadmin". COMMON_DICT_VIEW CB, "mdbadmin". 
TS_QUOTA_VIEW TQ, "mdbadmin". COMPARE CI, "mdbadmin". COMPARE_OBJECT 
CO, "mdbadmin". COLLECT COLA, "mdbadmin". COLLECT COLB WHERE 
CA.USERNAME = TQ.USERNAME AND CI.LAST_COLLECT_ID =TQ.COLLECT_ID AND 
CI.FIRST_COLLECT_ID = CA.COLLECT_ID AND CI.LAST_COLLECT_ID = 
CB.COLLECT_ID AND CI.COMPARE_ID = CO.COMPARE_ID AND CO.FIRST_OBJECT_ID
= CA.OBJECT_ID AND CO.LAST_OBJECT_ID = CB.OBJECT_ID AND 
CI.FIRST_COLLECT_ID = COLA.COLLECT_ID AND CI.LAST_COLLECT_ID = 
COLB.COLLECT_ID AND CO.STATUS = 'B' GROUP BY CI.COMPARE_ID,
CA.USERNAME,TQ.TABLESPACE_NAME, TQ.MAX_BYTES,CB.BLOCK_SIZE, 
(COLB.START_TIME - COLA.START_TIME)
\p\g
create view  MASTER_QUOTAS_ROLES_DIFF_VIEW ("COMPARE_ID","GRANTEE",
"DEFAULT_ROLE_A","ROLE_NAME_A","TABLESPACE_NAME_A","BYTES_A",
"MAX_BYTES_A","DEFAULT_ROLE_B","ROLE_NAME_B","TABLESPACE_NAME_B",
"BYTES_B","MAX_BYTES_B") AS SELECT COMPARE_ID, GRANTEE GRANTEE, 
DEFAULT_ROLE_A, ROLE_NAME_A, TABLESPACE_NAME_A, BYTES_A, MAX_BYTES_A, 
DEFAULT_ROLE_B, ROLE_NAME_B, TABLESPACE_NAME_B, BYTES_B, MAX_BYTES_B 
FROM "mdbadmin". QUOTAS_ROLES_DIFF_VIEW WHERE COMPARE_ID IS NOT NULL
\p\g
create view  ADDED_USERS_VIEW_G12 ("COMPARE_ID","USERNAME") AS SELECT 
ci.compare_id, A.USERNAME "USERNAME" FROM "mdbadmin". COMMON_DICT_VIEW
A, "mdbadmin". COMPARE CI WHERE CI.FIRST_COLLECT_ID = A.COLLECT_ID 
group by a.USERNAME,ci.compare_id
\p\g
create view  DROPPED_USERS_VIEW_G12 ("COMPARE_ID","USERNAME") AS 
SELECT CI.COMPARE_ID, B.USERNAME FROM "mdbadmin". COMMON_DICT_VIEW B, 
"mdbadmin". COMPARE CI WHERE CI.LAST_COLLECT_ID = B.COLLECT_ID group 
by B.USERNAME,CI.COMPARE_ID
\p\g
create view  DAO_REP10_VIEW_G ("TIMESTAMP","TABLESPACE","ALLOC_MB",
"USED_MB","AVG_BLEVEL","AVG_CLUSTERING_FACTOR","MAX_TEMP_MB") AS 
select timestamp, tablespace, sum(alloc_mb) "ALLOC_MB", sum(used_mb) 
"USED_MB", avg(blevel) "AVG_BLEVEL", avg(clustering_factor) 
"AVG_CLUSTERING_FACTOR", max(temp_mb) "MAX_TEMP_MB" from "mdbadmin". 
DAO_rep10_view group by timestamp,tablespace
\p\g
create view  MASTER_REF_VIEW ( COLLECT_ID, TABLE_NAME, USERNAME, 
TABLESPACE_NAME, COLUMN_NAME, IS_SCOPED, REF_ID, SCOPE_TABLE_NAME, 
TABLE_ID, WITH_ROWID, SCOPE_TABLE_OWNER ) AS SELECT COLLECT_ID 
COLLECT_ID, OBJECT_NAME TABLE_NAME, USERNAME, TABLESPACE_NAME, 
COLUMN_NAME COLUMN_NAME, IS_SCOPED, REF_ID REF_ID, SCOPE_TABLE_NAME, 
TABLE_ID, WITH_ROWID, SCOPE_TABLE_OWNER FROM "mdbadmin". REF_VIEW 
WHERE COLLECT_ID IS NOT NULL
\p\g
create view  INDEX_STORAGE_VIEW ( COLLECT_ID, Owner , "Table ", 
TABLESPACE_NAME, INITIAL_EXTENT, NEXT_EXTENT, MIN_EXTENTS, 
NBR_EXTENTS, MAX_EXTENTS, PCT_INCREASE, CURRENT_BYTES, PCT_FREE, 
PCT_THRESHOLD ) AS SELECT C.COLLECT_ID, C.USERNAME "Owner ", 
C.OBJECT_NAME "Table ", C.TABLESPACE_NAME, C.INITIAL_EXTENT, 
C.NEXT_EXTENT, C.MIN_EXTENTS, C.NBR_EXTENTS, C.MAX_EXTENTS, 
C.PCT_INCREASE, C.CURRENT_BYTES, C.PCT_FREE, C.PCT_THRESHOLD FROM 
"mdbadmin". COMMON_DICT_VIEW C WHERE C.TYPE_NO =1
\p\g
create view  INDEX_BLOCK_FRAG_VIEW ( COLLECT_ID, OWNER , INDEX_NAME, 
TABLESPACE_NAME, PCT_FREE, BLEVEL, UNIQUENESS, NUM_ROWS, 
DISTINCT_KEYS, SELECTIVITY , AVG_LEAF_BLOCKS_PER_KEY, 
AVG_DATA_BLOCKS_PER_KEY, CLUSTERING_FACTOR ) AS SELECT COLLECT_ID, 
USERNAME, OBJECT_NAME Index_Name, TABLESPACE_NAME, PCT_FREE, BLEVEL, 
UNIQUENESS, NUM_ROWS, DISTINCT_KEYS, DISTINCT_KEYS, 
AVG_LEAF_BLOCKS_PER_KEY, AVG_DATA_BLOCKS_PER_KEY, CLUSTERING_FACTOR 
FROM "mdbadmin". MASTER_COMMON_VIEW WHERE COLLECT_ID IS NOT NULL AND 
TYPE_NO = 1
\p\g
create view  TABLE_BLOCK_FRAG_VIEW ( COLLECT_ID, USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, PCT_FREE, PCT_USED, AVG_ROW_LEN, 
NUM_ROWS, CHAIN_CNT, NORMAL_ROW_CNT, CHAIN_ROW_CNT, MIGRATE_ROW_CNT, 
DELETE_ROW_CNT, AVG_CHAINED_ROW_BYTES, AVG_MIGRATED_ROW_BYTES, 
AVG_NORMAL_ROW_BYTES, AVG_DELETE_ROW_BYTES, AVG_SPACE_FREELIST_BLOCKS,
FREE_LIST_LENGTH ) AS SELECT COLLECT_ID, USERNAME, OBJECT_NAME, 
TABLESPACE_NAME, PCT_FREE, PCT_USED, AVG_ROW_LEN, NUM_ROWS, CHAIN_CNT,
NORMAL_ROW_CNT, CHAIN_ROW_CNT, MIGRATE_ROW_CNT, DELETE_ROW_CNT, 
AVG_CHAINED_ROW_BYTES, AVG_MIGRATED_ROW_BYTES, AVG_NORMAL_ROW_BYTES, 
AVG_DELETE_ROW_BYTES, AVG_SPACE_FREELIST_BLOCKS, FREE_LIST_LENGTH FROM
"mdbadmin". MASTER_COMMON_VIEW WHERE COLLECT_ID IS NOT NULL AND 
TYPE_NO = 2
\p\g
create view  MASTER_RBS_DIFF_VIEW ( COMPARE_ID, SEGMENT_NAME, 
USERNAME, MIN_EXTENTS_A, MIN_EXTENTS_B, MAX_EXTENTS_A, MAX_EXTENTS_B, 
OPTSIZE_A, OPTSIZE_B, TABLESPACE_NAME ) AS SELECT COMPARE_ID, 
SEGMENT_NAME, USERNAME, MIN_EXTENTS_A, MIN_EXTENTS_B, MAX_EXTENTS_A, 
MAX_EXTENTS_B, OPTSIZE_A, OPTSIZE_B, TABLESPACE_NAME FROM "mdbadmin". 
RBS_DIFF_VIEW WHERE COMPARE_ID IS NOT NULL
\p\g
create view  EXTENT_AVAILABILITY_VIEW ( COLLECT_ID, OBJECT_ID, 
OBJECT_NAME, USERNAME, TYPE_NO, TABLESPACE_NAME, NEXT_EXTENT, 
BLOCKS_ALLOC, SUM_USED_EXTENTS, SUM_FREE_EXTENTS ) AS SELECT 
COLLECT_ID, OBJECT_ID, OBJECT_NAME, USERNAME, TYPE_NO, 
TABLESPACE_NAME, NEXT_EXTENT, BLOCKS BLOCKS_ALLOC, SUM_USED_EXTENTS, 
SUM_FREE_EXTENTS FROM "mdbadmin". EXTENT_AVAILABILITY_VIEW_G WHERE 
COLLECT_ID IS NOT NULL
\p\g
create view  REPORT_REPOSITORY_VIEW ( REPORT_NAME, Type , END_TIME, 
FINISH_TIME, ORACLE_SID, Format , FILE_SIZE, REPORT_HEAD_ID, 
OUTPUT_REPOSITORY_ID ) AS SELECT R.REPORT_NAME, R.REPORT_TYPE "Type ",
C.END_TIME, R.FINISH_TIME, SID.ORACLE_SID, R.FORMAT "Format ", 
R.FILE_SIZE, H.REPORT_HEAD_ID, R.OUTPUT_REPOSITORY_ID FROM "mdbadmin".
OUTPUT_REPOSITORY R, "mdbadmin". REPORT_HEAD H, "mdbadmin". COLLECT C,
"mdbadmin". SID SID WHERE C.COLLECT_ID = R.COLLECT_ID AND 
H.REPORT_HEAD_ID = R.REPORT_HEAD_ID AND SID.COLLECT_ID = C.COLLECT_ID
\p\g
create view  QUERY_VIEW ( QUERY_ID, QUERY_NAME, SELECT_STATEMENT, 
QUERY_TYPE, QUERY_VERSION, AT_DATE, QUERY_SCOPE, USE_DB ) AS SELECT 
QUERY_ID, QUERY_NAME , QUERY_Text Select_Statement, QUERY_TYPE 
Query_Type, QUERY_VERSION, QUERY_DATE At_Date, QUERY_SCOPE 
QUERY_SCOPE, QUERY_USE_DB Use_DB FROM "mdbadmin". QUERY
\p\g
create view  REPORT_NAME_VIEW ( CATEGORY, REPORT_NAME, CONTEXT, 
DEFAULT_FILTER, REPORT_HEAD_ID, FILTER_ID, CAT_ID, VIEW_NAME, 
FILTER_CODE ) AS SELECT RC.CATEGORY, RH.REPORT_NAME, RH.REPORT_CONTEXT
Context, F.FILTER_NAME Default_Filter, RH.REPORT_HEAD_ID, 
RH.FILTER_ID, RH.CATEGORY_ID Cat_ID, RV.VIEW_NAME, RH.FILTER_CODE 
Filter_Code FROM "mdbadmin". REPORT_HEAD RH, "mdbadmin". 
REPORT_CATEGORY RC, "mdbadmin". FILTER_HEAD F, "mdbadmin". REPORT_VIEW
RV WHERE RC.REPORT_CATEGORY_ID = RH.CATEGORY_ID AND RH.FILTER_ID = 
F.FILTER_HEAD_ID AND RH.VIEW_ID=RV.REPORT_VIEW_ID UNION ALL SELECT 
RC.CATEGORY, RH.REPORT_NAME, RH.REPORT_CONTEXT Context, NULL 
Default_Filter, RH.REPORT_HEAD_ID, RH.FILTER_ID, RH.CATEGORY_ID 
Cat_ID, RV.VIEW_NAME, RH.FILTER_CODE Filter_Code FROM "mdbadmin". 
REPORT_HEAD RH, "mdbadmin". REPORT_CATEGORY RC, "mdbadmin". 
REPORT_VIEW RV WHERE RC.REPORT_CATEGORY_ID = RH.CATEGORY_ID AND 
RH.VIEW_ID=RV.REPORT_VIEW_ID AND RH.FILTER_ID IS NULL
\p\g
create view  REPORT_METRIC_VIEW ( METRIC_ID, METRIC_NAME, CREATED_BY, 
CREATED_DATE, QUERY_SCOPE, USE_DB, COLUMN_NBR, QUERY_NAME, QUERY_TEXT 
) AS SELECT M.METRIC_ID, M.METRIC_NAME, M.CREATED_BY, M.CREATED_DATE, 
Q.QUERY_SCOPE QUERY_SCOPE, Q.QUERY_USE_DB Use_DB, M.COLUMN_NBR, 
Q.QUERY_NAME, Q.QUERY_TEXT FROM "mdbadmin". QUERY Q, "mdbadmin". 
ANALYZER_METRIC M WHERE Q.QUERY_ID = M.QUERY_ID
\p\g
create view  ADDED_OBJECTS_VIEW ( COMPARE_ID, USERNAME, OBJECT_NAME, 
TYPE_NO, TYPE, TABLESPACE_NAME ) AS SELECT COMPARE_ID, USERNAME, 
OBJECT_NAME, TYPE_NO, TYPE, TABLESPACE_NAME FROM "mdbadmin". 
PADDED_OBJECTS_VIEW WHERE COMPARE_ID IS NOT NULL
\p\g
create view  DROPPED_OBJECTS_VIEW ( COMPARE_ID, USERNAME, OBJECT_NAME,
TYPE_NO, TYPE, TABLESPACE_NAME ) AS SELECT COMPARE_ID, USERNAME, 
OBJECT_NAME, TYPE_NO, TYPE, TABLESPACE_NAME FROM "mdbadmin". 
PDROPPED_OBJECTS_VIEW WHERE COMPARE_ID IS NOT NULL
\p\g
create view  SCHEMA_GROWTH_VIEW ( COMPARE_ID, USERNAME, OBJECT_NAME, 
TABLESPACE_NAME, TYPE, BLOCK_SIZE, CURRENT_MBYTES_A, CURRENT_MBYTES_B,
CURRENT_BYTES, CHANGED, BLOCKS_ALLOC_A, BLOCKS_ALLOC_B, LEAF_BLOCKS_A,
LB_BY_DK_A, NUM_ROWS_A, DISTINCT_KEYS_A, NR_BY_DK_A, LEAF_BLOCKS_B, 
NUM_ROWS_B, DISTINCT_KEYS_B, LB_BY_DK_B, NR_BY_DK_B, INITIAL_EXTENT, 
USED_BLOCKS_A, ACTUAL_BLOCKS_B, NBR_DAYS, USED_ALLOC_CHANGE, 
PCT_BLOCKS_USED, USED_MBYTES_CHANGE, USED_GROWTH_PCT_CHANGE, TYPE_NO, 
PC_INI_TRANS, PC_MAX_TRANS, PC_INITIAL_EXTENT, PC_NEXT_EXTENT, 
PC_MIN_EXTENTS, PC_MAX_EXTENTS, PC_PCT_INCREASE, PC_FREELISTS, 
PC_FREELIST_GROUPS, PC_NBR_EXTENTS, PC_LOGGING, PC_DEGREE, 
PC_INSTANCES, PC_TEMPORARY, PC_BUFFER_POOL, PC_CURRENT_BYTES, 
PC_BLOCK_SIZE, PC_ACTUAL_BLOCKS, PC_TABLE_CACHE, PC_TABLE_LOCK, 
PC_NUM_ROWS, PC_EMPTY_BLOCKS, PC_AVG_SPACE, PC_CHAIN_CNT, 
PC_AVG_ROW_LEN, PC_AVG_SPACE_FREELIST_BLOCKS, PC_SAMPLE_SIZE, 
PC_PCT_THRESHOLD, PC_BLEVEL, PC_LEAF_BLOCKS, PC_DISTINCT_KEYS, 
PC_AVG_LEAF_BLOCKS_PER_KEY, PC_AVG_DATA_BLOCKS_PER_KEY, 
PC_CLUSTERING_FACTOR, PC_KEY_SIZE, PC_AVG_BLOCKS_PER_KEY, 
PC_HASH_KEYS, PC_AVG_BYTES_PER_BLOCK, PC_AVG_BLOCK_FILL, 
COMPARE_STATUS ) AS SELECT COMPARE_ID, USERNAME, OBJECT_NAME, 
TABLESPACE_NAME, TYPE, BLOCK_SIZE, CURRENT_MBYTES_A, CURRENT_MBYTES_B,
CURRENT_BYTES, Changed, BLOCKS_ALLOC_A, BLOCKS BLOCKS_ALLOC_B, 
LEAF_BLOCKS_A, LB_BY_DK_A, NUM_ROWS_A, DISTINCT_KEYS_A, NR_BY_DK_A, 
LEAF_BLOCKS_B, NUM_ROWS_B, DISTINCT_KEYS_B, LB_BY_DK_B, NR_BY_DK_B, 
INITIAL_EXTENT, USED_BLOCKS_A, ACTUAL_BLOCKS ACTUAL_BLOCKS_B, 
NBR_DAYS, USED_ALLOC_CHANGE , PCT_BLOCKS_USED, USED_MBYTES_CHANGE, 
USED_GROWTH_PCT_CHANGE, TYPE_NO, PC_INI_TRANS, PC_MAX_TRANS, 
PC_INITIAL_EXTENT, PC_NEXT_EXTENT, PC_MIN_EXTENTS, PC_MAX_EXTENTS, 
PC_PCT_INCREASE, PC_FREELISTS, PC_FREELIST_GROUPS, PC_NBR_EXTENTS, 
PC_LOGGING, PC_DEGREE, PC_INSTANCES, PC_TEMPORARY, PC_BUFFER_POOL, 
PC_CURRENT_BYTES, PC_BLOCK_SIZE, PC_ACTUAL_BLOCKS, PC_TABLE_CACHE, 
PC_TABLE_LOCK, PC_NUM_ROWS, PC_EMPTY_BLOCKS, PC_AVG_SPACE, 
PC_CHAIN_CNT, PC_AVG_ROW_LEN, PC_AVG_SPACE_FREELIST_BLOCKS, 
PC_SAMPLE_SIZE, PC_PCT_THRESHOLD, PC_BLEVEL, PC_LEAF_BLOCKS, 
PC_DISTINCT_KEYS, PC_AVG_LEAF_BLOCKS_PER_KEY, 
PC_AVG_DATA_BLOCKS_PER_KEY, PC_CLUSTERING_FACTOR, PC_KEY_SIZE, 
PC_AVG_BLOCKS_PER_KEY, PC_HASH_KEYS, PC_AVG_BYTES_PER_BLOCK, 
PC_AVG_BLOCK_FILL, COMPARE_STATUS FROM "mdbadmin". 
OBJECT_DETAIL_CHANGE_VIEW WHERE COMPARE_ID IS NOT NULL
\p\g
create view  REPORT_COMPARE_VIEW ( COMPARE_ID, SID_1, SID_2, 
HOSTNAME_1, HOSTNAME_2, SID_1_TIME, SID_2_TIME, START_TIME_A, 
START_TIME_B, NBR_DATAPOINTS, AUTO_COMPARE, SCOPE_A, SCOPE_B, SID1_ID,
SID2_ID ) AS SELECT CI.COMPARE_ID, SID1.ORACLE_SID SID_1, 
SID2.ORACLE_SID SID_2, SID1.HOSTNAME HOSTNAME_1, SID2.HOSTNAME 
HOSTNAME_2, C1.END_TIME SID_1_Time, C2.END_TIME SID_2_Time, 
C1.START_TIME START_TIME_A, C2.START_TIME START_TIME_B, 
CI.NBR_DATAPOINTS, CI.AUTO_COMPARE Auto_Compare, S1.SCOPE_NAME 
SCOPE_A, S2.SCOPE_NAME SCOPE_B, sid1.sid_id sid1_id, sid2.sid_id 
sid2_id FROM "mdbadmin". SID SID1, "mdbadmin". SID SID2, "mdbadmin". 
COMPARE CI, "mdbadmin". COLLECT C1, "mdbadmin". COLLECT C2, "mdbadmin"
. SCOPE_HEAD S1, "mdbadmin". SCOPE_HEAD S2 WHERE C1.COLLECT_ID = 
SID1.COLLECT_ID AND C2.COLLECT_ID = SID2.COLLECT_ID AND 
CI.FIRST_COLLECT_ID = C1.COLLECT_ID AND CI.LAST_COLLECT_ID = 
C2.COLLECT_ID AND C1.SCOPE_ID = S1.SCOPE_HEAD_ID AND C2.SCOPE_ID = 
S2.SCOPE_HEAD_ID
\p\g
create view  TYPE_VIEW ( COLLECT_ID, Owner , TYPE_NAME, "Type Code", 
ATTRIBUTES, METHODS, Predef , Incomp ) AS SELECT C.COLLECT_ID, OWNER 
"Owner ", TYPE_NAME, TYPECODE "Type Code", ATTRIBUTES, METHODS, 
PREDEFINED "Predef ", INCOMP "Incomp " FROM "mdbadmin". TYPE C WHERE 
C.COLLECT_ID IS NOT NULL
\p\g
create view  ROLE_PRIV_VIEW ( GRANTEE, "Granted Role", Admin , 
"Default" , "Pwd Req" ) AS SELECT GRANTEE, ROLE_NAME "Granted Role", 
ADMIN_OPTION "Admin ", DEFAULT_ROLE "Default ", PASSWORD_REQUIRED 
"Pwd Req" FROM "mdbadmin". ROLE_PRIV WHERE COLLECT_ID IS NOT NULL
\p\g
create view  MASTER_RBS_VIEW ( COLLECT_ID, INITIAL_EXTENT, 
MAX_EXTENTS, MIN_EXTENTS, NEXT_EXTENT, PCT_INCREASE, SEGMENT_NAME, 
OPTSIZE, STATUS, FILE_NAME, TABLESPACE_NAME, USERNAME ) AS SELECT 
COLLECT_ID, INITIAL_EXTENT INITIAL_EXTENT, MAX_EXTENTS MAX_EXTENTS, 
MIN_EXTENTS MIN_EXTENTS, NEXT_EXTENT NEXT_EXTENT, PCT_INCREASE 
PCT_INCREASE, SEGMENT_NAME SEGMENT_NAME, OPTSIZE, Status , FILE_NAME, 
TABLESPACE_NAME, USERNAME FROM "mdbadmin". RBS_VIEW WHERE COLLECT_ID 
IS NOT NULL
\p\g
create view  CURRENT_SIZE_VIEW ("COLLECT_ID","TABLESPACE_NAME",
"USERNAME","OBJECT_NAME","INITIAL_EXTENT","NEXT_EXTENT", "BLOCKS",
"ACTUAL_BLOCKS","MB_ALLOC","ACTUAL_MB","BLOCK_SIZE") AS SELECT 
COLLECT_ID COLLECT_ID, TABLESPACE_NAME, USERNAME, OBJECT_NAME, 
INITIAL_EXTENT INITIAL_EXTENT, NEXT_EXTENT NEXT_EXTENT, BLOCKS, 
ACTUAL_BLOCKS, BLOCKS*BLOCK_SIZE/1048576 MB_ALLOC, 
ACTUAL_BLOCKS*BLOCK_SIZE/1048576 ACTUAL_MB, BLOCK_SIZE FROM "mdbadmin"
. COMMON_DICT_VIEW WHERE COLLECT_ID IS NOT NULL and collect_id =267
\p\g
create view  DROPPED_USERS_VIEW_G1 ("COMPARE_ID","USERNAME") AS SELECT
CI.COMPARE_ID, A.USERNAME FROM "mdbadmin". COMMON_DICT_VIEW A, 
"mdbadmin". COMPARE CI WHERE CI.FIRST_COLLECT_ID = A.COLLECT_ID group 
by A.USERNAME,CI.COMPARE_ID
\p\g
create view  DATAFILE_VIEW ( COLLECT_ID, FILE_NAME, TABLESPACE_NAME, 
"At Date", Status, "Auto Ext", BYTES, MAXBYTES, INCREMENT_BY, 
NBR_USED_EXTENTS, MAX_USED_SIZE, NBR_FREE_EXTENTS, AVG_FREE_SIZE ) AS 
SELECT C.COLLECT_ID, F.FILE_NAME, F.TABLESPACE_NAME, C.END_TIME 
"At Date", F.STATUS "Status", F.INCREMENT_BY "Auto Ext", F.BYTES, 
F.MAXBYTES, F.INCREMENT_BY, F.NBR_USED_EXTENTS, F.MAX_USED_SIZE, 
F.NBR_FREE_EXTENTS, F.AVG_FREE_SIZE FROM "mdbadmin". COLLECT C, 
"mdbadmin". DATAFILE F WHERE F.COLLECT_ID = C.COLLECT_ID
\p\g
create view  OBJECTS_NOT_LOGGED_VIEW ( COLLECT_ID, BACKED_UP, 
CURRENT_MBYTES, LOGGING, OBJECT_NAME, USERNAME, TABLESPACE_NAME, TYPE#
) AS SELECT COLLECT_ID COLLECT_ID, BACKED_UP BACKED_UP, 
CURRENT_BYTES/1048576 CURRENT_MBYTES, LOGGING LOGGING, OBJECT_NAME 
OBJECT_NAME, USERNAME USERNAME, TABLESPACE_NAME TABLESPACE_NAME, 
TYPE_NO TYPE# FROM "mdbadmin". MASTER_COMMON_VIEW WHERE LOGGING = 0
\p\g
create view  CLUSTER_BLOCK_FRAG_VIEW ( COLLECT_ID, USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, PCT_FREE, PCT_USED, KEY_SIZE, AVG_SPACE,
AVG_ROW_LEN, PCT_ROWS_CHAINED, AVG_CHAINED_ROW_BYTES ) AS SELECT 
COLLECT_ID, USERNAME, OBJECT_NAME, TABLESPACE_NAME, PCT_FREE, 
PCT_USED, KEY_SIZE, AVG_SPACE, AVG_ROW_LEN, PCT_ROWS_CHAINED, 
AVG_CHAINED_ROW_BYTES FROM "mdbadmin". MASTER_COMMON_VIEW WHERE 
TYPE_NO =3
\p\g
create view  EXTENT_FRAGMENTATION_VIEW ( COLLECT_ID, NBR_EXTENTS, 
TABLESPACE_NAME, OBJECT_NAME, CURRENT_BYTES, TYPE_NO, USERNAME, 
OBJECT_ID, BLOCK_SIZE, AVG_EXTENT_BLOCKS, MINMEGTABLE, NBR_CPU, 
MAX_DEGREE, MINMEGINDEX, FILE_CNT_OBJECT, FILE_CNT_TS ) AS SELECT 
COLLECT_ID, NBR_EXTENTS, TABLESPACE_NAME, OBJECT_NAME, CURRENT_BYTES, 
TYPE_NO, USERNAME "OWNER", OBJECT_ID, BLOCK_SIZE, AVG_EXTENT_BLOCKS, 
Minmegtable, Nbr_cpu, max_degree, MinmegIndex, FILE_CNT_OBJECT, 
FILE_CNT_TS FROM "mdbadmin". EXTENT_FRAG2_VIEW WHERE COLLECT_ID IS NOT
NULL
\p\g
create view  FREE_LIST_PROBLEMS_VIEW ( COLLECT_ID, 
NUM_FREELIST_BLOCKS, AVG_SPACE_FREELIST_BLOCKS, OBJECT_NAME, 
TABLESPACE_NAME, USERNAME ) AS SELECT COLLECT_ID, NUM_FREELIST_BLOCKS 
NUM_FREELIST_BLOCKS, AVG_SPACE_FREELIST_BLOCKS 
AVG_SPACE_FREELIST_BLOCKS, OBJECT_NAME OBJECT_NAME, TABLESPACE_NAME 
TABLESPACE_NAME, USERNAME USERNAME FROM "mdbadmin". MASTER_COMMON_VIEW
WHERE TYPE_NO = 2
\p\g
create view  MASTER_INDEX_VS_TABLE_VIEW ( COLLECT_ID, INDEX_NAME, 
USERNAME, TABLESPACE_NAME, TABLE_NAME, INDEX_DEGREE, TABLE_DEGREE ) AS
SELECT COLLECT_ID, OBJECT_NAME INDEX_NAME, USERNAME, TABLESPACE_NAME, 
TABLE_NAME, INDEX_DEGREE, TABLE_DEGREE FROM "mdbadmin". 
INDEX_VS_TABLE_DEGREE_VIEW WHERE COLLECT_ID IS NOT NULL
\p\g
create view  MASTER_INDEX_ANAL_VIEW ( COLLECT_ID, USERNAME, 
INDEX_NAME, INDEX_DEGREE, TABLESPACE_NAME, TABLE_NAME, TABLE_DEGREE, 
INDEX_TYPE, UNIQUENESS, PCT_THRESHOLD, INCLUDE_COLUMN, PCT_FREE, 
BLEVEL, LEAF_BLOCKS, BLOCKS_ALLOC, BLOCK_SIZE, DISTINCT_KEYS, 
AVG_LEAF_BLOCKS_PER_KEY, AVG_DATA_BLOCKS_PER_KEY, CLUSTERING_FACTOR, 
STATUS, NUM_ROWS, SAMPLE_SIZE, LAST_ANALYZED, GENERATED ) AS SELECT 
COLLECT_ID, USERNAME, OBJECT_NAME INDEX_NAME, INDEX_DEGREE, 
TABLESPACE_NAME, TABLE_NAME, TABLE_DEGREE, INDEX_TYPE, UNIQUENESS, 
PCT_THRESHOLD, INCLUDE_COLUMN, PCT_FREE, BLEVEL, LEAF_BLOCKS, BLOCKS 
BLOCKS_ALLOC, BLOCK_SIZE, DISTINCT_KEYS, AVG_LEAF_BLOCKS_PER_KEY, 
AVG_DATA_BLOCKS_PER_KEY, CLUSTERING_FACTOR, STATUS, NUM_ROWS, 
SAMPLE_SIZE, LAST_ANALYZED, GENERATED FROM "mdbadmin". 
INDEX_DICT_ANAL_VIEW WHERE COLLECT_ID IS NOT NULL
\p\g
create view  ADDED_DROPPED_VIEW ( COMPARE_ID, Owner , Object_Name , 
TYPE_NO, TYPE, TABLESPACE_NAME, COMPARE_STATUS ) AS SELECT COMPARE_ID,
USERNAME "Owner ", OBJECT_NAME "Object_Name ", TYPE_NO, TYPE_NO TYPE, 
TABLESPACE_NAME, COMPARE_STATUS FROM "mdbadmin". 
MASTER_DETAIL_CHANGE_VIEW WHERE COMPARE_STATUS IN ('A','D')
\p\g
create view  MASTER_ORACLE_VERSIONS_VIEW ( COMPARE_ID, ORACLE_SID_A, 
ORACLE_SID_B, PARAM_NAME_A, PARAM_VALUE_A, PARAM_NAME_B, 
PARAM_VALUE_B, CHANGED ) AS SELECT CI.COMPARE_ID COMPARE_ID, 
SA.ORACLE_SID ORACLE_SID_A, SB.ORACLE_SID ORACLE_SID_B, SPA.PARAM_NAME
PARAM_NAME_A, SPA.PARAM_VALUE PARAM_VALUE_A, SPB.PARAM_NAME 
PARAM_NAME_B, SPB.PARAM_VALUE PARAM_VALUE_B, SPB.PARAM_VALUE Changed 
FROM "mdbadmin". SID SA, "mdbadmin". SID SB, "mdbadmin". SID_PARAM 
SPA, "mdbadmin". SID_PARAM SPB, "mdbadmin". COMPARE CI WHERE 
SPA.PARAM_NAME =SPB.PARAM_NAME AND SA.SID_ID = SPA.SID_ID AND 
SB.SID_ID = SPB.SID_ID AND CI.FIRST_COLLECT_ID = SA.COLLECT_ID AND 
CI.LAST_COLLECT_ID = SB.COLLECT_ID AND CI.FIRST_COLLECT_ID = 
SPA.COLLECT_ID AND CI.LAST_COLLECT_ID = SPB.COLLECT_ID
\p\g
create view  OBJECT_GROWTH_VIEW ( COMPARE_ID, OBJECT_NAME, 
CURRENT_BYTES_B, CURRENT_MBYTES_A, CURRENT_MBYTES_B, TABLESPACE_NAME, 
USERNAME, CHANGED ) AS SELECT COMPARE_ID, OBJECT_NAME OBJECT_NAME, 
CURRENT_BYTES CURRENT_BYTES_B, CURRENT_MBYTES_A, CURRENT_MBYTES_B, 
TABLESPACE_NAME, USERNAME USERNAME, Changed FROM "mdbadmin". 
OBJECT_DETAIL_CHANGE_VIEW WHERE COMPARE_STATUS ='B'
\p\g
create view  MASTER_QUOTA_ROLES_DIFF_VIEW ( COMPARE_ID, GRANTEE, 
DEFAULT_ROLE_A, ROLE_NAME_A, TABLESPACE_NAME_A, BYTES_A, MAX_BYTES_A, 
DEFAULT_ROLE_B, ROLE_NAME_B, TABLESPACE_NAME_B, BYTES_B, MAX_BYTES_B )
AS SELECT COMPARE_ID, GRANTEE GRANTEE, DEFAULT_ROLE_A, ROLE_NAME_A, 
TABLESPACE_NAME_A, BYTES_A, MAX_BYTES_A, DEFAULT_ROLE_B, ROLE_NAME_B, 
TABLESPACE_NAME_B, BYTES_B, MAX_BYTES_B FROM "mdbadmin". 
QUOTAS_ROLES_DIFF_VIEW WHERE COMPARE_ID IS NOT NULL
\p\g
create view  INDEX_GROWTH_FRAG_VIEW ( COMPARE_ID, OBJECT_NAME, 
LEAF_BLOCKS_A, NUM_ROWS_A, DISTINCT_KEYS_A, LB_BY_DK_A, NR_BY_DK_A, 
LEAF_BLOCKS_B, NUM_ROWS_B, DISTINCT_KEYS_B, LB_BY_DK_B, NR_BY_DK_B, 
TABLESPACE_NAME, USERNAME ) AS SELECT COMPARE_ID, OBJECT_NAME 
OBJECT_NAME, LEAF_BLOCKS_A, NUM_ROWS_A, DISTINCT_KEYS_A, LB_BY_DK_A, 
NR_BY_DK_A, LEAF_BLOCKS_B, NUM_ROWS_B, DISTINCT_KEYS_B, LB_BY_DK_B, 
NR_BY_DK_B, TABLESPACE_NAME, USERNAME USERNAME FROM "mdbadmin". 
OBJECT_DETAIL_CHANGE_VIEW WHERE TYPE_NO = 1 AND COMPARE_ID IS NOT NULL
\p\g
create view  SIX_MONTH_NEXT_EXT_VIEW ( COMPARE_ID, USERNAME, 
OBJECT_NAME, TYPE_NO, TABLESPACE_NAME, BLOCK_SIZE, BLOCKS_ALLOC_A, 
BLOCKS_ALLOC_B, INITIAL_EXTENT, USED_BLOCKS_A, ACTUAL_BLOCKS_B, 
NBR_DAYS, USED_ALLOC_CHANGE, PCT_BLOCKS_USED ) AS SELECT COMPARE_ID, 
USERNAME, OBJECT_NAME, TYPE_NO, TABLESPACE_NAME, BLOCK_SIZE, 
BLOCKS_ALLOC_A, BLOCKS BLOCKS_ALLOC_B, INITIAL_EXTENT, USED_BLOCKS_A, 
ACTUAL_BLOCKS ACTUAL_BLOCKS_B, NBR_DAYS, USED_ALLOC_CHANGE , 
PCT_BLOCKS_USED FROM "mdbadmin". OBJECT_DETAIL_CHANGE_VIEW WHERE 
COMPARE_ID IS NOT NULL
\p\g
create view  FREE_SPACE_VIEW ( COLLECT_ID, TABLESPACE_NAME, 
NBR_DATAFILES, NBR_EXTENTS, NBR_FREE_EXTENTS, MIN_FREE_SIZE, 
MAX_FREE_SIZE, AVG_FREE_SIZE ) AS SELECT COLLECT_ID, TABLESPACE_NAME, 
NBR_DATAFILES, NBR_EXTENTS, NBR_FREE_EXTENTS, MIN_FREE_SIZE, 
MAX_FREE_SIZE, AVG_FREE_SIZE FROM "mdbadmin". FREE_SPACE_VIEW_G WHERE 
COLLECT_ID IS NOT NULL
\p\g
create view  DAYS_TILL_QUOTA_USED_VIEW ( COMPARE_ID, NBR_OBJECTS, 
TABLESPACE_NAME, MAX_BYTES, USERNAME, BLOCK_SIZE, SUM_BLOCKS_ALLOC_A, 
SUM_BLOCKS_ALLOC_B, SUM_USED_ALLOC_CHANGE, NBR_DAYS ) AS SELECT 
COMPARE_ID, NBR_OBJECTS, TABLESPACE_NAME, MAX_BYTES, USERNAME, 
BLOCK_SIZE, SUM_BLOCKS_ALLOC_A, SUM_BLOCKS_ALLOC_B, 
SUM_USED_ALLOC_CHANGE, NBR_DAYS FROM "mdbadmin". 
DAYS_TILL_QUOTA_USED_VIEW_G WHERE COMPARE_ID IS NOT NULL
\p\g
create view  EXTENT_SIZE_STAT_VIEW ( COLLECT_ID, USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, FILE_NAME, OFFSET, MIN_EXT_SIZE, 
MAX_EXT_SIZE, AVG_EXT_SIZE ) AS SELECT COLLECT_ID, USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, FILE_NAME, OFFSET, MIN_EXT_SIZE, 
MAX_EXT_SIZE, AVG_EXT_SIZE FROM "mdbadmin". EXTENT_SIZE_STAT_VIEW_G 
WHERE COLLECT_ID IS NOT NULL
\p\g
create view  GROWTH_RATES_VIEW ( COMPARE_ID, OBJECT_NAME, TYPE_NO, 
TABLESPACE_NAME, USERNAME, CURRENT_BYTES, USED_BLOCKS_A, 
ACTUAL_BLOCKS, BLOCK_SIZE, USED_MBYTES_CHANGE, USED_GROWTH_PCT_CHANGE,
NBR_DAYS ) AS SELECT COMPARE_ID, OBJECT_NAME, TYPE_NO, 
TABLESPACE_NAME, USERNAME, CURRENT_BYTES, USED_BLOCKS_A, 
ACTUAL_BLOCKS, BLOCK_SIZE, USED_MBYTES_CHANGE, USED_GROWTH_PCT_CHANGE,
NBR_DAYS FROM "mdbadmin". OBJECT_DETAIL_CHANGE_VIEW WHERE 
COMPARE_STATUS = 'B' AND TYPE_NO in (1,2)
\p\g
create view  PCT_USED_FREE_VIEW ( COLLECT_ID, AVG_FREE_SPACE_BLOCK, 
PCT_FREE, PCT_USED, TABLE_NAME, USERNAME, TABLESPACE_NAME, 
AVG_BYTES_PER_BLOCK, AVG_BLOCK_FILL ) AS SELECT COLLECT_ID, AVG_SPACE 
AVG_FREE_SPACE_BLOCK, PCT_FREE PCT_FREE, PCT_USED PCT_USED, 
OBJECT_NAME TABLE_NAME, USERNAME USERNAME, TABLESPACE_NAME, 
(BLOCK_SIZE - 90 -AVG_SPACE ) AVG_BYTES_PER_BLOCK, (BLOCK_SIZE - 90 
-AVG_SPACE )/(BLOCK_SIZE - 90)*100 AVG_BLOCK_FILL FROM "mdbadmin". 
COMMON_DICT_VIEW WHERE COLLECT_ID IS NOT NULL
\p\g
create view  TABLESPACE_GROWTH_VIEW ( COMPARE_ID, TABLESPACE_NAME, 
BLOCK_SIZE, SUM_BLOCKS_ALLOCS_A, SUM_BLOCKS_ALLOC_B, 
SUM_INITIAL_EXTENT, SUM_BLOCKS_A, SUM_BLOCKS_B, NBR_DAYS, 
SUM_USED_ALLOC_CHANGE, SUM_MB_CHANGE, PCT_ALLOC_USED, TS_MB_SIZE ) AS 
SELECT COMPARE_ID, TABLESPACE_NAME, BLOCK_SIZE, SUM_BLOCKS_ALLOCS_A, 
SUM_BLOCKS_ALLOC_B, SUM_INITIAL_EXTENT, SUM_BLOCKS_A, SUM_BLOCKS_B, 
NBR_DAYS, SUM_USED_ALLOC_CHANGE, SUM_MB_CHANGE, PCT_ALLOC_USED, 
TS_MB_SIZE FROM "mdbadmin". TABLESPACE_GROWTH_A_VIEW WHERE COMPARE_ID 
IS NOT NULL
\p\g
create view  ADDED_USERS_VIEW ( COMPARE_ID, USERNAME, NBR_OBJECTS, 
TOTAL_MEG ) AS SELECT COMPARE_ID, USERNAME, NBR_OBJECTS, TOTAL_MEG 
FROM "mdbadmin". ADDED_USERS_VIEW_G WHERE COMPARE_ID IS NOT NULL
\p\g
create view  DROPPED_USERS_VIEW ( COMPARE_ID, USERNAME, NBR_OBJECTS, 
TOTAL_MEG ) AS SELECT COMPARE_ID, USERNAME, NBR_OBJECTS, TOTAL_MEG 
FROM "mdbadmin". DROPPED_USERS_VIEW_G WHERE COMPARE_ID IS NOT NULL
\p\g
create view  ROLE_PRIV_CHANGE_VIEW ( COMPARE_ID, GRANTEE, 
"Granted Role A", "Admin A", "Default A", "Pwd Req A", 
"Granted Role B","Admin B", "Default B", "Pwd Req B" ) AS SELECT 
COMPARE_ID COMPARE_ID, A.GRANTEE, A.ROLE_NAME "Granted Role A", 
A.ADMIN_OPTION "Admin A", A.DEFAULT_ROLE "Default A", 
A.PASSWORD_REQUIRED "Pwd Req A", B.ROLE_NAME "Granted Role B", 
B.ADMIN_OPTION "Admin B", B.DEFAULT_ROLE "Default B", 
B.PASSWORD_REQUIRED "Pwd Req B" FROM "mdbadmin". ROLE_PRIV A, 
"mdbadmin". ROLE_PRIV B, "mdbadmin". COMPARE WHERE FIRST_COLLECT_ID = 
A.COLLECT_ID AND LAST_COLLECT_ID = B.COLLECT_ID AND A.GRANTEE = 
B.GRANTEE AND A.ROLE_NAME = B.ROLE_NAME and compare_id =226
\p\g
create view  STORAGE_SUMMARY_VIEW ( TABLESPACE_NAME, OBJECT_NAME, 
USERNAME, ACTUAL_BLOCKS, BLOCKS, BLOCK_SIZE, NBR_EXTENTS ) AS SELECT 
MASTER_COMMON_VIEW.TABLESPACE_NAME, MASTER_COMMON_VIEW.OBJECT_NAME, 
MASTER_COMMON_VIEW.USERNAME, MASTER_COMMON_VIEW.ACTUAL_BLOCKS, 
MASTER_COMMON_VIEW.BLOCKS, MASTER_COMMON_VIEW.BLOCK_SIZE, 
MASTER_COMMON_VIEW.NBR_EXTENTS FROM "mdbadmin". MASTER_COMMON_VIEW
\p\g
create view  STORAGE_CLAUSE_VIEW ( TABLESPACE_NAME, USERNAME, 
OBJECT_NAME, TYPE_NO, INITIAL_EXTENT, NEXT_EXTENT, MIN_EXTENTS, 
MAX_EXTENTS, PCT_INCREASE, INI_TRANS, MAX_TRANS, PCT_USED, PCT_FREE ) 
AS SELECT TABLESPACE_NAME, USERNAME, OBJECT_NAME, TYPE_NO, 
INITIAL_EXTENT, NEXT_EXTENT, MIN_EXTENTS, MAX_EXTENTS, PCT_INCREASE, 
INI_TRANS, MAX_TRANS, PCT_USED, PCT_FREE FROM "mdbadmin". 
MASTER_COMMON_VIEW
\p\g
create view  BLOCKS_CHANGE_VIEW ( COLLECT_ID, TIMESTAMP, 
TABLESPACE_NAME, EXTENTS, BLOCKS, TOTAL_ROWS, ACTUAL_BLOCKS, 
CHAINED_ROWS, EMPTY_BLOCKS, ACTUAL_MEGA_BYTES ) AS select 
c.COLLECT_ID, TIMESTAMP "TIMESTAMP", TABLESPACE_NAME "TABLESPACE_NAME"
, EXTENTS "EXTENTS", BLOCKS "BLOCKS", TOTAL_ROWS "TOTAL_ROWS", 
ACTUAL_BLOCKS "ACTUAL_BLOCKS", CHAINED_ROWS "CHAINED_ROWS", 
EMPTY_BLOCKS "EMPTY_BLOCKS", ACTUAL_MEGA_BYTES from "mdbadmin". 
ts_change_view c where collect_id is not null
\p\g
create view  USER_CHANGE_VIEW ( COLLECT_ID, END_TIME, USERNAME, 
NBR_TABLE, NBR_BTREE, NBR_CLUSTER ) AS select c.collect_id, 
c.end_time, username, nbr_table, nbr_btree, nbr_cluster from 
"mdbadmin". user_stat a, "mdbadmin". collect c, "mdbadmin". user_head 
d where a.user_head_id = d.user_head_id and c.collect_id = 
d.collect_id
\p\g
create view  DAO_110_VIEW ( OBJECT_NAME, TYPE, TABLESPACE_NAME, 
CHAIN_CNT, PC_CHAIN_CNT, NBR_EXTENTS, AVG_FREE_SPACE_BLOCK, PCT_USED, 
PCT_FREE, ACTUAL_BLOCKS_B, BLOCK_SIZE, NUM_ROWS_B ) AS SELECT 
OBJECT_NAME, TYPE, TABLESPACE_NAME, CHAIN_CNT, PC_CHAIN_CNT, 
NBR_EXTENTS, BLOCK_SIZE - AVG_BYTES_PER_BLOCK "AVG_FREE_SPACE_BLOCK", 
PCT_USED, PCT_FREE, ACTUAL_BLOCKS_B, BLOCK_SIZE, NUM_ROWS_B FROM 
"mdbadmin". MASTER_DETAIL_CHANGE_VIEW where type_no =2 and 
ACTUAL_BLOCKS_B*BLOCK_SIZE/1048576 > 1 or NBR_EXTENTS > 250 or 
(BLOCK_SIZE - AVG_BYTES_PER_BLOCK) < BLOCK_SIZE * PCT_FREE/100 or 
(BLOCK_SIZE - AVG_BYTES_PER_BLOCK) > BLOCK_SIZE *(100- PCT_USED)/100 
or PC_CHAIN_CNT >0
\p\g
create view  DAO_115_VIEW ( USERNAME, OBJECT_NAME, TABLESPACE_NAME, 
AVG_DATA_BLOCKS_PER_KEY, NBR_EXTENTS, OLD_BLEVEL, BLEVEL, 
OLD_AVG_DATA_BLOCKS_PER_KEY, INDEX_STATUS ) AS SELECT USERNAME, 
OBJECT_NAME, TABLESPACE_NAME, AVG_DATA_BLOCKS_PER_KEY, NBR_EXTENTS, 
OLD_BLEVEL, BLEVEL, OLD_AVG_DATA_BLOCKS_PER_KEY, INDEX_STATUS FROM 
"mdbadmin". MASTER_DETAIL_CHANGE_VIEW where type_no =1 or NBR_EXTENTS 
> 250 or PC_BLEVEL >0 or PC_AVG_DATA_BLOCKS_PER_KEY >0 or BLEVEL >5
\p\g
create view  FAST_STAT_VIEW ( COLLECT_ID, USERNAME, OBJECT_NAME, 
TABLESPACE_NAME, NORMAL_ROW_CNT, MIGRATE_ROW_CNT, CHAIN_ROW_CNT, 
MIGRATE_AND_CHAIN_ROW_CNT, DELETE_ROW_CNT, FREE_BLOCK_CNT, 
FREE_LIST_LENGTH, EMB_CNT, AVG_BLOCK_HEADER_BYTES, 
AVG_BLOCK_DATA_BYTES, AVG_UNUSED_FREE_SPACE, AVG_RELEASED_FREE_SPACE, 
AVG_NORMAL_ROW_BYTES, AVG_MIGRATED_ROW_BYTES, AVG_CHAINED_ROW_BYTES, 
AVG_MIG_AND_CHAINED_ROW_BYTES, MIN_ROW_LEN, MAX_ROW_LEN, AVG_ROW_LEN, 
MIN_SCN, MAX_SCN, AVG_ROW_DIR_ENTRIES, EMPTY_ROW_DIR_ENTRIES, 
TOTAL_ROW_DIR_ENTRIES, MIN_CHAIN_BLOCKSPAN_OFFSET, 
AVG_CHAIN_BLOCKSPAN_OFFSET, MAX_CHAIN_BLOCKSPAN_OFFSET, 
MIN_MIGRATED_BLOCKSPAN_OFFSET, AVG_MIGRATED_BLOCKSPAN_OFFSET, 
MAX_MIGRATED_BLOCKSPAN_OFFSET, CHAINED_ROWS_THAT_SPAN_FILES, 
MIGRATED_ROWS_THAT_SPAN_FILES, USED_BLOCK_FILL_PERCENTAGE, 
HOME_ROW_READS, MIGRATED_ROW_READS, CHAINED_ROW_READS, 
BLOCK_FILL_MORE_PCTFREE, BLOCK_FILL_LESS_PCTUSED, 
AVG_SPACE_FREELIST_BLOCKS, FREELIST_BLOCK_CNT ) AS select collect_id, 
username, object_name, tablespace_name, normal_row_cnt, 
migrate_row_cnt, chain_row_cnt, migrate_and_chain_row_cnt, 
delete_row_cnt, free_block_cnt, free_list_length, emb_cnt, 
avg_block_header_bytes, avg_block_data_bytes, avg_unused_free_space, 
avg_released_free_space, avg_normal_row_bytes, avg_migrated_row_bytes,
avg_chained_row_bytes, avg_mig_and_chained_row_bytes, min_row_len, 
max_row_len, avg_row_len, min_scn, max_scn, AVG_ROW_DIR_ENTRIES, 
EMPTY_ROW_DIR_ENTRIES, TOTAL_ROW_DIR_ENTRIES, 
MIN_CHAIN_BLOCKSPAN_OFFSET, AVG_CHAIN_BLOCKSPAN_OFFSET, 
MAX_CHAIN_BLOCKSPAN_OFFSET, MIN_MIGRATED_BLOCKSPAN_OFFSET, 
AVG_MIGRATED_BLOCKSPAN_OFFSET, MAX_MIGRATED_BLOCKSPAN_OFFSET, 
CHAINED_ROWS_THAT_SPAN_FILES, MIGRATED_ROWS_THAT_SPAN_FILES, 
USED_BLOCK_FILL_PERCENTAGE, HOME_ROW_READS, MIGRATED_ROW_READS, 
CHAINED_ROW_READS, BLOCK_FILL_MORE_PCTFREE, BLOCK_FILL_LESS_PCTUSED, 
AVG_SPACE_FREELIST_BLOCKS, FREELIST_BLOCK_CNT from "mdbadmin". 
master_fast_stat_view where collect_id IS not null
\p\g
create view  TAB_PRIV_VIEW ( COLLECT_ID, GRANTEE, GRANTOR, OWNER, 
TABLE_NAME, PRIVILEGE, GRANTABLE ) AS SELECT C.COLLECT_ID, 
UGE.USERNAME Grantee, UGR.USERNAME Grantor, C.USERNAME Owner, 
T.SEGMENT_NAME Table_Name, P.PRIVILEGE, P.GRANTABLE Grantable FROM 
"mdbadmin". USER_HEAD C, "mdbadmin". TAB_PRIV P, "mdbadmin". USER_HEAD
UGE, "mdbadmin". USER_HEAD UGR, "mdbadmin". SEGMENT_DICT T WHERE 
C.USER_HEAD_ID = P.OWNER_ID AND UGE.USER_HEAD_ID = P.GRANTEE_ID AND 
UGR.USER_HEAD_ID = P.GRANTOR_ID AND T.OBJECT_ID = P.TABLE_ID
\p\g
create view  REPORT_COLLECT_VIEW ( COLLECT_ID, SID, HOSTNAME, 
SCOPE_NAME, AT_DATE, END_TIME, UPDATE_DICT, FAST_ANALYZE, HISTOGRAMS, 
ANALYZE_TYPE, SCOPE_HEAD_ID, SID_ID ) AS SELECT C.COLLECT_ID, 
SID.ORACLE_SID SID, SID.HOSTNAME, S.SCOPE_NAME, C.START_TIME At_Date, 
C.END_TIME, c.anal_type Update_Dict, C.USE_FAST_ANAL Fast_Analyze, 
C.HISTOGRAM_OPTIONS Histograms, C.ANAL_TYPE Analyze_Type, 
s.scope_head_id, sid.sid_id FROM "mdbadmin". SID SID, "mdbadmin". 
SCOPE_HEAD S, "mdbadmin". COLLECT C WHERE C.COLLECT_ID = 
SID.COLLECT_ID AND C.SCOPE_ID = S.SCOPE_HEAD_ID
\p\g
create view  OUTPUT_VIEW ( REPORT_HEAD_ID, REPORT_NAME, FINISH_TIME ) 
AS SELECT REPORT_HEAD_ID, REPORT_NAME, FINISH_TIME FROM "mdbadmin". 
OUTPUT_REPOSITORY
\p\g
create view  MEG_TO_MOVE_VIEW ("COLLECT_ID","USERNAME","OBJECT_NAME",
"LEAF_BLOCKS","TABLE_NAME","BLOCKS","EMPTY_BLOCKS","NUM_ROWS") AS 
SELECT I.COLLECT_ID, I.USERNAME, I.OBJECT_NAME, I.LEAF_BLOCKS, 
I.TABLE_NAME, T.BLOCKS, T.EMPTY_BLOCKS, T.NUM_ROWS FROM "mdbadmin". 
INDEX_DICT_ANAL_VIEW I, "mdbadmin". TABLE_DICT_ANAL_VIEW T WHERE 
I.COLLECT_ID = T.COLLECT_ID AND I.TABLE_NAME = T.OBJECT_NAME AND 
I.USERNAME= T.USERNAME
\p\g
create view  OUTPUT_REPOSITORY_VIEW ("REPORT_DATE","ORACLE_SID",
"COLLECT_END","FILTER_NAME","SCOPE_NAME","REPORT_HEAD_ID", 
"REPORT_NAME","Type","Format","FILE_NAME","FILE_SIZE","REPORT_CONTEXT"
,"Context", "CATEGORY","CREATED_BY","JOB_ID","OUTPUT_REPOSITORY_ID") 
AS SELECT R.FINISH_TIME "REPORT_DATE", CV.SID_2_HOSTNAME ORACLE_SID, 
C.END_TIME "COLLECT_END", F.FILTER_NAME, S.SCOPE_NAME, 
R.REPORT_HEAD_ID, R.REPORT_NAME, R.REPORT_TYPE "Type", R.FORMAT 
"Format", R.FILE_NAME, R.FILE_SIZE, RH.REPORT_CONTEXT, 
RH.REPORT_CONTEXT "Context", RC.CATEGORY, OH.CREATED_BY, OH.JOB_ID, 
R.OUTPUT_REPOSITORY_ID FROM "mdbadmin". OUTPUT_REPOSITORY R, 
"mdbadmin". COLLECT C, "mdbadmin". REPORT_HEAD RH, "mdbadmin". 
REPORT_CATEGORY RC, "mdbadmin". SID SID, "mdbadmin". COMPARE_VIEW CV, 
"mdbadmin". OUTPUT_HEAD OH, "mdbadmin". FILTER_HEAD F, "mdbadmin". 
SCOPE_HEAD S WHERE R.COLLECT_ID = C.COLLECT_ID AND C.COLLECT_ID = 
SID.COLLECT_ID AND R.COMPARE_ID = CV.COMPARE_ID AND R.FILTER_HEAD_ID =
F.FILTER_HEAD_ID AND R.SCOPE_HEAD_ID = S.SCOPE_HEAD_ID AND 
RH.REPORT_HEAD_ID =R.REPORT_HEAD_ID AND 
RH.CATEGORY_ID=RC.REPORT_CATEGORY_ID AND OH.OUTPUT_HEAD_ID= 
R.OUTPUT_HEAD_ID AND R.FILE_SIZE >0
\p\g
create view  FILTER_CO_VIEW ( FILTER_HEAD_ID, FILTER_NAME, METRIC_ID, 
METRIC_NAME, MIN_VAL, MAX_VAL, PATTERN_MATCH, METRIC_INTERNAL ) AS 
SELECT H.FILTER_HEAD_ID, H.FILTER_NAME FILTER_NAME, M.METRIC_ID, 
M.METRIC_NAME, C.MIN_VAL, C.MAX_VAL, C.PATTERN_MATCH, 
M.METRIC_INTERNAL FROM "mdbadmin". FILTER_HEAD H, "mdbadmin". 
FILTER_COLLECT C, "mdbadmin". ANALYZER_METRIC M WHERE C.FILTER_HEAD_ID
= H.FILTER_HEAD_ID AND C.METRIC_ID = M.METRIC_ID
\p\g
create view  COLLECT_VIEW ( SID, HOSTNAME, SCOPE_NAME, AtDate, 
COLLECT_DESC, END_TIME, CREATED_BY, TABLE_CNT, INDEX_CNT, CLUSTER_CNT,
ROLLBACK_CNT, USER_CNT, JOB_ID, UpdateDict, Histograms, AnalyzeType, 
FastAnalyze, COLLECT_ID, AUTO_REORG, SCOPE_HEAD_ID, SID_ID ) AS SELECT
SI.ORACLE_SID SID, SI.HOSTNAME, S.SCOPE_NAME, C.START_TIME AtDate, 
C.COLLECT_DESC, C.END_TIME, C.CREATED_BY, C.TABLE_CNT, C.INDEX_CNT, 
C.CLUSTER_CNT, C.ROLLBACK_CNT, C.USER_CNT, C.JOB_ID, c.anal_type 
UpdateDict, C.HISTOGRAM_OPTIONS Histograms, C.ANAL_TYPE AnalyzeType, 
C.USE_FAST_ANAL FastAnalyze, C.COLLECT_ID, C.AUTO_REORG, 
S.SCOPE_HEAD_ID, SI.SID_ID FROM "mdbadmin". SID SI, "mdbadmin". 
SCOPE_HEAD S, "mdbadmin". COLLECT C WHERE C.COLLECT_ID = SI.COLLECT_ID
AND C.SCOPE_ID = S.SCOPE_HEAD_ID
\p\g
create view  DAO_TREND_CHANGE ( COLLECT_ID, TREND_ID, COMPARE_ID, 
USERS, INDEXES, TABLES, CLUSTERS, DAYS ) AS SELECT a.collect_id, 
b.collect_id trend_id, c.compare_id, ((b.user_cnt-a.user_cnt)
/a.user_cnt*100) users, (((b.index_cnt-a.index_cnt)/a.index_cnt)*100) 
indexes, (((b.table_cnt-a.table_cnt)/a.table_cnt)*100) tables, 
(((b.cluster_cnt-a.cluster_cnt)/a.cluster_cnt)*100) clusters, 
(b.start_time-a.start_time) days FROM "mdbadmin". collect a, 
"mdbadmin". collect b, "mdbadmin". compare c WHERE a.collect_id = 
c.first_collect_id AND b.collect_id = c.last_collect_id
\p\g
create view  REPORT_TEXT_VIEW ( REPORT_NAME, REPORT_HEAD_ID, 
VIEW_NAME, TEXT ) AS SELECT RH.REPORT_NAME, RH.REPORT_HEAD_ID, 
RV.VIEW_NAME, RV.TEXT FROM "mdbadmin". REPORT_HEAD RH, "mdbadmin". 
REPORT_VIEW RV WHERE RH.VIEW_ID=RV.REPORT_VIEW_ID
\p\g
create view  SCOPE_VIEW ( SCOPE_HEAD_ID, Name , Version , "At Date", 
"Object Type", Condition , OBJECT_NAME ) AS SELECT H.SCOPE_HEAD_ID, 
H.SCOPE_NAME "Name ", H.SCOPE_VERSION "Version ", CREATED_DATE 
"At Date", D.OBJECT_TYPE "Object Type", D.INCL_EXCL "Condition ", 
D.OBJECT_NAME FROM "mdbadmin". SCOPE_HEAD H, "mdbadmin". SCOPE_DET D 
WHERE D.SCOPE_HEAD_ID = H.SCOPE_HEAD_ID
\p\g
create view  BACKUP_HISTORY_VIEW ( COLLECT_ID, TABLESPACE_NAME, 
USERNAME, OBJECT_NAME, MAX_SCN, MIN_SCN ) AS SELECT TF.COLLECT_ID 
COLLECT_ID, TS.TABLESPACE_NAME TABLESPACE_NAME, TF.OWNER USERNAME, 
TF.SEGMENT_NAME OBJECT_NAME, TF.MAX_SCN MAX_SCN, TF.MIN_SCN MIN_SCN 
FROM "mdbadmin". SEGMENT_DICT TF, "mdbadmin". TABLESPACE TS WHERE 
TS.TABLESPACE_ID = TF.TABLESPACE_ID AND TF.TYPE#=2
\p\g
create view  MASTER_CUST_MET_CHANGE_VIEW ( COMPARE_ID, 
FIRST_COLLECT_ID, LAST_COLLECT_ID, METRIC_NAME, METRIC_VALUE_A, 
METRIC_VALUE_B, DATA_TYPE, PCT_CHANGE, OBJECT_NAME ) AS SELECT 
DISTINCT CI.COMPARE_ID, CI.FIRST_COLLECT_ID, CI.LAST_COLLECT_ID, 
A.METRIC_NAME, A.METRIC_STR_VALUE METRIC_VALUE_A , B.METRIC_STR_VALUE 
METRIC_VALUE_B , A.METRIC_STR_VALUE Data_Type, A.METRIC_VALUE 
Pct_Change, C.owner||'.'||C.Segment_name Object_name FROM "mdbadmin". 
USER_ANAL A , "mdbadmin". USER_ANAL B , "mdbadmin". SEGMENT_DICT C, 
"mdbadmin". SEGMENT_DICT D, "mdbadmin". COMPARE CI, "mdbadmin". 
COMPARE_OBJECT CO WHERE CI.FIRST_COLLECT_ID = A.COLLECT_ID AND 
CI.LAST_COLLECT_ID = B.COLLECT_ID AND CI.FIRST_COLLECT_ID = 
C.COLLECT_ID AND CI.LAST_COLLECT_ID = D.COLLECT_ID AND 
CI.COMPARE_ID=CO.COMPARE_ID AND CO.FIRST_OBJECT_ID = A.OBJECT_ID AND 
CO.LAST_OBJECT_ID = B.OBJECT_ID AND CO.FIRST_OBJECT_ID = C.OBJECT_ID 
AND CO.LAST_OBJECT_ID = D.OBJECT_ID
\p\g
create view  MASTER_CUSTOM_METRICS_VIEW ( COLLECT_ID, METRIC_NAME, 
METRIC_VALUE, DATA_TYPE, OBJECT_NAME ) AS SELECT A.COLLECT_ID, 
A.METRIC_NAME, A.METRIC_STR_VALUE METRIC_VALUE, A.METRIC_STR_VALUE 
Data_Type, B.owner||'.'||B.Segment_name Object_name FROM "mdbadmin". 
USER_ANAL A , "mdbadmin". SEGMENT_DICT B WHERE 
A.COLLECT_ID=B.COLLECT_ID AND A.OBJECT_ID=B.OBJECT_ID
\p\g
create view  MASTER_TAB_PRIV_VIEW ( COLLECT_ID, GRANTEE, GRANTOR, 
OWNER, TABLE_NAME, PRIVILEGE, GRANTABLE ) AS SELECT T.COLLECT_ID, 
UGE.USERNAME Grantee, UGR.USERNAME Grantor, C.USERNAME Owner, 
T.SEGMENT_NAME Table_Name, P.PRIVILEGE, P.GRANTABLE Grantable FROM 
"mdbadmin". USER_HEAD C, "mdbadmin". TAB_PRIV P, "mdbadmin". USER_HEAD
UGE, "mdbadmin". USER_HEAD UGR, "mdbadmin". SEGMENT_DICT T WHERE 
C.USER_HEAD_ID = P.OWNER_ID AND UGE.USER_HEAD_ID = P.GRANTEE_ID AND 
UGR.USER_HEAD_ID = P.GRANTOR_ID AND T.OBJECT_ID = P.TABLE_ID AND 
T.COLLECT_ID =P.COLLECT_ID
\p\g
create view  DAO_REORG_METRICS_VIEW ( MAX_VAL, MIN_VAL, METRIC_NAME ) 
AS SELECT A.MAX_VAL ,A.MIN_VAL ,M.METRIC_NAME FROM "mdbadmin". 
ANALYZER_METRIC M, "mdbadmin". DAO_REORG_DEF_METRICS A WHERE 
A.METRIC_ID = M.METRIC_ID
\p\g
create view  ORACLE_VERSIONS_VIEW ( COMPARE_ID, ORACLE_SID_A, 
ORACLE_SID_B, PARAM_NAME_A, PARAM_VALUE_A, PARAM_NAME_B, 
PARAM_VALUE_B, CHANGED ) AS SELECT CI.COMPARE_ID COMPARE_ID, 
SA.ORACLE_SID ORACLE_SID_A, SB.ORACLE_SID ORACLE_SID_B, SPA.PARAM_NAME
PARAM_NAME_A, SPA.PARAM_VALUE PARAM_VALUE_A, SPB.PARAM_NAME 
PARAM_NAME_B, SPB.PARAM_VALUE PARAM_VALUE_B, SPB.PARAM_VALUE Changed 
FROM "mdbadmin". SID SA, "mdbadmin". SID SB, "mdbadmin". SID_PARAM 
SPA, "mdbadmin". SID_PARAM SPB, "mdbadmin". COMPARE CI WHERE 
SPA.PARAM_NAME =SPB.PARAM_NAME AND SA.SID_ID = SPA.SID_ID AND 
SB.SID_ID = SPB.SID_ID AND CI.FIRST_COLLECT_ID = SA.COLLECT_ID AND 
CI.LAST_COLLECT_ID = SB.COLLECT_ID AND CI.FIRST_COLLECT_ID = 
SPA.COLLECT_ID AND CI.LAST_COLLECT_ID = SPB.COLLECT_ID
\p\g
create view  SCOPE_HEAD_VIEW ( SCOPE_HEAD_ID, Name , Version , 
CREATED_BY, "At Date" ) AS SELECT SCOPE_HEAD_ID, SCOPE_NAME "Name ", 
SCOPE_VERSION "Version ", CREATED_BY, CREATED_DATE "At Date" FROM 
"mdbadmin". SCOPE_HEAD
\p\g
create view  FILTER_COL_COM_VIEW ("FILTER_HEAD_ID","Name ",
"METRIC_NAME","MIN_VAL", "MAX_VAL","METRIC_INTERNAL","PATTERN_MATCH", 
"Oracle Version","LOW_PCT","HIGH_PCT") AS SELECT A.FILTER_HEAD_ID, 
A.Name, A.METRIC_NAME, A.MIN_VAL, A.MAX_VAL, A.METRIC_INTERNAL, 
A.PATTERN_MATCH, A."Oracle Version", B."Low Pct" Low_Pct, B."High Pct"
High_Pct FROM "mdbadmin". FILTER_COMPARE_VIEW B, "mdbadmin". 
FILTER_COLLECT_VIEW A WHERE A.FILTER_HEAD_ID = B.FILTER_HEAD_ID AND 
A.METRIC_NAME = B.METRIC_NAME UNION ALL SELECT A.FILTER_HEAD_ID, 
A.Name, A.METRIC_NAME, A.MIN_VAL, A.MAX_VAL, A.METRIC_INTERNAL, 
A.PATTERN_MATCH, A."Oracle Version", 0, 0 FROM "mdbadmin". 
FILTER_COLLECT_VIEW A UNION ALL SELECT B.FILTER_HEAD_ID, B.Name, 
B.METRIC_NAME, 0, 0, B.METRIC_INTERNAL, NULL, B."Oracle Version", 
B."Low Pct" Low_Pct, B."High Pct" High_Pct FROM "mdbadmin". 
FILTER_COMPARE_VIEW B
\p\g
create view  FILTER_HEAD_VIEW ( FILTER_HEAD_ID, Name , Version , 
"At Date", "Oracle Version", Inclusive ) AS SELECT FILTER_HEAD_ID, 
FILTER_NAME "Name ", FILTER_VERSION "Version ", CREATED_DATE "At Date"
, FILTER_ORA_VERSION "Oracle Version", FILTER_AND_OR "Inclusive " FROM
"mdbadmin". FILTER_HEAD
\p\g
create view  REPORT_HEAD_VIEW ( CATEGORY, REPORT_NAME, "Context ", 
"Default Filter", REPORT_HEAD_ID, FILTER_ID, "Cat ID", FILTER_CODE ) 
AS SELECT RC.CATEGORY, RH.REPORT_NAME, RH.REPORT_CONTEXT "Context ", 
F.FILTER_NAME "Default Filter", RH.REPORT_HEAD_ID, RH.FILTER_ID, 
RH.CATEGORY_ID "Cat ID", RH.FILTER_CODE Filter_Code FROM "mdbadmin". 
REPORT_HEAD RH, "mdbadmin". REPORT_CATEGORY RC, "mdbadmin". 
FILTER_HEAD F WHERE RC.REPORT_CATEGORY_ID = RH.CATEGORY_ID AND 
RH.FILTER_ID = F.FILTER_HEAD_ID UNION ALL SELECT RC.CATEGORY, 
RH.REPORT_NAME, RH.REPORT_CONTEXT "Context ", NULL "Default Filter", 
RH.REPORT_HEAD_ID, RH.FILTER_ID, RH.CATEGORY_ID, RH.FILTER_CODE 
Filter_Code FROM "mdbadmin". REPORT_HEAD RH, "mdbadmin". 
REPORT_CATEGORY RC WHERE RC.REPORT_CATEGORY_ID = RH.CATEGORY_ID AND 
RH.FILTER_ID IS NULL
\p\g
create view  METRIC_VIEW ( Name , CREATED_BY, CREATED_DATE, 
"Stored In", "Use DB", "Column" , Query , "Query Text", METRIC_ID, 
QUERY_ID ) AS SELECT M.METRIC_NAME "Name ", M.CREATED_BY, 
M.CREATED_DATE, Q.QUERY_SCOPE "Stored In", Q.QUERY_USE_DB "Use DB", 
M.COLUMN_NBR "Column ", Q.QUERY_NAME "Query ", Q.QUERY_TEXT 
"Query Text", M.METRIC_ID, Q.QUERY_ID FROM "mdbadmin". QUERY Q, 
"mdbadmin". ANALYZER_METRIC M WHERE Q.QUERY_ID = M.QUERY_ID
\p\g
create view  wvepComSMPNodeGroup AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.autoarrange_type,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtepComSMPNodeGroup r where m.uuid = r.uuid
\p\g
create view  wvepWorldSpace AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.autoarrange_type,r.* from "mdbadmin". tng_managedobject m, 
"mdbadmin". wtepWorldSpace r where m.uuid = r.uuid
\p\g
create view  wvepWorldSpaceRoot AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'epWorldSpaceRoot'
\p\g
create view  wvepWorldSpaceUnicenterProfile AS Select * from 
"mdbadmin". tng_managedobject where class_name = 'epWorldSpaceUnicente
rProfile'
\p\g
create view  wvepWorld_MSWin_pc AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_MSWin_pc r where m.uuid = r.uuid
\p\g
create view  wvepWorld_MSWin_s1 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_MSWin_s1 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_MSWin_c2 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_MSWin_c2 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_MSWin_c3 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_MSWin_c3 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_TSEnbl_pc AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_TSEnbl_pc r where m.uuid = r.uuid
\p\g
create view  wvepWorld_TSEnbl_s1 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_TSEnbl_s1 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_eCS_pc AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_eCS_pc r where m.uuid = r.uuid
\p\g
create view  wvepWorld_eCS_s2 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_eCS_s2 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_eCS_s3 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_eCS_s3 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_eCS_s4 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_eCS_s4 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_eCS_s5 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_eCS_s5 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_eCS_s1 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_eCS_s1 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_eCS_c6 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_eCS_c6 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_pc AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_pc r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s2 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s2 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s7 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s7 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s14 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s14 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s10 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s10 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s11 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s11 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s12 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s12 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s15 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s15 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s6 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s6 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_s3 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_s3 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_c8 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_c8 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_ePortal_c5 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_ePortal_c5 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_iTech_pc AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_iTech_pc r where m.uuid = r.uuid
\p\g
create view  wvepWorld_iTech_s5 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_iTech_s5 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_iTech_s7 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_iTech_s7 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_iTech_c3 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_iTech_c3 r where m.uuid = r.uuid
\p\g
create view  wvepWorld_iTech_c4 AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,
m.code_page,m.admin_status,m.DSM_Server,m.propagated_status_no,
m.propagated_sev,m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.autoarrange_type,
m.class_name,r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtepWorld_iTech_c4 r where m.uuid = r.uuid
\p\g
create view  wvAccess_Point AS Select m.name,m.label,m.address,
m.address_type,m.class_name,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtAccess_Point r where m.uuid = r.uuid
\p\g
create view  wvEricsson_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtEricsson_Access_Point r where m.uuid = r.uuid
\p\g
create view  wv_3COM_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wt_3COM_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvIntel_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtIntel_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvNortel_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtNortel_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvSymbol_1m_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtSymbol_1m_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvCisco_Aironet1200_Access_Point AS Select m.name,
m.label,m.address,m.address_type,m.status_no,m.hidden,
m.propagate_status,m.severity,m.posted,m.acknowledge,m.alarmset_name,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagedecal,m.override_imagetintbool,m.override_model,
m.background_image,m.weight,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.override_imagelarge,
m.override_imagesmall,m.interface_type,m.subnet_mask,m.ip_address_hex,
r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtCisco_Aironet1200_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvCisco_Aironet340_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtCisco_Aironet340_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvCisco_Aironet350_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtCisco_Aironet350_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvSymbol80211_1_2m_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtSymbol80211_1_2m_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvSymbol80211_11m_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtSymbol80211_11m_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvCompaq_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtCompaq_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvWireless_Domain AS Select m.name,m.label,m.address,
m.status_no,m.hidden,m.propagate_status,m.severity,m.posted,
m.acknowledge,m.alarmset_name,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagelarge,m.override_imagesmall,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.address_type,m.interface_type,m.autoarrange_type,r.* from "mdbadmin"
. tng_managedobject m, "mdbadmin". wtWireless_Domain r where m.uuid = 
r.uuid
\p\g
create view  wvWireless_Network AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'Wireless_Network'
\p\g
create view  wvWirelessUnit AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'WirelessUnit'
\p\g
create view  wvSuspectAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtSuspectAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvBelkinAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtBelkinAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvNetgearAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtNetgearAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvLinksysAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtLinksysAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvRoamAboutAccessPoint AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtRoamAboutAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvKarlNetAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtKarlNetAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvSMCAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtSMCAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvOrinocoAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtOrinocoAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvBreezeCOMAccessPoint AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtBreezeCOMAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvEthAirNetAccessPoint AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtEthAirNetAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvAvayaAccessPoint AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtAvayaAccessPoint r where m.uuid = r.uuid
\p\g
create view  wvBuffalo_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtBuffalo_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvCisco_Aironet1100_Access_Point AS Select m.name,
m.label,m.address,m.address_type,m.status_no,m.hidden,
m.propagate_status,m.severity,m.posted,m.acknowledge,m.alarmset_name,
m.autoarrange_type,m.date_ins,m.date_modify,m.code_page,
m.admin_status,m.DSM_Server,m.propagated_status_no,m.propagated_sev,
m.DSM_Address,m.license_machine_type,m.create_bpv,
m.override_imagedecal,m.override_imagetintbool,m.override_model,
m.background_image,m.weight,m.weighted_severity,m.Max_Sev,
m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,m.class_name,m.override_imagelarge,
m.override_imagesmall,m.interface_type,m.subnet_mask,m.ip_address_hex,
r.* from "mdbadmin". tng_managedobject m, "mdbadmin". 
wtCisco_Aironet1100_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvDLink_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtDLink_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvEntrasys_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtEntrasys_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvIBM_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtIBM_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvHawking_Access_Point AS Select m.name,m.label,
m.address,m.address_type,m.status_no,m.hidden,m.propagate_status,
m.severity,m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,
m.date_ins,m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtHawking_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvProxim_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtProxim_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvUSR_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtUSR_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvRogue_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtRogue_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvAdhoc_Access_Point AS Select m.name,m.label,m.address,
m.address_type,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagedecal,
m.override_imagetintbool,m.override_model,m.background_image,m.weight,
m.weighted_severity,m.Max_Sev,m.user_reclass,m.Asset_uuid,
m.source_repository,m.dnsname,m.last_seen_time,m.class_name,
m.override_imagelarge,m.override_imagesmall,m.interface_type,
m.subnet_mask,m.ip_address_hex,r.* from "mdbadmin". tng_managedobject 
m, "mdbadmin". wtAdhoc_Access_Point r where m.uuid = r.uuid
\p\g
create view  wvURM AS Select m.name,m.label,m.address,m.address_type,
m.class_name,m.status_no,m.hidden,m.propagate_status,m.severity,
m.posted,m.acknowledge,m.alarmset_name,m.autoarrange_type,m.date_ins,
m.date_modify,m.code_page,m.admin_status,m.DSM_Server,
m.propagated_status_no,m.propagated_sev,m.DSM_Address,
m.license_machine_type,m.create_bpv,m.override_imagelarge,
m.override_imagesmall,m.override_imagedecal,m.override_imagetintbool,
m.override_model,m.background_image,m.weight,m.weighted_severity,
m.Max_Sev,m.user_reclass,m.Asset_uuid,m.source_repository,m.dnsname,
m.last_seen_time,r.* from "mdbadmin". tng_managedobject m, "mdbadmin".
wtURM r where m.uuid = r.uuid
\p\g
create view  wvURMIPRes AS Select * from "mdbadmin". tng_managedobject
where class_name = 'URMIPRes'
\p\g
create view  wvURMIPAlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMIPAlarmResource'
\p\g
create view  wvURMIPPortAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMIPPortAlarm'
\p\g
create view  wvURMIPGenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMIPGenAlarm'
\p\g
create view  wvURMWinRes AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinRes'
\p\g
create view  wvURMWinAlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinAlarmResource'
\p\g
create view  wvURMWinPerfAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinPerfAlarm'
\p\g
create view  wvURMWinProcAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinProcAlarm'
\p\g
create view  wvURMWinRKeyAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinRKeyAlarm'
\p\g
create view  wvURMWinSnapAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinSnapAlarm'
\p\g
create view  wvURMWinServAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinServAlarm'
\p\g
create view  wvURMWinGenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMWinGenAlarm'
\p\g
create view  wvURMUnixRes AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMUnixRes'
\p\g
create view  wvURMSUNAlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMSUNAlarmResource'
\p\g
create view  wvURMSUNGenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMSUNGenAlarm'
\p\g
create view  wvURMSUNPerfAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMSUNPerfAlarm'
\p\g
create view  wvURMSUNInstAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMSUNInstAlarm'
\p\g
create view  wvURMHPAlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMHPAlarmResource'
\p\g
create view  wvURMHPGenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMHPGenAlarm'
\p\g
create view  wvURMHPPerfAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMHPPerfAlarm'
\p\g
create view  wvURMHPInstAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMHPInstAlarm'
\p\g
create view  wvURMAIXAlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMAIXAlarmResource'
\p\g
create view  wvURMAIXGenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMAIXGenAlarm'
\p\g
create view  wvURMAIXPerfAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMAIXPerfAlarm'
\p\g
create view  wvURMAIXInstAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMAIXInstAlarm'
\p\g
create view  wvURMLINUXAlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMLINUXAlarmResource'
\p\g
create view  wvURMLINUXGenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMLINUXGenAlarm'
\p\g
create view  wvURMLINUXPerfAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMLINUXPerfAlarm'
\p\g
create view  wvURMLINUXInstAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMLINUXInstAlarm'
\p\g
create view  wvURMTru64AlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMTru64AlarmResource'
\p\g
create view  wvURMTru64GenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMTru64GenAlarm'
\p\g
create view  wvURMTru64PerfAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMTru64PerfAlarm'
\p\g
create view  wvURMTru64InstAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMTru64InstAlarm'
\p\g
create view  wvURMMacRes AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMMacRes'
\p\g
create view  wvURMMACAlarmResource AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMMACAlarmResource'
\p\g
create view  wvURMMacOSXGenAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMMacOSXGenAlarm'
\p\g
create view  wvURMMacOSXPerfAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMMacOSXPerfAlarm'
\p\g
create view  wvURMMacOSXInstAlarm AS Select * from "mdbadmin". 
tng_managedobject where class_name = 'URMMacOSXInstAlarm'
\p\g

	/* PROCEDURES */
create procedure del_db_application_db_object as begin return; end
\p\g
grant execute on procedure del_db_application_db_object to public
\p\g
create procedure del_db_column_db_object as begin return; end
\p\g
grant execute on procedure del_db_column_db_object to public
\p\g
create procedure del_db_datatype_db_object as begin return; end
\p\g
grant execute on procedure del_db_datatype_db_object to public
\p\g
create procedure del_db_field_db_object as begin return; end
\p\g
grant execute on procedure del_db_field_db_object to public
\p\g
create procedure del_db_gator_db_object as begin return; end
\p\g
grant execute on procedure del_db_gator_db_object to public
\p\g
create procedure del_db_gatorstar_db_gator as begin return; end
\p\g
grant execute on procedure del_db_gatorstar_db_gator to public
\p\g
create procedure del_db_gatorstar_db_star as begin return; end
\p\g
grant execute on procedure del_db_gatorstar_db_star to public
\p\g
create procedure del_db_index_db_object as begin return; end
\p\g
grant execute on procedure del_db_index_db_object to public
\p\g
create procedure del_db_indexcol_db_column as begin return; end
\p\g
grant execute on procedure del_db_indexcol_db_column to public
\p\g
create procedure del_db_indexcol_db_index as begin return; end
\p\g
grant execute on procedure del_db_indexcol_db_index to public
\p\g
create procedure del_db_infoblob_db_object as begin return; end
\p\g
grant execute on procedure del_db_infoblob_db_object to public
\p\g
create procedure del_db_layout_db_object as begin return; end
\p\g
grant execute on procedure del_db_layout_db_object to public
\p\g
create procedure del_db_object_db_object as begin return; end
\p\g
grant execute on procedure del_db_object_db_object to public
\p\g
create procedure del_db_op_db_object as begin return; end
\p\g
grant execute on procedure del_db_op_db_object to public
\p\g
create procedure del_db_opsegment_db_op as begin return; end
\p\g
grant execute on procedure del_db_opsegment_db_op to public
\p\g
create procedure del_db_parameter_db_object as begin return; end
\p\g
grant execute on procedure del_db_parameter_db_object to public
\p\g
create procedure del_db_program_db_object as begin return; end
\p\g
grant execute on procedure del_db_program_db_object to public
\p\g
create procedure del_db_programinstance_db_object as begin return; end
\p\g
grant execute on procedure del_db_programinstance_db_object to public
\p\g
create procedure del_db_programtype_db_object as begin return; end
\p\g
grant execute on procedure del_db_programtype_db_object to public
\p\g
create procedure del_db_programtypemisc_db_object as begin return; end
\p\g
grant execute on procedure del_db_programtypemisc_db_object to public
\p\g
create procedure del_db_psafile_db_object as begin return; end
\p\g
grant execute on procedure del_db_psafile_db_object to public
\p\g
create procedure del_db_seqcolumn_db_column as begin return; end
\p\g
grant execute on procedure del_db_seqcolumn_db_column to public
\p\g
create procedure del_db_seqtable_db_table as begin return; end
\p\g
grant execute on procedure del_db_seqtable_db_table to public
\p\g
create procedure del_db_servertype_db_object as begin return; end
\p\g
grant execute on procedure del_db_servertype_db_object to public
\p\g
create procedure del_db_star_db_object as begin return; end
\p\g
grant execute on procedure del_db_star_db_object to public
\p\g
create procedure del_db_startable_db_table as begin return; end
\p\g
grant execute on procedure del_db_startable_db_table to public
\p\g
create procedure del_db_table_db_object as begin return; end
\p\g
grant execute on procedure del_db_table_db_object to public
\p\g
create procedure del_db_wkf_db_object as begin return; end
\p\g
grant execute on procedure del_db_wkf_db_object to public
\p\g
create procedure del_db_wkfconnection_db_object as begin return; end
\p\g
grant execute on procedure del_db_wkfconnection_db_object to public
\p\g
create procedure del_ddcolumn_ddtable as begin return; end
\p\g
grant execute on procedure del_ddcolumn_ddtable to public
\p\g
create procedure del_ddtable_execution as begin return; end
\p\g
grant execute on procedure del_ddtable_execution to public
\p\g
create procedure del_ddtablemodify_execution as begin return; end
\p\g
grant execute on procedure del_ddtablemodify_execution to public
\p\g
create procedure del_error_execution as begin return; end
\p\g
grant execute on procedure del_error_execution to public
\p\g
create procedure del_execution_lookoutserver as begin return; end
\p\g
grant execute on procedure del_execution_lookoutserver to public
\p\g
create procedure del_execution_request as begin return; end
\p\g
grant execute on procedure del_execution_request to public
\p\g
create procedure del_lookoutcontrol_lookoutserver as begin return; end
\p\g
grant execute on procedure del_lookoutcontrol_lookoutserver to public
\p\g
create procedure del_object_ipuser as begin return; end
\p\g
grant execute on procedure del_object_ipuser to public
\p\g
create procedure del_permissions_object as begin return; end
\p\g
grant execute on procedure del_permissions_object to public
\p\g
create procedure del_provider_object as begin return; end
\p\g
grant execute on procedure del_provider_object to public
\p\g
create procedure del_rdbms_provider_object as begin return; end
\p\g
grant execute on procedure del_rdbms_provider_object to public
\p\g
create procedure del_request_object as begin return; end
\p\g
grant execute on procedure del_request_object to public
\p\g
create procedure del_requestprovider_provider as begin return; end
\p\g
grant execute on procedure del_requestprovider_provider to public
\p\g
create procedure del_requestprovider_request as begin return; end
\p\g
grant execute on procedure del_requestprovider_request to public
\p\g
create procedure del_requestqueue_request as begin return; end
\p\g
grant execute on procedure del_requestqueue_request to public
\p\g
create procedure del_scriptmessagelog_execution as begin return; end
\p\g
grant execute on procedure del_scriptmessagelog_execution to public
\p\g
create procedure del_simplerequest_request as begin return; end
\p\g
grant execute on procedure del_simplerequest_request to public
\p\g
create procedure increment_id as begin return; end
\p\g
grant execute on procedure increment_id to public
\p\g
create procedure next_sequence_value as begin return; end
\p\g
grant execute on procedure next_sequence_value to public
\p\g
create procedure pd_cluster as begin return; end
\p\g
grant execute on procedure pd_cluster to public
\p\g
create procedure pd_collector as begin return; end
\p\g
grant execute on procedure pd_collector to public
\p\g
create procedure pd_collectoraction as begin return; end
\p\g
grant execute on procedure pd_collectoraction to public
\p\g
create procedure pd_columndefinition as begin return; end
\p\g
grant execute on procedure pd_columndefinition to public
\p\g
create procedure pd_connectortype as begin return; end
\p\g
grant execute on procedure pd_connectortype to public
\p\g
create procedure pd_counterdefinition as begin return; end
\p\g
grant execute on procedure pd_counterdefinition to public
\p\g
create procedure pd_countersource as begin return; end
\p\g
grant execute on procedure pd_countersource to public
\p\g
create procedure pd_dominoeventtype as begin return; end
\p\g
grant execute on procedure pd_dominoeventtype to public
\p\g
create procedure pd_dominologeventtype as begin return; end
\p\g
grant execute on procedure pd_dominologeventtype to public
\p\g
create procedure pd_errormessage as begin return; end
\p\g
grant execute on procedure pd_errormessage to public
\p\g
create procedure pd_eventseverity as begin return; end
\p\g
grant execute on procedure pd_eventseverity to public
\p\g
create procedure pd_eventtype as begin return; end
\p\g
grant execute on procedure pd_eventtype to public
\p\g
create procedure pd_indextable as begin return; end
\p\g
grant execute on procedure pd_indextable to public
\p\g
create procedure pd_mailconnector as begin return; end
\p\g
grant execute on procedure pd_mailconnector to public
\p\g
create procedure pd_maildb as begin return; end
\p\g
grant execute on procedure pd_maildb to public
\p\g
create procedure pd_maildisk as begin return; end
\p\g
grant execute on procedure pd_maildisk to public
\p\g
create procedure pd_maildomain as begin return; end
\p\g
grant execute on procedure pd_maildomain to public
\p\g
create procedure pd_mailevent as begin return; end
\p\g
grant execute on procedure pd_mailevent to public
\p\g
create procedure pd_mailobject as begin return; end
\p\g
grant execute on procedure pd_mailobject to public
\p\g
create procedure pd_mailorganisation as begin return; end
\p\g
grant execute on procedure pd_mailorganisation to public
\p\g
create procedure pd_mailqueue as begin return; end
\p\g
grant execute on procedure pd_mailqueue to public
\p\g
create procedure pd_mailservice as begin return; end
\p\g
grant execute on procedure pd_mailservice to public
\p\g
create procedure pd_mib as begin return; end
\p\g
grant execute on procedure pd_mib to public
\p\g
create procedure pd_mibdefinition as begin return; end
\p\g
grant execute on procedure pd_mibdefinition to public
\p\g
create procedure pd_mibstructure as begin return; end
\p\g
grant execute on procedure pd_mibstructure to public
\p\g
create procedure pd_mibvariabletype as begin return; end
\p\g
grant execute on procedure pd_mibvariabletype to public
\p\g
create procedure pd_objects as begin return; end
\p\g
grant execute on procedure pd_objects to public
\p\g
create procedure pd_person as begin return; end
\p\g
grant execute on procedure pd_person to public
\p\g
create procedure pd_report as begin return; end
\p\g
grant execute on procedure pd_report to public
\p\g
create procedure pd_reportcolumn as begin return; end
\p\g
grant execute on procedure pd_reportcolumn to public
\p\g
create procedure pd_reporttabledefinition as begin return; end
\p\g
grant execute on procedure pd_reporttabledefinition to public
\p\g
create procedure pd_site as begin return; end
\p\g
grant execute on procedure pd_site to public
\p\g
create procedure pd_solutiondescription as begin return; end
\p\g
grant execute on procedure pd_solutiondescription to public
\p\g
create procedure pd_sourcelocale as begin return; end
\p\g
grant execute on procedure pd_sourcelocale to public
\p\g
create procedure pd_tabledefinition as begin return; end
\p\g
grant execute on procedure pd_tabledefinition to public
\p\g
create procedure pd_tau_mdb as begin return; end
\p\g
grant execute on procedure pd_tau_mdb to public
\p\g
create procedure pd_tau_product as begin return; end
\p\g
grant execute on procedure pd_tau_product to public
\p\g
create procedure pd_unit as begin return; end
\p\g
grant execute on procedure pd_unit to public
\p\g
create procedure pdgetnextbpvid as begin return; end
\p\g
grant execute on procedure pdgetnextbpvid to public
\p\g
create procedure pdgetnextdayid as begin return; end
\p\g
grant execute on procedure pdgetnextdayid to public
\p\g
create procedure pdgetnextmachineid as begin return; end
\p\g
grant execute on procedure pdgetnextmachineid to public
\p\g
create procedure pdgetnextresid as begin return; end
\p\g
grant execute on procedure pdgetnextresid to public
\p\g
create procedure pfullcountername as begin return; end
\p\g
grant execute on procedure pfullcountername to public
\p\g
create procedure pi_alert as begin return; end
\p\g
grant execute on procedure pi_alert to public
\p\g
create procedure pi_collector as begin return; end
\p\g
grant execute on procedure pi_collector to public
\p\g
create procedure pi_collectorpolling as begin return; end
\p\g
grant execute on procedure pi_collectorpolling to public
\p\g
create procedure pi_columndefinition as begin return; end
\p\g
grant execute on procedure pi_columndefinition to public
\p\g
create procedure pi_componentofindex as begin return; end
\p\g
grant execute on procedure pi_componentofindex to public
\p\g
create procedure pi_counterdata as begin return; end
\p\g
grant execute on procedure pi_counterdata to public
\p\g
create procedure pi_counterpolling as begin return; end
\p\g
grant execute on procedure pi_counterpolling to public
\p\g
create procedure pi_countersource as begin return; end
\p\g
grant execute on procedure pi_countersource to public
\p\g
create procedure pi_countertitle as begin return; end
\p\g
grant execute on procedure pi_countertitle to public
\p\g
create procedure pi_discoveryvariable as begin return; end
\p\g
grant execute on procedure pi_discoveryvariable to public
\p\g
create procedure pi_errorsolution as begin return; end
\p\g
grant execute on procedure pi_errorsolution to public
\p\g
create procedure pi_gdcdiscovery as begin return; end
\p\g
grant execute on procedure pi_gdcdiscovery to public
\p\g
create procedure pi_mailconnector as begin return; end
\p\g
grant execute on procedure pi_mailconnector to public
\p\g
create procedure pi_maildb as begin return; end
\p\g
grant execute on procedure pi_maildb to public
\p\g
create procedure pi_maildisk as begin return; end
\p\g
grant execute on procedure pi_maildisk to public
\p\g
create procedure pi_maildomain as begin return; end
\p\g
grant execute on procedure pi_maildomain to public
\p\g
create procedure pi_mailevent as begin return; end
\p\g
grant execute on procedure pi_mailevent to public
\p\g
create procedure pi_mailobject as begin return; end
\p\g
grant execute on procedure pi_mailobject to public
\p\g
create procedure pi_mailqueue as begin return; end
\p\g
grant execute on procedure pi_mailqueue to public
\p\g
create procedure pi_mailservice as begin return; end
\p\g
grant execute on procedure pi_mailservice to public
\p\g
create procedure pi_mibdefinition as begin return; end
\p\g
grant execute on procedure pi_mibdefinition to public
\p\g
create procedure pi_mibstructure as begin return; end
\p\g
grant execute on procedure pi_mibstructure to public
\p\g
create procedure pi_mibvariabletype as begin return; end
\p\g
grant execute on procedure pi_mibvariabletype to public
\p\g
create procedure pi_objects as begin return; end
\p\g
grant execute on procedure pi_objects to public
\p\g
create procedure pi_person as begin return; end
\p\g
grant execute on procedure pi_person to public
\p\g
create procedure pi_pollrowdefinition as begin return; end
\p\g
grant execute on procedure pi_pollrowdefinition to public
\p\g
create procedure pi_reportcolumn as begin return; end
\p\g
grant execute on procedure pi_reportcolumn to public
\p\g
create procedure pi_reporttable as begin return; end
\p\g
grant execute on procedure pi_reporttable to public
\p\g
create procedure pi_resourcemonitoring as begin return; end
\p\g
grant execute on procedure pi_resourcemonitoring to public
\p\g
create procedure pi_schedule as begin return; end
\p\g
grant execute on procedure pi_schedule to public
\p\g
create procedure pi_site as begin return; end
\p\g
grant execute on procedure pi_site to public
\p\g
create procedure pi_tablesdescription as begin return; end
\p\g
grant execute on procedure pi_tablesdescription to public
\p\g
create procedure pi_tau_mdb_product as begin return; end
\p\g
grant execute on procedure pi_tau_mdb_product to public
\p\g
create procedure pu_alert as begin return; end
\p\g
grant execute on procedure pu_alert to public
\p\g
create procedure pu_cluster as begin return; end
\p\g
grant execute on procedure pu_cluster to public
\p\g
create procedure pu_collector as begin return; end
\p\g
grant execute on procedure pu_collector to public
\p\g
create procedure pu_collectorpolling as begin return; end
\p\g
grant execute on procedure pu_collectorpolling to public
\p\g
create procedure pu_columndefinition as begin return; end
\p\g
grant execute on procedure pu_columndefinition to public
\p\g
create procedure pu_componentofindex as begin return; end
\p\g
grant execute on procedure pu_componentofindex to public
\p\g
create procedure pu_connectortype as begin return; end
\p\g
grant execute on procedure pu_connectortype to public
\p\g
create procedure pu_counterdata as begin return; end
\p\g
grant execute on procedure pu_counterdata to public
\p\g
create procedure pu_counterpolling as begin return; end
\p\g
grant execute on procedure pu_counterpolling to public
\p\g
create procedure pu_countersource as begin return; end
\p\g
grant execute on procedure pu_countersource to public
\p\g
create procedure pu_countertitle as begin return; end
\p\g
grant execute on procedure pu_countertitle to public
\p\g
create procedure pu_discoveryvariable as begin return; end
\p\g
grant execute on procedure pu_discoveryvariable to public
\p\g
create procedure pu_dominoeventtype as begin return; end
\p\g
grant execute on procedure pu_dominoeventtype to public
\p\g
create procedure pu_dominologeventtype as begin return; end
\p\g
grant execute on procedure pu_dominologeventtype to public
\p\g
create procedure pu_errormessage as begin return; end
\p\g
grant execute on procedure pu_errormessage to public
\p\g
create procedure pu_errorsolution as begin return; end
\p\g
grant execute on procedure pu_errorsolution to public
\p\g
create procedure pu_eventseverity as begin return; end
\p\g
grant execute on procedure pu_eventseverity to public
\p\g
create procedure pu_eventtype as begin return; end
\p\g
grant execute on procedure pu_eventtype to public
\p\g
create procedure pu_gdcdiscovery as begin return; end
\p\g
grant execute on procedure pu_gdcdiscovery to public
\p\g
create procedure pu_indextable as begin return; end
\p\g
grant execute on procedure pu_indextable to public
\p\g
create procedure pu_mailconnector as begin return; end
\p\g
grant execute on procedure pu_mailconnector to public
\p\g
create procedure pu_maildb as begin return; end
\p\g
grant execute on procedure pu_maildb to public
\p\g
create procedure pu_maildisk as begin return; end
\p\g
grant execute on procedure pu_maildisk to public
\p\g
create procedure pu_maildomain as begin return; end
\p\g
grant execute on procedure pu_maildomain to public
\p\g
create procedure pu_mailevent as begin return; end
\p\g
grant execute on procedure pu_mailevent to public
\p\g
create procedure pu_mailobject as begin return; end
\p\g
grant execute on procedure pu_mailobject to public
\p\g
create procedure pu_mailorganisation as begin return; end
\p\g
grant execute on procedure pu_mailorganisation to public
\p\g
create procedure pu_mailqueue as begin return; end
\p\g
grant execute on procedure pu_mailqueue to public
\p\g
create procedure pu_mailservice as begin return; end
\p\g
grant execute on procedure pu_mailservice to public
\p\g
create procedure pu_mibdefinition as begin return; end
\p\g
grant execute on procedure pu_mibdefinition to public
\p\g
create procedure pu_mibstructure as begin return; end
\p\g
grant execute on procedure pu_mibstructure to public
\p\g
create procedure pu_mibvariabletype as begin return; end
\p\g
grant execute on procedure pu_mibvariabletype to public
\p\g
create procedure pu_objects as begin return; end
\p\g
grant execute on procedure pu_objects to public
\p\g
create procedure pu_person as begin return; end
\p\g
grant execute on procedure pu_person to public
\p\g
create procedure pu_pollrowdefinition as begin return; end
\p\g
grant execute on procedure pu_pollrowdefinition to public
\p\g
create procedure pu_reportcolumn as begin return; end
\p\g
grant execute on procedure pu_reportcolumn to public
\p\g
create procedure pu_reporttable as begin return; end
\p\g
grant execute on procedure pu_reporttable to public
\p\g
create procedure pu_resourcemonitoring as begin return; end
\p\g
grant execute on procedure pu_resourcemonitoring to public
\p\g
create procedure pu_schedule as begin return; end
\p\g
grant execute on procedure pu_schedule to public
\p\g
create procedure pu_site as begin return; end
\p\g
grant execute on procedure pu_site to public
\p\g
create procedure pu_solutiondescription as begin return; end
\p\g
grant execute on procedure pu_solutiondescription to public
\p\g
create procedure pu_sourcelocale as begin return; end
\p\g
grant execute on procedure pu_sourcelocale to public
\p\g
create procedure pu_tabledefinition as begin return; end
\p\g
grant execute on procedure pu_tabledefinition to public
\p\g
create procedure pu_tablesdescription as begin return; end
\p\g
grant execute on procedure pu_tablesdescription to public
\p\g
create procedure pu_tau_mdb as begin return; end
\p\g
grant execute on procedure pu_tau_mdb to public
\p\g
create procedure pu_tau_mdb_product as begin return; end
\p\g
grant execute on procedure pu_tau_mdb_product to public
\p\g
create procedure pu_tau_product as begin return; end
\p\g
grant execute on procedure pu_tau_product to public
\p\g
create procedure tng_add_2d_icon as begin return; end
\p\g
grant execute on procedure tng_add_2d_icon to public
\p\g
create procedure tng_add_3d_icon as begin return; end
\p\g
grant execute on procedure tng_add_3d_icon to public
\p\g
create procedure tng_add_alarmset as begin return; end
\p\g
grant execute on procedure tng_add_alarmset to public
\p\g
create procedure tng_add_auth as begin return; end
\p\g
grant execute on procedure tng_add_auth to public
\p\g
create procedure tng_add_class as begin return; end
\p\g
grant execute on procedure tng_add_class to public
\p\g
create procedure tng_add_class_ext as begin return; end
\p\g
grant execute on procedure tng_add_class_ext to public
\p\g
create procedure tng_add_managedobject as begin return; end
\p\g
grant execute on procedure tng_add_managedobject to public
\p\g
create procedure tng_add_manuf as begin return; end
\p\g
grant execute on procedure tng_add_manuf to public
\p\g
create procedure tng_add_method as begin return; end
\p\g
grant execute on procedure tng_add_method to public
\p\g
create procedure tng_add_pollset as begin return; end
\p\g
grant execute on procedure tng_add_pollset to public
\p\g
create procedure tng_add_propertydef as begin return; end
\p\g
grant execute on procedure tng_add_propertydef to public
\p\g
create procedure tng_add_sysobjid as begin return; end
\p\g
grant execute on procedure tng_add_sysobjid to public
\p\g
create procedure tng_add_to_alarmset_entry as begin return; end
\p\g
grant execute on procedure tng_add_to_alarmset_entry to public
\p\g
create procedure tng_ca_add_subnet1 as begin return; end
\p\g
grant execute on procedure tng_ca_add_subnet1 to public
\p\g
create procedure tng_ca_add_subnet2 as begin return; end
\p\g
grant execute on procedure tng_ca_add_subnet2 to public
\p\g
create procedure tng_ca_claim_discovery as begin return; end
\p\g
grant execute on procedure tng_ca_claim_discovery to public
\p\g
create procedure tng_ca_update_discovery_setup as begin return; end
\p\g
grant execute on procedure tng_ca_update_discovery_setup to public
\p\g
create procedure tng_ca_update_discovery_status as begin return; end
\p\g
grant execute on procedure tng_ca_update_discovery_status to public
\p\g
create procedure tng_clean_change_history as begin return; end
\p\g
grant execute on procedure tng_clean_change_history to public
\p\g
create procedure tng_clean_prop_status_history as begin return; end
\p\g
grant execute on procedure tng_clean_prop_status_history to public
\p\g
create procedure tng_clean_status_history as begin return; end
\p\g
grant execute on procedure tng_clean_status_history to public
\p\g
create procedure tng_columnupdated as begin return; end
\p\g
grant execute on procedure tng_columnupdated to public
\p\g
create procedure tng_del_uncls_w_name_option_ip as begin return; end
\p\g
grant execute on procedure tng_del_uncls_w_name_option_ip to public
\p\g
create procedure tng_deluncls_ipdiffname_uptclsip as begin return; end
\p\g
grant execute on procedure tng_deluncls_ipdiffname_uptclsip to public
\p\g
create procedure tng_discovery_get_community as begin return; end
\p\g
grant execute on procedure tng_discovery_get_community to public
\p\g
create procedure tng_discovery_get_drg_swtypes as begin return; end
\p\g
grant execute on procedure tng_discovery_get_drg_swtypes to public
\p\g
create procedure tng_discovery_get_ip_subnet as begin return; end
\p\g
grant execute on procedure tng_discovery_get_ip_subnet to public
\p\g
create procedure tng_discovery_get_lookup as begin return; end
\p\g
grant execute on procedure tng_discovery_get_lookup to public
\p\g
create procedure tng_discovery_get_setup_date as begin return; end
\p\g
grant execute on procedure tng_discovery_get_setup_date to public
\p\g
create procedure tng_get_class_id as begin return; end
\p\g
grant execute on procedure tng_get_class_id to public
\p\g
create procedure tng_get_class_ilp as begin return; end
\p\g
grant execute on procedure tng_get_class_ilp to public
\p\g
create procedure tng_get_discovery_ipsubnet_id as begin return; end
\p\g
grant execute on procedure tng_get_discovery_ipsubnet_id to public
\p\g
create procedure tng_get_id as begin return; end
\p\g
grant execute on procedure tng_get_id to public
\p\g
create procedure tng_get_if_uuid as begin return; end
\p\g
grant execute on procedure tng_get_if_uuid to public
\p\g
create procedure tng_get_network_class as begin return; end
\p\g
grant execute on procedure tng_get_network_class to public
\p\g
create procedure tng_get_segment_name as begin return; end
\p\g
grant execute on procedure tng_get_segment_name to public
\p\g
create procedure tng_get_subnet_if_connect_to as begin return; end
\p\g
grant execute on procedure tng_get_subnet_if_connect_to to public
\p\g
create procedure tng_get_super_class_name as begin return; end
\p\g
grant execute on procedure tng_get_super_class_name to public
\p\g
create procedure tng_get_uuid_classname_by_name as begin return; end
\p\g
grant execute on procedure tng_get_uuid_classname_by_name to public
\p\g
create procedure tng_iphex2str_nd as begin return; end
\p\g
grant execute on procedure tng_iphex2str_nd to public
\p\g
create procedure tng_ipstr2iphex as begin return; end
\p\g
grant execute on procedure tng_ipstr2iphex to public
\p\g
create procedure tng_is_attr_same_as_superclass as begin return; end
\p\g
grant execute on procedure tng_is_attr_same_as_superclass to public
\p\g
create procedure tng_is_man_obj_exist_w_sameip as begin return; end
\p\g
grant execute on procedure tng_is_man_obj_exist_w_sameip to public
\p\g
create procedure tng_is_obj_exist_class_name_ip as begin return; end
\p\g
grant execute on procedure tng_is_obj_exist_class_name_ip to public
\p\g
create procedure tng_is_obj_exist_w_name_diff_ip as begin return; end
\p\g
grant execute on procedure tng_is_obj_exist_w_name_diff_ip to public
\p\g
create procedure tng_is_same_property as begin return; end
\p\g
grant execute on procedure tng_is_same_property to public
\p\g
create procedure tng_isdiffclssameipnameexist as begin return; end
\p\g
grant execute on procedure tng_isdiffclssameipnameexist to public
\p\g
create procedure tng_log_change_hist as begin return; end
\p\g
grant execute on procedure tng_log_change_hist to public
\p\g
create procedure tng_log_status_hist as begin return; end
\p\g
grant execute on procedure tng_log_status_hist to public
\p\g
create procedure tng_manag_all_discovery_ipsubnet as begin return; end
\p\g
grant execute on procedure tng_manag_all_discovery_ipsubnet to public
\p\g
create procedure tng_senderror as begin return; end
\p\g
grant execute on procedure tng_senderror to public
\p\g
create procedure tng_setup_status as begin return; end
\p\g
grant execute on procedure tng_setup_status to public
\p\g
create procedure tng_td_inclusion as begin return; end
\p\g
grant execute on procedure tng_td_inclusion to public
\p\g
create procedure tng_td_jii_inclusion as begin return; end
\p\g
grant execute on procedure tng_td_jii_inclusion to public
\p\g
create procedure tng_td_link as begin return; end
\p\g
grant execute on procedure tng_td_link to public
\p\g
create procedure tng_td_managedobject as begin return; end
\p\g
grant execute on procedure tng_td_managedobject to public
\p\g
create procedure tng_ti_class_prop as begin return; end
\p\g
grant execute on procedure tng_ti_class_prop to public
\p\g
create procedure tng_ti_inclusion as begin return; end
\p\g
grant execute on procedure tng_ti_inclusion to public
\p\g
create procedure tng_ti_jii_inclusion as begin return; end
\p\g
grant execute on procedure tng_ti_jii_inclusion to public
\p\g
create procedure tng_ti_link as begin return; end
\p\g
grant execute on procedure tng_ti_link to public
\p\g
create procedure tng_ti_managedobject as begin return; end
\p\g
grant execute on procedure tng_ti_managedobject to public
\p\g
create procedure tng_tu_class_prop as begin return; end
\p\g
grant execute on procedure tng_tu_class_prop to public
\p\g
create procedure tng_tu_inclusion as begin return; end
\p\g
grant execute on procedure tng_tu_inclusion to public
\p\g
create procedure tng_tu_jii_inclusion as begin return; end
\p\g
grant execute on procedure tng_tu_jii_inclusion to public
\p\g
create procedure tng_tu_link_change_hist as begin return; end
\p\g
grant execute on procedure tng_tu_link_change_hist to public
\p\g
create procedure tng_tu_link_del_implinks_proc as begin return; end
\p\g
grant execute on procedure tng_tu_link_del_implinks_proc to public
\p\g
create procedure tng_tu_link_status_hist as begin return; end
\p\g
grant execute on procedure tng_tu_link_status_hist to public
\p\g
create procedure tng_tu_link_update_err as begin return; end
\p\g
grant execute on procedure tng_tu_link_update_err to public
\p\g
create procedure tng_tu_manobj_change_hist as begin return; end
\p\g
grant execute on procedure tng_tu_manobj_change_hist to public
\p\g
create procedure tng_tu_manobj_prop_hist as begin return; end
\p\g
grant execute on procedure tng_tu_manobj_prop_hist to public
\p\g
create procedure tng_tu_manobj_status_hist as begin return; end
\p\g
grant execute on procedure tng_tu_manobj_status_hist to public
\p\g
create procedure tng_tu_manobj_update_err as begin return; end
\p\g
grant execute on procedure tng_tu_manobj_update_err to public
\p\g
create procedure tng_unmanage_discovery_ipsubnet as begin return; end
\p\g
grant execute on procedure tng_unmanage_discovery_ipsubnet to public
\p\g
create procedure tng_upd_segment_uuid as begin return; end
\p\g
grant execute on procedure tng_upd_segment_uuid to public
\p\g
drop procedure del_db_application_db_object
\p\g
create procedure  del_db_Application_db_Object (arg integer) as begin 
delete from "mdbadmin". db_Application where dbrep_IID = :arg; end
\p\g
drop procedure del_db_column_db_object
\p\g
create procedure  del_db_Column_db_Object (arg integer) as begin 
delete from "mdbadmin". db_Column where dbrep_IID = :arg; end
\p\g
drop procedure del_db_datatype_db_object
\p\g
create procedure  del_db_DataType_db_Object (arg integer) as begin 
delete from "mdbadmin". db_DataType where dbrep_IID = :arg; end
\p\g
drop procedure del_db_field_db_object
\p\g
create procedure  del_db_Field_db_Object (arg integer) as begin delete
from "mdbadmin". db_Field where dbrep_IID = :arg; end
\p\g
drop procedure del_db_gator_db_object
\p\g
create procedure  del_db_Gator_db_Object (arg integer) as begin delete
from "mdbadmin". db_Gator where dbrep_IID = :arg; end
\p\g
drop procedure del_db_gatorstar_db_gator
\p\g
create procedure  del_db_GatorStar_db_Gator (arg integer) as begin 
delete from "mdbadmin". db_GatorStar where dbrep_GatorIID = :arg; end
\p\g
drop procedure del_db_gatorstar_db_star
\p\g
create procedure  del_db_GatorStar_db_Star (arg integer) as begin 
delete from "mdbadmin". db_GatorStar where dbrep_StarIID = :arg; end
\p\g
drop procedure del_db_index_db_object
\p\g
create procedure  del_db_Index_db_Object (arg integer) as begin delete
from "mdbadmin". db_Index where dbrep_IID = :arg; end
\p\g
drop procedure del_db_indexcol_db_column
\p\g
create procedure  del_db_IndexCol_db_Column (arg integer) as begin 
delete from "mdbadmin". db_IndexCol where dbrep_ColumnIID = :arg; end
\p\g
drop procedure del_db_indexcol_db_index
\p\g
create procedure  del_db_IndexCol_db_Index (arg integer) as begin 
delete from "mdbadmin". db_IndexCol where dbrep_IndexIID = :arg; end
\p\g
drop procedure del_db_infoblob_db_object
\p\g
create procedure  del_db_InfoBlob_db_Object (arg integer) as begin 
delete from "mdbadmin". db_InfoBlob where dbrep_IID = :arg; end
\p\g
drop procedure del_db_layout_db_object
\p\g
create procedure  del_db_Layout_db_Object (arg integer) as begin 
delete from "mdbadmin". db_Layout where dbrep_IID = :arg; end
\p\g
drop procedure del_db_object_db_object
\p\g
create procedure  del_db_Object_db_Object (arg integer) as begin 
delete from "mdbadmin". db_Object where dbrep_ParentIID = :arg; end
\p\g
drop procedure del_db_op_db_object
\p\g
create procedure  del_db_Op_db_Object (arg integer) as begin delete 
from "mdbadmin". db_Op where dbrep_IID = :arg; end
\p\g
drop procedure del_db_opsegment_db_op
\p\g
create procedure  del_db_OpSegment_db_Op (arg integer) as begin delete
from "mdbadmin". db_OpSegment where dbrep_IID = :arg; end
\p\g
drop procedure del_db_parameter_db_object
\p\g
create procedure  del_db_Parameter_db_Object (arg integer) as begin 
delete from "mdbadmin". db_Parameter where dbrep_IID = :arg; end
\p\g
drop procedure del_db_program_db_object
\p\g
create procedure  del_db_Program_db_Object (arg integer) as begin 
delete from "mdbadmin". db_Program where dbrep_IID = :arg; end
\p\g
drop procedure del_db_programinstance_db_object
\p\g
create procedure  del_db_ProgramInstance_db_Object (arg integer) as 
begin delete from "mdbadmin". db_ProgramInstance where dbrep_IID = 
:arg; end
\p\g
drop procedure del_db_programtype_db_object
\p\g
create procedure  del_db_ProgramType_db_Object (arg integer) as begin 
delete from "mdbadmin". db_ProgramType where dbrep_IID = :arg; end
\p\g
drop procedure del_db_programtypemisc_db_object
\p\g
create procedure  del_db_ProgramTypeMisc_db_Object (arg integer) as 
begin delete from "mdbadmin". db_ProgramTypeMisc where dbrep_IID = 
:arg; end
\p\g
drop procedure del_db_psafile_db_object
\p\g
create procedure  del_db_PSAFile_db_Object (arg integer) as begin 
delete from "mdbadmin". db_PSAFile where dbrep_IID = :arg; end
\p\g
drop procedure del_db_seqcolumn_db_column
\p\g
create procedure  del_db_SeqColumn_db_Column (arg integer) as begin 
delete from "mdbadmin". db_SeqColumn where dbrep_IID = :arg; end
\p\g
drop procedure del_db_seqtable_db_table
\p\g
create procedure  del_db_SeqTable_db_Table (arg integer) as begin 
delete from "mdbadmin". db_SeqTable where dbrep_IID = :arg; end
\p\g
drop procedure del_db_servertype_db_object
\p\g
create procedure  del_db_ServerType_db_Object (arg integer) as begin 
delete from "mdbadmin". db_ServerType where dbrep_IID = :arg; end
\p\g
drop procedure del_db_star_db_object
\p\g
create procedure  del_db_Star_db_Object (arg integer) as begin delete 
from "mdbadmin". db_Star where dbrep_IID = :arg; end
\p\g
drop procedure del_db_startable_db_table
\p\g
create procedure  del_db_StarTable_db_Table (arg integer) as begin 
delete from "mdbadmin". db_StarTable where dbrep_TableIID = :arg; end
\p\g
drop procedure del_db_table_db_object
\p\g
create procedure  del_db_Table_db_Object (arg integer) as begin delete
from "mdbadmin". db_Table where dbrep_IID = :arg; end
\p\g
drop procedure del_db_wkf_db_object
\p\g
create procedure  del_db_WKF_db_Object (arg integer) as begin delete 
from "mdbadmin". db_WKF where dbrep_IID = :arg; end
\p\g
drop procedure del_db_wkfconnection_db_object
\p\g
create procedure  del_db_WKFConnection_db_Object (arg integer) as 
begin delete from "mdbadmin". db_WKFConnection where dbrep_IID = :arg;
end
\p\g
drop procedure del_ddcolumn_ddtable
\p\g
create procedure  del_DDColumn_DDTable (arg integer) as begin delete 
from "mdbadmin". DDColumn where DDTableId = :arg; end
\p\g
drop procedure del_ddtable_execution
\p\g
create procedure  del_DDTable_Execution (arg integer) as begin delete 
from "mdbadmin". DDTable where ExecutionId = :arg; end
\p\g
drop procedure del_ddtablemodify_execution
\p\g
create procedure  del_DDTableModify_Execution (arg integer) as begin 
delete from "mdbadmin". DDTableModify where ExecutionId = :arg; end
\p\g
drop procedure del_error_execution
\p\g
create procedure  del_Error_Execution (arg integer) as begin delete 
from "mdbadmin". Error where ExecutionId = :arg; end
\p\g
drop procedure del_execution_lookoutserver
\p\g
create procedure  del_Execution_LookOutServer (arg integer) as begin 
delete from "mdbadmin". Execution where ServerId = :arg; end
\p\g
drop procedure del_execution_request
\p\g
create procedure  del_Execution_Request (arg integer) as begin delete 
from "mdbadmin". Execution where RequestId = :arg; end
\p\g
drop procedure del_lookoutcontrol_lookoutserver
\p\g
create procedure  del_LookOutControl_LookOutServer (arg integer) as 
begin delete from "mdbadmin". LookOutControl where ServerId = :arg; 
end
\p\g
drop procedure del_object_ipuser
\p\g
create procedure  del_Object_IPUser (arg integer) as begin delete from
"mdbadmin". ipObject where UserId = :arg; end
\p\g
drop procedure del_permissions_object
\p\g
create procedure  del_Permissions_Object (arg integer) as begin delete
from "mdbadmin". Permissions where ObjectId = :arg; end
\p\g
drop procedure del_provider_object
\p\g
create procedure  del_Provider_Object (arg integer) as begin delete 
from "mdbadmin". ipProvider where ProviderId = :arg; end
\p\g
drop procedure del_rdbms_provider_object
\p\g
create procedure  del_RDBMS_Provider_Object (arg integer) as begin 
delete from "mdbadmin". RDBMS_Provider where ProviderId = :arg; end
\p\g
drop procedure del_request_object
\p\g
create procedure  del_Request_Object (arg integer) as begin delete 
from "mdbadmin". ipRequest where RequestId = :arg; end
\p\g
drop procedure del_requestprovider_provider
\p\g
create procedure  del_RequestProvider_Provider (arg integer) as begin 
delete from "mdbadmin". RequestProvider where ProviderId = :arg; end
\p\g
drop procedure del_requestprovider_request
\p\g
create procedure  del_RequestProvider_Request (arg integer) as begin 
delete from "mdbadmin". RequestProvider where RequestId = :arg; end
\p\g
drop procedure del_requestqueue_request
\p\g
create procedure  del_RequestQueue_Request (arg integer) as begin 
delete from "mdbadmin". RequestQueue where RequestId = :arg; end
\p\g
drop procedure del_scriptmessagelog_execution
\p\g
create procedure  del_ScriptMessageLog_Execution (arg integer) as 
begin delete from "mdbadmin". ScriptMessageLog where ExecutionId = 
:arg; end
\p\g
drop procedure del_simplerequest_request
\p\g
create procedure  del_SimpleRequest_Request (arg integer) as begin 
delete from "mdbadmin". SimpleRequest where RequestId = :arg; end
\p\g
drop procedure increment_id
\p\g
create procedure  increment_id AS DECLARE maxid int; BEGIN SELECT 
ENTRYID INTO :maxid FROM "mdbadmin". increment_highval; UPDATE 
"mdbadmin". SEOSDATA SET entryid=:maxid WHERE entryid IS null; UPDATE 
"mdbadmin". increment_highval SET entryid=:maxid + 1; END
\p\g
drop procedure next_sequence_value
\p\g
create procedure  next_sequence_value ( name = varchar(32) not null ) 
as declare sequence_value= integer not null; x = smallint not null; 
begin select x = count(*) from "mdbadmin". sequence_values where name 
= :name; if iierrornumber > 0 then return 0; endif; if iirowcount != 1
then return 0; endif; if x = 0 then insert into "mdbadmin". 
sequence_values ( name, sequence_value ) values ( :name, 0 ); if 
iierrornumber > 0 then return 0; endif; if iirowcount != 1 then return
0; endif; endif; select sequence_value = sequence_value + 1 from 
"mdbadmin". sequence_values where name = :name; if iierrornumber > 0 
then return 0; endif; if iirowcount != 1 then return 0; endif; update 
"mdbadmin". sequence_values set sequence_value = sequence_value + 1 
where name = :name; if iierrornumber > 0 then return 0; endif; if 
iirowcount != 1 then return 0; elseif iirowcount = 1 then return 
:sequence_value; endif; end
\p\g
drop procedure pd_cluster
\p\g
create procedure  pD_Cluster ( oldClusterID integer, oldClusterName 
char(254), oldClusterType integer2, oldDescription varchar(255) ) as 
declare cnt1 integer4 not null;   begin   update "mdbadmin". Objects 
set ClusterID = NULL where  objects.ClusterID = :oldClusterID;   
update "mdbadmin". CounterSource set ClusterID = NULL where  
CounterSource.ClusterID = :oldClusterID; end
\p\g
drop procedure pd_collector
\p\g
create procedure  pD_Collector ( oldCollectorID integer, 
oldCollectorName char(15), oldParentCollectorID integer, oldHostName 
char(64), oldServerName varchar(255), oldDBName varchar(255), 
oldUserName varchar(255), oldUserPsw varchar(255), oldLogFileLocation 
varchar(255), oldNeedRefresh integer2, oldCollectorType integer2, 
oldRawDataKeepInterval integer, oldRawDataTimeFactor integer2, 
oldHourlyDataKeepInterval integer, oldHourlyTimeFactor integer2, 
oldDailyDataKeepInterval integer, oldDailyTimeFactor integer2, 
oldWeeklyDataKeepInterval integer, oldWeeklyTimeFactor integer2, 
oldMonthlyDataKeepInterval integer, oldMonthlyTimeFactor integer2, 
oldYearlyDataKeepInterval integer, oldYearlyTimeFactor integer2, 
oldInactive integer1, oldTopNServers integer, oldTopNPersons integer, 
oldTopNObjects integer, oldAlertLimit integer, oldIDFile1 varchar(8,0)
, oldIDFile2 varchar(8,0), oldOneIDFile integer1, oldIDFilePwd 
varchar(8,0) ) as declare cnt1 integer4 not null;   begin   delete 
from "mdbadmin". CollectorPolling where  CollectorPolling.CollectorID 
= :oldCollectorID;   select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  CounterSource.CollectorID = :oldCollectorID; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE Collector because C
ounterSource exists.'; endif;   delete from "mdbadmin". 
Server_Schedule where  Server_Schedule.CollectorID = :oldCollectorID; 
update "mdbadmin". Server_Collector set ParentCollectorID = NULL where
Server_Collector.ParentCollectorID = :oldCollectorID; end
\p\g
drop procedure pd_collectoraction
\p\g
create procedure  pD_CollectorAction ( oldActionID integer, 
oldActionName char(254), oldActionType integer2 ) as declare cnt1 
integer4 not null;   begin   delete from "mdbadmin". Server_Schedule 
where  Server_Schedule.ActionID = :oldActionID; end
\p\g
drop procedure pd_columndefinition
\p\g
create procedure  pD_ColumnDefinition ( oldTableIdx integer, 
oldOrderOfColumn integer, oldName varchar(32), oldTypeId integer, 
oldRollUpType c(1), oldReportLabel varchar(128) ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
TablesDescription where  TablesDescription.TableIdx = :oldTableIdx and
TablesDescription.OrderOfColumn = :oldOrderOfColumn; if ((cnt1 > 0)) 
then raise error 30001 'Cannot DELETE ColumnDefinition because TablesD
escription exists.'; endif; end
\p\g
drop procedure pd_connectortype
\p\g
create procedure  pD_ConnectorType ( oldConnectorTypeID integer, 
oldConnectorTypeName varchar(255) ) as declare cnt1 integer4 not null;
begin   select :cnt1 = count(*) from "mdbadmin". MailConnector where  
MailConnector.ConnectorTypeID = :oldConnectorTypeID; if ((cnt1 > 0)) 
then raise error 30001 'Cannot DELETE ConnectorType because MailConnec
tor exists.'; endif; end
\p\g
drop procedure pd_counterdefinition
\p\g
create procedure  pD_CounterDefinition ( oldCounterID integer, 
oldUnitID integer, oldFullCounterName char(254), oldCounterName 
char(254), oldDataType integer2, oldClass varchar(255), oldSubClass 
varchar(255), oldInstance varchar(255), oldCounterType integer, 
oldValueType integer2, oldAlgoType smallint ) as declare cnt1 integer4
not null;   begin   delete from "mdbadmin". ReportTable where  
ReportTable.CounterID = :oldCounterID;   delete from "mdbadmin". 
CollectorPolling where  CollectorPolling.CounterID = :oldCounterID;   
delete from "mdbadmin". Management_Alert where  
Management_Alert.CounterID = :oldCounterID;   delete from "mdbadmin". 
CounterPolling where  CounterPolling.CounterID = :oldCounterID;   
delete from "mdbadmin". CounterData where  CounterData.CounterID = 
:oldCounterID;   select :cnt1 = count(*) from "mdbadmin". CounterTitle
where  CounterTitle.CounterID = :oldCounterID; if ((cnt1 > 0)) then 
raise error 30001 'Cannot DELETE CounterDefinition because CounterTitl
e exists.'; endif;   select :cnt1 = count(*) from "mdbadmin". Unit 
where  :oldUnitID = Unit.UnitID and (0 = ( select count(*) from 
"mdbadmin". CounterDefinition where  CounterDefinition.UnitID = 
Unit.UnitID )); if ((cnt1 > 0)) then raise error 30010 'Cannot DELETE 
last CounterDefinition because Unit exists.'; endif; end
\p\g
drop procedure pd_countersource
\p\g
create procedure  pD_CounterSource ( oldSourceID integer, 
oldCollectorID integer, oldLocaleID integer, oldClusterID integer, 
oldSiteID integer, oldSourceName char(254), oldSourceType integer, 
oldHostName char(64), oldActiveState integer2, oldUserName 
varchar(255), oldUserPwd varchar(255), oldHostName1 varchar(64), 
oldHostName2 varchar(64), oldHostName3 varchar(64), oldSrcTimeZone 
float, oldMailOrgID integer ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". MailDomain where  
MailDomain.SourceID = :oldSourceID; if ((cnt1 > 0)) then raise error 
30001 'Cannot DELETE CounterSource because MailDomain exists.'; endif;
select :cnt1 = count(*) from "mdbadmin". MailObject where  
MailObject.SourceID = :oldSourceID; if ((cnt1 > 0)) then raise error 
30001 'Cannot DELETE CounterSource because MailObject exists.'; endif;
select :cnt1 = count(*) from "mdbadmin". MailService where  
MailService.SourceID = :oldSourceID; if ((cnt1 > 0)) then raise error 
30001 'Cannot DELETE CounterSource because MailService exists.'; 
endif;   select :cnt1 = count(*) from "mdbadmin". MailConnector where 
MailConnector.SourceID = :oldSourceID; if ((cnt1 > 0)) then raise 
error 30001 'Cannot DELETE CounterSource because MailConnector exists.
'; endif;   select :cnt1 = count(*) from "mdbadmin". MailDisk where  
MailDisk.SourceID = :oldSourceID; if ((cnt1 > 0)) then raise error 
30001 'Cannot DELETE CounterSource because MailDisk exists.'; endif;  
select :cnt1 = count(*) from "mdbadmin". MailEvent where  
MailEvent.SourceID = :oldSourceID; if ((cnt1 > 0)) then raise error 
30001 'Cannot DELETE CounterSource because MailEvent exists.'; endif; 
select :cnt1 = count(*) from "mdbadmin". MailDB where  MailDB.SourceID
= :oldSourceID; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE 
CounterSource because MailDB exists.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". MailQueue where  MailQueue.SourceID = 
:oldSourceID; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE Co
unterSource because MailQueue exists.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". Server_Person where  Server_Person.SourceID 
= :oldSourceID; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE 
CounterSource because Person exists.'; endif;   delete from "mdbadmin"
. Management_Alert where  Management_Alert.SourceID = :oldSourceID;   
delete from "mdbadmin". CounterData where  CounterData.SourceID = 
:oldSourceID;   delete from "mdbadmin". CounterPolling where  
CounterPolling.SourceID = :oldSourceID; end
\p\g
drop procedure pd_dominoeventtype
\p\g
create procedure  pD_DominoEventType ( oldDominoEventTypeID integer, 
oldDominoEventTypeName char(254) ) as declare cnt1 integer4 not null; 
begin   select :cnt1 = count(*) from "mdbadmin". MailEvent where  
MailEvent.DominoEventTypeID = :oldDominoEventTypeID; if ((cnt1 > 0)) 
then raise error 30001 'Cannot DELETE DominoEventType because MailEven
t exists.'; endif; end
\p\g
drop procedure pd_dominologeventtype
\p\g
create procedure  pD_DominoLogEventType ( oldDominoLogEventTypeID 
integer, oldDominoLogEventTypeName char(254) ) as declare cnt1 
integer4 not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
MailEvent where  MailEvent.DominoLogEventTypeID = 
:oldDominoLogEventTypeID; if ((cnt1 > 0)) then raise error 30001 'Cann
ot DELETE DominoLogEventType because MailEvent exists.'; endif; end
\p\g
drop procedure pd_errormessage
\p\g
create procedure  pD_ErrorMessage ( oldErrorMessageID integer, 
oldSourceType integer, oldMessageText varchar(255) ) as declare cnt1 
integer4 not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
ErrorSolution where  ErrorSolution.ErrorMessageID = 
:oldErrorMessageID; if ((cnt1 > 0)) then raise error 30001 'Cannot DEL
ETE ErrorMessage because ErrorSolution exists.'; endif; end
\p\g
drop procedure pd_eventseverity
\p\g
create procedure  pD_EventSeverity ( oldEventSeverityID integer, 
oldEventSeverityName varchar(255) ) as declare cnt1 integer4 not null;
begin   select :cnt1 = count(*) from "mdbadmin". MailEvent where 
MailEvent.EventSeverityID = :oldEventSeverityID; if ((cnt1 > 0)) then 
raise error 30001 'Cannot DELETE EventSeverity because MailEvent exist
s.'; endif; end
\p\g
drop procedure pd_eventtype
\p\g
create procedure  pD_EventType ( oldEventTypeID integer, 
oldEventTypeName varchar(255) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". MailEvent where  
MailEvent.EventTypeID = :oldEventTypeID; if ((cnt1 > 0)) then raise 
error 30001 'Cannot DELETE EventType because MailEvent exists.'; 
endif; end
\p\g
drop procedure pd_indextable
\p\g
create procedure  pD_IndexTable ( oldComponentMibIndexIdx integer, 
oldTypeOfIndexRetrieval c(1), oldIndexBaseOID varchar(128), 
oldIndexStartLoc integer, oldIndexLength float, oldColOidId 
varchar(32) ) as declare cnt1 integer4 not null;   begin    select 
:cnt1 = count(*) from "mdbadmin". ComponentOfIndex where  
ComponentOfIndex.ComponentMibIndexIdx = :oldComponentMibIndexIdx; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE IndexTable because 
ComponentOfIndex exists.'; endif;    update "mdbadmin". MibStructure 
set ComponentMibIndexIdx = NULL where  
MibStructure.ComponentMibIndexIdx = :oldComponentMibIndexIdx; end
\p\g
drop procedure pd_mailconnector
\p\g
create procedure  pD_MailConnector ( oldSourceID integer, 
oldMailConnectorID integer, oldConnectorTypeID integer, 
oldMailConnectorName char(254), oldDescription varchar(255) ) as 
declare cnt1 integer4 not null;   begin   update "mdbadmin". Objects 
set ConnectorSourceID = NULL, MailConnectorID = NULL where  
objects.ConnectorSourceID = :oldSourceID and objects.MailConnectorID =
:oldMailConnectorID; end
\p\g
drop procedure pd_maildb
\p\g
create procedure  pD_MailDB ( oldSourceID integer, oldMailDBID 
integer, oldDBTitle char(254), oldDBFileName varchar(255), 
oldMailDBName char(254), oldDescription varchar(255) ) as declare cnt1
integer4 not null;   begin   update "mdbadmin". Objects set DBSourceID
= NULL, MailDBID = NULL where  objects.DBSourceID = :oldSourceID and 
objects.MailDBID = :oldMailDBID; end
\p\g
drop procedure pd_maildisk
\p\g
create procedure  pD_MailDisk ( oldSourceID integer, oldMailDiskID 
integer, oldDiskSize float, oldMailDiskName char(254), oldDescription 
varchar(255) ) as declare cnt1 integer4 not null;   begin   update 
"mdbadmin". Objects set DiskSourceID = NULL, MailDiskID = NULL where  
objects.DiskSourceID = :oldSourceID and objects.MailDiskID = 
:oldMailDiskID; end
\p\g
drop procedure pd_maildomain
\p\g
create procedure  pD_MailDomain ( oldSourceID integer, oldMailDomainID
integer, oldMailDomainName char(254), oldDescription varchar(255) ) as
declare cnt1 integer4 not null;   begin   update "mdbadmin". Objects 
set DomainSourceID = NULL, MailDomainID = NULL where  
objects.DomainSourceID = :oldSourceID and objects.MailDomainID = 
:oldMailDomainID; end
\p\g
drop procedure pd_mailevent
\p\g
create procedure  pD_MailEvent ( oldSourceID integer, oldMailEventID 
integer, oldEventTypeID integer, oldEventSeverityID integer, 
oldMailEventName char(254), oldDescription varchar(255), oldEventID 
integer, oldDominoLogEventTypeID integer, oldDominoEventTypeID integer
) as declare cnt1 integer4 not null;   begin   update "mdbadmin". 
Objects set EventSourceID = NULL, MailEventID = NULL where  
objects.EventSourceID = :oldSourceID and objects.MailEventID = 
:oldMailEventID; end
\p\g
drop procedure pd_mailobject
\p\g
create procedure  pD_MailObject ( oldSourceID integer, oldMailObjectID
integer, oldMailObjectName char(254), oldMailObjectType integer2, 
oldDescription varchar(255) ) as declare cnt1 integer4 not null;   
begin   update "mdbadmin". Objects set ObjectSourceID = NULL, 
MailObjectID = NULL where  objects.ObjectSourceID = :oldSourceID and 
objects.MailObjectID = :oldMailObjectID; end
\p\g
drop procedure pd_mailorganisation
\p\g
create procedure  pD_MailOrganisation ( oldMailOrgID integer, 
oldOrganisationName char(254) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". Server_Site where  
Server_Site.MailOrgID = :oldMailOrgID; if ((cnt1 > 0)) then raise 
error 30001 'Cannot DELETE MailOrganisation because Server_Site exists
.'; endif; end
\p\g
drop procedure pd_mailqueue
\p\g
create procedure  pD_MailQueue ( oldSourceID integer, oldMailQueueID 
integer, oldQueueType integer2, oldMailQueueName char(254), 
oldDescription varchar(255) ) as declare cnt1 integer4 not null;   
begin   update "mdbadmin". Objects set QueueSourceID = NULL, 
MailQueueID = NULL where  objects.QueueSourceID = :oldSourceID and 
objects.MailQueueID = :oldMailQueueID; end
\p\g
drop procedure pd_mailservice
\p\g
create procedure  pD_MailService ( oldSourceID integer, 
oldMailServiceID integer, oldMailServiceName char(254), oldDescription
varchar(255) ) as declare cnt1 integer4 not null;   begin   update 
"mdbadmin". Objects set ServiceSourceID = NULL, MailServiceID = NULL 
where  objects.ServiceSourceID = :oldSourceID and 
objects.MailServiceID = :oldMailServiceID; end
\p\g
drop procedure pd_mib
\p\g
create procedure  pD_mib ( oldID integer, oldname varchar(128), 
oldbody text ) as declare cnt1 integer4 not null;   begin    update 
"mdbadmin". MIBDefinition set mib_id = NULL where  
MIBDefinition.mib_id = :oldID; end
\p\g
drop procedure pd_mibdefinition
\p\g
create procedure  pD_MIBDefinition ( oldMibIdx integer, oldMibType 
integer, oldDescription varchar(128), oldCollection c(1), oldmib_id 
integer ) as declare cnt1 integer4 not null;   begin    select :cnt1 =
count(*) from "mdbadmin". DiscoveryVariable where  
DiscoveryVariable.MibIdx = :oldMibIdx; if ((cnt1 > 0)) then raise 
error 30001 'Cannot DELETE MIBDefinition because DiscoveryVariable exi
sts.'; endif;    select :cnt1 = count(*) from "mdbadmin". MibStructure
where  MibStructure.MibIdx = :oldMibIdx; if ((cnt1 > 0)) then raise 
error 30001 'Cannot DELETE MIBDefinition because MibStructure exists.'
; endif;    update "mdbadmin". ThresholdDesc set MibIdx = NULL where  
ThresholdDesc.MibIdx = :oldMibIdx;    select :cnt1 = count(*) from 
"mdbadmin". GDCDiscovery where  GDCDiscovery.MibIdx = :oldMibIdx; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE MIBDefinition becau
se GDCDiscovery exists.'; endif;    select :cnt1 = count(*) from 
"mdbadmin". ResourceMonitoring where  ResourceMonitoring.MibIdx = 
:oldMibIdx; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE MIBD
efinition because ResourceMonitoring exists.'; endif; end
\p\g
drop procedure pd_mibstructure
\p\g
create procedure  pD_MibStructure ( oldMibIdx integer, oldOidIdxForMIB
integer, oldOID varchar(128), oldType integer, oldDiscoveryKey c(1), 
oldIsIfIndex c(1), oldIsStatus c(1), oldComponentMibIndexIdx integer )
as declare cnt1 integer4 not null;   begin    select :cnt1 = count(*) 
from "mdbadmin". PollRowDefinition where  PollRowDefinition.MibIdx = 
:oldMibIdx and PollRowDefinition.OidIdxForMIB = :oldOidIdxForMIB; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE MibStructure becaus
e PollRowDefinition exists.'; endif;    select :cnt1 = count(*) from 
"mdbadmin". TablesDescription where  TablesDescription.MibIdx = 
:oldMibIdx and TablesDescription.OidIdxForMIB = :oldOidIdxForMIB; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE MibStructure becaus
e TablesDescription exists.'; endif;    select :cnt1 = count(*) from 
"mdbadmin". ComponentOfIndex where  ComponentOfIndex.MibIdx = 
:oldMibIdx and ComponentOfIndex.OidIdxForMIB = :oldOidIdxForMIB; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE MibStructure becaus
e ComponentOfIndex exists.'; endif;    select :cnt1 = count(*) from 
"mdbadmin". DiscoveryVariable where  DiscoveryVariable.MibIdx = 
:oldMibIdx and DiscoveryVariable.OidIdxForMIB = :oldOidIdxForMIB; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE MibStructure becaus
e DiscoveryVariable exists.'; endif; end
\p\g
drop procedure pd_mibvariabletype
\p\g
create procedure  pD_MibVariableType ( oldTypeId integer, oldCategory 
c(32), oldSubcategory c(32), oldDescription varchar(128), 
oldBaseTypeIdx integer, oldCollectable c(1) ) as declare cnt1 integer4
not null;   begin    select :cnt1 = count(*) from "mdbadmin". 
DiscoveryVariable where  DiscoveryVariable.TypeId = :oldTypeId; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE MibVariableType bec
ause DiscoveryVariable exists.'; endif;    update "mdbadmin". 
MibVariableType set BaseTypeIdx = NULL where  
MibVariableType.BaseTypeIdx = :oldTypeId;    select :cnt1 = count(*) 
from "mdbadmin". ColumnDefinition where  ColumnDefinition.TypeId = 
:oldTypeId; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE MibV
ariableType because ColumnDefinition exists.'; endif; end
\p\g
drop procedure pd_objects
\p\g
create procedure  pD_Objects ( oldObjectID integer, oldObjectType 
integer2, oldObjectName varchar(255), oldDescription varchar(255), 
oldObjectSourceID integer, oldClusterID integer, oldDomainSourceID 
integer, oldMailObjectID integer, oldServiceSourceID integer, 
oldMailDomainID integer, oldMailServiceID integer, 
oldConnectorSourceID integer, oldMailConnectorID integer, 
oldDBSourceID integer, oldMailDBID integer, oldEventSourceID integer, 
oldMailEventID integer, oldQueueSourceID integer, oldMailQueueID 
integer, oldDiskSourceID integer, oldMailDiskID integer ) as declare 
cnt1 integer4 not null;   begin   update "mdbadmin". CounterData set 
ObjectID = NULL where  CounterData.ObjectID = :oldObjectID;   update 
"mdbadmin". Management_Alert set ObjectID = NULL where  
Management_Alert.ObjectID = :oldObjectID; end
\p\g
drop procedure pd_person
\p\g
create procedure  pD_Person ( oldSourceID integer, oldPersonID 
integer, oldPersonName char(254), oldDescription varchar(255), 
oldDisplayName char(254), oldMailFile varchar(255) ) as declare cnt1 
integer4 not null;   begin   update "mdbadmin". CounterData set 
PersonSourceID = NULL, PersonID = NULL where  
CounterData.PersonSourceID = :oldSourceID and CounterData.PersonID = 
:oldPersonID;   update "mdbadmin". Management_Alert set PersonSourceID
= NULL, PersonID = NULL where  Management_Alert.PersonSourceID = 
:oldSourceID and Management_Alert.PersonID = :oldPersonID; end
\p\g
drop procedure pd_report
\p\g
create procedure  pD_Report ( oldReportID integer, oldTitle char(254),
oldTableName varchar(255), oldAllColumns integer1, oldIsDistinct 
integer1, oldReportType integer2 ) as declare cnt1 integer4 not null; 
begin   delete from "mdbadmin". ReportColumn where  
ReportColumn.ReportID = :oldReportID; end
\p\g
drop procedure pd_reportcolumn
\p\g
create procedure  pD_ReportColumn ( oldColumnID integer, oldReportID 
integer, oldThresholdColumnID integer, oldThresholdReportID integer, 
oldColumnName varchar(255), oldIsVisible integer2, oldSortBy integer2,
oldFormula varchar(255), oldIsDistinct integer1, oldIsGroup integer2, 
oldTitle varchar(255), oldPresentation integer2, oldUnitID integer, 
oldInWorkSpace integer1 ) as declare cnt1 integer4 not null;   begin  
update "mdbadmin". ReportColumn set ThresholdColumnID = NULL, 
ThresholdReportID = NULL where  ReportColumn.ThresholdColumnID = 
:oldColumnID and ReportColumn.ThresholdReportID = :oldReportID; end
\p\g
drop procedure pd_reporttabledefinition
\p\g
create procedure  pD_ReportTableDefinition ( oldReportTableID integer,
oldReportTableName char(2543), oldAlgoType smallint ) as declare cnt1 
integer4 not null;   begin   delete from "mdbadmin". ReportTable where
ReportTable.ReportTableID = :oldReportTableID; end
\p\g
drop procedure pd_site
\p\g
create procedure  pD_Site ( oldSiteID integer, oldMailOrgID integer, 
oldSiteName char(254) ) as declare cnt1 integer4 not null;   begin   
select :cnt1 = count(*) from "mdbadmin". CounterSource where  
CounterSource.SiteID = :oldSiteID and CounterSource.MailOrgID = 
:oldMailOrgID; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE S
erver_Site because CounterSource exists.'; endif; end
\p\g
drop procedure pd_solutiondescription
\p\g
create procedure  pD_SolutionDescription ( oldSolutionDescriptionID 
integer, oldSolutionText text(4096) ) as declare cnt1 integer4 not 
null;   begin   select :cnt1 = count(*) from "mdbadmin". ErrorSolution
where  ErrorSolution.SolutionDescriptionID = 
:oldSolutionDescriptionID; if ((cnt1 > 0)) then raise error 30001 'Can
not DELETE SolutionDescription because ErrorSolution exists.'; endif; 
end
\p\g
drop procedure pd_sourcelocale
\p\g
create procedure  pD_SourceLocale ( oldLocaleID integer, oldLocaleName
char(32), oldLangCode char(4), oldSourceType integer, oldJavaLocale 
char(5) ) as declare cnt1 integer4 not null;   begin   select :cnt1 = 
count(*) from "mdbadmin". CounterTitle where  CounterTitle.LocaleID = 
:oldLocaleID; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE So
urceLocale because CounterTitle exists.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". CounterSource where  CounterSource.LocaleID 
= :oldLocaleID; if ((cnt1 > 0)) then raise error 30001 'Cannot DELETE 
SourceLocale because CounterSource exists.'; endif; end
\p\g
drop procedure pd_tabledefinition
\p\g
create procedure  pD_TableDefinition ( oldTableIdx integer, 
oldNameOfTable varchar(32) ) as declare cnt1 integer4 not null;   
begin    select :cnt1 = count(*) from "mdbadmin". ColumnDefinition 
where  ColumnDefinition.TableIdx = :oldTableIdx; if ((cnt1 > 0)) then 
raise error 30001 'Cannot DELETE TableDefinition because ColumnDefinit
ion exists.'; endif; end
\p\g
drop procedure pd_tau_mdb
\p\g
create procedure  pD_tau_mdb ( oldmdbMajorVersion integer, 
oldmdbMinorVersion integer, oldreleaseDate date, oldinstallDate date )
as declare cnt1 integer4 not null;   begin          select :cnt1 = 
count(*) from "mdbadmin". tau_mdb_product where  
tau_mdb_product.mdbMajorVersion = :oldmdbMajorVersion and 
tau_mdb_product.mdbMinorVersion = :oldmdbMinorVersion; if ((cnt1 > 0))
then raise error 30001 'Cannot DELETE tau_mdb because tau_mdb_product 
exists.'; endif; end
\p\g
drop procedure pd_tau_product
\p\g
create procedure  pD_tau_product ( oldproductName varchar(64), 
oldproductMajorVersion integer, oldproductMinorVersion integer, 
oldreleaseDate date, oldinstallCount integer ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
tau_mdb_product where  tau_mdb_product.productName = :oldproductName 
and tau_mdb_product.productMajorVersion = :oldproductMajorVersion and 
tau_mdb_product.productMinorVersion = :oldproductMinorVersion; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE tau_product because
 tau_mdb_product exists.'; endif; end
\p\g
drop procedure pd_unit
\p\g
create procedure  pD_Unit ( oldUnitID integer, oldUnitName char(254), 
oldPrec integer2, oldUnitShortName char(10) ) as declare cnt1 integer4
not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
CounterDefinition where  CounterDefinition.UnitID = :oldUnitID; if 
((cnt1 > 0)) then raise error 30001 'Cannot DELETE Unit because Counte
rDefinition exists.'; endif;   select :cnt1 = count(*) from "mdbadmin"
. ReportColumn where  ReportColumn.UnitID = :oldUnitID; if ((cnt1 > 0)
) then raise error 30001 'Cannot DELETE Unit because ReportColumn exis
ts.'; endif; end
\p\g
drop procedure pdgetnextbpvid
\p\g
create procedure  pdGetNextBpvId ( num integer not null with default )
as declare maxVal int not null; rcount int not null; enumber int not 
null; emessage varchar(100) not null; begin  select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber != 0) then emessage
= 'procedure pdGetNextBpvId failed' + ascii(iierrornumber); raise 
error 10001 :emessage with destination = (session,error_log); return 
-1; endif; maxVal = 0; update "mdbadmin". pd_max_bpv set max_bpv_id = 
max_bpv_id + :num; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber != 0) then emessage = 'procedure pdGetNextBpvId
 failed' + ascii(iierrornumber); raise error 10002 :emessage with 
destination = (session,error_log); return -1; endif; if rcount = 0 
then maxVal = :num; insert into "mdbadmin". pd_max_bpv values(maxVal);
else select max_bpv_id into maxVal from "mdbadmin". pd_max_bpv; endif;
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
!= 0) then emessage = 'procedure pdGetNextBpvId failed' + 
ascii(iierrornumber); raise error 10003 :emessage with destination = 
(session,error_log); return -1; endif; if rcount = 1 then commit; 
return maxVal; else rollback; return -1; endif end
\p\g
grant execute on procedure "mdbadmin".pdgetnextbpvid to public
\p\g
drop procedure pdgetnextdayid
\p\g
create procedure  pdGetNextDayId ( num integer not null with default )
as declare maxVal int not null; rcount int not null; enumber int not 
null; emessage varchar(100) not null; begin  select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber != 0) then emessage
= 'procedure pdGetNextDayId failed' + ascii(iierrornumber); raise 
error 10001 :emessage with destination = (session,error_log); return 
-1; endif; maxVal = 0; update "mdbadmin". pd_max_day set max_day_id = 
max_day_id + :num; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber != 0) then emessage = 'procedure pdGetNextDayId
 failed' + ascii(iierrornumber); raise error 10002 :emessage with 
destination = (session,error_log); return -1; endif; if rcount = 0 
then maxVal = :num; insert into "mdbadmin". pd_max_day values(maxVal);
else select max_day_id into maxVal from "mdbadmin". pd_max_day; endif;
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
!= 0) then emessage = 'procedure pdGetNextDayId failed' + 
ascii(iierrornumber); raise error 10003 :emessage with destination = 
(session,error_log); return -1; endif; if rcount = 1 then commit; 
return maxVal; else rollback; return -1; endif end
\p\g
grant execute on procedure "mdbadmin".pdgetnextdayid to public
\p\g
drop procedure pdgetnextmachineid
\p\g
create procedure  pdGetNextMachineId ( num integer not null with 
default ) as declare maxVal int not null; rcount int not null; enumber
int not null; emessage varchar(100) not null; begin  select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber != 0) 
then emessage = 'procedure pdGetNextMachineId failed' + 
ascii(iierrornumber); raise error 10001 :emessage with destination = 
(session,error_log); return -1; endif; maxVal = 0; update "mdbadmin". 
pd_max_machine set max_machine_id = max_machine_id + :num; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber != 0) 
then emessage = 'procedure pdGetNextMachineId failed' + 
ascii(iierrornumber); raise error 10002 :emessage with destination = 
(session,error_log); return -1; endif; if rcount = 0 then maxVal = 
:num; insert into "mdbadmin". pd_max_machine values(maxVal); else 
select max_machine_id into maxVal from "mdbadmin". pd_max_machine; 
endif; select iirowcount, iierrornumber into :rcount, :enumber; if 
(:enumber != 0) then emessage = 'procedure pdGetNextMachineId failed' 
+ ascii(iierrornumber); raise error 10003 :emessage with destination =
(session,error_log); return -1; endif; if rcount = 1 then commit; 
return maxVal; else rollback; return -1; endif end
\p\g
grant execute on procedure "mdbadmin".pdgetnextmachineid to public
\p\g
drop procedure pdgetnextresid
\p\g
create procedure  pdGetNextResId ( num integer not null with default )
as declare maxVal int not null; rcount int not null; enumber int not 
null; emessage varchar(100) not null; begin  select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber != 0) then emessage
= 'procedure pdGetNextResId failed' + ascii(iierrornumber); raise 
error 10001 :emessage with destination = (session,error_log); return 
-1; endif; maxVal = 0; update "mdbadmin". pd_max_resource set 
max_res_id = max_res_id + :num; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber != 0) then emessage = 'procedure pdGet
NextResId failed' + ascii(iierrornumber); raise error 10002 :emessage 
with destination = (session,error_log); return -1; endif; if rcount = 
0 then maxVal = :num; insert into "mdbadmin". pd_max_resource 
values(maxVal); else select max_res_id into maxVal from "mdbadmin". 
pd_max_resource; endif; select iirowcount, iierrornumber into :rcount,
:enumber; if (:enumber != 0) then emessage = 'procedure pdGetNextResId
 failed' + ascii(iierrornumber); raise error 10003 :emessage with 
destination = (session,error_log); return -1; endif; if rcount = 1 
then commit; return maxVal; else rollback; return -1; endif end
\p\g
grant execute on procedure "mdbadmin".pdgetnextresid to public
\p\g
drop procedure pfullcountername
\p\g
create procedure  pFullCounterName ( oldCounterID integer, oldUnitID 
integer, oldFullCounterName char(254), oldCounterName char(254), 
oldDataType integer2, oldClass varchar(255), oldSubClass varchar(255),
oldInstance varchar(255), oldCounterType integer, oldValueType 
integer2, oldAlgoType smallint, newCounterID integer, newUnitID 
integer, newFullCounterName char(254), newCounterName char(254), 
newDataType integer2, newClass varchar(255), newSubClass varchar(255),
newInstance varchar(255), newCounterType integer, newValueType 
integer2, newAlgoType smallint ) as declare cnt1 integer4 not null;  
begin        select :cnt1 = count(*) from "mdbadmin". CounterTitle 
where  CounterTitle.CounterID = :oldCounterID; if ((cnt1 > 0)) then 
raise error 30005 'Cannot UPDATE CounterDefinition because CounterTitl
e exists.'; endif; end
\p\g
drop procedure pi_alert
\p\g
create procedure  pI_Alert ( newCounterID integer, newSourceID 
integer, newAlertID integer, newSource char(254), newTStamp date, 
newObjectID integer, newPersonSourceID integer, newPersonID integer, 
newStatus integer2, newDescription varchar(255), newThreshold float, 
newPrevStatus integer2, newIsSent integer2, newCounterValue float, 
newStringValue varchar(255), newDateValue date ) as declare cnt1 
integer4 not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30002 'Cannot INSERT Alert because Count
erSource does not exist.'; endif;   update "mdbadmin". 
Management_Alert set ObjectID = NULL where (0 = ( select count(*) from
"mdbadmin". Objects where  :newObjectID = objects.ObjectID )) and 
Management_Alert.CounterID = :newCounterID and 
Management_Alert.SourceID = :newSourceID and Management_Alert.AlertID 
= :newAlertID ;   update "mdbadmin". Management_Alert set 
PersonSourceID = NULL, PersonID = NULL where (0 = ( select count(*) 
from "mdbadmin". Server_Person where :newPersonSourceID = 
Server_Person.SourceID and :newPersonID = Server_Person.PersonID )) 
and Management_Alert.CounterID = :newCounterID and 
Management_Alert.SourceID = :newSourceID and Management_Alert.AlertID 
= :newAlertID ; end
\p\g
drop procedure pi_collector
\p\g
create procedure  pI_Collector ( newCollectorID integer, 
newCollectorName char(15), newParentCollectorID integer, newHostName 
char(64), newServerName varchar(255), newDBName varchar(255), 
newUserName varchar(255), newUserPsw varchar(255), newLogFileLocation 
varchar(255), newNeedRefresh integer2, newCollectorType integer2, 
newRawDataKeepInterval integer, newRawDataTimeFactor integer2, 
newHourlyDataKeepInterval integer, newHourlyTimeFactor integer2, 
newDailyDataKeepInterval integer, newDailyTimeFactor integer2, 
newWeeklyDataKeepInterval integer, newWeeklyTimeFactor integer2, 
newMonthlyDataKeepInterval integer, newMonthlyTimeFactor integer2, 
newYearlyDataKeepInterval integer, newYearlyTimeFactor integer2, 
newInactive integer1, newTopNServers integer, newTopNPersons integer, 
newTopNObjects integer, newAlertLimit integer, newIDFile1 varchar(8,0)
, newIDFile2 varchar(8,0), newOneIDFile integer1, newIDFilePwd 
varchar(8,0) ) as declare cnt1 integer4 not null;   begin    cnt1 = 1;
end
\p\g
drop procedure pi_collectorpolling
\p\g
create procedure  pI_CollectorPolling ( newCollectorID integer, 
newCounterID integer ) as declare cnt1 integer4 not null;   begin   
select :cnt1 = count(*) from "mdbadmin". Server_Collector where  
:newCollectorID = Server_Collector.CollectorID; if (  (cnt1 = 0) ) 
then raise error 30002 'Cannot INSERT CollectorPolling because Collect
or does not exist.'; endif;   select :cnt1 = count(*) from "mdbadmin".
CounterDefinition where  :newCounterID = CounterDefinition.CounterID; 
if (  (cnt1 = 0) ) then raise error 30002 'Cannot INSERT CollectorPoll
ing because CounterDefinition does not exist.'; endif; end
\p\g
drop procedure pi_columndefinition
\p\g
create procedure  pI_ColumnDefinition ( newTableIdx integer, 
newOrderOfColumn integer, newName varchar(32), newTypeId integer, 
newRollUpType c(1), newReportLabel varchar(128) ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
TableDefinition where  :newTableIdx = TableDefinition.TableIdx; if (  
(cnt1 = 0) ) then raise error 30002 'Cannot INSERT ColumnDefinition be
cause TableDefinition does not exist.'; endif;    select :cnt1 = 
count(*) from "mdbadmin". MibVariableType where  :newTypeId = 
MibVariableType.TypeId; if (  (cnt1 = 0) ) then raise error 30002 'Can
not INSERT ColumnDefinition because MibVariableType does not exist.'; 
endif; end
\p\g
drop procedure pi_componentofindex
\p\g
create procedure  pI_ComponentOfIndex ( newComponentMibIndexIdx 
integer, newComponentOfIndexOrder integer, newMibIdx integer, 
newOidIdxForMIB integer, newIndexStart integer, newIndexLength 
integer, newImplied c(1) ) as declare cnt1 integer4 not null;   begin 
select :cnt1 = count(*) from "mdbadmin". IndexTable where  
:newComponentMibIndexIdx = IndexTable.ComponentMibIndexIdx; if (  
(cnt1 = 0) ) then raise error 30002 'Cannot INSERT ComponentOfIndex be
cause IndexTable does not exist.'; endif;    select :cnt1 = count(*) 
from "mdbadmin". MibStructure where  :newMibIdx = MibStructure.MibIdx 
and :newOidIdxForMIB = MibStructure.OidIdxForMIB; if (  (cnt1 = 0) ) 
then raise error 30002 'Cannot INSERT ComponentOfIndex because MibStru
cture does not exist.'; endif; end
\p\g
drop procedure pi_counterdata
\p\g
create procedure  pI_CounterData ( newCounterID integer, newSourceID 
integer, newCounterDataID integer, newTStamp date, newObjectID 
integer, newPersonSourceID integer, newPersonID integer, newDelta 
float, newWarningThreshold float, newCriticalThreshold float, 
newIsSent integer2, newTimeInterval float, newCounterValue float, 
newStringValue varchar(255), newDateValue date ) as declare cnt1 
integer4 not null;   begin   update "mdbadmin". CounterData set 
PersonSourceID = NULL, PersonID = NULL where (0 = ( select count(*) 
from "mdbadmin". Server_Person where  :newPersonSourceID = 
Server_Person.SourceID and :newPersonID = Server_Person.PersonID )) 
and CounterData.CounterID = :newCounterID and CounterData.SourceID = 
:newSourceID and CounterData.CounterDataID = :newCounterDataID ;   
update "mdbadmin". CounterData set ObjectID = NULL where (0 = ( select
count(*) from "mdbadmin". Objects where  :newObjectID = 
objects.ObjectID )) and CounterData.CounterID = :newCounterID and 
CounterData.SourceID = :newSourceID and CounterData.CounterDataID = 
:newCounterDataID ;   select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30002 'Cannot INSERT CounterData because
 CounterSource does not exist.'; endif;   select :cnt1 = count(*) from
"mdbadmin". CounterDefinition where  :newCounterID = 
CounterDefinition.CounterID; if (  (cnt1 = 0) ) then raise error 30002
'Cannot INSERT CounterData because CounterDefinition does not exist.';
endif; end
\p\g
drop procedure pi_counterpolling
\p\g
create procedure  pI_CounterPolling ( newSourceID integer, 
newCounterID integer ) as declare cnt1 integer4 not null;   begin   
select :cnt1 = count(*) from "mdbadmin". CounterDefinition where  
:newCounterID = CounterDefinition.CounterID; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT CounterPolling because CounterDefinit
ion does not exist.'; endif;   select :cnt1 = count(*) from "mdbadmin"
. CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30002 'Cannot INSERT CounterPolling beca
use CounterSource does not exist.'; endif; end
\p\g
drop procedure pi_countersource
\p\g
create procedure  pI_CounterSource ( newSourceID integer, 
newCollectorID integer, newLocaleID integer, newClusterID integer, 
newSiteID integer, newSourceName char(254), newSourceType integer, 
newHostName char(64), newActiveState integer2, newUserName 
varchar(255), newUserPwd varchar(255), newHostName1 varchar(64), 
newHostName2 varchar(64), newHostName3 varchar(64), newSrcTimeZone 
float, newMailOrgID integer ) as declare cnt1 integer4 not null;   
begin      select :cnt1 = count(*) from "mdbadmin". SourceLocale where
:newLocaleID = SourceLocale.LocaleID; if (  (cnt1 = 0) ) then raise 
error 30002 'Cannot INSERT CounterSource because SourceLocale does not
 exist.'; endif;   update "mdbadmin". CounterSource set ClusterID = 
NULL where (0 = ( select count(*) from "mdbadmin". Cluster where  
:newClusterID = Cluster.ClusterID )) and CounterSource.SourceID = 
:newSourceID ;   select :cnt1 = count(*) from "mdbadmin". Server_Site 
where  :newSiteID = Server_Site.SiteID and :newMailOrgID = 
Server_Site.MailOrgID; if (  (cnt1 = 0) ) then raise error 30002 'Cann
ot INSERT CounterSource because Server_Site does not exist.'; endif; 
end
\p\g
drop procedure pi_countertitle
\p\g
create procedure  pI_CounterTitle ( newLocaleID integer, newCounterID 
integer, newSourceType integer, newFullCounterName char(254) ) as 
declare cnt1 integer4 not null;   begin   select :cnt1 = count(*) from
"mdbadmin". SourceLocale where  :newLocaleID = SourceLocale.LocaleID; 
if (  (cnt1 = 0) ) then raise error 30002 'Cannot INSERT CounterTitle 
because SourceLocale does not exist.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". CounterDefinition where  :newCounterID = 
CounterDefinition.CounterID; if (  (cnt1 = 0) ) then raise error 30002
'Cannot INSERT CounterTitle because CounterDefinition does not exist.'
; endif; end
\p\g
drop procedure pi_discoveryvariable
\p\g
create procedure  pI_DiscoveryVariable ( newMibIdx integer, newTypeId 
integer, newOidIdxForMIB integer, newDiscGet c(1), newDiscRespLocation
c(1), newDiscRespValue varchar(32), newOper c(1), newDescription 
varchar(128) ) as declare cnt1 integer4 not null;   begin    select 
:cnt1 = count(*) from "mdbadmin". MibVariableType where  :newTypeId = 
MibVariableType.TypeId; if (  (cnt1 = 0) ) then raise error 30002 'Can
not INSERT DiscoveryVariable because MibVariableType does not exist.';
endif;    select :cnt1 = count(*) from "mdbadmin". MIBDefinition where
:newMibIdx = MIBDefinition.MibIdx; if (  (cnt1 = 0) ) then raise error
30002 'Cannot INSERT DiscoveryVariable because MIBDefinition does not 
exist.'; endif;    select :cnt1 = count(*) from "mdbadmin". 
MibStructure where  :newMibIdx = MibStructure.MibIdx and 
:newOidIdxForMIB = MibStructure.OidIdxForMIB; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT DiscoveryVariable because MibStructur
e does not exist.'; endif; end
\p\g
drop procedure pi_errorsolution
\p\g
create procedure  pI_ErrorSolution ( newErrorMessageID integer, 
newSolutionDescriptionID integer ) as declare cnt1 integer4 not null; 
begin   select :cnt1 = count(*) from "mdbadmin". SolutionDescription 
where  :newSolutionDescriptionID = 
SolutionDescription.SolutionDescriptionID; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT ErrorSolution because SolutionDescrip
tion does not exist.'; endif;   select :cnt1 = count(*) from 
"mdbadmin". ErrorMessage where  :newErrorMessageID = 
ErrorMessage.ErrorMessageID; if (  (cnt1 = 0) ) then raise error 30002
'Cannot INSERT ErrorSolution because ErrorMessage does not exist.'; 
endif; end
\p\g
drop procedure pi_gdcdiscovery
\p\g
create procedure  pI_GDCDiscovery ( newserver_addr integer, 
newprobe_addr integer, newMibIdx integer, newIntervalDateTime date, 
newDiscovered integer ) as declare cnt1 integer4 not null;   begin    
select :cnt1 = count(*) from "mdbadmin". MIBDefinition where  
:newMibIdx = MIBDefinition.MibIdx; if (  (cnt1 = 0) ) then raise error
30002 'Cannot INSERT GDCDiscovery because MIBDefinition does not exist
.'; endif; end
\p\g
drop procedure pi_mailconnector
\p\g
create procedure  pI_MailConnector ( newSourceID integer, 
newMailConnectorID integer, newConnectorTypeID integer, 
newMailConnectorName char(254), newDescription varchar(255) ) as 
declare cnt1 integer4 not null;   begin   select :cnt1 = count(*) from
"mdbadmin". ConnectorType where  :newConnectorTypeID = 
ConnectorType.ConnectorTypeID; if (  (cnt1 = 0) ) then raise error 
30002 'Cannot INSERT MailConnector because ConnectorType does not exis
t.'; endif;   select :cnt1 = count(*) from "mdbadmin". CounterSource 
where  :newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT MailConnector because CounterSource d
oes not exist.'; endif; end
\p\g
drop procedure pi_maildb
\p\g
create procedure  pI_MailDB ( newSourceID integer, newMailDBID 
integer, newDBTitle char(254), newDBFileName varchar(255), 
newMailDBName char(254), newDescription varchar(255) ) as declare cnt1
integer4 not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30002 'Cannot INSERT MailDB because Coun
terSource does not exist.'; endif; end
\p\g
drop procedure pi_maildisk
\p\g
create procedure  pI_MailDisk ( newSourceID integer, newMailDiskID 
integer, newDiskSize float, newMailDiskName char(254), newDescription 
varchar(255) ) as declare cnt1 integer4 not null;   begin   select 
:cnt1 = count(*) from "mdbadmin". CounterSource where  :newSourceID = 
CounterSource.SourceID; if (  (cnt1 = 0) ) then raise error 30002 'Can
not INSERT MailDisk because CounterSource does not exist.'; endif; end
\p\g
drop procedure pi_maildomain
\p\g
create procedure  pI_MailDomain ( newSourceID integer, newMailDomainID
integer, newMailDomainName char(254), newDescription varchar(255) ) as
declare cnt1 integer4 not null;   begin   select :cnt1 = count(*) from
"mdbadmin". CounterSource where  :newSourceID = 
CounterSource.SourceID; if (  (cnt1 = 0) ) then raise error 30002 'Can
not INSERT MailDomain because CounterSource does not exist.'; endif; 
end
\p\g
drop procedure pi_mailevent
\p\g
create procedure  pI_MailEvent ( newSourceID integer, newMailEventID 
integer, newEventTypeID integer, newEventSeverityID integer, 
newMailEventName char(254), newDescription varchar(255), newEventID 
integer, newDominoLogEventTypeID integer, newDominoEventTypeID integer
) as declare cnt1 integer4 not null;   begin   select :cnt1 = count(*)
from "mdbadmin". DominoEventType where  :newDominoEventTypeID = 
DominoEventType.DominoEventTypeID; if (  (cnt1 = 0) ) then raise error
30002 'Cannot INSERT MailEvent because DominoEventType does not exist.
'; endif;   select :cnt1 = count(*) from "mdbadmin". 
DominoLogEventType where  :newDominoLogEventTypeID = 
DominoLogEventType.DominoLogEventTypeID; if (  (cnt1 = 0) ) then raise
error 30002 'Cannot INSERT MailEvent because DominoLogEventType does n
ot exist.'; endif;   select :cnt1 = count(*) from "mdbadmin". 
EventSeverity where  :newEventSeverityID = 
EventSeverity.EventSeverityID; if (  (cnt1 = 0) ) then raise error 
30002 'Cannot INSERT MailEvent because EventSeverity does not exist.';
endif;   select :cnt1 = count(*) from "mdbadmin". EventType where  
:newEventTypeID = EventType.EventTypeID; if (  (cnt1 = 0) ) then raise
error 30002 'Cannot INSERT MailEvent because EventType does not exist.
'; endif;   select :cnt1 = count(*) from "mdbadmin". CounterSource 
where  :newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT MailEvent because CounterSource does 
not exist.'; endif; end
\p\g
drop procedure pi_mailobject
\p\g
create procedure  pI_MailObject ( newSourceID integer, newMailObjectID
integer, newMailObjectName char(254), newMailObjectType integer2, 
newDescription varchar(255) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". CounterSource where  
:newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then raise 
error 30002 'Cannot INSERT MailObject because CounterSource does not e
xist.'; endif; end
\p\g
drop procedure pi_mailqueue
\p\g
create procedure  pI_MailQueue ( newSourceID integer, newMailQueueID 
integer, newQueueType integer2, newMailQueueName char(254), 
newDescription varchar(255) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". CounterSource where  
:newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then raise 
error 30002 'Cannot INSERT MailQueue because CounterSource does not ex
ist.'; endif; end
\p\g
drop procedure pi_mailservice
\p\g
create procedure  pI_MailService ( newSourceID integer, 
newMailServiceID integer, newMailServiceName char(254), newDescription
varchar(255) ) as declare cnt1 integer4 not null;   begin   select 
:cnt1 = count(*) from "mdbadmin". CounterSource where  :newSourceID = 
CounterSource.SourceID; if (  (cnt1 = 0) ) then raise error 30002 'Can
not INSERT MailService because CounterSource does not exist.'; endif; 
end
\p\g
drop procedure pi_mibdefinition
\p\g
create procedure  pI_MIBDefinition ( newMibIdx integer, newMibType 
integer, newDescription varchar(128), newCollection c(1), newmib_id 
integer ) as declare cnt1 integer4 not null;   begin    update 
"mdbadmin". MIBDefinition set mib_id = NULL where (0 = ( select 
count(*) from "mdbadmin". network_mib where  :newmib_id = 
network_mib.ID ))    and  MIBDefinition.MibIdx = :newMibIdx ; end
\p\g
drop procedure pi_mibstructure
\p\g
create procedure  pI_MibStructure ( newMibIdx integer, newOidIdxForMIB
integer, newOID varchar(128), newType integer, newDiscoveryKey c(1), 
newIsIfIndex c(1), newIsStatus c(1), newComponentMibIndexIdx integer )
as declare cnt1 integer4 not null;   begin    update "mdbadmin". 
MibStructure set ComponentMibIndexIdx = NULL where (0 = ( select 
count(*) from "mdbadmin". IndexTable where  :newComponentMibIndexIdx =
IndexTable.ComponentMibIndexIdx ))    and  MibStructure.MibIdx = 
:newMibIdx and MibStructure.OidIdxForMIB = :newOidIdxForMIB ;    
select :cnt1 = count(*) from "mdbadmin". MIBDefinition where  
:newMibIdx = MIBDefinition.MibIdx; if (  (cnt1 = 0) ) then raise error
30002 'Cannot INSERT MibStructure because MIBDefinition does not exist
.'; endif; end
\p\g
drop procedure pi_mibvariabletype
\p\g
create procedure  pI_MibVariableType ( newTypeId integer, newCategory 
c(32), newSubcategory c(32), newDescription varchar(128), 
newBaseTypeIdx integer, newCollectable c(1) ) as declare cnt1 integer4
not null;   begin    update "mdbadmin". MibVariableType set 
BaseTypeIdx = NULL where (0 = ( select count(*) from "mdbadmin". 
MibVariableType where  :newBaseTypeIdx = MibVariableType.TypeId ))    
and  MibVariableType.TypeId = :newTypeId ; end
\p\g
drop procedure pi_objects
\p\g
create procedure  pI_Objects ( newObjectID integer, newObjectType 
integer2, newObjectName varchar(255), newDescription varchar(255), 
newObjectSourceID integer, newClusterID integer, newDomainSourceID 
integer, newMailObjectID integer, newServiceSourceID integer, 
newMailDomainID integer, newMailServiceID integer, 
newConnectorSourceID integer, newMailConnectorID integer, 
newDBSourceID integer, newMailDBID integer, newEventSourceID integer, 
newMailEventID integer, newQueueSourceID integer, newMailQueueID 
integer, newDiskSourceID integer, newMailDiskID integer ) as declare 
cnt1 integer4 not null;   begin   update "mdbadmin". Objects set 
DomainSourceID = NULL, MailDomainID = NULL where (0 = ( select 
count(*) from "mdbadmin". MailDomain where  :newDomainSourceID = 
MailDomain.SourceID and :newMailDomainID = MailDomain.MailDomainID )) 
and objects.ObjectID = :newObjectID ;   update "mdbadmin". Objects set
ObjectSourceID = NULL, MailObjectID = NULL where (0 = ( select 
count(*) from "mdbadmin". MailObject where  :newObjectSourceID = 
MailObject.SourceID and :newMailObjectID = MailObject.MailObjectID )) 
and objects.ObjectID = :newObjectID ;   update "mdbadmin". Objects set
ClusterID = NULL where (0 = ( select count(*) from "mdbadmin". Cluster
where  :newClusterID = Cluster.ClusterID )) and objects.ObjectID = 
:newObjectID ;   update "mdbadmin". Objects set ServiceSourceID = 
NULL, MailServiceID = NULL where (0 = ( select count(*) from 
"mdbadmin". MailService where  :newServiceSourceID = 
MailService.SourceID and :newMailServiceID = MailService.MailServiceID
)) and objects.ObjectID = :newObjectID ;   update "mdbadmin". Objects 
set ConnectorSourceID = NULL, MailConnectorID = NULL where (0 = ( 
select count(*) from "mdbadmin". MailConnector where  
:newConnectorSourceID = MailConnector.SourceID and :newMailConnectorID
= MailConnector.MailConnectorID )) and objects.ObjectID = :newObjectID
;   update "mdbadmin". Objects set DiskSourceID = NULL, MailDiskID = 
NULL where (0 = ( select count(*) from "mdbadmin". MailDisk where  
:newDiskSourceID = MailDisk.SourceID and :newMailDiskID = 
MailDisk.MailDiskID )) and objects.ObjectID = :newObjectID ;   update 
"mdbadmin". Objects set EventSourceID = NULL, MailEventID = NULL where
(0 = ( select count(*) from "mdbadmin". MailEvent where  
:newEventSourceID = MailEvent.SourceID and :newMailEventID = 
MailEvent.MailEventID )) and objects.ObjectID = :newObjectID ;   
update "mdbadmin". Objects set DBSourceID = NULL, MailDBID = NULL 
where (0 = ( select count(*) from "mdbadmin". MailDB where  
:newDBSourceID = MailDB.SourceID and :newMailDBID = MailDB.MailDBID ))
and objects.ObjectID = :newObjectID ;   update "mdbadmin". Objects set
QueueSourceID = NULL, MailQueueID = NULL where (0 = ( select count(*) 
from "mdbadmin". MailQueue where  :newQueueSourceID = 
MailQueue.SourceID and :newMailQueueID = MailQueue.MailQueueID )) and 
objects.ObjectID = :newObjectID ; end
\p\g
drop procedure pi_person
\p\g
create procedure  pI_Person ( newSourceID integer, newPersonID 
integer, newPersonName char(254), newDescription varchar(255), 
newDisplayName char(254), newMailFile varchar(255) ) as declare cnt1 
integer4 not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30002 'Cannot INSERT Person because Coun
terSource does not exist.'; endif; end
\p\g
drop procedure pi_pollrowdefinition
\p\g
create procedure  pI_PollRowDefinition ( newRowId integer, newMibIdx 
integer, newOidIdxForMIB integer, newOidOrder integer, newRowDesc 
varchar(128) ) as declare cnt1 integer4 not null;   begin    select 
:cnt1 = count(*) from "mdbadmin". MibStructure where  :newMibIdx = 
MibStructure.MibIdx and :newOidIdxForMIB = MibStructure.OidIdxForMIB; 
if (  (cnt1 = 0) ) then raise error 30002 'Cannot INSERT PollRowDefini
tion because MibStructure does not exist.'; endif; end
\p\g
drop procedure pi_reportcolumn
\p\g
create procedure  pI_ReportColumn ( newColumnID integer, newReportID 
integer, newThresholdColumnID integer, newThresholdReportID integer, 
newColumnName varchar(255), newIsVisible integer2, newSortBy integer2,
newFormula varchar(255), newIsDistinct integer1, newIsGroup integer2, 
newTitle varchar(255), newPresentation integer2, newUnitID integer, 
newInWorkSpace integer1 ) as declare cnt1 integer4 not null;   begin  
select :cnt1 = count(*) from "mdbadmin". Management_Report where  
:newReportID = Management_Report.ReportID; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT ReportColumn because Report does not 
exist.'; endif;       end
\p\g
drop procedure pi_reporttable
\p\g
create procedure  pI_ReportTable ( newCounterID integer, 
newReportTableID integer ) as declare cnt1 integer4 not null;   begin 
select :cnt1 = count(*) from "mdbadmin". ReportTableDefinition where  
:newReportTableID = ReportTableDefinition.ReportTableID; if (  (cnt1 =
0) ) then raise error 30002 'Cannot INSERT ReportTable because ReportT
ableDefinition does not exist.'; endif;   select :cnt1 = count(*) from
"mdbadmin". CounterDefinition where  :newCounterID = 
CounterDefinition.CounterID; if (  (cnt1 = 0) ) then raise error 30002
'Cannot INSERT ReportTable because CounterDefinition does not exist.';
endif; end
\p\g
drop procedure pi_resourcemonitoring
\p\g
create procedure  pI_ResourceMonitoring ( newserver_addr integer, 
newprobe_addr integer, newIntervalDateTime date, newMibIdx integer, 
newMonitor c(1), newIndex1 integer, newIndex2 integer, newIndex3 
integer, newIndex4 integer, newIndex5 integer ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
MIBDefinition where  :newMibIdx = MIBDefinition.MibIdx; if (  (cnt1 = 
0) ) then raise error 30002 'Cannot INSERT ResourceMonitoring because 
MIBDefinition does not exist.'; endif; end
\p\g
drop procedure pi_schedule
\p\g
create procedure  pI_Schedule ( newCollectorID integer, newActionID 
integer, newScheduleType integer2, newStartDateTime date, newOccurs 
integer2, newDailyFrequency integer2, newEvery integer, newEndDateTime
date, newSun integer1, newMon integer1, newTue integer1, newWen 
integer1, newThur integer1, newFri integer1, newSat integer1, 
newDayType integer2, newIntervalUnit integer2, newDayOfMonth integer2,
newWeekNumber integer2, newWeekDay integer2, newLastRunDate date, 
newTimeEvery integer, newInScale integer1 ) as declare cnt1 integer4 
not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
Server_CollectorAction where  :newActionID = 
Server_CollectorAction.ActionID; if (  (cnt1 = 0) ) then raise error 
30002 'Cannot INSERT Server_Schedule because CollectorAction does not 
exist.'; endif; end
\p\g
drop procedure pi_site
\p\g
create procedure  pI_Site ( newSiteID integer, newMailOrgID integer, 
newSiteName char(254) ) as declare cnt1 integer4 not null;   begin   
select :cnt1 = count(*) from "mdbadmin". MailOrganisation where  
:newMailOrgID = MailOrganisation.MailOrgID; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT Server_Site because MailOrganisation 
does not exist.'; endif; end
\p\g
drop procedure pi_tablesdescription
\p\g
create procedure  pI_TablesDescription ( newOidIdxForMIB integer, 
newMibIdx integer, newTableIdx integer, newOrderOfColumn integer, 
newTypeOfSaving c(1), newCollectable c(1) ) as declare cnt1 integer4 
not null;   begin    select :cnt1 = count(*) from "mdbadmin". 
MibStructure where  :newMibIdx = MibStructure.MibIdx and 
:newOidIdxForMIB = MibStructure.OidIdxForMIB; if (  (cnt1 = 0) ) then 
raise error 30002 'Cannot INSERT TablesDescription because MibStructur
e does not exist.'; endif;    select :cnt1 = count(*) from "mdbadmin".
ColumnDefinition where  :newTableIdx = ColumnDefinition.TableIdx and 
:newOrderOfColumn = ColumnDefinition.OrderOfColumn; if (  (cnt1 = 0) )
then raise error 30002 'Cannot INSERT TablesDescription because Column
Definition does not exist.'; endif; end
\p\g
drop procedure pi_tau_mdb_product
\p\g
create procedure  pI_tau_mdb_product ( newmdbMajorVersion integer, 
newmdbMinorVersion integer, newproductName varchar(64), 
newproductMajorVersion integer, newproductMinorVersion integer ) as 
declare cnt1 integer4 not null;   begin    select :cnt1 = count(*) 
from "mdbadmin". tau_product where  :newproductName = 
tau_product.productName and :newproductMajorVersion = 
tau_product.productMajorVersion and :newproductMinorVersion = 
tau_product.productMinorVersion; if (  (cnt1 = 0) ) then raise error 
30002 'Cannot INSERT tau_mdb_product because tau_product does not exis
t.'; endif;    select :cnt1 = count(*) from "mdbadmin". tau_mdb where 
:newmdbMajorVersion = tau_mdb.mdbMajorVersion and :newmdbMinorVersion 
= tau_mdb.mdbMinorVersion; if (  (cnt1 = 0) ) then raise error 30002 '
Cannot INSERT tau_mdb_product because tau_mdb does not exist.'; endif;
end
\p\g
drop procedure pu_alert
\p\g
create procedure  pU_Alert ( oldCounterID integer, oldSourceID 
integer, oldAlertID integer, oldSource char(254), oldTStamp date, 
oldObjectID integer, oldPersonSourceID integer, oldPersonID integer, 
oldStatus integer2, oldDescription varchar(255), oldThreshold float, 
oldPrevStatus integer2, oldIsSent integer2, oldCounterValue float, 
oldStringValue varchar(255), oldDateValue date, newCounterID integer, 
newSourceID integer, newAlertID integer, newSource char(254), 
newTStamp date, newObjectID integer, newPersonSourceID integer, 
newPersonID integer, newStatus integer2, newDescription varchar(255), 
newThreshold float, newPrevStatus integer2, newIsSent integer2, 
newCounterValue float, newStringValue varchar(255), newDateValue date 
) as declare cnt1 integer4 not null; begin select :cnt1 = count(*) 
from "mdbadmin". CounterSource where :newSourceID = 
CounterSource.SourceID; if ((cnt1 = 0)) then raise error 30007 'Cannot
 UPDATE Alert because CounterSource does not exist.'; endif; update 
"mdbadmin". Management_Alert set ObjectID = NULL where (0 = ( select 
count(*) from "mdbadmin". Objects where :newObjectID = 
objects.ObjectID )) and Management_Alert.CounterID = :newCounterID and
Management_Alert.SourceID = :newSourceID and Management_Alert.AlertID 
= :newAlertID ; update "mdbadmin". Management_Alert set PersonSourceID
= NULL, PersonID = NULL where (0 = ( select count(*) from "mdbadmin". 
Server_Person where :newPersonSourceID = Server_Person.SourceID and 
:newPersonID = Server_Person.PersonID )) and 
Management_Alert.CounterID = :newCounterID and 
Management_Alert.SourceID = :newSourceID and Management_Alert.AlertID 
= :newAlertID ; end
\p\g
drop procedure pu_cluster
\p\g
create procedure  pU_Cluster ( oldClusterID integer, oldClusterName 
char(254), oldClusterType integer2, oldDescription varchar(255), 
newClusterID integer, newClusterName char(254), newClusterType 
integer2, newDescription varchar(255) ) as declare cnt1 integer4 not 
null;   begin    if  :oldClusterID <> :newClusterID then update 
"mdbadmin". Objects set ClusterID = NULL where  Objects.ClusterID = 
:oldClusterID; endif;    if  :oldClusterID <> :newClusterID then 
update "mdbadmin". CounterSource set ClusterID = NULL where  
CounterSource.ClusterID = :oldClusterID; endif; end
\p\g
drop procedure pu_collector
\p\g
create procedure  pU_Collector ( oldCollectorID integer, 
oldCollectorName char(15), oldParentCollectorID integer, oldHostName 
char(64), oldServerName varchar(255), oldDBName varchar(255), 
oldUserName varchar(255), oldUserPsw varchar(255), oldLogFileLocation 
varchar(255), oldNeedRefresh integer2, oldCollectorType integer2, 
oldRawDataKeepInterval integer, oldRawDataTimeFactor integer2, 
oldHourlyDataKeepInterval integer, oldHourlyTimeFactor integer2, 
oldDailyDataKeepInterval integer, oldDailyTimeFactor integer2, 
oldWeeklyDataKeepInterval integer, oldWeeklyTimeFactor integer2, 
oldMonthlyDataKeepInterval integer, oldMonthlyTimeFactor integer2, 
oldYearlyDataKeepInterval integer, oldYearlyTimeFactor integer2, 
oldInactive integer1, oldTopNServers integer, oldTopNPersons integer, 
oldTopNObjects integer, oldAlertLimit integer, oldIDFile1 varchar(8,0)
, oldIDFile2 varchar(8,0), oldOneIDFile integer1, oldIDFilePwd 
varchar(8,0), newCollectorID integer, newCollectorName char(15), 
newParentCollectorID integer, newHostName char(64), newServerName 
varchar(255), newDBName varchar(255), newUserName varchar(255), 
newUserPsw varchar(255), newLogFileLocation varchar(255), 
newNeedRefresh integer2, newCollectorType integer2, 
newRawDataKeepInterval integer, newRawDataTimeFactor integer2, 
newHourlyDataKeepInterval integer, newHourlyTimeFactor integer2, 
newDailyDataKeepInterval integer, newDailyTimeFactor integer2, 
newWeeklyDataKeepInterval integer, newWeeklyTimeFactor integer2, 
newMonthlyDataKeepInterval integer, newMonthlyTimeFactor integer2, 
newYearlyDataKeepInterval integer, newYearlyTimeFactor integer2, 
newInactive integer1, newTopNServers integer, newTopNPersons integer, 
newTopNObjects integer, newAlertLimit integer, newIDFile1 varchar(8,0)
, newIDFile2 varchar(8,0), newOneIDFile integer1, newIDFilePwd 
varchar(8,0) ) as declare cnt1 integer4 not null;   begin   if  
:oldCollectorID <> :newCollectorID then update "mdbadmin". 
CounterSource set CollectorID = :newCollectorID where  
CounterSource.CollectorID = :oldCollectorID; endif;    end
\p\g
drop procedure pu_collectorpolling
\p\g
create procedure  pU_CollectorPolling ( oldCollectorID integer, 
oldCounterID integer, newCollectorID integer, newCounterID integer ) 
as declare cnt1 integer4 not null;   begin   select :cnt1 = count(*) 
from "mdbadmin". Server_Collector where  :newCollectorID = 
Server_Collector.CollectorID; if (  (cnt1 = 0) ) then raise error 
30007 'Cannot UPDATE CollectorPolling because Collector does not exist
.'; endif;   select :cnt1 = count(*) from "mdbadmin". 
CounterDefinition where  :newCounterID = CounterDefinition.CounterID; 
if (  (cnt1 = 0) ) then raise error 30007 'Cannot UPDATE CollectorPoll
ing because CounterDefinition does not exist.'; endif; end
\p\g
drop procedure pu_columndefinition
\p\g
create procedure  pU_ColumnDefinition ( oldTableIdx integer, 
oldOrderOfColumn integer, oldName varchar(32), oldTypeId integer, 
oldRollUpType c(1), oldReportLabel varchar(128), newTableIdx integer, 
newOrderOfColumn integer, newName varchar(32), newTypeId integer, 
newRollUpType c(1), newReportLabel varchar(128) ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
TablesDescription where  TablesDescription.TableIdx = :oldTableIdx and
TablesDescription.OrderOfColumn = :oldOrderOfColumn; if ((cnt1 > 0)) 
then raise error 30005 'Cannot UPDATE ColumnDefinition because TablesD
escription exists.'; endif;    select :cnt1 = count(*) from "mdbadmin"
. TableDefinition where  :newTableIdx = TableDefinition.TableIdx; if (
(cnt1 = 0) ) then raise error 30007 'Cannot UPDATE ColumnDefinition be
cause TableDefinition does not exist.'; endif;    select :cnt1 = 
count(*) from "mdbadmin". MibVariableType where  :newTypeId = 
MibVariableType.TypeId; if (  (cnt1 = 0) ) then raise error 30007 'Can
not UPDATE ColumnDefinition because MibVariableType does not exist.'; 
endif; end
\p\g
drop procedure pu_componentofindex
\p\g
create procedure  pU_ComponentOfIndex ( oldComponentMibIndexIdx 
integer, oldComponentOfIndexOrder integer, oldMibIdx integer, 
oldOidIdxForMIB integer, oldIndexStart integer, oldIndexLength 
integer, oldImplied c(1), newComponentMibIndexIdx integer, 
newComponentOfIndexOrder integer, newMibIdx integer, newOidIdxForMIB 
integer, newIndexStart integer, newIndexLength integer, newImplied 
c(1) ) as declare cnt1 integer4 not null;   begin    select :cnt1 = 
count(*) from "mdbadmin". IndexTable where  :newComponentMibIndexIdx =
IndexTable.ComponentMibIndexIdx; if (  (cnt1 = 0) ) then raise error 
30007 'Cannot UPDATE ComponentOfIndex because IndexTable does not exis
t.'; endif;    select :cnt1 = count(*) from "mdbadmin". MibStructure 
where  :newMibIdx = MibStructure.MibIdx and :newOidIdxForMIB = 
MibStructure.OidIdxForMIB; if (  (cnt1 = 0) ) then raise error 30007 '
Cannot UPDATE ComponentOfIndex because MibStructure does not exist.'; 
endif; end
\p\g
drop procedure pu_connectortype
\p\g
create procedure  pU_ConnectorType ( oldConnectorTypeID integer, 
oldConnectorTypeName varchar(255), newConnectorTypeID integer, 
newConnectorTypeName varchar(255) ) as declare cnt1 integer4 not null;
begin   select :cnt1 = count(*) from "mdbadmin". MailConnector where  
MailConnector.ConnectorTypeID = :oldConnectorTypeID; if ((cnt1 > 0)) 
then raise error 30005 'Cannot UPDATE ConnectorType because MailConnec
tor exists.'; endif; end
\p\g
drop procedure pu_counterdata
\p\g
create procedure  pU_CounterData ( oldCounterID integer, oldSourceID 
integer, oldCounterDataID integer, oldTStamp date, oldObjectID 
integer, oldPersonSourceID integer, oldPersonID integer, oldDelta 
float, oldWarningThreshold float, oldCriticalThreshold float, 
oldIsSent integer2, oldTimeInterval float, oldCounterValue float, 
oldStringValue varchar(255), oldDateValue date, newCounterID integer, 
newSourceID integer, newCounterDataID integer, newTStamp date, 
newObjectID integer, newPersonSourceID integer, newPersonID integer, 
newDelta float, newWarningThreshold float, newCriticalThreshold float,
newIsSent integer2, newTimeInterval float, newCounterValue float, 
newStringValue varchar(255), newDateValue date ) as declare cnt1 
integer4 not null;   begin   update "mdbadmin". CounterData set 
PersonSourceID = NULL, PersonID = NULL where (0 = ( select count(*) 
from "mdbadmin". Server_Person where :newPersonSourceID = 
Server_Person.SourceID and :newPersonID = Server_Person.PersonID )) 
and CounterData.CounterID = :newCounterID and CounterData.SourceID = 
:newSourceID and CounterData.CounterDataID = :newCounterDataID ;   
update "mdbadmin". CounterData set ObjectID = NULL where (0 = ( select
count(*) from "mdbadmin". Objects where  :newObjectID = 
objects.ObjectID )) and CounterData.CounterID = :newCounterID and 
CounterData.SourceID = :newSourceID and CounterData.CounterDataID = 
:newCounterDataID ;   select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30007 'Cannot UPDATE CounterData because
 CounterSource does not exist.'; endif;   select :cnt1 = count(*) from
"mdbadmin". CounterDefinition where  :newCounterID = 
CounterDefinition.CounterID; if (  (cnt1 = 0) ) then raise error 30007
'Cannot UPDATE CounterData because CounterDefinition does not exist.';
endif; end
\p\g
drop procedure pu_counterpolling
\p\g
create procedure  pU_CounterPolling ( oldSourceID integer, 
oldCounterID integer, newSourceID integer, newCounterID integer ) as 
declare cnt1 integer4 not null;   begin   select :cnt1 = count(*) from
"mdbadmin". CounterDefinition where  :newCounterID = 
CounterDefinition.CounterID; if (  (cnt1 = 0) ) then raise error 30007
'Cannot UPDATE CounterPolling because CounterDefinition does not exist
.'; endif;   select :cnt1 = count(*) from "mdbadmin". CounterSource 
where  :newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then 
raise error 30007 'Cannot UPDATE CounterPolling because CounterSource 
does not exist.'; endif; end
\p\g
drop procedure pu_countersource
\p\g
create procedure  pU_CounterSource ( oldSourceID integer, 
oldCollectorID integer, oldLocaleID integer, oldClusterID integer, 
oldSiteID integer, oldSourceName char(254), oldSourceType integer, 
oldHostName char(64), oldActiveState integer2, oldUserName 
varchar(255), oldUserPwd varchar(255), oldHostName1 varchar(64), 
oldHostName2 varchar(64), oldHostName3 varchar(64), oldSrcTimeZone 
float, oldMailOrgID integer, newSourceID integer, newCollectorID 
integer, newLocaleID integer, newClusterID integer, newSiteID integer,
newSourceName char(254), newSourceType integer, newHostName char(64), 
newActiveState integer2, newUserName varchar(255), newUserPwd 
varchar(255), newHostName1 varchar(64), newHostName2 varchar(64), 
newHostName3 varchar(64), newSrcTimeZone float, newMailOrgID integer )
as declare cnt1 integer4 not null;   begin   select :cnt1 = count(*) 
from "mdbadmin". MailDomain where  MailDomain.SourceID = :oldSourceID;
if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE CounterSource be
cause MailDomain exists.'; endif;   select :cnt1 = count(*) from 
"mdbadmin". MailObject where  MailObject.SourceID = :oldSourceID; if 
((cnt1 > 0)) then raise error 30005 'Cannot UPDATE CounterSource becau
se MailObject exists.'; endif;   select :cnt1 = count(*) from 
"mdbadmin". MailService where  MailService.SourceID = :oldSourceID; if
((cnt1 > 0)) then raise error 30005 'Cannot UPDATE CounterSource becau
se MailService exists.'; endif;   select :cnt1 = count(*) from 
"mdbadmin". MailConnector where  MailConnector.SourceID = 
:oldSourceID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE Co
unterSource because MailConnector exists.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". MailDisk where  MailDisk.SourceID = 
:oldSourceID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE Co
unterSource because MailDisk exists.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". MailEvent where  MailEvent.SourceID = 
:oldSourceID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE Co
unterSource because MailEvent exists.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". MailDB where  MailDB.SourceID = 
:oldSourceID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE Co
unterSource because MailDB exists.'; endif;   select :cnt1 = count(*) 
from "mdbadmin". MailQueue where  MailQueue.SourceID = :oldSourceID; 
if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE CounterSource be
cause MailQueue exists.'; endif;   select :cnt1 = count(*) from 
"mdbadmin". Server_Person where  Server_Person.SourceID = 
:oldSourceID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE Co
unterSource because Person exists.'; endif;      select :cnt1 = 
count(*) from "mdbadmin". SourceLocale where  :newLocaleID = 
SourceLocale.LocaleID; if (  (cnt1 = 0) ) then raise error 30007 'Cann
ot UPDATE CounterSource because SourceLocale does not exist.'; endif; 
update "mdbadmin". CounterSource set ClusterID = NULL where (0 = ( 
select count(*) from "mdbadmin". Cluster where  :newClusterID = 
Cluster.ClusterID )) and CounterSource.SourceID = :newSourceID ;   
select :cnt1 = count(*) from "mdbadmin". Server_Site where  :newSiteID
= Server_Site.SiteID and :newMailOrgID = Server_Site.MailOrgID; if (  
(cnt1 = 0) ) then raise error 30007 'Cannot UPDATE CounterSource becau
se Server_Site does not exist.'; endif; end
\p\g
drop procedure pu_countertitle
\p\g
create procedure  pU_CounterTitle ( oldLocaleID integer, oldCounterID 
integer, oldSourceType integer, oldFullCounterName char(254), 
newLocaleID integer, newCounterID integer, newSourceType integer, 
newFullCounterName char(254) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". SourceLocale where  
:newLocaleID = SourceLocale.LocaleID; if (  (cnt1 = 0) ) then raise 
error 30007 'Cannot UPDATE CounterTitle because SourceLocale does not 
exist.'; endif;   select :cnt1 = count(*) from "mdbadmin". 
CounterDefinition where  :newCounterID = CounterDefinition.CounterID; 
if (  (cnt1 = 0) ) then raise error 30007 'Cannot UPDATE CounterTitle 
because CounterDefinition does not exist.'; endif; end
\p\g
drop procedure pu_discoveryvariable
\p\g
create procedure  pU_DiscoveryVariable ( oldMibIdx integer, oldTypeId 
integer, oldOidIdxForMIB integer, oldDiscGet c(1), oldDiscRespLocation
c(1), oldDiscRespValue varchar(32), oldOper c(1), oldDescription 
varchar(128), newMibIdx integer, newTypeId integer, newOidIdxForMIB 
integer, newDiscGet c(1), newDiscRespLocation c(1), newDiscRespValue 
varchar(32), newOper c(1), newDescription varchar(128) ) as declare 
cnt1 integer4 not null;   begin    select :cnt1 = count(*) from 
"mdbadmin". MibVariableType where  :newTypeId = 
MibVariableType.TypeId; if (  (cnt1 = 0) ) then raise error 30007 'Can
not UPDATE DiscoveryVariable because MibVariableType does not exist.';
endif;    select :cnt1 = count(*) from "mdbadmin". MIBDefinition where
:newMibIdx = MIBDefinition.MibIdx; if (  (cnt1 = 0) ) then raise error
30007 'Cannot UPDATE DiscoveryVariable because MIBDefinition does not 
exist.'; endif;    select :cnt1 = count(*) from "mdbadmin". 
MibStructure where  :newMibIdx = MibStructure.MibIdx and 
:newOidIdxForMIB = MibStructure.OidIdxForMIB; if (  (cnt1 = 0) ) then 
raise error 30007 'Cannot UPDATE DiscoveryVariable because MibStructur
e does not exist.'; endif; end
\p\g
drop procedure pu_dominoeventtype
\p\g
create procedure  pU_DominoEventType ( oldDominoEventTypeID integer, 
oldDominoEventTypeName char(254), newDominoEventTypeID integer, 
newDominoEventTypeName char(254) ) as declare cnt1 integer4 not null; 
begin   select :cnt1 = count(*) from "mdbadmin". MailEvent where  
MailEvent.DominoEventTypeID = :oldDominoEventTypeID; if ((cnt1 > 0)) 
then raise error 30005 'Cannot UPDATE DominoEventType because MailEven
t exists.'; endif; end
\p\g
drop procedure pu_dominologeventtype
\p\g
create procedure  pU_DominoLogEventType ( oldDominoLogEventTypeID 
integer, oldDominoLogEventTypeName char(254), newDominoLogEventTypeID 
integer, newDominoLogEventTypeName char(254) ) as declare cnt1 
integer4 not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
MailEvent where  MailEvent.DominoLogEventTypeID = 
:oldDominoLogEventTypeID; if ((cnt1 > 0)) then raise error 30005 'Cann
ot UPDATE DominoLogEventType because MailEvent exists.'; endif; end
\p\g
drop procedure pu_errormessage
\p\g
create procedure  pU_ErrorMessage ( oldErrorMessageID integer, 
oldSourceType integer, oldMessageText varchar(255), newErrorMessageID 
integer, newSourceType integer, newMessageText varchar(255) ) as 
declare cnt1 integer4 not null;   begin   select :cnt1 = count(*) from
"mdbadmin". ErrorSolution where  ErrorSolution.ErrorMessageID = 
:oldErrorMessageID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPD
ATE ErrorMessage because ErrorSolution exists.'; endif; end
\p\g
drop procedure pu_errorsolution
\p\g
create procedure  pU_ErrorSolution ( oldErrorMessageID integer, 
oldSolutionDescriptionID integer, newErrorMessageID integer, 
newSolutionDescriptionID integer ) as declare cnt1 integer4 not null; 
begin select :cnt1 = count(*) from "mdbadmin". SolutionDescription 
where :newSolutionDescriptionID = 
SolutionDescription.SolutionDescriptionID; if ((cnt1 = 0)) then raise 
error 30007 'Cannot UPDATE ErrorSolution because SolutionDescription d
oes not exist.'; endif; select :cnt1 = count(*) from "mdbadmin". 
ErrorMessage where :newErrorMessageID = ErrorMessage.ErrorMessageID; 
if ((cnt1 = 0)) then raise error 30007 'Cannot UPDATE ErrorSolution be
cause ErrorMessage does not exist.'; endif; end
\p\g
drop procedure pu_eventseverity
\p\g
create procedure  pU_EventSeverity ( oldEventSeverityID integer, 
oldEventSeverityName varchar(255), newEventSeverityID integer, 
newEventSeverityName varchar(255) ) as declare cnt1 integer4 not null;
begin   select :cnt1 = count(*) from "mdbadmin". MailEvent where  
MailEvent.EventSeverityID = :oldEventSeverityID; if ((cnt1 > 0)) then 
raise error 30005 'Cannot UPDATE EventSeverity because MailEvent exist
s.'; endif; end
\p\g
drop procedure pu_eventtype
\p\g
create procedure  pU_EventType ( oldEventTypeID integer, 
oldEventTypeName varchar(255), newEventTypeID integer, 
newEventTypeName varchar(255) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". MailEvent where  
MailEvent.EventTypeID = :oldEventTypeID; if ((cnt1 > 0)) then raise 
error 30005 'Cannot UPDATE EventType because MailEvent exists.'; 
endif; end
\p\g
drop procedure pu_gdcdiscovery
\p\g
create procedure  pU_GDCDiscovery ( oldserver_addr integer, 
oldprobe_addr integer, oldMibIdx integer, oldIntervalDateTime date, 
oldDiscovered integer, newserver_addr integer, newprobe_addr integer, 
newMibIdx integer, newIntervalDateTime date, newDiscovered integer ) 
as declare cnt1 integer4 not null;   begin    select :cnt1 = count(*) 
from "mdbadmin". MIBDefinition where  :newMibIdx = 
MIBDefinition.MibIdx; if (  (cnt1 = 0) ) then raise error 30007 'Canno
t UPDATE GDCDiscovery because MIBDefinition does not exist.'; endif; 
end
\p\g
drop procedure pu_indextable
\p\g
create procedure  pU_IndexTable ( oldComponentMibIndexIdx integer, 
oldTypeOfIndexRetrieval c(1), oldIndexBaseOID varchar(128), 
oldIndexStartLoc integer, oldIndexLength float, oldColOidId 
varchar(32), newComponentMibIndexIdx integer, newTypeOfIndexRetrieval 
c(1), newIndexBaseOID varchar(128), newIndexStartLoc integer, 
newIndexLength float, newColOidId varchar(32) ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
ComponentOfIndex where  ComponentOfIndex.ComponentMibIndexIdx = 
:oldComponentMibIndexIdx; if ((cnt1 > 0)) then raise error 30005 'Cann
ot UPDATE IndexTable because ComponentOfIndex exists.'; endif;    if  
:oldComponentMibIndexIdx <> :newComponentMibIndexIdx then update 
"mdbadmin". MibStructure set ComponentMibIndexIdx = NULL where  
MibStructure.ComponentMibIndexIdx = :oldComponentMibIndexIdx; endif; 
end
\p\g
drop procedure pu_mailconnector
\p\g
create procedure  pU_MailConnector ( oldSourceID integer, 
oldMailConnectorID integer, oldConnectorTypeID integer, 
oldMailConnectorName char(254), oldDescription varchar(255), 
newSourceID integer, newMailConnectorID integer, newConnectorTypeID 
integer, newMailConnectorName char(254), newDescription varchar(255) )
as declare cnt1 integer4 not null;   begin    if  :oldSourceID <> 
:newSourceID or :oldMailConnectorID <> :newMailConnectorID then update
"mdbadmin". Objects set ConnectorSourceID = NULL, MailConnectorID = 
NULL where  Objects.ConnectorSourceID = :oldSourceID and 
Objects.MailConnectorID = :oldMailConnectorID; endif;    select :cnt1 
= count(*) from "mdbadmin". ConnectorType where  :newConnectorTypeID =
ConnectorType.ConnectorTypeID; if (  (cnt1 = 0) ) then raise error 
30007 'Cannot UPDATE MailConnector because ConnectorType does not exis
t.'; endif;    select :cnt1 = count(*) from "mdbadmin". CounterSource 
where  :newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then 
raise error 30007 'Cannot UPDATE MailConnector because CounterSource d
oes not exist.'; endif; end
\p\g
drop procedure pu_maildb
\p\g
create procedure  pU_MailDB ( oldSourceID integer, oldMailDBID 
integer, oldDBTitle char(254), oldDBFileName varchar(255), 
oldMailDBName char(254), oldDescription varchar(255), newSourceID 
integer, newMailDBID integer, newDBTitle char(254), newDBFileName 
varchar(255), newMailDBName char(254), newDescription varchar(255) ) 
as declare cnt1 integer4 not null;   begin    if  :oldSourceID <> 
:newSourceID or :oldMailDBID <> :newMailDBID then update "mdbadmin". 
Objects set DBSourceID = NULL, MailDBID = NULL where  
Objects.DBSourceID = :oldSourceID and Objects.MailDBID = :oldMailDBID;
endif;    select :cnt1 = count(*) from "mdbadmin". CounterSource where
:newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then raise 
error 30007 'Cannot UPDATE MailDB because CounterSource does not exist
.'; endif; end
\p\g
drop procedure pu_maildisk
\p\g
create procedure  pU_MailDisk ( oldSourceID integer, oldMailDiskID 
integer, oldDiskSize float, oldMailDiskName char(254), oldDescription 
varchar(255), newSourceID integer, newMailDiskID integer, newDiskSize 
float, newMailDiskName char(254), newDescription varchar(255) ) as 
declare cnt1 integer4 not null;   begin    if  :oldSourceID <> 
:newSourceID or :oldMailDiskID <> :newMailDiskID then update 
"mdbadmin". Objects set DiskSourceID = NULL, MailDiskID = NULL where  
Objects.DiskSourceID = :oldSourceID and Objects.MailDiskID = 
:oldMailDiskID; endif;    select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30007 'Cannot UPDATE MailDisk because Co
unterSource does not exist.'; endif; end
\p\g
drop procedure pu_maildomain
\p\g
create procedure  pU_MailDomain ( oldSourceID integer, oldMailDomainID
integer, oldMailDomainName char(254), oldDescription varchar(255), 
newSourceID integer, newMailDomainID integer, newMailDomainName 
char(254), newDescription varchar(255) ) as declare cnt1 integer4 not 
null;   begin    if  :oldSourceID <> :newSourceID or :oldMailDomainID 
<> :newMailDomainID then update "mdbadmin". Objects set DomainSourceID
= NULL, MailDomainID = NULL where  Objects.DomainSourceID = 
:oldSourceID and Objects.MailDomainID = :oldMailDomainID; endif;    
select :cnt1 = count(*) from "mdbadmin". CounterSource where  
:newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then raise 
error 30007 'Cannot UPDATE MailDomain because CounterSource does not e
xist.'; endif; end
\p\g
drop procedure pu_mailevent
\p\g
create procedure  pU_MailEvent ( oldSourceID integer, oldMailEventID 
integer, oldEventTypeID integer, oldEventSeverityID integer, 
oldMailEventName char(254), oldDescription varchar(255), oldEventID 
integer, oldDominoLogEventTypeID integer, oldDominoEventTypeID 
integer, newSourceID integer, newMailEventID integer, newEventTypeID 
integer, newEventSeverityID integer, newMailEventName char(254), 
newDescription varchar(255), newEventID integer, 
newDominoLogEventTypeID integer, newDominoEventTypeID integer ) as 
declare cnt1 integer4 not null;   begin    if  :oldSourceID <> 
:newSourceID or :oldMailEventID <> :newMailEventID then update 
"mdbadmin". Objects set EventSourceID = NULL, MailEventID = NULL where
Objects.EventSourceID = :oldSourceID and Objects.MailEventID = 
:oldMailEventID; endif;          select :cnt1 = count(*) from 
"mdbadmin". EventSeverity where  :newEventSeverityID = 
EventSeverity.EventSeverityID; if (  (cnt1 = 0) ) then raise error 
30007 'Cannot UPDATE MailEvent because EventSeverity does not exist.';
endif;    select :cnt1 = count(*) from "mdbadmin". EventType where  
:newEventTypeID = EventType.EventTypeID; if (  (cnt1 = 0) ) then raise
error 30007 'Cannot UPDATE MailEvent because EventType does not exist.
'; endif;    select :cnt1 = count(*) from "mdbadmin". CounterSource 
where  :newSourceID = CounterSource.SourceID; if (  (cnt1 = 0) ) then 
raise error 30007 'Cannot UPDATE MailEvent because CounterSource does 
not exist.'; endif; end
\p\g
drop procedure pu_mailobject
\p\g
create procedure  pU_MailObject ( oldSourceID integer, oldMailObjectID
integer, oldMailObjectName char(254), oldMailObjectType integer2, 
oldDescription varchar(255), newSourceID integer, newMailObjectID 
integer, newMailObjectName char(254), newMailObjectType integer2, 
newDescription varchar(255) ) as declare cnt1 integer4 not null;   
begin    if  :oldSourceID <> :newSourceID or :oldMailObjectID <> 
:newMailObjectID then update "mdbadmin". Objects set ObjectSourceID = 
NULL, MailObjectID = NULL where  Objects.ObjectSourceID = :oldSourceID
and Objects.MailObjectID = :oldMailObjectID; endif;    select :cnt1 = 
count(*) from "mdbadmin". CounterSource where  :newSourceID = 
CounterSource.SourceID; if (  (cnt1 = 0) ) then raise error 30007 'Can
not UPDATE MailObject because CounterSource does not exist.'; endif; 
end
\p\g
drop procedure pu_mailorganisation
\p\g
create procedure  pU_MailOrganisation ( oldMailOrgID integer, 
oldOrganisationName char(254), newMailOrgID integer, 
newOrganisationName char(254) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". Server_Site where  
Server_Site.MailOrgID = :oldMailOrgID; if ((cnt1 > 0)) then raise 
error 30005 'Cannot UPDATE MailOrganisation because Server_Site exists
.'; endif; end
\p\g
drop procedure pu_mailqueue
\p\g
create procedure  pU_MailQueue ( oldSourceID integer, oldMailQueueID 
integer, oldQueueType integer2, oldMailQueueName char(254), 
oldDescription varchar(255), newSourceID integer, newMailQueueID 
integer, newQueueType integer2, newMailQueueName char(254), 
newDescription varchar(255) ) as declare cnt1 integer4 not null;   
begin    if  :oldSourceID <> :newSourceID or :oldMailQueueID <> 
:newMailQueueID then update "mdbadmin". Objects set QueueSourceID = 
NULL, MailQueueID = NULL where  Objects.QueueSourceID = :oldSourceID 
and Objects.MailQueueID = :oldMailQueueID; endif;    select :cnt1 = 
count(*) from "mdbadmin". CounterSource where  :newSourceID = 
CounterSource.SourceID; if (  (cnt1 = 0) ) then raise error 30007 'Can
not UPDATE MailQueue because CounterSource does not exist.'; endif; 
end
\p\g
drop procedure pu_mailservice
\p\g
create procedure  pU_MailService ( oldSourceID integer, 
oldMailServiceID integer, oldMailServiceName char(254), oldDescription
varchar(255), newSourceID integer, newMailServiceID integer, 
newMailServiceName char(254), newDescription varchar(255) ) as declare
cnt1 integer4 not null;   begin    if  :oldSourceID <> :newSourceID or
:oldMailServiceID <> :newMailServiceID then update "mdbadmin". Objects
set ServiceSourceID = NULL, MailServiceID = NULL where  
Objects.ServiceSourceID = :oldSourceID and Objects.MailServiceID = 
:oldMailServiceID; endif;    select :cnt1 = count(*) from "mdbadmin". 
CounterSource where  :newSourceID = CounterSource.SourceID; if (  
(cnt1 = 0) ) then raise error 30007 'Cannot UPDATE MailService because
 CounterSource does not exist.'; endif; end
\p\g
drop procedure pu_mibdefinition
\p\g
create procedure  pU_MIBDefinition ( oldMibIdx integer, oldMibType 
integer, oldDescription varchar(128), oldCollection c(1), oldmib_id 
integer, newMibIdx integer, newMibType integer, newDescription 
varchar(128), newCollection c(1), newmib_id integer ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
DiscoveryVariable where  DiscoveryVariable.MibIdx = :oldMibIdx; if 
((cnt1 > 0)) then raise error 30005 'Cannot UPDATE MIBDefinition becau
se DiscoveryVariable exists.'; endif;    select :cnt1 = count(*) from 
"mdbadmin". MibStructure where  MibStructure.MibIdx = :oldMibIdx; if 
((cnt1 > 0)) then raise error 30005 'Cannot UPDATE MIBDefinition becau
se MibStructure exists.'; endif;    if  :oldMibIdx <> :newMibIdx then 
update "mdbadmin". ThresholdDesc set MibIdx = NULL where  
ThresholdDesc.MibIdx = :oldMibIdx; endif;    select :cnt1 = count(*) 
from "mdbadmin". GDCDiscovery where  GDCDiscovery.MibIdx = :oldMibIdx;
if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE MIBDefinition be
cause GDCDiscovery exists.'; endif;    select :cnt1 = count(*) from 
"mdbadmin". ResourceMonitoring where  ResourceMonitoring.MibIdx = 
:oldMibIdx; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE MIBD
efinition because ResourceMonitoring exists.'; endif; end
\p\g
drop procedure pu_mibstructure
\p\g
create procedure  pU_MibStructure ( oldMibIdx integer, oldOidIdxForMIB
integer, oldOID varchar(128), oldType integer, oldDiscoveryKey c(1), 
oldIsIfIndex c(1), oldIsStatus c(1), oldComponentMibIndexIdx integer, 
newMibIdx integer, newOidIdxForMIB integer, newOID varchar(128), 
newType integer, newDiscoveryKey c(1), newIsIfIndex c(1), newIsStatus 
c(1), newComponentMibIndexIdx integer ) as declare cnt1 integer4 not 
null;   begin    select :cnt1 = count(*) from "mdbadmin". 
PollRowDefinition where  PollRowDefinition.MibIdx = :oldMibIdx and 
PollRowDefinition.OidIdxForMIB = :oldOidIdxForMIB; if ((cnt1 > 0)) 
then raise error 30005 'Cannot UPDATE MibStructure because PollRowDefi
nition exists.'; endif;    select :cnt1 = count(*) from "mdbadmin". 
TablesDescription where  TablesDescription.MibIdx = :oldMibIdx and 
TablesDescription.OidIdxForMIB = :oldOidIdxForMIB; if ((cnt1 > 0)) 
then raise error 30005 'Cannot UPDATE MibStructure because TablesDescr
iption exists.'; endif;    select :cnt1 = count(*) from "mdbadmin". 
ComponentOfIndex where  ComponentOfIndex.MibIdx = :oldMibIdx and 
ComponentOfIndex.OidIdxForMIB = :oldOidIdxForMIB; if ((cnt1 > 0)) then
raise error 30005 'Cannot UPDATE MibStructure because ComponentOfIndex
 exists.'; endif;    select :cnt1 = count(*) from "mdbadmin". 
DiscoveryVariable where  DiscoveryVariable.MibIdx = :oldMibIdx and 
DiscoveryVariable.OidIdxForMIB = :oldOidIdxForMIB; if ((cnt1 > 0)) 
then raise error 30005 'Cannot UPDATE MibStructure because DiscoveryVa
riable exists.'; endif;    update "mdbadmin". MibStructure set 
ComponentMibIndexIdx = NULL where (0 = ( select count(*) from 
"mdbadmin". IndexTable where  :newComponentMibIndexIdx = 
IndexTable.ComponentMibIndexIdx ))    and  MibStructure.MibIdx = 
:newMibIdx and MibStructure.OidIdxForMIB = :newOidIdxForMIB ;    
select :cnt1 = count(*) from "mdbadmin". MIBDefinition where  
:newMibIdx = MIBDefinition.MibIdx; if (  (cnt1 = 0) ) then raise error
30007 'Cannot UPDATE MibStructure because MIBDefinition does not exist
.'; endif; end
\p\g
drop procedure pu_mibvariabletype
\p\g
create procedure  pU_MibVariableType ( oldTypeId integer, oldCategory 
c(32), oldSubcategory c(32), oldDescription varchar(128), 
oldBaseTypeIdx integer, oldCollectable c(1), newTypeId integer, 
newCategory c(32), newSubcategory c(32), newDescription varchar(128), 
newBaseTypeIdx integer, newCollectable c(1) ) as declare cnt1 integer4
not null;   begin    select :cnt1 = count(*) from "mdbadmin". 
DiscoveryVariable where  DiscoveryVariable.TypeId = :oldTypeId; if 
((cnt1 > 0)) then raise error 30005 'Cannot UPDATE MibVariableType bec
ause DiscoveryVariable exists.'; endif;    select :cnt1 = count(*) 
from "mdbadmin". ColumnDefinition where  ColumnDefinition.TypeId = 
:oldTypeId; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE MibV
ariableType because ColumnDefinition exists.'; endif; end
\p\g
drop procedure pu_objects
\p\g
create procedure  pU_Objects ( oldObjectID integer, oldObjectType 
integer2, oldObjectName varchar(255), oldDescription varchar(255), 
oldObjectSourceID integer, oldClusterID integer, oldDomainSourceID 
integer, oldMailObjectID integer, oldServiceSourceID integer, 
oldMailDomainID integer, oldMailServiceID integer, 
oldConnectorSourceID integer, oldMailConnectorID integer, 
oldDBSourceID integer, oldMailDBID integer, oldEventSourceID integer, 
oldMailEventID integer, oldQueueSourceID integer, oldMailQueueID 
integer, oldDiskSourceID integer, oldMailDiskID integer, newObjectID 
integer, newObjectType integer2, newObjectName varchar(255), 
newDescription varchar(255), newObjectSourceID integer, newClusterID 
integer, newDomainSourceID integer, newMailObjectID integer, 
newServiceSourceID integer, newMailDomainID integer, newMailServiceID 
integer, newConnectorSourceID integer, newMailConnectorID integer, 
newDBSourceID integer, newMailDBID integer, newEventSourceID integer, 
newMailEventID integer, newQueueSourceID integer, newMailQueueID 
integer, newDiskSourceID integer, newMailDiskID integer ) as declare 
cnt1 integer4 not null;   begin                                     
update "mdbadmin". Objects set DomainSourceID = NULL, MailDomainID = 
NULL where (0 = ( select count(*) from "mdbadmin". MailDomain where  
:newDomainSourceID = MailDomain.SourceID and :newMailDomainID = 
MailDomain.MailDomainID )) and objects.ObjectID = :newObjectID ;   
update "mdbadmin". Objects set ObjectSourceID = NULL, MailObjectID = 
NULL where (0 = ( select count(*) from "mdbadmin". MailObject where  
:newObjectSourceID = MailObject.SourceID and :newMailObjectID = 
MailObject.MailObjectID )) and objects.ObjectID = :newObjectID ;   
update "mdbadmin". Objects set ClusterID = NULL where (0 = ( select 
count(*) from "mdbadmin". Cluster where  :newClusterID = 
Cluster.ClusterID )) and objects.ObjectID = :newObjectID ;   update 
"mdbadmin". Objects set ServiceSourceID = NULL, MailServiceID = NULL 
where (0 = ( select count(*) from "mdbadmin". MailService where  
:newServiceSourceID = MailService.SourceID and :newMailServiceID = 
MailService.MailServiceID )) and objects.ObjectID = :newObjectID ;   
update "mdbadmin". Objects set ConnectorSourceID = NULL, 
MailConnectorID = NULL where (0 = ( select count(*) from "mdbadmin". 
MailConnector where  :newConnectorSourceID = MailConnector.SourceID 
and :newMailConnectorID = MailConnector.MailConnectorID )) and 
objects.ObjectID = :newObjectID ;   update "mdbadmin". Objects set 
DiskSourceID = NULL, MailDiskID = NULL where (0 = ( select count(*) 
from "mdbadmin". MailDisk where  :newDiskSourceID = MailDisk.SourceID 
and :newMailDiskID = MailDisk.MailDiskID )) and objects.ObjectID = 
:newObjectID ;   update "mdbadmin". Objects set EventSourceID = NULL, 
MailEventID = NULL where (0 = ( select count(*) from "mdbadmin". 
MailEvent where  :newEventSourceID = MailEvent.SourceID and 
:newMailEventID = MailEvent.MailEventID )) and objects.ObjectID = 
:newObjectID ;   update "mdbadmin". Objects set DBSourceID = NULL, 
MailDBID = NULL where (0 = ( select count(*) from "mdbadmin". MailDB 
where  :newDBSourceID = MailDB.SourceID and :newMailDBID = 
MailDB.MailDBID )) and objects.ObjectID = :newObjectID ;   update 
"mdbadmin". Objects set QueueSourceID = NULL, MailQueueID = NULL where
(0 = ( select count(*) from "mdbadmin". MailQueue where  
:newQueueSourceID = MailQueue.SourceID and :newMailQueueID = 
MailQueue.MailQueueID )) and objects.ObjectID = :newObjectID ; end
\p\g
drop procedure pu_person
\p\g
create procedure  pU_Person ( oldSourceID integer, oldPersonID 
integer, oldPersonName char(254), oldDescription varchar(255), 
oldDisplayName char(254), oldMailFile varchar(255), newSourceID 
integer, newPersonID integer, newPersonName char(254), newDescription 
varchar(255), newDisplayName char(254), newMailFile varchar(255) ) as 
declare cnt1 integer4 not null;   begin    if  :oldSourceID <> 
:newSourceID or :oldPersonID <> :newPersonID then update "mdbadmin". 
CounterData set PersonSourceID = NULL, PersonID = NULL where  
CounterData.PersonSourceID = :oldSourceID and CounterData.PersonID = 
:oldPersonID; endif;    if  :oldSourceID <> :newSourceID or 
:oldPersonID <> :newPersonID then update "mdbadmin". Management_Alert 
set PersonSourceID = NULL, PersonID = NULL where  
Management_Alert.PersonSourceID = :oldSourceID and 
Management_Alert.PersonID = :oldPersonID; endif;    select :cnt1 = 
count(*) from "mdbadmin". CounterSource where  :newSourceID = 
CounterSource.SourceID; if (  (cnt1 = 0) ) then raise error 30007 'Can
not UPDATE Person because CounterSource does not exist.'; endif; end
\p\g
drop procedure pu_pollrowdefinition
\p\g
create procedure  pU_PollRowDefinition ( oldRowId integer, oldMibIdx 
integer, oldOidIdxForMIB integer, oldOidOrder integer, oldRowDesc 
varchar(128), newRowId integer, newMibIdx integer, newOidIdxForMIB 
integer, newOidOrder integer, newRowDesc varchar(128) ) as declare 
cnt1 integer4 not null;   begin    select :cnt1 = count(*) from 
"mdbadmin". MibStructure where  :newMibIdx = MibStructure.MibIdx and 
:newOidIdxForMIB = MibStructure.OidIdxForMIB; if (  (cnt1 = 0) ) then 
raise error 30007 'Cannot UPDATE PollRowDefinition because MibStructur
e does not exist.'; endif; end
\p\g
drop procedure pu_reportcolumn
\p\g
create procedure  pU_ReportColumn ( oldColumnID integer, oldReportID 
integer, oldThresholdColumnID integer, oldThresholdReportID integer, 
oldColumnName varchar(255), oldIsVisible integer2, oldSortBy integer2,
oldFormula varchar(255), oldIsDistinct integer1, oldIsGroup integer2, 
oldTitle varchar(255), oldPresentation integer2, oldUnitID integer, 
oldInWorkSpace integer1, newColumnID integer, newReportID integer, 
newThresholdColumnID integer, newThresholdReportID integer, 
newColumnName varchar(255), newIsVisible integer2, newSortBy integer2,
newFormula varchar(255), newIsDistinct integer1, newIsGroup integer2, 
newTitle varchar(255), newPresentation integer2, newUnitID integer, 
newInWorkSpace integer1 ) as declare cnt1 integer4 not null;   begin  
select :cnt1 = count(*) from "mdbadmin". Management_Report where  
:newReportID = Management_Report.ReportID; if (  (cnt1 = 0) ) then 
raise error 30007 'Cannot UPDATE ReportColumn because Management_Repor
t does not exist.'; endif;       end
\p\g
drop procedure pu_reporttable
\p\g
create procedure  pU_ReportTable ( oldCounterID integer, 
oldReportTableID integer, newCounterID integer, newReportTableID 
integer ) as declare cnt1 integer4 not null;   begin   select :cnt1 = 
count(*) from "mdbadmin". ReportTableDefinition where  
:newReportTableID = ReportTableDefinition.ReportTableID; if (  (cnt1 =
0) ) then raise error 30007 'Cannot UPDATE ReportTable because ReportT
ableDefinition does not exist.'; endif;   select :cnt1 = count(*) from
"mdbadmin". CounterDefinition where  :newCounterID = 
CounterDefinition.CounterID; if (  (cnt1 = 0) ) then raise error 30007
'Cannot UPDATE ReportTable because CounterDefinition does not exist.';
endif; end
\p\g
drop procedure pu_resourcemonitoring
\p\g
create procedure  pU_ResourceMonitoring ( oldserver_addr integer, 
oldprobe_addr integer, oldIntervalDateTime date, oldMibIdx integer, 
oldMonitor c(1), oldIndex1 integer, oldIndex2 integer, oldIndex3 
integer, oldIndex4 integer, oldIndex5 integer, newserver_addr integer,
newprobe_addr integer, newIntervalDateTime date, newMibIdx integer, 
newMonitor c(1), newIndex1 integer, newIndex2 integer, newIndex3 
integer, newIndex4 integer, newIndex5 integer ) as declare cnt1 
integer4 not null;   begin    select :cnt1 = count(*) from "mdbadmin".
MIBDefinition where  :newMibIdx = MIBDefinition.MibIdx; if (  (cnt1 = 
0) ) then raise error 30007 'Cannot UPDATE ResourceMonitoring because 
MIBDefinition does not exist.'; endif; end
\p\g
drop procedure pu_schedule
\p\g
create procedure  pU_Schedule ( oldCollectorID integer, oldActionID 
integer, oldScheduleType integer2, oldStartDateTime date, oldOccurs 
integer2, oldDailyFrequency integer2, oldEvery integer, oldEndDateTime
date, oldSun integer1, oldMon integer1, oldTue integer1, oldWen 
integer1, oldThur integer1, oldFri integer1, oldSat integer1, 
oldDayType integer2, oldIntervalUnit integer2, oldDayOfMonth integer2,
oldWeekNumber integer2, oldWeekDay integer2, oldLastRunDate date, 
oldTimeEvery integer, oldInScale integer1, newCollectorID integer, 
newActionID integer, newScheduleType integer2, newStartDateTime date, 
newOccurs integer2, newDailyFrequency integer2, newEvery integer, 
newEndDateTime date, newSun integer1, newMon integer1, newTue 
integer1, newWen integer1, newThur integer1, newFri integer1, newSat 
integer1, newDayType integer2, newIntervalUnit integer2, newDayOfMonth
integer2, newWeekNumber integer2, newWeekDay integer2, newLastRunDate 
date, newTimeEvery integer, newInScale integer1 ) as declare cnt1 
integer4 not null;   begin   select :cnt1 = count(*) from "mdbadmin". 
Server_CollectorAction where  :newActionID = 
Server_CollectorAction.ActionID; if (  (cnt1 = 0) ) then raise error 
30007 'Cannot UPDATE Server_Schedule because CollectorAction does not 
exist.'; endif; end
\p\g
drop procedure pu_site
\p\g
create procedure  pU_Site ( oldSiteID integer, oldMailOrgID integer, 
oldSiteName char(254), newSiteID integer, newMailOrgID integer, 
newSiteName char(254) ) as declare cnt1 integer4 not null;   begin   
select :cnt1 = count(*) from "mdbadmin". CounterSource where  
CounterSource.SiteID = :oldSiteID and CounterSource.MailOrgID = 
:oldMailOrgID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE S
erver_Site because CounterSource exists.'; endif;   select :cnt1 = 
count(*) from "mdbadmin". MailOrganisation where  :newMailOrgID = 
MailOrganisation.MailOrgID; if ( (cnt1 = 0) ) then raise error 30007 '
Cannot UPDATE Server_Site because MailOrganisation does not exist.'; 
endif; end
\p\g
drop procedure pu_solutiondescription
\p\g
create procedure  pU_SolutionDescription ( oldSolutionDescriptionID 
integer, oldSolutionText text(4096), newSolutionDescriptionID integer,
newSolutionText text(4096) ) as declare cnt1 integer4 not null;   
begin   select :cnt1 = count(*) from "mdbadmin". ErrorSolution where  
ErrorSolution.SolutionDescriptionID = :oldSolutionDescriptionID; if 
((cnt1 > 0)) then raise error 30005 'Cannot UPDATE SolutionDescription
 because ErrorSolution exists.'; endif; end
\p\g
drop procedure pu_sourcelocale
\p\g
create procedure  pU_SourceLocale ( oldLocaleID integer, oldLocaleName
char(32), oldLangCode char(4), oldSourceType integer, oldJavaLocale 
char(5), newLocaleID integer, newLocaleName char(32), newLangCode 
char(4), newSourceType integer, newJavaLocale char(5) ) as declare 
cnt1 integer4 not null;   begin   select :cnt1 = count(*) from 
"mdbadmin". CounterTitle where  CounterTitle.LocaleID = :oldLocaleID; 
if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE SourceLocale bec
ause CounterTitle exists.'; endif;   select :cnt1 = count(*) from 
"mdbadmin". CounterSource where  CounterSource.LocaleID = 
:oldLocaleID; if ((cnt1 > 0)) then raise error 30005 'Cannot UPDATE So
urceLocale because CounterSource exists.'; endif; end
\p\g
drop procedure pu_tabledefinition
\p\g
create procedure  pU_TableDefinition ( oldTableIdx integer, 
oldNameOfTable varchar(32), newTableIdx integer, newNameOfTable 
varchar(32) ) as declare cnt1 integer4 not null;   begin    select 
:cnt1 = count(*) from "mdbadmin". ColumnDefinition where  
ColumnDefinition.TableIdx = :oldTableIdx; if ((cnt1 > 0)) then raise 
error 30005 'Cannot UPDATE TableDefinition because ColumnDefinition ex
ists.'; endif; end
\p\g
drop procedure pu_tablesdescription
\p\g
create procedure  pU_TablesDescription ( oldOidIdxForMIB integer, 
oldMibIdx integer, oldTableIdx integer, oldOrderOfColumn integer, 
oldTypeOfSaving c(1), oldCollectable c(1), newOidIdxForMIB integer, 
newMibIdx integer, newTableIdx integer, newOrderOfColumn integer, 
newTypeOfSaving c(1), newCollectable c(1) ) as declare cnt1 integer4 
not null;   begin    select :cnt1 = count(*) from "mdbadmin". 
MibStructure where  :newMibIdx = MibStructure.MibIdx and 
:newOidIdxForMIB = MibStructure.OidIdxForMIB; if (  (cnt1 = 0) ) then 
raise error 30007 'Cannot UPDATE TablesDescription because MibStructur
e does not exist.'; endif;    select :cnt1 = count(*) from "mdbadmin".
ColumnDefinition where  :newTableIdx = ColumnDefinition.TableIdx and 
:newOrderOfColumn = ColumnDefinition.OrderOfColumn; if (  (cnt1 = 0) )
then raise error 30007 'Cannot UPDATE TablesDescription because Column
Definition does not exist.'; endif; end
\p\g
drop procedure pu_tau_mdb
\p\g
create procedure  pU_tau_mdb ( oldmdbMajorVersion integer, 
oldmdbMinorVersion integer, oldreleaseDate date, oldinstallDate date, 
newmdbMajorVersion integer, newmdbMinorVersion integer, newreleaseDate
date, newinstallDate date ) as declare cnt1 integer4 not null;   begin
select :cnt1 = count(*) from "mdbadmin". tau_mdb_product where  
tau_mdb_product.mdbMajorVersion = :oldmdbMajorVersion and 
tau_mdb_product.mdbMinorVersion = :oldmdbMinorVersion; if ((cnt1 > 0))
then raise error 30005 'Cannot UPDATE tau_mdb because tau_mdb_product 
exists.'; endif; end
\p\g
drop procedure pu_tau_mdb_product
\p\g
create procedure  pU_tau_mdb_product ( oldmdbMajorVersion integer, 
oldmdbMinorVersion integer, oldproductName varchar(64), 
oldproductMajorVersion integer, oldproductMinorVersion integer, 
newmdbMajorVersion integer, newmdbMinorVersion integer, newproductName
varchar(64), newproductMajorVersion integer, newproductMinorVersion 
integer ) as declare cnt1 integer4 not null;   begin    select :cnt1 =
count(*) from "mdbadmin". tau_product where  :newproductName = 
tau_product.productName and :newproductMajorVersion = 
tau_product.productMajorVersion and :newproductMinorVersion = 
tau_product.productMinorVersion; if (  (cnt1 = 0) ) then raise error 
30007 'Cannot UPDATE tau_mdb_product because tau_product does not exis
t.'; endif;    select :cnt1 = count(*) from "mdbadmin". tau_mdb where 
:newmdbMajorVersion = tau_mdb.mdbMajorVersion and :newmdbMinorVersion 
= tau_mdb.mdbMinorVersion; if (  (cnt1 = 0) ) then raise error 30007 '
Cannot UPDATE tau_mdb_product because tau_mdb does not exist.'; endif;
end
\p\g
drop procedure pu_tau_product
\p\g
create procedure  pU_tau_product ( oldproductName varchar(64), 
oldproductMajorVersion integer, oldproductMinorVersion integer, 
oldreleaseDate date, oldinstallCount integer, newproductName 
varchar(64), newproductMajorVersion integer, newproductMinorVersion 
integer, newreleaseDate date, newinstallCount integer ) as declare 
cnt1 integer4 not null;   begin    select :cnt1 = count(*) from 
"mdbadmin". tau_mdb_product where  tau_mdb_product.productName = 
:oldproductName and tau_mdb_product.productMajorVersion = 
:oldproductMajorVersion and tau_mdb_product.productMinorVersion = 
:oldproductMinorVersion; if ((cnt1 > 0)) then raise error 30005 'Canno
t UPDATE tau_product because tau_mdb_product exists.'; endif; end
\p\g
drop procedure tng_add_2d_icon
\p\g
create procedure  tng_add_2d_icon ( icongroup varchar(30) , icon0 
varchar(64) with null, icon1 varchar(64) with null, icon2 varchar(64) 
with null, icon3 varchar(64) with null, icon4 varchar(64) with null, 
icon5 varchar(64) with null, icon6 varchar(64) with null, icon7 
varchar(64) with null, icon8 varchar(64) with null, icon9 varchar(64) 
with null ) as declare emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'procedure add_2d
_icon failed' + ascii(:enumber); raise error 40014 :emessage with 
destination=(session,error_log); return -1; endif; insert into 
"mdbadmin". tng_icon_2d (name,normal_icon,unknown_icon,warning_icon, 
minor_icon,major_icon,critical_icon,down_icon,inservice_icon, 
remove_icon,future_icon) values (:icongroup, :icon0, :icon1, :icon2, 
:icon3, :icon4, :icon5, :icon6, :icon7, :icon8, :icon9); select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'procedure add_2d_icon insert of tng_icon_2d failed' +
ascii(:enumber); raise error 40030 :emessage with destination = 
(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_2d_icon to group 
tngadmin
\p\g
drop procedure tng_add_3d_icon
\p\g
create procedure  tng_add_3d_icon ( icongroup varchar(40) , nff_file1 
varchar(64) with null, nff_file2 varchar(64) with null, nff_file3 
varchar(64) with null, nff_file4 varchar(64) with null, distance1 
float with null, distance2 float with null, distance3 float with null,
distance4 float with null, expand_distance float with null, nff_inside
varchar(64) with null, status int with null) as declare emessage 
char(255) not null with default; rcount int; enumber int; begin select
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'procedure add_3d_icon failed' + ascii(:enumber); 
raise error 40015 :emessage with destination=(session,error_log); 
return -1; endif; :nff_file2=null; :nff_file3=null; :nff_file4=null; 
insert into "mdbadmin". tng_icon_3d (name, nff_file1, nff_file2, 
nff_file3, nff_file4, distance1, distance2, distance3, distance4, 
expand_distance, nff_inside, status ) values (:icongroup, :nff_file1, 
:nff_file2, :nff_file3, :nff_file4, :distance1, :distance2, 
:distance3, :distance4, :expand_distance, :nff_inside, :status); 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'procedure add_3d_icon insert of tng_icon_3d fail
ed' + ascii(:enumber); raise error 40031 :emessage with 
destination=(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_3d_icon to group 
tngadmin
\p\g
drop procedure tng_add_alarmset
\p\g
create procedure  tng_add_alarmset ( name varchar(40) , comment 
varchar(255) with null) as declare emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure add_alarmset failed' + ascii(:enumber); raise 
error 40018 :emessage with destination = (session, error_log); return 
-1; endif; if (:name is null) then raise error 90030 'MSG:(90030) add_
alarmset: bad :name'; return; endif;  insert into "mdbadmin". 
tng_alarmset ( name, comment) values (:name, :comment); select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure add_alarmset insert of tng_alarmset failed'
+ ascii(:enumber); raise error 40033 :emessage with destination = 
(session, error_log); return -1; endif;   end
\p\g
grant execute on procedure "mdbadmin".tng_add_alarmset to group 
tngadmin
\p\g
drop procedure tng_add_auth
\p\g
create procedure  tng_add_auth( name varchar(40), access char(1), mask
varchar(16) with null, status_on int1 not null with default) as 
declare msg varchar(255) not null; emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'procedure add_auth failed' + ascii(:enumber); raise error 40011 
:emessage with destination=(session,error_log); return -1; endif; if 
(:mask is null) then :mask = '*.*.*.*'; endif; insert into "mdbadmin".
tng_auth ( name, access, mask ) values ( :name, :access, :mask ); 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'procedure add_auth insert of tng_auth failed' + 
ascii(:enumber); raise error 40027 :emessage with 
destination=(session,error_log); return -1; endif; if (iierrornumber 
!= 0) then if (:status_on = 1) then :msg = 'Insert tng_auth error, :na
me='+ :name+', :access='+:access+'.'; raise error 90024 :msg; return; 
endif; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_auth to group tngadmin
\p\g
drop procedure tng_add_class
\p\g
create procedure  tng_add_class ( classname varchar(30), 
superclassname varchar(30), virtual_class int1 not null with default, 
vendor_name char(30) with null, map_visible int1 with null, vr_visible
int1 with null, external_data int1 with null, open_space int1 with 
null, propagate_status int1 with null, system_class int1 not null with
default, hidden_class int1 not null with default, property_group 
varchar(10) with null, instance_storage varchar(30) with null, 
popup_menu_name varchar(30) with null, d2_icongroup varchar(30) with 
null, d3_icongroup varchar(30) with null, initial_x int with null, 
initial_y int with null, initial_z int with null, label_font 
varchar(10) with null, label_position varchar(20) with null, 
label_border varchar(5) with null, top_left_name varchar(30) with 
null, top_right_name varchar(30) with null, bottom_left_name 
varchar(30) with null, bottom_right_name varchar(30) with null, 
NoAddClassExt int not null with default) as declare super_class_id 
int; vendor_id int; rc int ; string varchar(255); vendor_full_name 
varchar(30); errornumber int; rowcount int; classid int; msg 
varchar(255) not null; emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'procedure add_cl
ass failed' + ascii(:enumber); raise error 40009 :emessage with 
destination=(session,error_log); return -1; endif; if (:map_visible is
null) then :map_visible = 1; endif; if (:vr_visible is null) then 
:vr_visible = 1; endif; if (:open_space is null) then :open_space = 1;
endif; if (:propagate_status is null) then :propagate_status = 1; 
endif; if(:superclassname='Class' and :classname='Class' ) then 
:super_class_id=0; else :super_class_id = null; select class_id into 
:super_class_id from "mdbadmin". tng_class where name=:superclassname;
if(:super_class_id is null) then raise error 90021 'MSG:(90021) Bad :s
uperclassname'; return; endif; endif; if(:vendor_name is null) then 
:vendor_id = 0;  else :vendor_id = null; select vendor_id into 
:vendor_id from "mdbadmin". tng_vendor where vendor_name=:vendor_name;
if(:vendor_id is null) then raise error 90022 'MSG:(90022) Bad :vendor
_name'; return; endif; endif;  if(uppercase(:classname) = 'CLASS') 
then :superclassname='Class'; endif;  execute procedure "mdbadmin". 
tng_get_class_id ( key_id = byref(:classid)); insert into "mdbadmin". 
tng_class (name, super_class_id, super_class_name, virtual_class, 
map_visible, vr_visible, system_class, hidden_class, instance_storage,
class_id) values (:classname, :super_class_id, :superclassname, 
:virtual_class, :map_visible, :vr_visible, :system_class, 
:hidden_class, :instance_storage, :classid); select iierrornumber, 
iirowcount into :errornumber, :rowcount; if (:errornumber != 0 or 
:rowcount != 1) then :msg = 'MSG:(90023) Can''t insert entry '+ 'into 
tng_class table.'; raise error 90023 :msg; return; endif;  if 
(:NoAddClassExt=1) then return; endif;  if(:d2_icongroup is null) then
select name into :d2_icongroup from "mdbadmin". tng_icon_2d where 
name=:classname; endif; if(:d3_icongroup is null) then select name 
into :d3_icongroup from "mdbadmin". tng_icon_3d where name=:classname;
endif;  if(:d3_icongroup is null) then select name into :d3_icongroup 
from "mdbadmin". tng_icon_3d where name=:superclassname; endif;   if 
(:popup_menu_name is not null) then :rc=-1; execute procedure 
"mdbadmin". tng_is_attr_same_as_superclass( classname=:classname, 
name='popup_menu_name', datatype='varchar', string=:popup_menu_name, 
rc=byref(:rc)); if( :rc=0) then execute procedure "mdbadmin". 
tng_add_class_ext( classname=:classname, name='popup_menu_name', 
datatype='varchar', length=40, property_group='Map_2d', 
string=:popup_menu_name); endif; endif; if (:external_data is not 
null) then :rc=-1; :string=varchar(:external_data); execute procedure 
"mdbadmin". tng_is_attr_same_as_superclass( classname=:classname, 
name='external_data', datatype='int1',  string=:string, rc=byref(:rc))
; if( :rc=0) then execute procedure "mdbadmin". tng_add_class_ext( 
classname=:classname, name='external_data', datatype='int1', length=1,
property_group='Class_Flag',  string=:string); endif; endif; if ( 
:open_space is not null) then :rc=-1; :string=varchar(:open_space); 
execute procedure "mdbadmin". tng_is_attr_same_as_superclass( 
classname=:classname, name='open_space', datatype='int1',  
string=:string, rc=byref(:rc)); if( :rc=0) then execute procedure 
"mdbadmin". tng_add_class_ext( classname=:classname, name='open_space'
, datatype='int1', length=1, property_group='VR_3d',  string=:string);
endif; endif; if ( :vendor_name is not null) then 
:vendor_full_name=null; select name into :vendor_full_name from 
"mdbadmin". tng_vendor where vendor_name=:vendor_name; 
if(:vendor_full_name is not null) then :vendor_name=:vendor_full_name;
endif; :rc=-1; execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='vendor_nam
e', datatype='varchar', string=:vendor_name, rc=byref(:rc)); if( 
:rc=0) then execute procedure "mdbadmin". tng_add_class_ext( 
classname=:classname, name='vendor_name', datatype='varchar', 
length=40, property_group='Vendor', string=:vendor_name); endif; 
endif; if (:label_font is not null) then :rc=-1; execute procedure 
"mdbadmin". tng_is_attr_same_as_superclass( classname=:classname, 
name='label_font', datatype='varchar', string=:label_font, 
rc=byref(:rc)); if( :rc=0) then execute procedure "mdbadmin". 
tng_add_class_ext( classname=:classname, name='label_font', datatype='
varchar', length=10, property_group='Map_2d', string=:label_font); 
endif; endif; if (:label_position is not null) then :rc=-1; execute 
procedure "mdbadmin". tng_is_attr_same_as_superclass( 
classname=:classname, name='label_position', datatype='varchar', 
string=:label_position, rc=byref(:rc)); if( :rc=0) then execute 
procedure "mdbadmin". tng_add_class_ext( classname=:classname, name='l
abel_position', datatype='varchar', length=20, property_group='Map_2d'
, string=:label_position); endif; endif; if (:label_border is not 
null) then :rc=-1; execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='label_bord
er', datatype='varchar', string=:label_border, rc=byref(:rc)); if( 
:rc=0) then execute procedure "mdbadmin". tng_add_class_ext( 
classname=:classname, name='label_border', datatype='varchar', 
length=5, property_group='Map_2d', string=:label_border); endif; 
endif; if (:d2_icongroup is not null) then :rc=-1; execute procedure 
"mdbadmin". tng_is_attr_same_as_superclass( classname=:classname, 
name='icon_2d_name', datatype='varchar', string=:d2_icongroup, 
rc=byref(:rc)); if( :rc=0) then execute procedure "mdbadmin". 
tng_add_class_ext( classname=:classname, name='icon_2d_name', 
datatype='varchar', length=40, property_group='Map_2d', 
string=:d2_icongroup); endif; endif; if (:d3_icongroup is not null) 
then :rc=-1; execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='icon_3d_na
me', datatype='varchar', string=:d3_icongroup, rc=byref(:rc)); if( 
:rc=0) then execute procedure "mdbadmin". tng_add_class_ext( 
classname=:classname, name='icon_3d_name', datatype='varchar', 
length=40, property_group='VR_3d', string=:d3_icongroup); endif; 
endif; if (:initial_x is not null) then :rc=-1; 
:string=varchar(:initial_x); execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='initial_x'
, datatype='int', string=:string, rc=byref(:rc)); if( :rc=0) then 
execute procedure "mdbadmin". tng_add_class_ext( classname=:classname,
name='initial_x', datatype='int', length=4, property_group='VR_3d', 
string=:string); endif; endif; if (:initial_y is not null) then 
:rc=-1; :string=varchar(:initial_y); execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='initial_y'
, datatype='int', string=:string, rc=byref(:rc)); if( :rc=0) then 
execute procedure "mdbadmin". tng_add_class_ext( classname=:classname,
name='initial_y', datatype='int', length=4, property_group='VR_3d', 
string=:string); endif; endif; if (:initial_z is not null) then 
:rc=-1; :string=varchar(:initial_z); execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='initial_z'
, datatype='int', string=:string, rc=byref(:rc)); if( :rc=0) then 
execute procedure "mdbadmin". tng_add_class_ext( classname=:classname,
name='initial_z', datatype='int', length=4, property_group='VR_3d', 
string=:string); endif; endif; if (:top_left_name is not null) then 
:rc=-1; execute procedure "mdbadmin". tng_is_attr_same_as_superclass( 
classname=:classname, name='top_left_name', datatype='varchar', 
string=:top_left_name, rc=byref(:rc)); if( :rc=0) then execute 
procedure "mdbadmin". tng_add_class_ext( classname=:classname, name='t
op_left_name', datatype='varchar', length=40, property_group='VR_3d', 
string=:top_left_name); endif; endif; if (:top_right_name is not null)
then :rc=-1; execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='top_right_
name', datatype='varchar', string=:top_right_name, rc=byref(:rc)); if(
:rc=0) then execute procedure "mdbadmin". tng_add_class_ext( 
classname=:classname, name='top_right_name', datatype='varchar', 
length=40, property_group='VR_3d', string=:top_right_name); endif; 
endif; if (:bottom_left_name is not null) then :rc=-1; execute 
procedure "mdbadmin". tng_is_attr_same_as_superclass( 
classname=:classname, name='bottom_left_name', datatype='varchar', 
string=:bottom_left_name, rc=byref(:rc)); if( :rc=0) then execute 
procedure "mdbadmin". tng_add_class_ext( classname=:classname, name='b
ottom_left_name', datatype='varchar', length=40, property_group='VR_3d
', string=:bottom_left_name); endif; endif; if (:bottom_right_name is 
not null) then :rc=-1; execute procedure "mdbadmin". 
tng_is_attr_same_as_superclass( classname=:classname, name='bottom_rig
ht_name', datatype='varchar', string=:bottom_right_name, rc=byref(:rc)
); if( :rc=0) then execute procedure "mdbadmin". tng_add_class_ext( 
classname=:classname, name='bottom_right_name', datatype='varchar', 
length=40, property_group='VR_3d', string=:bottom_right_name); endif; 
endif;  end
\p\g
grant execute on procedure "mdbadmin".tng_add_class to group tngadmin
\p\g
drop procedure tng_add_class_ext
\p\g
create procedure  tng_add_class_ext ( classname varchar(30), name 
varchar(255), datatype varchar(30), length int, property_group 
varchar(10) with null, integer int with null, tinyint int1 with null, 
float float with null, datetime date with null, string varchar(255) 
with null, binary byte varying(255) with null) as declare class_id 
int; emessage char(255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
(:enumber > 0) then emessage = 'procedure add_class_ext failed' + 
ascii(:enumber); raise error 40006 :emessage with 
destination=(session,error_log); return -1; endif; :class_id = null; 
select class_id into :class_id from "mdbadmin". tng_class where 
name=:classname; if( :class_id is null ) then raise error 90018 'MSG(9
0018): Bad :classname pass in add_class_ext procedure.'; return; 
endif; insert into "mdbadmin". tng_class_ext (class_id, name, 
datatype, length, property_group, string) values (:class_id, :name, 
:datatype, :length, :property_group, :string); select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure add_class_ext insert of tng_class_ext failed' + 
ascii(:enumber); raise error 40028 :emessage with destination = 
(session, error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_class_ext to group 
tngadmin
\p\g
drop procedure tng_add_managedobject
\p\g
create procedure  tng_add_managedobject ( uuid byte(16), name 
varchar(255) with null, label varchar(255) with null, address 
varchar(255) with null, address_type int with null, class_name 
varchar(30), interface_type int with null, hidden int1 with null, 
propagate_status int1 with null, status_no int with null, severity int
with null, autoarrange_type int with null, posted int1 with null, 
acknowledge int1 with null,  ip_address_hex byte(4) with null, 
mac_address varchar(12) with null, subnet_mask byte(4) with null, 
date_ins date with null, date_modify date with null, alarmset_name 
varchar(40) with null, override_imagelarge varchar(64) with null, 
override_imagesmall varchar(64) with null, override_imagedecal 
varchar(64) with null, override_imagetintbool int1 with null, 
override_model varchar(64) with null, background_image varchar(64) 
with null) as declare msg varchar(255) not null; errno int; emessage 
char(255) not null with default; rcount int; enumber int; begin select
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure add_managedobject failed' + ascii(:enumber)
; raise error 40020 :emessage with destination = (session, error_log);
return -1; endif; INSERT INTO "mdbadmin". tng_managedobject (uuid, 
name, label, address, address_type, class_name, interface_type, 
hidden, propagate_status, status_no, severity, posted, acknowledge,
autoarrange_type, ip_address_hex, mac_address, subnet_mask, date_ins, 
date_modify, alarmset_name, override_imagelarge, override_imagesmall, 
override_imagedecal, override_imagetintbool, override_model, 
background_image) values (:uuid,:name,:label,:address,:address_type,
:class_name, :interface_type,:hidden, :propagate_status,:status_no, 
:severity,:posted,:acknowledge,:autoarrange_type, :ip_address_hex,
:mac_address,:subnet_mask,:date_ins, :date_modify, :alarmset_name, 
:override_imagelarge, :override_imagesmall, :override_imagedecal, 
:override_imagetintbool, :override_model,:background_image); select 
iierrornumber into :errno; if (:errno != 0) then :msg = 'MSG:(90031) I
nsert tng_managedobject error='+:errno+ ', :name='+:name+', :label='+
:label+ ', :class_name='+ :class_name+'. :ip_address_hex='+
char(:ip_address_hex); raise error 90031 :msg; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_managedobject to group 
tngadmin
\p\g
drop procedure tng_add_manuf
\p\g
create procedure  tng_add_manuf ( id int, name varchar(40), 
vendor_name varchar(10), comment varchar(80) ) as declare emessage 
char(255) not null with default; rcount int; enumber int; begin select
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'procedure add_manuf failed' + ascii(:enumber); raise 
error 40010 :emessage with destination=(session,error_log); return -1;
endif; insert into "mdbadmin". tng_vendor (vendor_id, name, 
vendor_name, comment ) values (:id, :name, :vendor_name, :comment ); 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'procedure add_manuf insert of tng_vendor failed'
+ ascii(:enumber); raise error 40026 :emessage with 
destination=(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_manuf to group tngadmin
\p\g
drop procedure tng_add_method
\p\g
create procedure  tng_add_method ( name varchar(40) , type int with 
null, exe_name varchar(255) with null, parameter varchar(255) with 
null) as declare emessage char(255) not null with default; rcount int;
enumber int; begin select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'procedure add_method fail
ed' + ascii(:enumber); raise error 40017 :emessage with 
destination=(session,error_log); return -1; endif; if (:name is null) 
then raise error 90028 'MSG:(90028) add_method: bad :name'; return; 
endif; insert into "mdbadmin". tng_method ( name, type, exe_name, 
parameter) values (:name, :type,:exe_name, :parameter); select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'procedure add_method insert of tng_method failed' + 
ascii(:enumber); raise error 40032 :emessage with 
destination=(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_method to group tngadmin
\p\g
drop procedure tng_add_pollset
\p\g
create procedure  tng_add_pollset ( name varchar(40), Pinterval int, 
TOinterval int, retries int, port_number int with null, 
getCommunityString varchar(30) with null, setCommunityString 
varchar(30) with null, retriesInterval int with null, objectFilter 
varchar(30) with null, hostFilter varchar(30) with null ) as declare 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if 
(:enumber > 0) then emessage = 'procedure add_pollset failed' + 
ascii(:enumber); raise error 40012 :emessage with 
destination=(session,error_log); return -1; endif; if (:port_number is
null) then :port_number = 161; endif; if (:getCommunityString is null)
then :getCommunityString = 'public'; endif; if (:setCommunityString is
null) then :setCommunityString = 'admin'; endif; if (:retriesInterval 
is null) then :retriesInterval = 0; endif; if (:objectFilter is null) 
then :objectFilter = '*'; endif; if (:hostFilter is null) then 
:hostFilter = '*'; endif; insert into "mdbadmin". tng_pollset (name, 
interval, timeout, retries, port_number, getCommunityString, 
setCommunityString, retriesInterval, objectFilter, hostFilter) values 
(:name, :Pinterval, :TOinterval, :retries, :port_number, 
:getCommunityString, :setCommunityString, :retriesInterval, 
:objectFilter, :hostFilter); select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'procedure add_po
llset insert of tng_pollset failed' + ascii(:enumber); raise error 
40028 :emessage with destination = (session,error_log); return -1; 
endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_pollset to group 
tngadmin
\p\g
drop procedure tng_add_propertydef
\p\g
create procedure  tng_add_propertydef ( classname varchar(30) , name 
varchar(30) , datatype varchar(20) , length int, is_key int1 not null 
with default, required int1 not null with default, readonly int1 not 
null with default, defaultval varchar(255) with null, storage 
varchar(30) with null, storage_field varchar(30) with null, 
property_group varchar(10) with null, method_name varchar(30) with 
null) as declare class_id int; rc int; err_msg varchar(255) not null; 
id int; emessage char(255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
(:enumber > 0) then emessage = 'procedure add_propertydef failed' + 
ascii(:enumber); raise error 40016 :emessage with 
destination=(session,error_log); return -1; endif; if 
(uppercase(:classname) = 'CLASS') then :class_id=0; else select 
class_id into :class_id from "mdbadmin". tng_class where 
name=:classname; if (:class_id is null) then :err_msg='MSG:(90026) add
_property_def: bad '+ ':classname: '+:classname; raise error 90026 
:err_msg; return; endif; endif; if ((:storage is not null) and 
(:storage_field is null)) then  :storage_field=:name; endif; :rc=-1; 
execute procedure "mdbadmin". tng_is_same_property( classname = 
:classname, name = :name, datatype = :datatype, length = :length, 
is_key = :is_key, required = :required, instance_storage = :storage, 
storage_field = :storage_field, default_value = :defaultval, rc = 
byref(:rc)); if(:rc=0) then execute procedure "mdbadmin". tng_get_id (
key_id = byref(:id)); insert into "mdbadmin". tng_property_definition 
(class_id, name, datatype, length, is_key, required, default_value, 
instance_storage, storage_field, property_group, method_name, 
readonly, override, id) values (:class_id, :name, :datatype, :length, 
:is_key, :required, :defaultval, :storage, :storage_field, 
:property_group, :method_name, :readonly, 1, :id); if 
(iierrornumber!=0) then :err_msg='MSG:(90027) Failed to insert entry f
or '+ 'property of class name: '+:classname; raise error 90027 
:err_msg; endif; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_propertydef to group 
tngadmin
\p\g
drop procedure tng_add_sysobjid
\p\g
create procedure  tng_add_sysobjid ( classname varchar(30), sysobjid 
varchar(251) ) as declare class_id int; emessage char(255) not null 
with default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'procedure add_sysobjid failed' + ascii(:enumber); raise error 40013
:emessage with destination=(session,error_log); return -1; endif;  
insert into "mdbadmin". tng_sysobjid ( class_name, sysobjid ) 
values(:classname, :sysobjid ); select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'procedure add_sy
sobjid insert of tng_sysobjid failed' + ascii(:enumber); raise error 
40029 :emessage with destination = (session,error_log); return -1; 
endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_sysobjid to group 
tngadmin
\p\g
drop procedure tng_add_to_alarmset_entry
\p\g
create procedure  tng_add_to_alarmset_entry ( alarmset_name 
varchar(40), status_no int, severity int, propagate_status int1 with 
null) as declare emessage char(255) not null with default; rcount int;
enumber int; begin select iirowcount, iierrornumber into :rcount, 
:enumber; if ( :enumber > 0 ) then emessage = 'procedure add_to_alarms
et_entry failed' + ascii(:enumber); raise error 40019 :emessage with 
destination = (session, error_log); return -1; endif; if 
(:propagate_status is null) then :propagate_status = 1; endif; if 
(:alarmset_name = 'Workstation' or :alarmset_name = 'Unclassified_TCP'
) then :propagate_status = 0; endif; insert into "mdbadmin". 
tng_alarmset_entry (alarmset_name, status_no, severity, 
propagate_status) values (:alarmset_name, :status_no, :severity,
:propagate_status); select iirowcount, iierrornumber into :rcount, 
:enumber; if ( :enumber > 0 ) then emessage = 'procedure add_to_alarms
et_entry inser of tng_alarmset_entry failed' + ascii(:enumber); raise 
error 40034 :emessage with destination = (session, error_log); return 
-1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_add_to_alarmset_entry to 
group tngadmin
\p\g
drop procedure tng_ca_add_subnet1
\p\g
create procedure  tng_ca_add_subnet1 ( name char(20), subnet_addr 
byte(4), subnet_mask byte(4), gateway1 byte(4) with null, gateway2 
byte(4) with null, managed int with null, uuid1 byte(16), uuid2 
byte(16), uuid3 byte(16), uuid4 byte(16), uuid5 byte(16), uuid6 
byte(16), call_noniu int with null ) as declare ipsubnet_id int; 
free_id int; start_ipaddr byte(4); end_ipaddr byte(4); objid int; 
time_stamp date; ipaddr_str1 char(15); subnet_addr_only byte(4); 
subnet_class_id int; uuid_bin byte(16); uuid_str varchar(36); 
network_class_id int; network_uuid byte(16); hier_uuid byte(16); 
internet_uuid byte(16);  ManagedObjectRoot_uuid byte(16); 
network_class char(1); network_class_addr_hex byte(4); 
network_class_addr_str varchar(15); network_mask byte(4); class_name 
varchar(30); hidden int1; propagate_status int1; label varchar(255); 
severity int; address_type int; autoarrange_type int; posted int1; 
acknowledge int1; msg varchar(255) not null; numrows int; 
discovery_ipsubnet_id int;  subnetaddr byte(4); subnetaddrstr char(15)
; subnetmaskstr char(15); gateway1str char(15); gateway2str char(15); 
managedstr char(6);  emessage char(255) not null with default; rcount 
int; enumber int; begin select iirowcount, iierrornumber into :rcount,
:enumber; if ( :enumber > 0 ) then emessage = 'procedure ca_add_subnet
1 failed' + ascii(:enumber); raise error 60043 :emessage with 
destination = (session,error_log); return -1; endif; if (managed is 
null) then managed = 1; endif; if (call_noniu is null) then call_noniu
= 1; endif;  :start_ipaddr = bit_and(:subnet_addr, :subnet_mask); 
:end_ipaddr = bit_add(:subnet_addr, bit_not(:subnet_mask)); select 
count(*) into :numrows from "mdbadmin". tng_discovery_ipsubnet where 
name=:name; if (:numrows > 0) then if (managed = 3) then update 
"mdbadmin". tng_discovery_ipsubnet set managed = 3, managed_str = 'No'
where subnet_addr_str = :name; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'ca_add_subnet1 u
pdate of tng_discovery_ipsubnet failed' + ascii(:enumber); raise error
60024 :emessage with destination = (session,error_log); return -1; 
endif; endif;  select count(*) into :numrows from "mdbadmin". 
tng_managedobject where name=:name; if(:numrows > 0) then return; 
endif; endif;         if (:numrows > 0) then  return; endif; 
:time_stamp = date('now');  :subnetaddr = bit_and(:subnet_addr, 
:subnet_mask); execute procedure "mdbadmin". tng_iphex2str_nd ( 
ipaddr_hex=:subnetaddr, ipaddr_str=byref(:subnetaddrstr)); execute 
procedure "mdbadmin". tng_iphex2str_nd ( ipaddr_hex=:subnet_mask, 
ipaddr_str=byref(:subnetmaskstr)); execute procedure "mdbadmin". 
tng_iphex2str_nd ( ipaddr_hex=:gateway1, 
ipaddr_str=byref(:gateway1str)); execute procedure "mdbadmin". 
tng_iphex2str_nd ( ipaddr_hex=:gateway2, 
ipaddr_str=byref(:gateway2str)); if :managed = 1 then :managedstr = 'Y
es'; else :managedstr = 'No'; endif;   if (:gateway1 is not null) then
execute procedure "mdbadmin". tng_get_discovery_ipsubnet_id ( key_id =
byref(:discovery_ipsubnet_id)); insert into "mdbadmin". 
tng_discovery_ipsubnet (name, subnet_addr, subnet_mask, gateway1, 
gateway2, managed, time_stamp, subnet_addr_str, subnet_mask_str, 
gateway1_str, gateway2_str, managed_str, computer_name, instance_no, 
discovery_ipsubnet_id) values (:name, :subnetaddr, :subnet_mask, 
:gateway1, :gateway2, :managed, :time_stamp, :subnetaddrstr, 
:subnetmaskstr, :gateway1str, :gateway2str, :managedstr, null, 0, 
:discovery_ipsubnet_id); select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'ca_add_subnet1 i
nsert of tng_discovery_ipsubnet failed' + ascii(:enumber); raise error
60025 :emessage with destination = (session,error_log); return -1; 
endif; endif;   :subnet_addr_only = bit_and(:subnet_addr, 
:subnet_mask);  :network_uuid=null; :internet_uuid=null; if 
(call_noniu = 1) then select count(*) into :numrows from "mdbadmin". 
tng_managedobject where ip_address_hex = :subnet_addr_only; if 
(:numrows = 0) then :ipaddr_str1 =  
squeeze(char(intextract(subnet_addr_only, 1))) + '.' + 
squeeze(char(intextract(subnet_addr_only, 2))) + '.' + 
squeeze(char(intextract(subnet_addr_only, 3))) + '.' + 
squeeze(char(intextract(subnet_addr_only, 4))) ;  execute procedure 
"mdbadmin". tng_get_network_class( subnet_addr = :subnet_addr, 
subnet_mask = :subnet_mask, network_class = byref(:network_class), 
network_class_addr_hex = byref(:network_class_addr_hex), 
network_class_addr_str = byref(:network_class_addr_str)); if 
(:network_class='A' or :network_class='B' or :network_class='C') then 
select count(*) into :numrows from "mdbadmin". tng_managedobject where
name=:network_class_addr_str and class_name='IP_Network'; if (:numrows
= 0) then if(:network_class='A') then :network_mask=X'ff000000'; 
endif; if(:network_class='B') then :network_mask=X'ffff0000'; endif; 
if(:network_class='C') then :network_mask=X'ffffff00'; endif; 
:hidden=1; :propagate_status=1; :address_type=1; :autoarrange_type=1; 
:severity=1; :posted=1; :acknowledge=1; execute procedure "mdbadmin". 
tng_get_class_ilp( class_name = 'IP_Network', hidden = byref(:hidden),
propagate_status = byref(:propagate_status), address_type = 
byref(:address_type), autoarrange_type = byref(:autoarrange_type), 
severity = byref(:severity), posted = byref(:posted), acknowledge = 
byref(:acknowledge));   :internet_uuid=null; select uuid into 
:internet_uuid from "mdbadmin". tng_managedobject where class_name='Ne
twork' and name='TCP/IP Network' and label='TCP/IP Network'; 
if(:internet_uuid is null) then  :internet_uuid=uuid1; execute 
procedure "mdbadmin". tng_add_managedobject( uuid=:internet_uuid, 
name='TCP/IP Network', label='TCP/IP Network', class_name='Network', 
hidden=0, propagate_status=1, status_no=0, severity=0 , posted=0 , 
acknowledge=0, autoarrange_type=:autoarrange_type, 
date_ins=:time_stamp, date_modify=:time_stamp);    
:ManagedObjectRoot_uuid= X'8809f8f5ca81cf11b4370020af03cf7c';     
hier_uuid=uuid2;  insert into "mdbadmin". tng_inclusion (uuid, 
parent_class, parent_uuid, child_class, child_uuid) values 
(:hier_uuid, 'ManagedObjectRoot', :ManagedObjectRoot_uuid, 'Network', 
:internet_uuid ); select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'ca_add_subnet1 insert of 
tng_inclusion failed' + ascii(:enumber); raise error 60026 :emessage 
with destination = (session,error_log); return -1; endif;  endif; 
:network_uuid=uuid3; execute procedure "mdbadmin". 
tng_add_managedobject( uuid=:network_uuid, 
name=:network_class_addr_str, label=:network_class_addr_str, 
address=:network_class_addr_str, class_name='IP_Network', hidden=0, 
propagate_status=1, status_no=0, severity=0 , posted=0 , 
acknowledge=0, autoarrange_type=:autoarrange_type, 
ip_address_hex=:network_class_addr_hex, subnet_mask=:network_mask, 
date_ins=:time_stamp, date_modify=:time_stamp);   :hier_uuid=:uuid4;  
insert into "mdbadmin". tng_inclusion (uuid, parent_class, 
parent_uuid, child_class, child_uuid) values (:hier_uuid, 'Network', 
:internet_uuid, 'IP_Network', :network_uuid ); select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'ca_add_subnet1 insert of tng_inclusion failed' + ascii(:enumber); 
raise error 60027 :emessage with destination = (session,error_log); 
return -1; endif;  endif; endif;  uuid_bin=uuid5;  if 
(:network_class='R') then :class_name='Unclassified_Class'; else 
:class_name='IP_Subnet'; endif; :label=:name; if (:network_class='B' 
and bit_and(X'000000ff', :subnet_mask)=X'00000000') then         
:label = squeeze(char(intextract(:subnet_addr_only, 3))); endif; 
:hidden=1; :propagate_status=1; :address_type=1; :autoarrange_type=1; 
:severity=1; :posted=1; :acknowledge=1; execute procedure "mdbadmin". 
tng_get_class_ilp( class_name = :class_name, hidden = byref(:hidden), 
propagate_status = byref(:propagate_status), address_type = 
byref(:address_type), autoarrange_type = byref(:autoarrange_type), 
severity = byref(:severity), posted = byref(:posted), acknowledge = 
byref(:acknowledge)); execute procedure "mdbadmin". 
tng_add_managedobject( uuid = :uuid_bin, name = :name, label = :label,
address = :ipaddr_str1, class_name = :class_name, hidden = :hidden, 
propagate_status = :propagate_status, status_no = 10, address_type = 
:address_type , autoarrange_type = :autoarrange_type , severity = 
:severity , posted = :posted , acknowledge = :acknowledge, 
ip_address_hex = :subnet_addr_only, subnet_mask = :subnet_mask, 
date_ins = :time_stamp, date_modify = :time_stamp);  insert into 
"mdbadmin". tng_IP_Subnet(uuid) values (:uuid_bin); select iirowcount,
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'ca_add_subnet1 insert of IP_Subnet failed' + ascii(:enumber); raise
error 60028 :emessage with destination = (session,error_log); return 
-1; endif; update "mdbadmin". tng_discovery_status set 
new_subnet=new_subnet+1; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'ca_add_subnet1 u
pdate of tng_discovery_status failed' + ascii(:enumber); raise error 
60029 :emessage with destination = (session,error_log); return -1; 
endif;     if (:network_class != 'R' ) then if (:network_uuid is null)
then select uuid into :network_uuid from "mdbadmin". tng_managedobject
where class_name = 'IP_Network' and name=:network_class_addr_str; 
endif; if (:network_uuid is not null) then :hier_uuid=:uuid6;  insert 
into "mdbadmin". tng_inclusion (uuid, parent_class, parent_uuid, 
child_class, child_uuid) values (:hier_uuid, 'IP_Network', 
:network_uuid, 'IP_Subnet', :uuid_bin); select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'ca_add_subnet1 insert of tng_inclusion failed' + ascii(:enumber); 
raise error 60030 :emessage with destination = (session, error_log); 
return -1; endif;  else  if (:internet_uuid is null) then select uuid 
into :internet_uuid from "mdbadmin". tng_managedobject where 
class_name = 'Network' and name='TCP/IP Network' and label='TCP/IP Net
work'; endif; if (:internet_uuid is null) then :msg='MSG(99991):(call 
in '+ 'ca_add_ipsubnet) can not create hierarchy '+ 'for IP_Subnet: '+
:name+ ' because  object of Internet not exists!'; raise error 99991 
:msg; else :hier_uuid=:uuid6;  insert into "mdbadmin". tng_inclusion 
(uuid, parent_class, parent_uuid, child_class, child_uuid) values 
(:hier_uuid, 'Network', :internet_uuid, 'IP_Subnet', :uuid_bin); 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'ca_add_subnet1 insert of tng_inclusion failed' +
ascii(:enumber); raise error 60031 :emessage with destination = 
(session,error_log); return -1; endif;  endif; endif; endif; endif; 
endif; end
\p\g
grant execute on procedure "mdbadmin".tng_ca_add_subnet1 to group 
tngadmin
\p\g
drop procedure tng_ca_add_subnet2
\p\g
create procedure  tng_ca_add_subnet2 ( name char(20), subnet_addr 
byte(4), subnet_mask byte(4), gateway1 byte(4) with null, gateway2 
byte(4) with null, managed int with null ) as declare start_ipaddr 
byte(4); end_ipaddr byte(4); time_stamp date;  subnetaddr byte(4); 
subnetaddrstr char(15); subnetmaskstr char(15); gateway1str char(15); 
gateway2str char(15); managedstr char(6); discovery_ipsubnet_id int;  
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if ( 
:enumber > 0 ) then emessage = 'procedure ca_add_subnet2 failed' + 
ascii(iierrornumber); raise error 60044 :emessage with destination = 
(session,error_log); return -1; endif; if (managed is null) then 
managed = 1; endif; :start_ipaddr = bit_and(:subnet_addr, 
:subnet_mask); :end_ipaddr = bit_add(:subnet_addr, 
bit_not(:subnet_mask));    :time_stamp = date('now');   :subnetaddr = 
bit_and(:subnet_addr, :subnet_mask); execute procedure "mdbadmin". 
tng_iphex2str_nd ( ipaddr_hex=:subnetaddr, 
ipaddr_str=byref(:subnetaddrstr)); execute procedure "mdbadmin". 
tng_iphex2str_nd ( ipaddr_hex=:subnet_mask, 
ipaddr_str=byref(:subnetmaskstr)); execute procedure "mdbadmin". 
tng_iphex2str_nd ( ipaddr_hex=:gateway1, 
ipaddr_str=byref(:gateway1str)); execute procedure "mdbadmin". 
tng_iphex2str_nd ( ipaddr_hex=:gateway2, 
ipaddr_str=byref(:gateway2str)); if :managed = 1 then :managedstr = 'Y
es'; else :managedstr = 'No'; endif;   execute procedure "mdbadmin". 
tng_get_discovery_ipsubnet_id ( key_id = byref(:discovery_ipsubnet_id)
); insert into "mdbadmin". tng_discovery_ipsubnet (name, subnet_addr, 
subnet_mask, gateway1, gateway2, managed, time_stamp, subnet_addr_str,
subnet_mask_str, gateway1_str, gateway2_str, managed_str, 
computer_name, instance_no, discovery_ipsubnet_id) values (:name, 
:subnetaddr, :subnet_mask, :gateway1, :gateway2, :managed, 
:time_stamp, :subnetaddrstr, :subnetmaskstr, :gateway1str, 
:gateway2str, :managedstr, null, 0, :discovery_ipsubnet_id); select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'ca_add_subnet2 insert of tng_discovery_ipsubnet faile
d' + ascii(:enumber); raise error 60032 :emessage with destination = 
(session,error_log); return -1; endif;  end
\p\g
grant execute on procedure "mdbadmin".tng_ca_add_subnet2 to group 
tngadmin
\p\g
drop procedure tng_ca_claim_discovery
\p\g
create procedure  tng_ca_claim_discovery ( instance_no int with null, 
computer_name varchar(25) with null ) as declare process_no int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin    delete from "mdbadmin". tng_ca_claim_discovery_tmp; select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0) 
then emessage = 'ca_claim_discovery delete of tng_ca_claim_discovery_t
mp failed' + ascii(:enumber); raise error 60003 :emessage with 
destination = (session,error_log); return -1; endif; if (:instance_no 
> 1) then insert into "mdbadmin". tng_ca_claim_discovery_tmp (ret, 
computer_name, instance_no ) values (1, :computer_name, :instance_no);
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'ca_claim_discovery insert of tng_ca_claim_discov
ery_tmp failed' + ascii(:enumber); raise error 60004 :emessage with 
destination = (session,error_log); return -1; elseif ( :rcount = 0) 
then emessage = 'ca_claim_discovery insert of tng_ca_claim_discovery_t
mp zero rows'; raise error 60004 :emessage with destination = 
(session,error_log); return -1; endif; return 1; else update 
"mdbadmin". tng_discovery_ipsubnet set instance_no = 0, computer_name 
= NULL; select iirowcount, iierrornumber into :rcount, :enumber; if 
(:enumber > 0 ) then emessage = 'ca_claim_discovery update of tng_disc
overy_ipsubnet failed' + ascii(:enumber); raise error 60005 :emessage 
with destination = (session,error_log); return -1; endif; delete from 
"mdbadmin". tng_discovery_ipsubnet_tmp; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'ca_claim_discovery delete of tng_discovery_ipsubnet_tmp failed' + 
ascii(:enumber); raise error 60006 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_discovery_status set curr_total_devices = 0, new_tcpip=0, 
new_subnet=0, new_managedobject=0, init_time = date('now'), 
curr_new_devices = 0 ; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0 ) then emessage = 'ca_claim_discovery updat
e of tng_discovery_status failed' + ascii(:enumber); raise error 60007
:emessage with destination = (session,error_log); return -1; endif; 
insert into "mdbadmin". tng_ca_claim_discovery_tmp (ret, 
computer_name, instance_no ) values (0, :computer_name, :instance_no);
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0 ) then emessage = 'ca_claim_discovery insert of tng_ca_claim_disco
very_tmp failed' + ascii(:enumber); raise error 60008 :emessage with 
destination = (session,error_log); return -1; elseif ( :rcount = 0 ) 
then emessage = 'ca_claim_discovery insert of tng_ca_claim_discovery_t
mp zero rows'; raise error 60008 :emessage with destination = 
(session,error_log); return -1; endif; return 0; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_ca_claim_discovery to group 
tngadmin
\p\g
drop procedure tng_ca_update_discovery_setup
\p\g
create procedure  tng_ca_update_discovery_setup( start_time date with 
null, frequency int not null with default, mask int not null with 
default) as declare dev_mask int; s_time date; emessage char(255) not 
null with default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure ca_update_discovery_setup failed' + 
ascii(:enumber); raise error 60037 :emessage with destination = 
(session,error_log); return -1; endif; if (:start_time is not null) 
then :s_time = :start_time; else :s_time = date('now'); endif; update 
"mdbadmin". tng_discovery_setup set start_time = :s_time, frequency = 
:frequency; select iirowcount, iierrornumber into :rcount, :enumber; 
if (:enumber > 0) then emessage = 'ca_update_discovery_setup update of
 tng_discovery_setup failed' + ascii(:enumber); raise error 60012 
:emessage with destination = (session,error_log); return -1; endif; 
end
\p\g
grant execute on procedure "mdbadmin".tng_ca_update_discovery_setup to
group tngadmin
\p\g
drop procedure tng_ca_update_discovery_status
\p\g
create procedure  tng_ca_update_discovery_status( curr_status int, 
start_time date with null, cycle_time int with null, type int not null
with default) as declare emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if ( :enumber > 0 ) then emessage = 'procedure ca_u
pdate_discovery_status failed' + ascii(:enumber); raise error 60035 
:emessage with destination = (session, error_log); return -1; endif; 
if( type = 1 ) then update "mdbadmin". tng_discovery_status set 
current_status = :curr_status, start_time = date('now'); select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage='ca_update_discovery_status update of tng_discovery_stat
us failed' + ascii(:enumber); raise error 60009 :emessage with 
destination = (session,error_log); return -1; endif; elseif ( type = 2
) then update "mdbadmin". tng_discovery_status set current_status = 
:curr_status, cycle_time = :cycle_time; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then 
emessage='ca_update_discovery_status update of tng_discovery_status fa
iled' + ascii(:enumber); raise error 60010 :emessage with destination 
= (session,error_log); return -1; endif; else update "mdbadmin". 
tng_discovery_status set current_status = :curr_status; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0 ) 
then emessage='ca_update_discovery_status update of tng_discovery_stat
us failed' + ascii(:enumber); raise error 60011 :emessage with 
destination = (session,error_log); return -1; endif; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_ca_update_discovery_status 
to group tngadmin
\p\g
drop procedure tng_clean_change_history
\p\g
create procedure  tng_clean_change_history as declare rowcount int; 
deletecount int; sequence_no int; min_seq_no int; begin select 
count(*) into :rowcount from "mdbadmin". tng_change_history ; if ( 
:rowcount <= 1000000 ) then return; endif; :deletecount = :rowcount - 
1000000;  if (:deletecount < 10000) then :deletecount = 10000; endif; 
select sequence_no_key, min_seq_no into :sequence_no, :min_seq_no from
"mdbadmin". tng_key_change_hist ; delete from "mdbadmin". 
tng_change_history where sequence_no < :min_seq_no + :deletecount; 
update "mdbadmin". tng_key_change_hist set min_seq_no = :min_seq_no+
:deletecount; end
\p\g
grant execute on procedure "mdbadmin".tng_clean_change_history to 
group tngadmin
\p\g
drop procedure tng_clean_prop_status_history
\p\g
create procedure  tng_clean_prop_status_history as declare rowcount 
int; deletecount int; sequence_no int; min_seq_no int; begin select 
count(*) into :rowcount from "mdbadmin". tng_prop_status_history ; if 
( :rowcount <= 1000000 ) then return; endif; :deletecount = :rowcount 
- 1000000;  if (:deletecount < 10000) then :deletecount = 10000; 
endif; select sequence_no_key, min_seq_no into :sequence_no, 
:min_seq_no from "mdbadmin". tng_key_prop_status_hist ; delete from 
"mdbadmin". tng_prop_status_history where sequence_no < :min_seq_no + 
:deletecount; update "mdbadmin". tng_key_prop_status_hist set 
min_seq_no = :min_seq_no+:deletecount; end
\p\g
grant execute on procedure "mdbadmin".tng_clean_prop_status_history to
group tngadmin
\p\g
drop procedure tng_clean_status_history
\p\g
create procedure  tng_clean_status_history as declare rowcount int; 
deletecount int; sequence_no int; min_seq_no int; begin select 
count(*) into :rowcount from "mdbadmin". tng_status_history ; if ( 
:rowcount <= 1000000 ) then return; endif; :deletecount = :rowcount - 
1000000;  if (:deletecount < 10000) then :deletecount = 10000; endif; 
select sequence_no_key, min_seq_no into :sequence_no, :min_seq_no from
"mdbadmin". tng_key_status_hist ; delete from "mdbadmin". 
tng_status_history where sequence_no < :min_seq_no + :deletecount; 
update "mdbadmin". tng_key_status_hist set min_seq_no = :min_seq_no+
:deletecount; end
\p\g
grant execute on procedure "mdbadmin".tng_clean_status_history to 
group tngadmin
\p\g
drop procedure tng_columnupdated
\p\g
create procedure  tng_ColumnUpdated ( v_int_old int, v_int_new int, 
v_int1_old int1, v_int1_new int1, v_int2_old int2, v_int2_new int2, 
v_float_old float, v_float_new float, v_uuid_old byte(16), v_uuid_new 
byte(16), v_hex4_old byte(4), v_hex4_new byte(4), v_date_old date, 
v_date_new date, v_varchar_old varchar(255), v_varchar_new 
varchar(255), v_datatype int not null ) as declare v_BOOL int not 
null; emessage char(255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
( :enumber > 0 ) then emessage = 'procedure ColumnUpdated failed' + 
ascii(iierrornumber); raise error 60045 :emessage with destination = 
(session, error_log); return -1; endif; if(v_datatype=0) then 
if((v_varchar_old is not null and v_varchar_new is not null) and 
(v_varchar_old!=v_varchar_new)) then return 1; elseif( v_varchar_old 
is not null and v_varchar_new is null) then return 1; elseif( 
v_varchar_old is null and v_varchar_new is not null) then return 1; 
elseif( v_varchar_old is null and v_varchar_new is null) then return 
0; elseif( v_varchar_old = v_varchar_new ) then return 0; else return 
-1;  endif; elseif(v_datatype=4) then if( (v_int_old is not null and 
v_int_new is not null) and ( v_int_old!=v_int_new)) then return 1; 
elseif( v_int_old is not null and v_int_new is null) then return 1; 
elseif( v_int_old is null and v_int_new is not null) then return 1; 
elseif( v_int_old is null and v_int_new is null) then return 0; 
elseif( v_int_old = v_int_new ) then return 0; else return -1;  endif;
elseif(v_datatype=1) then if( (v_int1_old is not null and v_int1_new 
is not null) and ( v_int1_old!=v_int1_new)) then return 1; elseif( 
v_int1_old is not null and v_int1_new is null) then return 1; elseif( 
v_int1_old is null and v_int1_new is not null) then return 1; elseif( 
v_int1_old is null and v_int1_new is null) then return 0; elseif( 
v_int1_old = v_int1_new ) then return 0; else return -1;  endif; 
elseif(v_datatype=2) then if( (v_int2_old is not null and v_int2_new 
is not null) and ( v_int2_old!=v_int2_new)) then return 1; elseif( 
v_int2_old is not null and v_int2_new is null) then return 1; elseif( 
v_int2_old is null and v_int2_new is not null) then return 1; elseif( 
v_int2_old is null and v_int2_new is null) then return 0; elseif( 
v_int2_old = v_int2_new ) then return 0; else return -1;  endif; 
elseif(v_datatype=7) then if( (v_float_old is not null and v_float_new
is not null) and ( v_float_old!=v_float_new)) then return 1; elseif( 
v_float_old is not null and v_float_new is null) then return 1; 
elseif( v_float_old is null and v_float_new is not null) then return 
1; elseif( v_float_old is null and v_float_new is null) then return 0;
elseif( v_float_old = v_float_new ) then return 0; else return -1;  
endif; elseif(v_datatype=16) then if( (v_uuid_old is not null and 
v_uuid_new is not null) and ( v_uuid_old!=v_uuid_new)) then return 1; 
elseif( v_uuid_old is not null and v_uuid_new is null) then return 1; 
elseif( v_uuid_old is null and v_uuid_new is not null) then return 1; 
elseif( v_uuid_old is null and v_uuid_new is null) then return 0; 
elseif( v_uuid_old = v_uuid_new ) then return 0; else return -1;  
endif; elseif(v_datatype=5) then if( (v_hex4_old is not null and 
v_hex4_new is not null) and ( v_hex4_old!=v_hex4_new)) then return 1; 
elseif( v_hex4_old is not null and v_hex4_new is null) then return 1; 
elseif( v_hex4_old is null and v_hex4_new is not null) then return 1; 
elseif( v_hex4_old is null and v_hex4_new is null) then return 0; 
elseif( v_hex4_old = v_hex4_new ) then return 0; else return -1;  
endif; elseif(v_datatype=6) then if( (v_date_old is not null and 
v_date_new is not null) and ( v_date_old!=v_date_new)) then return 1; 
elseif( v_date_old is not null and v_date_new is null) then return 1; 
elseif( v_date_old is null and v_date_new is not null) then return 1; 
elseif( v_date_old is null and v_date_new is null) then return 0; 
elseif( v_date_old = v_date_new ) then return 0; else return -1;  
endif; else return -1; endif; end
\p\g
drop procedure tng_del_uncls_w_name_option_ip
\p\g
create procedure  tng_del_uncls_w_name_option_ip ( name varchar(255), 
ipaddr_str varchar(16), bDelUnclassifyObj int not null with default) 
as declare del_uuid byte(16); emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure del_uncls_w_name_option_ip failed' + 
ascii(:enumber); raise error 50028 :emessage with destination = 
(session,error_log); return -1; endif; :del_uuid = null; if 
(:bDelUnclassifyObj <> 0) then select uuid into :del_uuid from 
"mdbadmin". tng_managedobject where address=:ipaddr_str and 
class_name='Unclassified_TCP'; else select uuid into :del_uuid from 
"mdbadmin". tng_managedobject where address=:ipaddr_str and 
class_name='Unclassified_TCP' and name=:name; endif; if (iirowcount = 
1) then delete from "mdbadmin". tng_unclassified_tcp where uuid = 
:del_uuid; select iirowcount, iierrornumber into :rcount, :enumber; if
( :enumber > 0 ) then emessage = 'del_uncls_w_name_option_ip delete of
 tng_unclassified_tcp failed' + ascii(:enumber); raise error 50010 
:emessage with destination = (session,error_log); return -1; elseif ( 
:rcount = 0 ) then emessage = 'del_uncls_w_name_option_ip delete of tn
g_unclassified_tcp zero rows'; raise error 50010 :emessage with 
destination = (session,error_log); return -1; endif; delete from 
"mdbadmin". tng_managedobject where uuid = :del_uuid; select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'del_uncls_w_name_option_ip delete of tng_managedobjec
t failed' + ascii(:enumber); raise error 50011 :emessage with 
destination = (session,error_log); return -1; elseif ( :rcount = 0 ) 
then emessage = 'del_uncls_w_name_option_ip delete of tng_managedobjec
t zero rows'; raise error 50011 :emessage with destination = (session,
error_log); return -1; endif; endif; return iirowcount; end
\p\g
grant execute on procedure "mdbadmin".tng_del_uncls_w_name_option_ip 
to group tngadmin
\p\g
drop procedure tng_deluncls_ipdiffname_uptclsip
\p\g
create procedure  tng_DelUncls_IpDiffName_UptClsIp ( class_name 
varchar(30), name varchar(255), address varchar(255), 
bDelUnclassifyObj int not null with default, bUpdateClassifyObj int 
not null with default, bIsInDHCPRange int not null with default) as 
declare del_count int not null; del_uuid byte(16); emessage char(255) 
not null with default; rcount int; enumber int; begin select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure DelUncls_IpDiffName_UptClsIp failed' + 
ascii(:enumber); raise error 60030 :emessage with destination = 
(session,error_log); return -1; endif; select count(*) into :del_count
from "mdbadmin". tng_managedobject where class_name=:class_name and 
address=:address and name<>:name; if (:bDelUnclassifyObj <> 0 and 
:del_count <> 0) then  delete from "mdbadmin". tng_unclassified_tcp 
where uuid in (select uuid from "mdbadmin". tng_managedobject where 
class_name=:class_name and address=:address and name<>:name); select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'DelUncls_IpDiffName_UptClsIp delete of tng_unclassifi
ed_tcp failed' + ascii(:enumber); raise error 50014 :emessage with 
destination = (session,error_log); return -1; elseif ( :rcount = 0 ) 
then emessage = 'DelUncls_IpDiffName_UptClsIp delete of tng_unclassifi
ed_tcp zero rows'; raise error 50015 :emessage with destination = 
(session,error_log); return -1; endif;  delete from "mdbadmin". 
tng_managedobject where uuid in (select uuid from "mdbadmin". 
tng_managedobject where class_name=:class_name and address=:address 
and name<>:name); select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'DelUncls_IpDiffName_UptCl
sIp delete of tng_managedobject failed' + ascii(:enumber); raise error
50016 :emessage with destination = (session,error_log); return -1; 
elseif ( :rcount = 0 ) then emessage = 'DelUncls_IpDiffName_UptClsIp d
elete of tng_managedobject zero rows'; raise error 50016 :emessage 
with destination = (session,error_log); return -1; endif;  endif; if 
(:bUpdateClassifyObj <> 0 and :bUpdateClassifyObj <> 0) then  update 
"mdbadmin". tng_managedobject set status_no=23 where (class_name<>'Unc
lassified_TCP' and class_name<>:class_name and address=:address and 
status_no<>23) or (name<>:name and class_name=:class_name and 
address=:address and status_no<>23); select iirowcount, iierrornumber 
into :rcount, :enumber; if (:enumber > 0) then emessage = 'DelUncls_Ip
DiffName_UptClsIp update of tng_managedobject zero rows' + 
ascii(:enumber); raise error 50017 :emessage with destination = 
(session,error_log); return -1; endif;  endif; return :del_count; end
\p\g
grant execute on procedure "mdbadmin".tng_deluncls_ipdiffname_uptclsip
to group tngadmin
\p\g
drop procedure tng_discovery_get_community
\p\g
create procedure  tng_discovery_get_community as declare name 
varchar(30); mask varchar(30); emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure discovery_get_community failed' + 
ascii(:enumber); raise error 60040 :emessage with destination = 
(session,error_log); return -1; endif; select tng_auth.name, 
tng_auth.mask into :name, :mask from "mdbadmin". tng_auth where 
tng_auth.access = 'G'; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'discovery_get_community s
elect of tng_auth failed' + ascii(:enumber); raise error 60019 
:emessage with destination = (session,error_log); return -1; endif; 
end
\p\g
grant execute on procedure "mdbadmin".tng_discovery_get_community to 
group tngadmin
\p\g
drop procedure tng_discovery_get_drg_swtypes
\p\g
create procedure  tng_discovery_get_drg_swtypes as begin return; end
\p\g
grant execute on procedure "mdbadmin".tng_discovery_get_drg_swtypes to
group tngadmin
\p\g
drop procedure tng_discovery_get_ip_subnet
\p\g
create procedure  tng_discovery_get_ip_subnet( instance_no int with 
null, computer_name varchar(25) with null, nonew int with null ) as 
declare tid int; subnet_addr byte(4); subnet_mask byte(4); gateway1 
byte(4); gateway2 byte(4); time_stamp date; numrows int; init_time 
date; emessage char (255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
( :enumber > 0 ) then emessage = 'procedure discovery_get_ip_subnet fa
iled' + ascii(:enumber); raise error 60038 :emessage with destination 
= (session, error_log); return -1; endif; select init_time into 
:init_time from "mdbadmin". tng_discovery_status; delete from 
"mdbadmin". tng_discovery_ipsubnet_tmp where computer_name = 
:computer_name and instance_no = :instance_no; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'discovery_get_ip_subnet delete of tng_discovery_ipsubnet_tmp failed
' + ascii(:enumber); raise error 60014 :emessage with destination = 
(session,error_log); return -1; endif; if (:instance_no is null or 
:instance_no = 0) then insert into "mdbadmin". 
tng_discovery_ipsubnet_tmp (subnet_addr, subnet_mask, gateway1, 
gateway2, time_stamp, computer_name, instance_no) select subnet_addr, 
subnet_mask, gateway1, gateway2, time_stamp, :computer_name, 
:instance_no from "mdbadmin". tng_discovery_ipsubnet where managed = 
1; select iirowcount, iierrornumber into :rcount, :enumber; if 
(:enumber > 0) then emessage = 'discovery_get_ip_subnet insert of tng_
discovery_ipsubnet_tmp failed' + ascii(:enumber); raise error 60015 
:emessage with destination = (session,error_log); return -1; elseif ( 
:rcount = 0) then emessage = 'discovery_get_ip_subnet insert of tng_di
scovery_ipsubnet_tmp zero rows'; raise error 60015 :emessage with 
destination = (session,error_log); return -1; endif; else :tid = 0; if
(:nonew is null or :nonew = 0) then select count(*) into :numrows from
"mdbadmin". tng_discovery_ipsubnet where managed = 1 and instance_no =
:instance_no and (computer_name is null or computer_name = 
:computer_name); else select count(*) into :numrows from "mdbadmin". 
tng_discovery_ipsubnet where managed = 1 and instance_no = 
:instance_no and time_stamp < :init_time and (computer_name is null or
computer_name = :computer_name); endif; if (:numrows > 0) then if 
(:nonew is null or :nonew = 0) then select max(discovery_ipsubnet_id) 
into :tid from "mdbadmin". tng_discovery_ipsubnet where managed = 1 
and instance_no = :instance_no; else select max(discovery_ipsubnet_id)
into :tid from "mdbadmin". tng_discovery_ipsubnet where managed = 1 
and instance_no = :instance_no and time_stamp < :init_time; endif; 
else if (:nonew is null or :nonew = 0) then select 
max(discovery_ipsubnet_id) into :tid from "mdbadmin". 
tng_discovery_ipsubnet where managed = 1 and (instance_no = 0 or 
instance_no is null); else select max(discovery_ipsubnet_id) into :tid
from "mdbadmin". tng_discovery_ipsubnet where managed = 1 and 
(instance_no = 0 or instance_no is null) and time_stamp < :init_time; 
endif; update "mdbadmin". tng_discovery_ipsubnet set instance_no = 
:instance_no, computer_name = :computer_name where 
discovery_ipsubnet_id = :tid; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'discovery_get_ip
_subnet update of tng_discovery_ipsubnet failed' + ascii(:enumber); 
raise error 60016 :emessage with destination = (session,error_log); 
return -1; endif; endif; insert into "mdbadmin". 
tng_discovery_ipsubnet_tmp (subnet_addr, subnet_mask, gateway1, 
gateway2, computer_name, instance_no ) select subnet_addr, 
subnet_mask, gateway1, gateway2, :computer_name, :instance_no from 
"mdbadmin". tng_discovery_ipsubnet where discovery_ipsubnet_id = :tid;
select iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber
> 0) then emessage = 'discovery_get_ip_subnet insert of tng_discovery_
ipsubnet_tmp failed' + ascii(:enumber); raise error 60017 :emessage 
with destination = (session,error_log); return -1; endif; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_discovery_get_ip_subnet to 
group tngadmin
\p\g
drop procedure tng_discovery_get_lookup
\p\g
create procedure  tng_discovery_get_lookup as declare class_name 
varchar(30); description varchar(30); super_class varchar(30); 
a1gProductType char; add_ipcount char; f_a1supv char; sysobjid 
varchar(128); san varchar(255); emessage char (255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure discovery_get_lookup failed' + ascii(:enumber); 
raise error 60039 :emessage with destination = (session, error_log); 
return -1; endif; select tng_class.name as class_name, tng_class.name 
as description, tng_class.super_class_name as super_class, null as 
a1gProductType, '1' as add_ipcount, '0' as f_a1supv, 
tng_sysobjid.sysobjid ,tng_class_ext.string into :class_name, 
:description, :super_class, :a1gProductType, :add_ipcount, :f_a1supv, 
:sysobjid, :san from ( "mdbadmin". tng_class left join "mdbadmin". 
tng_class_ext on tng_class_ext.name = 'SAN' and tng_class_ext.class_id
= tng_class.class_id), "mdbadmin". tng_sysobjid where 
tng_sysobjid.class_name = tng_class.name; select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0) then emessage
= 'discovery_get_lookup select of tng_class failed'+ ascii(:enumber); 
raise error 60018 :emessage with destination = (session,error_log); 
return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_discovery_get_lookup to 
group tngadmin
\p\g
drop procedure tng_discovery_get_setup_date
\p\g
create procedure  tng_discovery_get_setup_date as declare year int; 
month int; day int; hour int; minute int; second int; emessage 
char(255) not null with default; rcount int; enumber int; begin select
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure discovery_get_setup_date failed' + 
ascii(:enumber); raise error 60038 :emessage with destination = 
(session,error_log); return -1; endif; select date_part('year',
start_time), date_part('month',start_time), date_part('day',
start_time), date_part('hour',start_time), date_part('minute',
start_time), date_part('second',start_time) into :year, :month, :day, 
:hour, :minute, :second from "mdbadmin". tng_discovery_setup; select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'discovery_get_setup_date select of date_part failed' 
+ ascii(:enumber); raise error 60013 :emessage with destination = 
(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_discovery_get_setup_date to 
group tngadmin
\p\g
drop procedure tng_get_class_id
\p\g
create procedure  tng_get_class_id ( key_id int) as declare emessage 
char(255) not null with default; rcount int; enumber int; begin select
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure get_class_id failed' + ascii(:enumber); 
raise error 40001 :emessage with destination = (session,error_log); 
return -1; endif; update "mdbadmin". tng_key_class_id set 
class_id_key=class_id_key + 1; select iirowcount, iierrornumber into 
:rcount, :enumber; if ( :enumber > 0 ) then emessage = 'procedure get_
class_id update of key_class_id failed' + ascii(:enumber); raise error
40023 :emessage with destination = (session, error_log); return -1; 
endif; select class_id_key into :key_id from "mdbadmin". 
tng_key_class_id; end
\p\g
grant execute on procedure "mdbadmin".tng_get_class_id to group 
tngadmin
\p\g
drop procedure tng_get_class_ilp
\p\g
create procedure  tng_get_class_ilp ( class_name varchar(30), hidden 
int1 with null,  propagate_status int1 with null,  address_type int 
with null,  autoarrange_type int with null,  severity int with null,  
posted int1 with null,  alarmset_name varchar(30) with null,  
acknowledge int1 with null,  override_imagelarge varchar(64) with 
null,  override_imagesmall varchar(64) with null,  override_imagedecal
varchar(64) with null,  override_imagetintbool int1 with null,  
override_model varchar(64) with null,  background_image varchar(64) 
with null)  as declare super_classname varchar(30); msg varchar(255) 
not null; prodef_id int; numrows int; emessage char(255) not null with
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'procedure get_class_ilp failed' + ascii(:enumber); raise error 
40004 :emessage with destination=(session,error_log); return -1; 
endif; select count(*) into :numrows from "mdbadmin". tng_class where 
name=:class_name; if (numrows = 0) then :msg='(MSG:90033)The class '+
:class_name+' not exist.'; raise error 90033 :msg; return; endif; 
if(:hidden is not null) then :hidden=null; :prodef_id=null; 
:super_classname=:class_name; while (2>1) do select 
int1(default_value), id into :hidden, :prodef_id from "mdbadmin". 
tng_property_definition where name='hidden' and class_id= (select 
class_id from "mdbadmin". tng_class where name=:super_classname); 
if(:prodef_id is not null) then endloop; endif; select 
super_class_name into :super_classname from "mdbadmin". tng_class 
where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  endloop; endif; endwhile; endif; 
if(:propagate_status is not null) then :propagate_status=null; 
:prodef_id=null; :super_classname=:class_name; while (2>1) do select 
int1(default_value), id into :propagate_status, :prodef_id from 
"mdbadmin". tng_property_definition where name='propagate_status' and 
class_id= (select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then endloop; 
endif; select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname ; if(:super_classname is null or
:super_classname='Class') then  endloop; endif; endwhile; endif; 
if(:address_type is not null) then :address_type=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
int4(default_value), id into :address_type, :prodef_id from "mdbadmin"
. tng_property_definition where name='address_type' and class_id= 
(select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then endloop; 
endif; select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  endloop; endif; endwhile; endif; 
if(:autoarrange_type is not null) then :autoarrange_type=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
int4(default_value), id into :autoarrange_type, :prodef_id from 
"mdbadmin". tng_property_definition where name='autoarrange_type' and 
class_id= (select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then endloop; 
endif; select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  endloop; endif; endwhile; endif; 
if(:severity is not null) then :severity=null; :prodef_id=null; 
:super_classname=:class_name; while(2>1) do select int4(default_value)
,id into :severity, :prodef_id from "mdbadmin". 
tng_property_definition where name='severity' and class_id= (select 
class_id from "mdbadmin". tng_class where name=:super_classname); 
if(:prodef_id is not null) then endloop; endif; select 
super_class_name into :super_classname from "mdbadmin". tng_class 
where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  endloop; endif; endwhile; endif; 
if(:posted is not null) then :posted=null; :prodef_id=null; 
:super_classname=:class_name; while(2>1) do select int1(default_value)
, id into :posted, :prodef_id from "mdbadmin". tng_property_definition
where name='posted' and class_id= (select class_id from "mdbadmin". 
tng_class where name=:super_classname); if(:prodef_id is not null) 
then endloop; endif; select super_class_name into :super_classname 
from "mdbadmin". tng_class where name=:super_classname; 
if(:super_classname is null or :super_classname='Class') then  
endloop; endif; endwhile; endif; if(:acknowledge is not null) then 
:acknowledge=null; :prodef_id=null; :super_classname=:class_name; 
while(2>1) do select int1(default_value), id into :acknowledge, 
:prodef_id from "mdbadmin". tng_property_definition where name='acknow
ledge' and class_id= (select class_id from "mdbadmin". tng_class where
name=:super_classname); if(:prodef_id is not null) then endloop; 
endif; select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  return; endif; endwhile; endif; 
if(:alarmset_name is not null) then :alarmset_name=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
default_value, id into :alarmset_name, :prodef_id from "mdbadmin". 
tng_property_definition where name='alarmset_name' and class_id= 
(select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then return; endif;
select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  endloop; endif; endwhile; endif; 
if(:override_imagelarge is not null) then :override_imagelarge=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
default_value, id into :override_imagelarge, :prodef_id from 
"mdbadmin". tng_property_definition where name='override_imagelarge' 
and class_id= (select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then return; endif;
select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  return; endif; endwhile; endif; 
if(:override_imagesmall is not null) then :override_imagesmall=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
default_value, id into :override_imagesmall, :prodef_id from 
"mdbadmin". tng_property_definition where name='override_imagesmall' 
and class_id= (select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then return; endif;
select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  return; endif; endwhile; endif; 
if(:override_imagedecal is not null) then :override_imagedecal=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
default_value, id into :override_imagedecal, :prodef_id from 
"mdbadmin". tng_property_definition where name='override_imagedecal' 
and class_id= (select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then return; endif;
select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  return; endif; endwhile; endif; 
if(:override_imagetintbool is not null) then 
:override_imagetintbool=null; :prodef_id=null; 
:super_classname=:class_name; while(2>1) do select int1(default_value)
, id into :override_imagetintbool, :prodef_id from "mdbadmin". 
tng_property_definition where name='override_imagetintbool' and 
class_id= (select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then endloop; 
endif; select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  endloop; endif; endwhile; endif; 
if(:override_model is not null) then :override_model=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
default_value, id into :override_model, :prodef_id from "mdbadmin". 
tng_property_definition where name='override_model' and class_id= 
(select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then return; endif;
select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  return; endif; endwhile; endif; 
if(:background_image is not null) then :background_image=null; 
:prodef_id=null; :super_classname=:class_name; while(2>1) do select 
default_value, id into :background_image, :prodef_id from "mdbadmin". 
tng_property_definition where name='background_image' and class_id= 
(select class_id from "mdbadmin". tng_class where 
name=:super_classname); if(:prodef_id is not null) then return; endif;
select super_class_name into :super_classname from "mdbadmin". 
tng_class where name=:super_classname; if(:super_classname is null or 
:super_classname='Class') then  return; endif; endwhile; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_get_class_ilp to group 
tngadmin
\p\g
drop procedure tng_get_discovery_ipsubnet_id
\p\g
create procedure  tng_get_discovery_ipsubnet_id ( key_id int) as 
declare emessage char(255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
(:enumber > 0) then emessage = 'procedure get_discovery_ipsubnet_id fa
iled' + ascii(:enumber); raise error 40002 :emessage with 
destination=(session,error_log); return -1; endif; update "mdbadmin". 
tng_key_discovery_ipsubnet_id set 
discovery_ipsubnet_id_key=discovery_ipsubnet_id_key + 1; select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure get_discovery_ipsubnet_id update of tng_key
_discovery_ipsubnet_id failed' + ascii(:enumber); raise error 40024 
:emessage with destination = (session, error_log); return -1; endif; 
select discovery_ipsubnet_id_key into :key_id from "mdbadmin". 
tng_key_discovery_ipsubnet_id; end
\p\g
grant execute on procedure "mdbadmin".tng_get_discovery_ipsubnet_id to
group tngadmin
\p\g
drop procedure tng_get_id
\p\g
create procedure  tng_get_id ( key_id int) as declare emessage 
char(255) not null with default; rcount int; enumber int; begin select
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'procedure get_id failed' + ascii(:enumber); raise 
error 40003 :emessage with destination=(session,error_log); return -1;
endif; update "mdbadmin". tng_key_id set id_key=id_key + 1; select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure get_id update of key_id failed' + 
ascii(:enumber); raise error 40025 :emessage with destination = 
(session, error_log); return -1; endif; select id_key into :key_id 
from "mdbadmin". tng_key_id; end
\p\g
grant execute on procedure "mdbadmin".tng_get_id to group tngadmin
\p\g
drop procedure tng_get_if_uuid
\p\g
create procedure  tng_get_IF_uuid ( parent_uuid byte(16), ifnum int , 
child_uuid byte(16))  as declare msg varchar(255); status_no int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if ( 
:enumber > 0 ) then emessage = 'procedure get_IF_uuid failed' + 
ascii(:enumber); raise error 50022 :emessage with destination = 
(session,error_log); return -1; endif;  select child_uuid into 
:child_uuid from "mdbadmin". tng_inclusion t1, "mdbadmin". 
tng_ip_interface t2 where t1.child_class='IP_Interface' and 
t1.parent_uuid=:parent_uuid and t2.interface_no=:ifnum and 
t1.child_uuid=t2.uuid; select iirowcount, iierrornumber into :rcount, 
:enumber; if ( :enumber > 0 ) then emessage = 'get_IF_uuid select of t
ng_inclusion failed' + ascii(:enumber); raise error 50003 :emessage 
with destination = (session,error_log); return -1; endif; return; end
\p\g
grant execute on procedure "mdbadmin".tng_get_if_uuid to group 
tngadmin
\p\g
grant execute on procedure "mdbadmin".tng_get_if_uuid to group tnguser
\p\g
drop procedure tng_get_network_class
\p\g
create procedure  tng_get_network_class ( subnet_addr byte(4), 
subnet_mask byte(4), network_class char(1) with null,  
network_class_addr_hex byte(4) with null,  network_class_addr_str 
varchar(15) with null)  as declare subnet_1st_octet int; 
network_addr_only byte(4); emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'procedure get_ne
twork_class failed' + ascii(:enumber); raise error 40005 :emessage 
with destination=(session,error_log); return -1; endif; 
:network_addr_only= bit_and(:subnet_addr, :subnet_mask); 
:subnet_1st_octet=intextract(:network_addr_only,1); 
if(:subnet_1st_octet=0) then  :network_class='R'; return; endif; 
if(:subnet_1st_octet>=1 and :subnet_1st_octet<=126) then 
:network_class='A'; :network_class_addr_hex= bit_and(:subnet_addr, 
X'ff000000'); :network_class_addr_str= 
squeeze(char(intextract(:network_addr_only, 1)));  return; 
elseif(:subnet_1st_octet>=128 and :subnet_1st_octet<=191) then 
:network_class='B'; :network_class_addr_hex= bit_and(:subnet_addr, 
X'ffff0000'); :network_class_addr_str= 
squeeze(char(intextract(:network_addr_only, 1))) + '.' + 
squeeze(char(intextract(:network_addr_only, 2)));  return; 
elseif(:subnet_1st_octet>=192 and :subnet_1st_octet<=223) then 
:network_class='C'; :network_class_addr_hex= bit_and(:subnet_addr, 
X'ffffff00'); :network_class_addr_str= 
squeeze(char(intextract(:network_addr_only, 1))) + '.' + 
squeeze(char(intextract(:network_addr_only, 2))) + '.' + 
squeeze(char(intextract(:network_addr_only, 3)));  return; 
elseif(:subnet_1st_octet>=224 and :subnet_1st_octet<=239) then 
:network_class='D'; return; else :network_class='E'; return; endif; 
end
\p\g
grant execute on procedure "mdbadmin".tng_get_network_class to group 
tngadmin
\p\g
drop procedure tng_get_segment_name
\p\g
create procedure  tng_get_segment_name ( subnet_in_str varchar(16) 
with null, subnet_in_hex byte(4) with null, segment_name varchar(255) 
with null) as declare subnet_name varchar(255); subnet_name_hold 
varchar(255); segment_number int; emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure get_segment_name failed' + ascii(:enumber); 
raise error 50024 :emessage with destination=(session,error_log); 
return -1; endif; if(:subnet_in_str is not null) then select name into
:subnet_name from "mdbadmin". tng_managedobject where class_name = 'IP
_Subnet' and address = :subnet_in_str; else select name into 
:subnet_name from "mdbadmin". tng_managedobject where class_name = 'IP
_Subnet' and ip_address_hex = :subnet_in_hex; endif; select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'get_segment_name select of tng_managedobject failed' 
+ ascii(:enumber); raise error 50005 :emessage with destination = 
(session,error_log); return -1; endif; :subnet_name_hold = 
:subnet_name + ':Segment%'; select count(*) into :segment_number from 
"mdbadmin". tng_managedobject where name like :subnet_name_hold; 
:segment_number = :segment_number + 1; :segment_name = :subnet_name+':
Segment.'+varchar(:segment_number, 3); select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'get_segment_name select of tng_managedobject failed' + 
ascii(:enumber); raise error 50006 :emessage with destination = 
(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_get_segment_name to group 
tngadmin
\p\g
drop procedure tng_get_subnet_if_connect_to
\p\g
create procedure  tng_get_subnet_IF_connect_to ( ip_address_hex 
byte(4), uuid byte(16), ipa_hex byte(4), subnet_mask byte(4) ) as 
declare ip_address_int_1 int; ip_address_int_2 int; ip_address_int_3 
int; ip_address_int_4 int; emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if ( :enumber > 0 ) then emessage = 'procedure get_
subnet_IF_connect_to failed' + ascii(:enumber); raise error 50023 
:emessage with destination = (session,error_log); return -1; endif; 
ip_address_int_1 = intextract(:ip_address_hex, 1); ip_address_int_2 = 
intextract(:ip_address_hex, 2); ip_address_int_3 = 
intextract(:ip_address_hex, 3); ip_address_int_4 = 
intextract(:ip_address_hex, 4); select uuid, ip_address_hex, 
subnet_mask into :uuid, :ipa_hex, :subnet_mask from "mdbadmin". 
tng_managedobject where class_name='IP_Subnet' and 
(intextract(subnet_mask, 4) > 0 and ( ( intextract(ip_address_hex, 4) 
> 0 and ip_address_int_1 >= intextract(ip_address_hex, 1) and 
ip_address_int_2 >= intextract(ip_address_hex, 2) and ip_address_int_3
>= intextract(ip_address_hex, 3) and ip_address_int_4 >= 
intextract(ip_address_hex, 4) and ip_address_int_1 <= 
(intextract(ip_address_hex, 1) + 255 - intextract(subnet_mask, 1)) and
ip_address_int_2 <= (intextract(ip_address_hex, 2) + 255 - 
intextract(subnet_mask, 2)) and ip_address_int_3 <= 
(intextract(ip_address_hex, 3) + 255 - intextract(subnet_mask, 3)) and
ip_address_int_4 <= (intextract(ip_address_hex, 4) + 255 - 
intextract(subnet_mask, 4)) ) or ( intextract(ip_address_hex, 4) = 0 
and ip_address_int_1 >= intextract(ip_address_hex, 1) and 
ip_address_int_2 >= intextract(ip_address_hex, 2) and ip_address_int_3
>= intextract(ip_address_hex, 3) and ip_address_int_4 >= 0 and 
(ip_address_int_1 + 255 - intextract(subnet_mask, 1)) <= 
intextract(ip_address_hex, 1) and (ip_address_int_2 + 255 - 
intextract(subnet_mask, 2)) <= intextract(ip_address_hex, 2) and 
(ip_address_int_3 + 255 - intextract(subnet_mask, 3)) <= 
intextract(ip_address_hex, 3) and ip_address_int_4 <= (255 - 
intextract(subnet_mask, 4)) ) ) or intextract(subnet_mask, 4) = 0 and 
( ( intextract(ip_address_hex, 4) > 0 and ip_address_int_1 >= 
intextract(ip_address_hex, 1) and ip_address_int_2 >= 
intextract(ip_address_hex, 2) and ip_address_int_3 >= 
intextract(ip_address_hex, 3) and ip_address_int_4 >= 
intextract(ip_address_hex, 4) and ip_address_int_1 <= 
(intextract(ip_address_hex, 1) + 255 - intextract(subnet_mask, 1)) and
ip_address_int_2 <= (intextract(ip_address_hex, 2) + 255 - 
intextract(subnet_mask, 2)) and ip_address_int_3 <= 
(intextract(ip_address_hex, 3) + 255 - intextract(subnet_mask, 3)) and
ip_address_int_4 <= (intextract(ip_address_hex, 4) + 255 - 
intextract(subnet_mask, 4)) ) or ( intextract(ip_address_hex, 4) = 0 
and ip_address_int_1 >= intextract(ip_address_hex, 1) and 
ip_address_int_2 >= intextract(ip_address_hex, 2) and ip_address_int_3
>= intextract(ip_address_hex, 3) and ip_address_int_4 >= 0 and 
(ip_address_int_1 + 255 - intextract(subnet_mask, 1)) <= 
intextract(ip_address_hex, 1) and (ip_address_int_2 + 255 - 
intextract(subnet_mask, 2)) <= intextract(ip_address_hex, 2) and 
(ip_address_int_3 + 255 - intextract(subnet_mask, 3)) <= 
intextract(ip_address_hex, 3) and ip_address_int_4 <= 255 ) ) or ( 
bit_and(byte(ip_address_int_1), byte(intextract(subnet_mask, 1))) = 
byte(intextract(ip_address_hex, 1)) and bit_and(byte(ip_address_int_2)
, byte(intextract(subnet_mask, 2))) = byte(intextract(ip_address_hex, 
2)) and bit_and(byte(ip_address_int_3), byte(intextract(subnet_mask, 
3))) = byte(intextract(ip_address_hex, 3)) ) or ( 
intextract(subnet_mask, 3) = 0 and bit_and(byte(ip_address_int_1), 
byte(intextract(subnet_mask, 1))) = byte(intextract(ip_address_hex, 1)
) and bit_and(byte(ip_address_int_2), byte(intextract(subnet_mask, 2))
) = byte(intextract(ip_address_hex, 2)) ) ); select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'get_subnet_IF_connect_to select of tng_managedobject faile
d' + ascii(:enumber); raise error 50004 :emessage with destination = 
(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_get_subnet_if_connect_to to 
group tngadmin
\p\g
drop procedure tng_get_super_class_name
\p\g
create procedure  tng_get_super_class_name ( class_name varchar(30) , 
super_class_name varchar(30))  as declare v_class_name varchar(30); 
msg varchar(255) not null; numrows int; emessage char(255) not null 
with default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure get_super_class_name failed' + ascii(:enumber); 
raise error 40022 :emessage with destination = (session, error_log); 
return -1; endif; select count(*) into :numrows from "mdbadmin". 
tng_class where name=:class_name; if (:numrows = 0) then :msg='The cla
ss name: '+:class_name+ ' is not defined in tng_class table'; raise 
error 0 :msg; select :super_class_name=null; return; endif; 
:super_class_name=:class_name; :v_class_name=:class_name; while (2>1) 
do if (:super_class_name='Router' or :super_class_name='Hub' or 
:super_class_name='Workstation' or :super_class_name='Xterm' or 
:super_class_name='Printers' or :super_class_name='Host' or 
:super_class_name='Server' or :super_class_name='Manager' or 
:super_class_name='Unclassified_TCP' or :super_class_name='Bridge' ) 
then  return; elseif ( :super_class_name='Class') then :msg='The class
 name: '+:class_name+ ' is not derived from class:Hub,Host,'+ 'Worksta
tion,Xterm,Manager,Printers or '+ 'Unclassified_TCP.'; raise error 0 
:msg; :super_class_name=null; return; endif; select 
:super_class_name=super_class_name from "mdbadmin". tng_class where 
:v_class_name=name; :v_class_name=:super_class_name; endwhile; end
\p\g
grant execute on procedure "mdbadmin".tng_get_super_class_name to 
group tngadmin
\p\g
drop procedure tng_get_uuid_classname_by_name
\p\g
create procedure  tng_get_uuid_classname_by_name ( name varchar(255)  
) as declare uuid byte(16); class_name varchar(30); emessage char(255)
not null with default; rcount int; enumber int; begin select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure get_uuid_classname_by_name failed' + 
ascii(:enumber); raise error 50021 :emessage with destination = 
(session,error_log); return -1; endif;  select uuid, class_name into 
:uuid, :class_name from "mdbadmin". tng_managedobject where 
name=:name; select iirowcount, iierrornumber into :rcount, :enumber; 
if ( :enumber > 0 ) then emessage = 'get_uuid_classname_by_name select
 of tng_managedobject failed' + ascii(:enumber); raise error 50002 
:emessage with destination = (session,error_log); return -1; endif; 
return; end
\p\g
grant execute on procedure "mdbadmin".tng_get_uuid_classname_by_name 
to group tngadmin
\p\g
drop procedure tng_iphex2str_nd
\p\g
create procedure  tng_iphex2str_nd( ipaddr_hex byte(4), ipaddr_str 
varchar(15)) as declare emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if ( :enumber > 0 ) then emessage = 'procedure tng_
iphex2str_nd failed' + ascii(:enumber); raise error 60036 :emessage 
with destination = (session,error_log); return -1; endif; if 
(ipaddr_hex is null) then ipaddr_str = null; else ipaddr_str = 
squeeze(char(intextract(ipaddr_hex, 1))) + '.' + 
squeeze(char(intextract(ipaddr_hex, 2))) + '.' + 
squeeze(char(intextract(ipaddr_hex, 3))) + '.' + 
squeeze(char(intextract(ipaddr_hex, 4))); endif; select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure tng_iphex2str_nd  failed' + ascii(:enumber); 
raise error 60033 :emessage with destination = (session,error_log); 
return -1; endif end
\p\g
grant execute on procedure "mdbadmin".tng_iphex2str_nd to group 
tngadmin
\p\g
drop procedure tng_ipstr2iphex
\p\g
create procedure  tng_ipstr2iphex ( ipaddr_str char(15), ipaddr_hex 
byte(4))  as declare ipaddr float; ipbyte int; temp char(25); ch 
char(1); ipaddr_int int; emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if ( :enumber > 0 ) then emessage = 'procedure ipst
r2iphex failed' + ascii(:enumber); raise error 50020 :emessage with 
destination = (session,error_log); return -1; endif; if (:ipaddr_str 
is NULL) then :ipaddr_hex = NULL; return; endif; ipaddr_hex = 
ii_ipaddr(ipaddr_str); select iirowcount, iierrornumber into :rcount, 
:enumber; if ( :enumber > 0 ) then emessage = 'procedure ipstr2iphex f
ailed' + ascii(:enumber); raise error 50001 :emessage with destination
= (session,error_log); return -1; endif end
\p\g
grant execute on procedure "mdbadmin".tng_ipstr2iphex to group 
tngadmin
\p\g
drop procedure tng_is_attr_same_as_superclass
\p\g
create procedure  tng_is_attr_same_as_superclass ( classname 
varchar(30), name varchar(255), datatype varchar(30), length int with 
null, string varchar(255) with null, integer int with null, tinyint 
int1 with null, rc int)  as declare super_class_id int; 
super_classname varchar(30); string_value varchar(255); integer_value 
int; tinyint_value int1; msg varchar(255) not null; numrows int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if 
(:enumber > 0) then emessage = 'procedure is_attr_same_as_superclass f
ailed' + ascii(:enumber); raise error 40007 :emessage with 
destination=(session,error_log); return -1; endif; if( 
uppercase(:classname)='CLASS' OR uppercase(:classname)='TNGROOT') then
:rc=0; return; endif; while (2>1) do :super_classname = null; 
:super_class_id=null; select super_class_name, super_class_id into 
:super_classname, :super_class_id from "mdbadmin". tng_class where 
name=:classname; if(:super_classname is null) then :msg = 'MSG(90019):
 Bad :classname pass '+ 'in is_attr_same_as_superclass procedure.'; 
raise error 90019 :msg; return; endif; if( uppercase(:super_classname)
='TNGROOT' ) then  :rc=0; return; endif; select count(*) into :numrows
from "mdbadmin". tng_class_ext where name=:name and 
class_id=:super_class_id; if (numrows > 0) then if(:string is not 
null) then select string into :string_value from "mdbadmin". 
tng_class_ext where name=:name and class_id=:super_class_id; 
if(:string_value=:string) then  :rc=1; return; else  :rc=0; return; 
endif; endif;  endif; :classname=:super_classname; endwhile; end
\p\g
grant execute on procedure "mdbadmin".tng_is_attr_same_as_superclass 
to group tngadmin
\p\g
drop procedure tng_is_man_obj_exist_w_sameip
\p\g
create procedure  tng_is_man_obj_exist_w_sameip ( ipaddr_str 
varchar(16) with null, ipaddr_hex byte(4) with null) as declare 
obj_count int not null; emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if ( :enumber > 0 ) then emessage = 'procedure is_m
an_obj_exist_w_sameip failed' + ascii(:enumber); raise error 50025 
:emessage with destination = (session,error_log); return -1; endif; 
if(:ipaddr_str is not null) then select count(*) into :obj_count from 
"mdbadmin". tng_managedobject where address=:ipaddr_str; else select 
count(*) into :obj_count from "mdbadmin". tng_managedobject where 
ip_address_hex=:ipaddr_hex; endif; select iirowcount, iierrornumber 
into :rcount, :enumber; if ( :enumber > 0 ) then emessage = 'is_man_ob
j_exist_w_sameip select of tng_managedobject failed' + ascii(:enumber)
; raise error 50007 :emessage with destination = (session,error_log); 
return -1; endif; return :obj_count; end
\p\g
grant execute on procedure "mdbadmin".tng_is_man_obj_exist_w_sameip to
group tngadmin
\p\g
drop procedure tng_is_obj_exist_class_name_ip
\p\g
create procedure  tng_is_obj_exist_class_name_ip ( class_name 
varchar(30), name varchar(255) with null, address varchar(255) with 
null) as declare obj_count int not null; emessage char(255) not null 
with default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure is_obj_exist_class_name_ip failed' + 
ascii(:enumber); raise error 50026 :emessage with destination = 
(session,error_log); return -1; endif; if (:name is not null and 
:address is not null) then select count(*) into :obj_count from 
"mdbadmin". tng_managedobject where address=:address and name=:name 
and class_name=:class_name; return :obj_count; endif; if (:name is not
null and :address is null) then select count(*) into :obj_count from 
"mdbadmin". tng_managedobject where name=:name and 
class_name=:class_name; return :obj_count; endif; if (:name is null 
and :address is not null) then select count(*) into :obj_count from 
"mdbadmin". tng_managedobject where address=:address and 
class_name=:class_name; return :obj_count; endif; select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'is_obj_exist_class_name_ip select of tng_managedobject fai
led' + ascii(:enumber); raise error 50008 :emessage with destination =
(session,error_log); return -1; endif; end
\p\g
grant execute on procedure "mdbadmin".tng_is_obj_exist_class_name_ip 
to group tngadmin
\p\g
drop procedure tng_is_obj_exist_w_name_diff_ip
\p\g
create procedure  tng_is_obj_exist_w_name_diff_ip ( class_name 
varchar(30), name varchar(255) with null, address varchar(255) with 
null) as declare obj_count int not null; emessage char(255) not null 
with default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure is_obj_exist_w_name_diff_ip failed' + 
ascii(:enumber); raise error 50027 :emessage with destination = 
(session,error_log); return -1; endif; select count(*) into :obj_count
from "mdbadmin". tng_managedobject where class_name=:class_name and 
name =:name and address<>:address; select iirowcount, iierrornumber 
into :rcount, :enumber; if ( :enumber > 0 ) then emessage = 'is_obj_ex
ist_w_name_diff_ip select of tng_managedobject failed' + 
ascii(:enumber); raise error 50009 :emessage with destination = 
(session,error_log); return -1; endif; return :obj_count; end
\p\g
grant execute on procedure "mdbadmin".tng_is_obj_exist_w_name_diff_ip 
to group tngadmin
\p\g
grant execute on procedure "mdbadmin".tng_is_obj_exist_w_name_diff_ip 
to group tnguser
\p\g
drop procedure tng_is_same_property
\p\g
create procedure  tng_is_same_property ( classname varchar(30), name 
varchar(255), datatype varchar(30), length int , is_key int1, required
int1 with null, instance_storage varchar(30) with null, storage_field 
varchar(30) with null, default_value varchar(255) with null, rc int)  
as declare super_class_id int; super_classname varchar(30); 
string_value varchar(255); error_msg varchar(255) not null; v_datatype
varchar(30); v_length int; v_is_key int1; v_required int1; 
v_instance_storage varchar(30); v_storage_field varchar(30); 
v_default_value varchar(255); v_classname varchar(30); numrows int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if 
(:enumber > 0) then emessage = 'procedure is_same_property failed' + 
ascii(:enumber); raise error 40008 :emessage with 
destination=(session,error_log); return -1; endif; 
:v_classname=:classname; while (2>1) do :super_classname = null; 
:super_class_id=null; select :super_classname = t1.super_class_name, 
:super_class_id=t1.super_class_id from "mdbadmin". tng_class t1 where 
t1.name=:classname; if(:super_classname is null) then :error_msg='MSG(
90019): Bad classname: '+:classname+ ' pass in is_attr_same_as_supercl
ass procedure.'; raise error 90019 :error_msg; return; endif; if( 
uppercase(:super_classname)='CLASS' ) then  :rc=0; return; endif; 
select count(*) into :numrows from "mdbadmin". tng_property_definition
where name=:name and class_id=:super_class_id; if (:numrows > 0) then 
select datatype, length, is_key, required, instance_storage, 
storage_field, default_value into :v_datatype, :v_length, :v_is_key, 
:v_required, :v_instance_storage, :v_storage_field, :v_default_value 
from "mdbadmin". tng_property_definition where name=:name and 
class_id=:super_class_id; if (:v_datatype != :datatype or :v_length !=
:length or ((:v_is_key=1) and (:is_key=0)) ) then      if ((:datatype 
!= 'tinyint') or ((:length != 1) and (:length != 4))) then 
:error_msg='MSG(90020): Can''t change super '+ 'class: '+
:super_classname+ '''s property name:, '+:name+ ' s''datatype:'+
:datatype+ ' or length: '; :error_msg=:error_msg+varchar(:length)+ ' o
r is_key:'+ varchar(:is_key)+ ', when add property for class:'+: 
v_classname; raise error 90020 :error_msg; :rc=1; return; endif; 
endif; if (:v_is_key != :is_key) then  :rc=0; return; endif; if 
((:v_required is null) or (:required is null)) then if ((:v_required 
is not null) or (:required is not null)) then  :rc=0; return; endif; 
elseif( :v_required != :required) then :rc=0; return; endif; if( 
(:v_instance_storage is null) or (:instance_storage is null)) then if(
(:v_instance_storage is not null) or (:instance_storage is not null)) 
then  :rc=0; return; endif; elseif( :v_instance_storage != 
:instance_storage) then :rc=0; return; endif; if( (:v_storage_field is
null) or (:storage_field is null)) then if( (:v_storage_field is not 
null) or (:storage_field is not null)) then  :rc=0; return; endif; 
elseif( :v_storage_field != :storage_field) then :rc=0; return; endif;
if( (:v_default_value is null) or (:default_value is null)) then if( 
(:v_default_value is not null) or (:default_value is not null)) then  
:rc=0; return; endif; elseif( :v_default_value != :default_value) then
:rc=0; return; endif; :rc=1; return; endif; 
:classname=:super_classname; endwhile; end
\p\g
grant execute on procedure "mdbadmin".tng_is_same_property to group 
tngadmin
\p\g
drop procedure tng_isdiffclssameipnameexist
\p\g
create procedure  tng_IsDiffClsSameIpNameExist ( class_name 
varchar(30), dsc_name varchar(255), ipaddr_str varchar(16)) as declare
obj_count int not null;  emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber; if ( :enumber > 0 ) then emessage = 'procedure IsDi
ffClsSameIpNameExist failed' + ascii(:enumber); raise error 50031 
:emessage with destination = (session,error_log); return -1; endif; 
select count(*) into :obj_count from "mdbadmin". tng_managedobject 
where class_name !=:class_name and name = :dsc_name and 
address=:ipaddr_str; select iirowcount, iierrornumber into :rcount, 
:enumber; if ( :enumber > 0 ) then emessage = 'IsDiffClsSameIpNameExis
t select of tng_managedobject failed' + ascii(:enumber); raise error 
50018 :emessage with destination = (session,error_log); endif; return 
:obj_count; end
\p\g
grant execute on procedure "mdbadmin".tng_isdiffclssameipnameexist to 
group tngadmin
\p\g
drop procedure tng_log_change_hist
\p\g
create procedure  tng_log_change_hist ( v_operation char(1), 
v_class_name varchar(30), v_uuid byte(16)) as declare sequence_no int;
max_seq_no int; emessage char(255) not null with default; rcount int; 
enumber int; user_name varchar(30); begin select iirowcount, 
iierrornumber into :rcount, :enumber; select dbmsinfo('username') into
:user_name ; if ( :enumber > 0 ) then emessage = 'procedure tng_log_ch
ange_hist failed' + ascii(:enumber); raise error 70066 :emessage with 
destination = (session,error_log); return -1; endif; update "mdbadmin"
. tng_key_change_hist set sequence_no_key=sequence_no_key+1; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'tng_log_change_hist update of tng_key_change_hist fai
led' + ascii(:enumber); raise error 70001 :emessage with destination =
(session,error_log); return -1; endif; select 
:sequence_no=sequence_no_key, :max_seq_no=min_seq_no from "mdbadmin". 
tng_key_change_hist; insert into "mdbadmin". tng_change_history ( 
sequence_no, operation, class_name, object_id1, portnum1, portnum2, 
timestamp,user_name ) values (:sequence_no, :v_operation, 
:v_class_name, :v_uuid, 0, 0, date('now'),:user_name ); select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'tng_log_change_hist insert of tng_change_history fail
ed' + ascii(:enumber); raise error 70002 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'tng_log_change_hist insert of tng_change_history zero rows'; raise 
error 70002 :emessage with destination = (session,error_log); return 
-1; endif;  return; end
\p\g
drop procedure tng_log_status_hist
\p\g
create procedure  tng_log_status_hist ( v_class_name varchar(30), 
v_uuid byte(16), v_status_no int, v_severity int) as declare 
sequence_no int; min_seq_no int; emessage char(255) not null with 
default; rcount int; enumber int; user_name varchar(30); begin select 
iirowcount, iierrornumber into :rcount, :enumber;  select dbmsinfo('us
ername') into :user_name; if ( :enumber > 0 ) then emessage = 'procedu
re log_status_hist failed' + ascii(:enumber); raise error 70067 
:emessage with destination = (session,error_log); return -1; endif; 
update "mdbadmin". tng_key_status_hist set 
sequence_no_key=sequence_no_key+1; select iirowcount, iierrornumber 
into :rcount, :enumber; if (:enumber > 0) then emessage = 'log_status_
hist update of tng_key_status_hist failed' + ascii(:enumber); raise 
error 70004 :emessage with destination = (session,error_log); return 
-1; endif; select :sequence_no=sequence_no_key, :min_seq_no=min_seq_no
from "mdbadmin". tng_key_status_hist; insert into "mdbadmin". 
tng_status_history( class_name, record_uuid, status_no, severity, 
timestamp, sequence_no,user_name) values (:v_class_name, :v_uuid, 
:v_status_no, :v_severity, date('now'), :sequence_no,:user_name); 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'log_status_hist insert of tng_status_history fai
led' + ascii(:enumber); raise error 70005 :emessage with destination =
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'log_status_hist insert of tng_status_history zero rows'; raise error 
70005 :emessage with destination = (session,error_log); return -1; 
endif;  update "mdbadmin". tng_key_status_hist set min_seq_no = 
:min_seq_no+5000; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'log_status_hist update of
 tng_status_history failed' + ascii(:enumber); raise error 70007 
:emessage with destination = (session,error_log); return -1; endif; 
return; end
\p\g
drop procedure tng_manag_all_discovery_ipsubnet
\p\g
create procedure  tng_manag_all_discovery_ipsubnet( name char(20)) as 
declare emessage char(255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
( :enumber > 0 ) then emessage = 'procedure manage_all_discovery_ipsub
net failed' + ascii(:enumber); raise error 60042 :emessage with 
destination = (session, error_log); return -1; endif; if (name = '0.0.
0.0') then update "mdbadmin". tng_discovery_ipsubnet set managed = 1, 
managed_str = 'Yes'; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'manage_all_discovery_ipsu
bnet update of tng_discovery_ipsubnet failed' + ascii(:enumber); raise
error 60021 :emessage with destination = (session,error_log); return 
-1; endif; elseif (name = 'filtered') then update "mdbadmin". 
tng_discovery_ipsubnet set managed = 1, managed_str = 'Yes' where 
managed = 3; select iirowcount, iierrornumber into :rcount, :enumber; 
if (:enumber > 0) then emessage = 'manage_all_discovery_ipsubnet updat
e of tng_discovery_ipsubnet failed' + ascii(:enumber); raise error 
60022 :emessage with destination = (session,error_log); return -1; 
endif; else update "mdbadmin". tng_discovery_ipsubnet set managed = 1,
managed_str = 'Yes' where subnet_addr_str = :name; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'manage_all_discovery_ipsubnet update of tng_discovery_ipsubnet fail
ed' + ascii(:enumber); raise error 60023 :emessage with destination = 
(session,error_log); return -1; endif; endif; return; end
\p\g
grant execute on procedure "mdbadmin".tng_manag_all_discovery_ipsubnet
to group tngadmin
\p\g
drop procedure tng_senderror
\p\g
create procedure  tng_senderror ( errno int not null) as declare str 
varchar(255) not null; begin   :str = 'MSG:('+varchar(:errno)+ ') Send
error:  An unknown error has occurred.'; raise error :errno :str; end
\p\g
grant execute on procedure "mdbadmin".tng_senderror to group tngadmin
\p\g
drop procedure tng_setup_status
\p\g
create procedure  tng_setup_status ( bNeedQueryStatus int with null, 
dsc_name varchar(255), ipaddr_str varchar(16) with null, ipaddr_hex 
byte(4) with null, macaddr varchar(15), class_name varchar(30), 
bIpInDHCPRange int not null with default, bDelUncls int not null with 
default, iDHCPStatus int not null with default ) as declare msg 
varchar(255); old_name varchar(255); old_ipaddr_hex byte(4); 
old_ipaddr_str varchar(16); old_mac varchar(15); old_class_name 
varchar(30); upper_mac varchar(30); status_no int not null;  emessage 
char(255) not null with default; rcount int; enumber int; begin select
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure setup_status failed' + ascii(:enumber); 
raise error 50029 :emessage with destination = (session,error_log); 
return -1; endif; if (:bNeedQueryStatus is null) then 
:bNeedQueryStatus = 1; endif; if (:bIpInDHCPRange <> 0 and :bDelUncls 
= 0) then update "mdbadmin". tng_managedobject set 
status_no=:iDHCPStatus, address_type=2 where address=:ipaddr_str and 
status_no<>:iDHCPStatus; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'setup_status upd
ate of tng_managedobject failed' + ascii(:enumber); raise error 50012 
:emessage with destination = (session,error_log); return -1; endif; 
elseif (:bIpInDHCPRange <> 0 and :bDelUncls <> 0) then update 
"mdbadmin". tng_managedobject set status_no=:iDHCPStatus, 
address_type=2 where class_name<>'Unclassified_TCP' and 
address=:ipaddr_str and status_no<>:iDHCPStatus; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'setup_status update of tng_managedobject failed' + ascii(:enumber);
raise error 50013 :emessage with destination = (session,error_log); 
return -1; endif; endif; if (:bNeedQueryStatus <> 0) then 
:upper_mac=uppercase(:macaddr); :status_no=0; :old_name=null; 
:old_ipaddr_hex=null; :old_ipaddr_str=null; :old_class_name=null; 
:old_mac=null; if (:ipaddr_str is not null) then   select name, 
address, class_name, uppercase(mac_address) into :old_name,
:old_ipaddr_str,:old_class_name,:old_mac from "mdbadmin". 
tng_managedobject where class_name!='Unclassified_TCP' and 
address_type <=2 and address=:ipaddr_str; if (:iirowcount = 0) then 
select name, address, class_name, uppercase(mac_address) into 
:old_name,:old_ipaddr_str,:old_class_name,:old_mac from "mdbadmin". 
tng_managedobject where class_name!='Unclassified_TCP' and 
address_type <=2 and name=:dsc_name; if (:iirowcount = 0) then select 
name, address, class_name, uppercase(mac_address) into :old_name,
:old_ipaddr_str,:old_class_name,:old_mac from "mdbadmin". 
tng_managedobject where class_name!='Unclassified_TCP' and 
address_type <=2 and uppercase(mac_address)=:upper_mac; endif; endif; 
else select name, ip_address_hex, class_name, uppercase(mac_address) 
into :old_name, :old_ipaddr_hex, :old_class_name, :old_mac from 
"mdbadmin". tng_managedobject where class_name!='Unclassified_TCP' and
address_type <= 2 and (name=:dsc_name or ip_address_hex=:ipaddr_hex or
uppercase(mac_address)=:upper_mac); endif;  if (:iirowcount = 0) then 
return 0; endif;  if (:ipaddr_str is null) then if (:old_ipaddr_hex !=
:ipaddr_hex and :old_name = :dsc_name) then :status_no = 21; endif; if
(:old_ipaddr_hex != :ipaddr_hex and :old_mac = :upper_mac and 
:upper_mac != '000000000000') then :status_no = 14; endif; if 
(:old_class_name != :class_name and :old_mac = :upper_mac and 
:upper_mac != '000000000000') then :status_no = 15; endif; if 
(:old_class_name != :class_name and :old_ipaddr_hex = :ipaddr_hex) 
then :status_no = 16; endif; else if (:old_ipaddr_str != :ipaddr_str 
and :old_name = :dsc_name) then :status_no = 21; endif; if 
(:old_ipaddr_str != :ipaddr_str and :old_mac = :upper_mac and 
:upper_mac != '000000000000' ) then :status_no = 14; endif; if 
(:old_class_name != :class_name and :old_mac = :upper_mac and 
:upper_mac != '000000000000' ) then :status_no = 15; endif; if 
(:old_class_name != :class_name and :old_ipaddr_str = :ipaddr_str) 
then :status_no = 16; endif; endif; return :status_no; else return 0; 
endif; end
\p\g
grant execute on procedure "mdbadmin".tng_setup_status to group 
tngadmin
\p\g
drop procedure tng_td_inclusion
\p\g
create procedure  tng_td_inclusion ( uuid_old byte(16), 
parent_uuid_old byte(16), child_uuid_old byte(16), 
parent_sequence_no_old int, child_sequence_no_old int ) as declare 
sequence_no int; min_seq_no int; emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure td_inclusion failed' + ascii(:enumber); raise 
error 70080 :emessage with destination = (session,error_log); return 
-1; endif; update "mdbadmin". tng_key_change_hist set 
sequence_no_key=sequence_no_key+1; select iirowcount, iierrornumber 
into :rcount, :enumber; if (:enumber > 0) then emessage = 'td_inclusio
n update of tng_key_change_hist failed' + ascii(:enumber); raise error
70040 :emessage with destination = (session,error_log); return -1; 
elseif ( :rcount = 0 ) then emessage = 'td_inclusion update of tng_key
_change_hist zero rows'; raise error 70040 :emessage with destination 
= (session,error_log); return -1; endif; select 
:sequence_no=sequence_no_key, :min_seq_no=min_seq_no from "mdbadmin". 
tng_key_change_hist; insert into "mdbadmin". tng_change_history 
(operation, class_name, object_id1, portnum1, object_id2, portnum2, 
object_id3, timestamp, sequence_no) values ('d', 'Inclusion', 
:uuid_old, :child_sequence_no_old, :child_uuid_old, 
:parent_sequence_no_old, :parent_uuid_old, date('now'), :sequence_no);
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'td_inclusion insert of tng_change_history failed
' + ascii(:enumber); raise error 70041 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'td_inclusion insert of tng_change_history zero rows'; raise error 
70041 :emessage with destination = (session,error_log); return -1; 
endif; if (:sequence_no >= 10000+:min_seq_no) then  delete from 
"mdbadmin". tng_change_history where sequence_no < :min_seq_no + 500; 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'td_inclusion delete of tng_change_history failed
' + ascii(:enumber); raise error 70042 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'td_inclusion delete of tng_change_history zero rows'; raise error 
70042 :emessage with destination = (session,error_log); return -1; 
endif; update "mdbadmin". tng_key_change_hist set min_seq_no = 
:min_seq_no+500; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'td_inclusion update of tn
g_key_change_hist failed' + ascii(:enumber); raise error 70043 
:emessage with destination = (session,error_log); return -1; elseif ( 
:rcount = 0 ) then emessage = 'td_inclusion update of tng_key_change_h
ist zero rows'; raise error 70043 :emessage with destination = 
(session,error_log); return -1; endif; endif; return; end
\p\g
drop procedure tng_td_jii_inclusion
\p\g
create procedure  tng_td_jii_inclusion( uuid byte ( 16 ), parent_uuid 
byte ( 16 ), parent_sequence_no int) as declare sequence_no int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if ( 
:enumber > 0 ) then emessage = 'procedure td_jii_inclusion failed' + 
ascii(:enumber); raise error 80083 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_key_change_hist set sequence_no_key=sequence_no_key+1; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'td_jii_inclusion update of tng_key_change_hist failed
' + ascii(:enumber); raise error 70056 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'td_jii_inclusion update of tng_key_change_hist zero rows'; raise 
error 70056 :emessage with destination = (session,error_log); return 
-1; endif; select :sequence_no=sequence_no_key from "mdbadmin". 
tng_key_change_hist; insert into "mdbadmin". tng_change_history ( 
sequence_no,operation, class_name, object_id1, portnum1, object_id2, 
portnum2, timestamp ) values ( :sequence_no,'d', 'Jii_Inclusion', 
:uuid, 0, :parent_uuid, :parent_sequence_no, date('now') ); select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'td_jii_inclusion insert of tng_change_history failed'
+ ascii(:enumber); raise error 70061 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'td_jii_inclusion insert of tng_change_history zero rows'; raise error
70061 :emessage with destination = (session,error_log); return -1; 
endif; return end
\p\g
drop procedure tng_td_link
\p\g
create procedure  tng_td_link ( class_name_old varchar(30), uuid_old 
byte(16), source_port_old int, source_uuid_old byte(16), dest_port_old
int, dest_uuid_old byte(16), source_seq_old int, dest_seq_old int, 
implied_new int1 ) as declare sequence_no int; min_seq_no int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if ( 
:enumber > 0 ) then emessage = 'procedure td_link failed' + 
ascii(:enumber); raise error 70074 :emessage with destination = 
(session,error_log); return -1; endif;  update "mdbadmin". 
tng_key_change_hist set sequence_no_key=sequence_no_key+1; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'td_link update of tng_key_change_hist failed' + 
ascii(:enumber); raise error 70024 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'td_link update of tng_key_change_hist zero rows'; raise error 70024 
:emessage with destination = (session,error_log); return -1; endif; 
select :sequence_no=sequence_no_key, :min_seq_no=min_seq_no from 
"mdbadmin". tng_key_change_hist; insert into "mdbadmin". 
tng_change_history (operation, class_name, object_id1, portnum1, 
object_id2, portnum2, object_id3, timestamp, source_seq, dest_seq, 
sequence_no) values ('d', :class_name_old, :uuid_old, 
:source_port_old, :source_uuid_old, :dest_port_old, :dest_uuid_old, 
date('now'), :source_seq_old, :dest_seq_old, :sequence_no); select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'td_link insert of tng_change_history failed' + 
ascii(:enumber); raise error 70025 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'td_link insert of tng_change_history zero rows'; raise error 70025 
:emessage with destination = (session,error_log); return -1; endif; if
(:sequence_no >= 10000+:min_seq_no) then  delete from "mdbadmin". 
tng_change_history where sequence_no < :min_seq_no + 500; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'td_link delete of tng_change_history failed' + 
ascii(:enumber); raise error 70026 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'td_link delete of tng_change_history zero rows'; raise error 70026 
:emessage with destination = (session,error_log); return -1; endif; 
update "mdbadmin". tng_key_change_hist set min_seq_no = :min_seq_no+
500; select iirowcount, iierrornumber into :rcount, :enumber; if 
(:enumber > 0) then emessage = 'td_link update of tng_key_change_hist 
failed' + ascii(:enumber); raise error 70027 :emessage with 
destination = (session,error_log); return -1; elseif (:rcount = 0 ) 
then emessage = 'td_link update of tng_key_change_hist zero rows'; 
raise error 70026 :emessage with destination = (session,error_log); 
return -1; endif; endif;  if (implied_new = 0) then delete from 
"mdbadmin". tng_link where parent_link = uuid_old; endif; return; end
\p\g
drop procedure tng_td_managedobject
\p\g
create procedure  tng_td_managedobject ( class_name_old varchar(30), 
uuid_old byte(16)) as declare emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure td_managedobject failed' + ascii(:enumber); 
raise error 70072 :emessage with destination = (session,error_log); 
return -1; endif; execute procedure "mdbadmin". 
tng_log_change_hist(v_operation = 'd', v_class_name = :class_name_old,
v_uuid = :uuid_old);  delete from "mdbadmin". tng_link where uuid = 
(select a.uuid from "mdbadmin". tng_link a, "mdbadmin". tng_inclusion 
b where (a.source_uuid = b.child_uuid and b.parent_uuid = :uuid_old 
and a.source_seq = b.child_sequence_no)); select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'td_managedobject delete from tng_link table failed' + 
ascii(:enumber); raise error 70019 :emessage with destination = 
(session,error_log); return -1; endif; delete from "mdbadmin". 
tng_link where uuid = (select a.uuid from "mdbadmin". tng_link a, 
"mdbadmin". tng_inclusion b where (a.dest_uuid = b.child_uuid and 
b.parent_uuid = :uuid_old and a.dest_seq =b.child_sequence_no)); 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'td_managedobject delete from tng_link table fail
ed' + ascii(:enumber); raise error 70019 :emessage with destination = 
(session,error_log); return -1; endif;              delete from 
"mdbadmin". tng_inclusion where parent_uuid=:uuid_old; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'td_managedobject delete of tng_inclusion failed' + 
ascii(:enumber); raise error 70019 :emessage with destination = 
(session,error_log); return -1; endif; delete from "mdbadmin". 
tng_inclusion where child_uuid=:uuid_old; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'td_managedobject delete of tng_inclusion failed' + ascii(:enumber);
raise error 70020 :emessage with destination = (session,error_log); 
return -1; endif; delete from "mdbadmin". tng_link where 
source_uuid=:uuid_old; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'td_managedobject delete o
f tng_link failed' + ascii(:enumber); raise error 70021 :emessage with
destination = (session,error_log); return -1; endif; delete from 
"mdbadmin". tng_link where dest_uuid=:uuid_old; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'td_managedobject delete of tng_link failed' + ascii(:enumber); 
raise error 70022 :emessage with destination = (session,error_log); 
return -1; endif; delete from "mdbadmin". tng_link where 
common_ancestor_uuid= :uuid_old; select iirowcount, iierrornumber into
:rcount, :enumber; if (:enumber > 0) then emessage = 'td_managedobject
 delete of tng_link failed' + ascii(:enumber); raise error 70023 
:emessage with destination = (session,error_log); return -1; endif; 
return; end
\p\g
drop procedure tng_ti_class_prop
\p\g
create procedure  tng_ti_class_prop( v_class_id int) as declare 
class_name varchar(30); begin select name into :class_name from 
"mdbadmin". tng_class where class_id=:v_class_id; execute procedure 
"mdbadmin". tng_log_change_hist(v_operation = 'I', v_class_name = 
:class_name, v_uuid = '0'); end
\p\g
drop procedure tng_ti_inclusion
\p\g
create procedure  tng_ti_inclusion ( uuid_new byte(16), child_uuid_new
byte(16), child_sequence_no_new int ) as declare max_child_sequence_no
int; sequence_no int; emessage char(255) not null with default; rcount
int; enumber int; begin select iirowcount, iierrornumber into :rcount,
:enumber; if ( :enumber > 0 ) then emessage = 'procedure ti_inclusion 
failed' + ascii(iierrornumber); raise error 70079 :emessage with 
destination = (session,error_log); return -1; endif; if (uuid_new is 
not null) then execute procedure "mdbadmin". 
tng_log_change_hist(v_operation = 'i', v_class_name = 'Inclusion', 
v_uuid = uuid_new); if((:child_sequence_no_new is null or 
:child_sequence_no_new=0) and :child_uuid_new is not null) then  
:child_sequence_no_new = null;  select child_sequence_no into 
:child_sequence_no_new from "mdbadmin". tng_inclusion where 
child_uuid=:child_uuid_new and uuid<>:uuid_new and child_sequence_no =
0; select max(child_sequence_no) into :max_child_sequence_no from 
"mdbadmin". tng_inclusion where child_uuid=:child_uuid_new and 
uuid<>:uuid_new; if(:max_child_sequence_no is null or 
:child_sequence_no_new is null) then :max_child_sequence_no=0; else 
:max_child_sequence_no=:max_child_sequence_no+1; endif; update 
"mdbadmin". tng_inclusion set child_sequence_no=:max_child_sequence_no
where uuid=:uuid_new; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'ti_inclusion update of tn
g_inclusion failed' + ascii(:enumber); raise error 70039 :emessage 
with destination = (session,error_log); return -1; endif; endif; 
endif; return; end
\p\g
drop procedure tng_ti_jii_inclusion
\p\g
create procedure  tng_ti_jii_inclusion( uuid byte ( 16 ), parent_uuid 
byte ( 16 ), parent_sequence_no int) as declare sequence_no int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if ( 
:enumber > 0 ) then emessage = 'procedure ti_jii_inclusion failed' + 
ascii(:enumber); raise error 70082 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_key_change_hist set sequence_no_key=sequence_no_key+1; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'ti_jii_inclusion update of tng_key_change_hist failed
' + ascii(:enumber); raise error 70054 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'ti_jii_inclusion update of tng_key_change_hist zero rows'; raise 
error 70054 :emessage with destination = (session,error_log); return 
-1; endif; select :sequence_no=sequence_no_key from "mdbadmin". 
tng_key_change_hist; insert into "mdbadmin". tng_change_history ( 
sequence_no,operation, class_name, object_id1, portnum1, object_id2, 
portnum2, timestamp ) values ( :sequence_no,'i', 'Jii_Inclusion', 
:uuid, 0, :parent_uuid, :parent_sequence_no, date('now') ); return end
\p\g
drop procedure tng_ti_link
\p\g
create procedure  tng_ti_link ( class_name_new varchar(30), uuid_new 
byte(16) ) as declare emessage char(255) not null with default; rcount
int; enumber int; begin select iirowcount, iierrornumber into :rcount,
:enumber; if ( :enumber > 0 ) then emessage = 'procedure ti_link faile
d' + ascii(:enumber); raise error 70073 :emessage with destination = 
(session,error_log); return -1; endif; execute procedure "mdbadmin". 
tng_log_change_hist(v_operation = 'i', v_class_name = :class_name_new,
v_uuid = :uuid_new); return; end
\p\g
drop procedure tng_ti_managedobject
\p\g
create procedure  tng_ti_managedobject ( class_name_new varchar(30), 
uuid_new byte(16), v_weight int1, v_severity int1, v_prop_sev int1) as
declare v_weighted_sev int; v_max_sev int; emessage char(255) not null
with default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure ti_managedobject failed' + ascii(:enumber); 
raise error 70071 :emessage with destination = (session,error_log); 
return -1; endif; execute procedure "mdbadmin". 
tng_log_change_hist(v_operation = 'i', v_class_name = :class_name_new,
v_uuid = :uuid_new); v_weighted_sev = v_weight * v_severity; 
if(:v_severity > :v_prop_sev) then v_max_sev = v_severity; else 
v_max_sev = v_prop_sev; endif; update "mdbadmin". tng_managedobject 
set weighted_severity = :v_weighted_sev,Max_Sev = :v_max_sev where 
uuid = :uuid_new; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'ti_managedobject update o
f tng_managedobject failed' + ascii(:enumber); raise error 70086 
:emessage with destination = (session,error_log); return -1; elseif ( 
:rcount = 0 ) then emessage = 'ti_managedobject update of tng_managedo
bject zero rows'; raise error 70086 :emessage with destination = 
(session,error_log); return -1; endif; return; end
\p\g
drop procedure tng_tu_class_prop
\p\g
create procedure  tng_tu_class_prop( v_class_id int) as declare 
class_name varchar(30); begin select name into :class_name from 
"mdbadmin". tng_class where class_id=:v_class_id; execute procedure 
"mdbadmin". tng_log_change_hist(v_operation = 'U', v_class_name = 
:class_name, v_uuid = '0'); end
\p\g
drop procedure tng_tu_inclusion
\p\g
create procedure  tng_tu_inclusion ( uuid_old byte(16), uuid_new 
byte(16), parent_class_old varchar(30), parent_class_new varchar(30), 
parent_uuid_old byte(16), parent_uuid_new byte(16), 
parent_repository_old varchar(64), parent_repository_new varchar(64), 
child_class_old varchar(30), child_class_new varchar(30), 
child_uuid_old byte(16), child_uuid_new byte(16), child_repository_old
varchar(64), child_repository_new varchar(64), parent_sequence_no_old 
int, child_sequence_no_old int, hidden_old integer1, hidden_new 
integer1, coord_type_old int, coord_type_new int, position_x_old 
float, position_x_new float, position_y_old float, position_y_new 
float, position_z_old float, position_z_new float, size_cx_old float, 
size_cx_new float, size_cy_old float, size_cy_new float, size_cz_old 
float, size_cz_new float ) as declare bUpdated1 int; sequence_no int; 
min_seq_no int; emessage char(255) not null with default; rcount int; 
enumber int; begin select iirowcount, iierrornumber into :rcount, 
:enumber; if ( :enumber > 0 ) then emessage = 'procedure tu_inclusion 
failed' + ascii(:enumber); raise error 70081 :emessage with 
destination = (session,error_log); return -1; endif;  bUpdated1 = 
execute procedure "mdbadmin". tng_ColumnUpdated ( v_uuid_old = 
:child_uuid_old, v_uuid_new = :child_uuid_new, v_datatype = 16 ); if 
(bUpdated1 = 0) then bUpdated1 = execute procedure "mdbadmin". 
tng_ColumnUpdated ( v_varchar_old = :child_class_old, v_varchar_new = 
:child_class_new, v_datatype = 0 ); endif; if (bUpdated1 = 0) then 
bUpdated1 = execute procedure "mdbadmin". tng_ColumnUpdated ( 
v_varchar_old = :child_repository_old, v_varchar_new = 
:child_repository_new, v_datatype = 0 ); endif; if (bUpdated1 = 0) 
then bUpdated1 = execute procedure "mdbadmin". tng_ColumnUpdated ( 
v_int1_old = :hidden_old, v_int1_new = :hidden_new, v_datatype = 1 ); 
endif; if (bUpdated1 = 0) then bUpdated1 = execute procedure 
"mdbadmin". tng_ColumnUpdated ( v_float_old = :position_x_old, 
v_float_new = :position_x_new, v_datatype = 7 ); endif; if (bUpdated1 
= 0) then bUpdated1 = execute procedure "mdbadmin". tng_ColumnUpdated 
( v_float_old = :position_y_old, v_float_new = :position_y_new, 
v_datatype = 7 ); endif; if (bUpdated1 = 0) then bUpdated1 = execute 
procedure "mdbadmin". tng_ColumnUpdated ( v_float_old = 
:position_z_old, v_float_new = :position_z_new, v_datatype = 7 ); 
endif; if (bUpdated1 = 0) then bUpdated1 = execute procedure 
"mdbadmin". tng_ColumnUpdated ( v_float_old = :size_cx_old, 
v_float_new = :size_cx_new, v_datatype = 7 ); endif; if (bUpdated1 = 
0) then bUpdated1 = execute procedure "mdbadmin". tng_ColumnUpdated ( 
v_float_old = :size_cy_old, v_float_new = :size_cy_new, v_datatype = 7
); endif; if (bUpdated1 = 0) then bUpdated1 = execute procedure 
"mdbadmin". tng_ColumnUpdated ( v_float_old = :size_cz_old, 
v_float_new = :size_cz_new, v_datatype = 7 ); endif; if (bUpdated1 = 
0) then bUpdated1=execute procedure "mdbadmin". tng_ColumnUpdated( 
v_int_old=:coord_type_old, v_int_new=:coord_type_new, v_datatype=4);  
endif; if (bUpdated1 = 0) then bUpdated1 = execute procedure 
"mdbadmin". tng_ColumnUpdated ( v_uuid_old = :parent_uuid_old, 
v_uuid_new = :parent_uuid_new, v_datatype = 16 ); endif; if (bUpdated1
= 0) then bUpdated1 = execute procedure "mdbadmin". tng_ColumnUpdated 
( v_varchar_old = :parent_class_old, v_varchar_new = 
:parent_class_new, v_datatype = 0 ); endif; if (bUpdated1 = 0) then 
bUpdated1 = execute procedure "mdbadmin". tng_ColumnUpdated ( 
v_varchar_old = :parent_repository_old, v_varchar_new = 
:parent_repository_new, v_datatype = 0 ); endif; if (bUpdated1 = 1) 
then update "mdbadmin". tng_key_change_hist set 
sequence_no_key=sequence_no_key+1; select iirowcount, iierrornumber 
into :rcount, :enumber; if (:enumber > 0) then emessage = 'tu_inclusio
n update of tng_key_change_hist failed' + ascii(:enumber); raise error
70044 :emessage with destination = (session,error_log); return -1; 
elseif ( :rcount = 0 ) then emessage = 'tu_inclusion update of tng_key
_change_hist zero rows'; raise error 70044 :emessage with destination 
= (session,error_log); return -1; endif; select 
:sequence_no=sequence_no_key, :min_seq_no=min_seq_no from "mdbadmin". 
tng_key_change_hist; insert into "mdbadmin". tng_change_history 
(operation, class_name, object_id1, portnum1, portnum2, timestamp, 
sequence_no) values ('u', 'Inclusion', :uuid_old, 
:child_sequence_no_old, :parent_sequence_no_old, date('now'), 
:sequence_no); select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'tu_inclusion insert of tn
g_change_history failed' + ascii(:enumber); raise error 70045 
:emessage with destination = (session,error_log); return -1; elseif ( 
:rcount = 0 ) then emessage = 'tu_inclusion insert of tng_change_histo
ry zero rows'; raise error 70045 :emessage with destination = 
(session,error_log); return -1; endif; if (:sequence_no >= 10000+
:min_seq_no) then  delete from "mdbadmin". tng_change_history where 
sequence_no < :min_seq_no + 500; select iirowcount, iierrornumber into
:rcount, :enumber; if (:enumber > 0) then emessage = 'tu_inclusion del
ete of tng_change_history failed' + ascii(:enumber); raise error 70046
:emessage with destination = (session,error_log); return -1; elseif ( 
:rcount = 0 ) then emessage = 'tu_inclusion delete of tng_change_histo
ry zero rows'; raise error 70046 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_key_change_hist set min_seq_no = :min_seq_no+500; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'tu_inclusion update of tng_key_change_hist failed' + 
ascii(:enumber); raise error 70047 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'tu_inclusion update of tng_key_change_hist zero rows'; raise error 
70047 :emessage with destination = (session,error_log); return -1; 
endif; endif; endif; return; end
\p\g
drop procedure tng_tu_jii_inclusion
\p\g
create procedure  tng_tu_jii_inclusion( uuid byte ( 16 ), parent_uuid 
byte ( 16 ), parent_sequence_no int) as declare sequence_no int; 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if ( 
:enumber > 0 ) then emessage = 'procedure tu_jii_inclusion failed' + 
ascii(:enumber); raise error 80084 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_key_change_hist set sequence_no_key=sequence_no_key+1; select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'tu_jii_inclusion update of tng_key_change_hist failed
' + ascii(:enumber); raise error 70058 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'tu_jii_inclusion update of tng_key_change_hist zero rows'; raise 
error 70058 :emessage with destination = (session,error_log); return 
-1; endif; select :sequence_no=sequence_no_key from "mdbadmin". 
tng_key_change_hist; insert into "mdbadmin". tng_change_history ( 
sequence_no,operation, class_name, object_id1, portnum1, object_id2, 
portnum2, timestamp ) values ( :sequence_no,'u', 'Jii_Inclusion', 
:uuid, 0, :parent_uuid, :parent_sequence_no, date('now') ); select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'tu_jii_inclusion insert of tng_change_history failed'
+ ascii(:enumber); raise error 70065 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'tu_jii_inclusion insert of tng_change_history zero rows'; raise error
70065 :emessage with destination = (session,error_log); return -1; 
endif; return end
\p\g
drop procedure tng_tu_link_change_hist
\p\g
create procedure  tng_tu_link_change_hist( v_class_name_old 
varchar(30), v_uuid_old byte(16)) as declare emessage char(255) not 
null with default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure tu_link_change_hist failed' + ascii(:enumber); 
raise error 70076 :emessage with destination = (session,error_log); 
return -1; endif; execute procedure "mdbadmin". 
tng_log_change_hist(v_operation = 'u', v_class_name = 
:v_class_name_old, v_uuid = :v_uuid_old); return; end
\p\g
drop procedure tng_tu_link_del_implinks_proc
\p\g
create procedure  tng_tu_link_del_implinks_proc( v_old_unimplied 
integer1, v_new_unimplied integer1, v_uuid_old byte(16)) as declare 
emessage char(255) not null with default; rcount int; enumber int; 
begin select iirowcount, iierrornumber into :rcount, :enumber; if ( 
:enumber > 0 ) then emessage = 'procedure tu_link_del_implinks_proc fa
iled' + ascii(:enumber); raise error 70078 :emessage with destination 
= (session,error_log); return -1; endif;  if (v_new_unimplied = 1 and 
v_old_unimplied = 0)then delete from "mdbadmin". tng_link where 
parent_link = v_uuid_old; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'tu_link_del_impl
inks_proc delete of tng_link failed' + ascii(:enumber); raise error 
70037 :emessage with destination = (session,error_log); return -1; 
elseif ( :rcount = 0 ) then emessage = 'tu_link_del_implinks_proc dele
te of tng_link zero rows'; raise error 70037 :emessage with 
destination = (session,error_log); return -1; endif; endif; return; 
end
\p\g
drop procedure tng_tu_link_status_hist
\p\g
create procedure  tng_tu_link_status_hist( v_class_name_new 
varchar(30), v_uuid_new byte(16), v_status_no_old int, v_status_no_new
int, v_severity_old int, v_severity_new int, v_alarmset_name_old 
varchar(30), v_alarmset_name_new varchar(30), v_implied_new int1) as 
declare a_severity int; sequence_no int; v_bUpdated int; v_bUpdated2 
int; v_bUpdated3 int; emessage char(255) not null with default; rcount
int; enumber int; begin select iirowcount, iierrornumber into :rcount,
:enumber; if ( :enumber > 0 ) then emessage = 'procedure tu_link_statu
s_hist failed' + ascii(:enumber); raise error 70077 :emessage with 
destination = (session,error_log); return -1; endif; 
v_bUpdated3=execute procedure "mdbadmin". tng_ColumnUpdated( 
v_varchar_old=v_alarmset_name_old, v_varchar_new=v_alarmset_name_new, 
v_datatype=0);  v_bUpdated2=execute procedure "mdbadmin". 
tng_ColumnUpdated( v_int_old=v_status_no_old, 
v_int_new=v_status_no_new, v_datatype=4);  v_bUpdated=execute 
procedure "mdbadmin". tng_ColumnUpdated( v_int_old=v_severity_old, 
v_int_new=v_severity_new, v_datatype=4);  if (v_bUpdated = 0 and 
v_bUpdated2 = 0 and v_bUpdated3 = 0) then return; endif; if 
(v_implied_new = 1) then  if (v_bUpdated = 1 or v_bUpdated2 = 1) then 
execute procedure "mdbadmin". tng_log_status_hist(v_class_name = 
:v_class_name_new, v_uuid = :v_uuid_new, v_status_no = 
:v_status_no_new, v_severity = :v_severity_new); endif; if 
(v_bUpdated3 = 1) then  execute procedure "mdbadmin". 
tng_log_change_hist(v_operation = 'u', v_class_name = 
:v_class_name_new, v_uuid = :v_uuid_new); endif; return; endif; 
if(v_bUpdated=0) then   select severity into :a_severity from 
"mdbadmin". tng_alarmset_entry where 
alarmset_name=:v_alarmset_name_new and status_no=:v_status_no_new; 
if(iirowcount=0) then execute procedure "mdbadmin". 
tng_log_status_hist(v_class_name = :v_class_name_new, v_uuid = 
:v_uuid_new, v_status_no = :v_status_no_new, v_severity = 
:v_severity_new);  if (v_implied_new = 0) then update "mdbadmin". 
tng_link set status_no=:v_status_no_new, severity=:v_severity_new, 
alarmset_name=:v_alarmset_name_new where parent_link = :v_uuid_new; 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'tu_link_status_hist update of tng_link failed' +
ascii(:enumber); raise error 70031 :emessage with destination 
=(session, error_log); return -1; endif; endif; return; endif;  if 
(a_severity = :v_severity_new) then execute procedure "mdbadmin". 
tng_log_status_hist(v_class_name = :v_class_name_new, v_uuid = 
:v_uuid_new, v_status_no = :v_status_no_new, v_severity = :a_severity)
;  if (v_implied_new = 0) then update "mdbadmin". tng_link set 
status_no=:v_status_no_new, severity=:v_severity_new, 
alarmset_name=:v_alarmset_name_new where parent_link = :v_uuid_new; 
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'tu_link_status_hist update of tng_link failed' +
ascii(:enumber); raise error 70032 :emessage with destination 
=(session, error_log); return -1; endif; endif; else update "mdbadmin"
. tng_link l from "mdbadmin". tng_alarmset_entry a set 
severity=a.severity where l.uuid=:v_uuid_new and 
a.alarmset_name=:v_alarmset_name_new and a.status_no=:v_status_no_new 
and a.severity!=:v_severity_new; select iirowcount, iierrornumber into
:rcount, :enumber; if (:enumber > 0) then emessage = 'tu_link_status_h
ist update of tng_link failed' + ascii(:enumber); raise error 70033 
:emessage with destination =(session, error_log); return -1; endif;  
update "mdbadmin". tng_link l from "mdbadmin". tng_alarmset_entry a 
set status_no=:v_status_no_new, severity=a.severity, 
alarmset_name=:v_alarmset_name_new where parent_link = :v_uuid_new and
a.alarmset_name=:v_alarmset_name_new and a.status_no=:v_status_no_new;
select iirowcount, iierrornumber into :rcount, :enumber; if (:enumber 
> 0) then emessage = 'tu_link_status_hist update of tng_link failed' +
ascii(:enumber); raise error 70034 :emessage with destination 
=(session, error_log); return -1; endif; endif; else  execute 
procedure "mdbadmin". tng_log_status_hist(v_class_name = 
:v_class_name_new, v_uuid = :v_uuid_new, v_status_no = 
:v_status_no_new, v_severity = :v_severity_new);  if (v_implied_new = 
0) then update "mdbadmin". tng_link set status_no=:v_status_no_new, 
severity=:v_severity_new, alarmset_name=:v_alarmset_name_new where 
parent_link = v_uuid_new; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'tu_link_status_h
ist update of tng_link failed' + ascii(:enumber); raise error 70035 
:emessage with destination =(session, error_log); return -1; endif; 
endif; endif; if (v_bUpdated3 = 1) then  execute procedure "mdbadmin".
tng_log_change_hist(v_operation = 'u', v_class_name = 
:v_class_name_new, v_uuid = :v_uuid_new); endif; end
\p\g
drop procedure tng_tu_link_update_err
\p\g
create procedure  tng_tu_link_update_err as declare emessage char(255)
not null with default; rcount int; enumber int; begin select 
iirowcount, iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) 
then emessage = 'procedure tu_link_update_err failed' + 
ascii(:enumber); raise error 70075 :emessage with destination = 
(session,error_log); return -1; endif; raise error 80002 'Do not allow
 to update class name or uuid or implied or parent_link of a linkobjec
t, the transaction rollback.'; return; end
\p\g
drop procedure tng_tu_manobj_change_hist
\p\g
create procedure  tng_tu_manobj_change_hist( v_class_name_old 
varchar(30), v_uuid_old byte(16), v_uuid_new byte(16), 
v_acknowledge_new int1, v_acknowledge_old int1, v_hidden_new int1, 
v_hidden_old int1, v_weight_old int1, v_weight_new int1) AS declare 
v_acknowledge int1; v_hidden int1; v_severity int1; v_weighted_sev 
int1; v_max_sev int1; v_weight int1; emessage char(255) not null with 
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure tu_manobj_change_hist failed' + 
ascii(iierrornumber); raise error 70068 :emessage with destination = 
(session,error_log); return -1; endif;   v_hidden=execute procedure 
"mdbadmin". tng_ColumnUpdated( v_int1_old=v_hidden_old, 
v_int1_new=v_hidden_new, v_datatype=1); v_weight=execute procedure 
"mdbadmin". tng_ColumnUpdated( v_int1_old=v_weight_old, 
v_int1_new=v_weight_new, v_datatype=1);   v_acknowledge=execute 
procedure "mdbadmin". tng_ColumnUpdated( v_int1_old=v_acknowledge_old,
v_int1_new=v_acknowledge_new, v_datatype=1); if (v_hidden=1 and 
v_hidden_new=1) then update "mdbadmin". tng_managedobject set 
propagate_status=0 where uuid=v_uuid_new and v_hidden_new=1; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'tu_manobj_change_hist update of tng_managedobject fai
led' + ascii(:enumber); raise error 70008 :emessage with destination =
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'tu_manobj_change_hist update of tng_managedobject zero rows'; raise 
error 70008 :emessage with destination = (session,error_log); return 
-1; endif; endif; if (v_acknowledge=1 and v_acknowledge_new=1) then 
update "mdbadmin". tng_managedobject set propagate_status=0 where 
uuid=v_uuid_new and v_acknowledge_new=1; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'tu_manobj_change_hist update of tng_managedobject failed' + 
ascii(:enumber); raise error 70009 :emessage with destination = 
(session,error_log); return -1; elseif ( :rcount = 0 ) then emessage =
'tu_manobj_change_hist update of tng_managedobject zero rows'; raise 
error 70009 :emessage with destination = (session,error_log); return 
-1; endif; endif; select severity into :v_severity from "mdbadmin". 
tng_managedobject where uuid = v_uuid_new; :v_weighted_sev = 
:v_severity * :v_weight; update "mdbadmin". tng_managedobject set 
weighted_severity = :v_weighted_sev, Max_Sev = :v_severity where uuid 
= :v_uuid_new; select iirowcount, iierrornumber into :rcount, 
:enumber; if (:enumber > 0) then emessage = 'tu_manobj_change_hist upd
ate of tng_managedobject failed' + ascii(:enumber); raise error 70083 
:emessage with destination = (session,error_log); return -1; elseif ( 
:rcount = 0 ) then emessage = 'tu_manobj_change_hist update of tng_man
agedobject zero rows'; raise error 70083 :emessage with destination = 
(session,error_log); return -1; endif; execute procedure "mdbadmin". 
tng_log_change_hist(v_operation = 'u', v_class_name = 
:v_class_name_old, v_uuid = :v_uuid_old); return; end
\p\g
drop procedure tng_tu_manobj_prop_hist
\p\g
create procedure  tng_tu_manobj_prop_hist( v_class_name_new 
varchar(30), v_uuid_new byte(16), v_status_no_new int, 
v_propagated_sev_new int ) as declare v_max_sev int1; v_sev int1; 
user_name varchar(30); emessage char(255) not null with default; 
rcount int; enumber int; begin select iirowcount, iierrornumber into 
:rcount, :enumber;  select dbmsinfo('username') into :user_name; if ( 
:enumber > 0 ) then emessage = 'procedure tu_manobj_prop_hist failed' 
+ ascii(:enumber); raise error 70069 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_key_prop_status_hist set sequence_no_key=sequence_no_key+1; select
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'tu_manobj_prop_hist update of tng_key_prop_status_his
t failed' + ascii(:enumber); raise error 70011 :emessage with 
destination = (session,error_log); return -1; endif; insert into 
"mdbadmin". tng_prop_status_history (sequence_no, class_name, 
record_uuid, status_no, severity, timestamp,user_name) select 
sequence_no_key, :v_class_name_new, :v_uuid_new, :v_status_no_new, 
:v_propagated_sev_new, date('now'), :user_name from "mdbadmin". 
tng_key_prop_status_hist; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'tu_manobj_prop_h
ist insert of tng_prop_status_history failed' + ascii(:enumber); raise
error 70012 :emessage with destination = (session,error_log); return 
-1; elseif ( :rcount = 0 ) then emessage = 'tu_manobj_prop_hist insert
 of tng_prop_status_history zero rows'; raise error 70012 :emessage 
with destination = (session,error_log); return -1; endif; select 
severity into :v_sev from "mdbadmin". tng_managedobject where uuid = 
v_uuid_new; if(:v_sev > :v_propagated_sev_new) then v_max_sev = v_sev;
else v_max_sev = v_propagated_sev_new; endif; update "mdbadmin". 
tng_managedobject tm set Max_Sev = :v_max_sev where tm.uuid = 
:v_uuid_new; select iirowcount, iierrornumber into :rcount, :enumber; 
if (:enumber > 0) then emessage = 'tu_manobj_prop_hist update of tng_m
anagedobject failed' + ascii(:enumber); raise error 70084 :emessage 
with destination = (session,error_log); return -1; elseif ( :rcount = 
0 ) then emessage = 'tu_manobj_prop_hist update of tng_managedobject z
ero rows'; raise error 70084 :emessage with destination = (session,
error_log); return -1; endif; end
\p\g
drop procedure tng_tu_manobj_status_hist
\p\g
create procedure  tng_tu_manobj_status_hist( v_class_name_new 
varchar(30), v_uuid_new byte(16), v_status_no_old int, v_status_no_new
int, v_severity_old int, v_severity_new int, v_alarmset_name_old 
varchar(30), v_alarmset_name_new varchar(30), v_propagate_status_old 
int1, v_propagate_status_new int1, v_acknowledge_old int1, 
v_acknowledge_new int1) as declare v_errorstr varchar(255) not null; 
strbuf varchar(255) not null; a_severity int; v_bUpdated int; 
v_bUpdated2 int; v_bUpdated3 int; v_weight int1; v_max_sev int1; 
v_weighted_sev int1; v_prop_sev int1; emessage char(255) not null with
default; rcount int; enumber int; begin select iirowcount, 
iierrornumber into :rcount, :enumber; if ( :enumber > 0 ) then 
emessage = 'procedure tu_manobj_status_hist failed' + ascii(:enumber);
raise error 70070 :emessage with destination = (session,error_log); 
return -1; endif; v_bUpdated3=execute procedure "mdbadmin". 
tng_ColumnUpdated( v_varchar_old=v_alarmset_name_old, 
v_varchar_new=v_alarmset_name_new, v_datatype=0);  v_bUpdated2=execute
procedure "mdbadmin". tng_ColumnUpdated( v_int_old=v_status_no_old, 
v_int_new=v_status_no_new, v_datatype=4);  v_bUpdated=execute 
procedure "mdbadmin". tng_ColumnUpdated( v_int_old=v_severity_old, 
v_int_new=v_severity_new, v_datatype=4);  if (v_bUpdated = 0 and 
v_bUpdated2 = 0 and v_bUpdated3 = 0) then return; endif; if 
(v_bUpdated = 1 or v_bUpdated2 = 1) and (v_acknowledge_old=1 and 
v_acknowledge_new=1) then raise error 80001 'Update severity or status
_no failed Since one of acknowledges is on(1)'; return; endif; 
:a_severity = -1; if(v_bUpdated=0) then   select severity into 
:a_severity from "mdbadmin". tng_alarmset_entry where 
alarmset_name=:v_alarmset_name_new and status_no=:v_status_no_new; 
if(iirowcount=0) then execute procedure "mdbadmin". 
tng_log_status_hist(v_class_name = :v_class_name_new, v_uuid = 
:v_uuid_new, v_status_no = :v_status_no_new, v_severity = 
:v_severity_new);  select weight , propagated_sev into :v_weight, 
:v_prop_sev from "mdbadmin". tng_managedobject where uuid = 
:v_uuid_new; :v_weighted_sev = :v_weight* :a_severity; if(:a_severity 
> :v_prop_sev) then v_max_sev = a_severity; else v_max_sev = 
v_prop_sev; endif; update "mdbadmin". tng_managedobject tm set Max_Sev
= :v_max_sev, weighted_severity = :v_weighted_sev where tm.uuid = 
:v_uuid_new; select iirowcount, iierrornumber into :rcount, :enumber; 
if (:enumber > 0) then emessage = 'tu_manobj_status_hist update of tng
_managedobject failed' + ascii(:enumber); raise error 70085 :emessage 
with destination = (session,error_log); return -1; elseif ( :rcount = 
0 ) then emessage = 'tu_manobj_status_hist update of tng_managedobject
 zero rows'; raise error 70085 :emessage with destination = (session,
error_log); return -1; endif; return; else  if (:a_severity < 0 or 
:a_severity > 9) then select v_errorstr = char(:a_severity); strbuf = 
'Invalid severity = ' + v_errorstr; message strbuf with destination = 
(error_log); return; endif; if (:a_severity = :v_severity_new) then 
execute procedure "mdbadmin". tng_log_status_hist(v_class_name = 
:v_class_name_new, v_uuid = :v_uuid_new, v_status_no = 
:v_status_no_new, v_severity = :a_severity); endif; endif;  
v_bUpdated=execute procedure "mdbadmin". 
tng_ColumnUpdated(v_int1_old=v_propagate_status_old, 
v_int1_new=v_propagate_status_new, v_datatype=1); if(v_bUpdated=0) 
then     update "mdbadmin". tng_key_status_hist set sequence_no_key = 
sequence_no_key where sequence_no_key = -18; select iirowcount, 
iierrornumber into :rcount, :enumber; if (:enumber > 0) then emessage 
= 'tu_manobj_status_hist update of tng_key_status_hist failed' + 
ascii(:enumber); raise error 70014 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_managedobject m from "mdbadmin". tng_alarmset_entry a set 
severity=a.severity, propagate_status=a.propagate_status where 
m.uuid=:v_uuid_new and a.alarmset_name=:v_alarmset_name_new and 
a.status_no=:v_status_no_new; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'tu_manobj_status
_hist update of tng_managedobject failed' + ascii(:enumber); raise 
error 70015 :emessage with destination = (session,error_log); return 
-1; endif; else update "mdbadmin". tng_managedobject m from "mdbadmin"
. tng_alarmset_entry a set severity=a.severity where 
m.uuid=:v_uuid_new and a.alarmset_name=:v_alarmset_name_new and 
a.status_no=:v_status_no_new and a.severity!=:v_severity_new; select 
iirowcount, iierrornumber into :rcount, :enumber; if (:enumber > 0) 
then emessage = 'tu_manobj_status_hist update of tng_managedobject fai
led' + ascii(:enumber); raise error 70016 :emessage with destination =
(session,error_log); return -1; endif; endif; else  execute procedure 
"mdbadmin". tng_log_status_hist(v_class_name = :v_class_name_new, 
v_uuid = :v_uuid_new, v_status_no = :v_status_no_new, v_severity = 
:v_severity_new); endif; end
\p\g
drop procedure tng_tu_manobj_update_err
\p\g
create procedure  tng_tu_manobj_update_err as begin raise error 80002 
'80002: Update of class name or uuid for table tng_managedobject is no
t allowed, the transaction is aborted'; return; end
\p\g
drop procedure tng_unmanage_discovery_ipsubnet
\p\g
create procedure  tng_unmanage_discovery_ipsubnet( name char(20)) as 
declare emessage char(255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
( :enumber > 0 ) then emessage = 'procedure unmanage_discovery_ipsubne
t failed' + ascii(:enumber); raise error 60041 :emessage with 
destination = (session, error_log); return -1; endif; update 
"mdbadmin". tng_discovery_ipsubnet set managed = 2, managed_str = 'Fin
ish' where subnet_addr_str = :name; select iirowcount, iierrornumber 
into :rcount, :enumber; if (:enumber > 0) then emessage = 'unmanage_di
scovery_ipsubnet update of tng_discovery_ipsubnet failed' + 
ascii(:enumber); raise error 60020 :emessage with destination = 
(session,error_log); return -1; endif;  return; end
\p\g
grant execute on procedure "mdbadmin".tng_unmanage_discovery_ipsubnet 
to group tngadmin
\p\g
drop procedure tng_upd_segment_uuid
\p\g
create procedure  tng_upd_segment_uuid ( start_address varchar(200), 
end_address varchar(200), iftype int, segment_uuid byte(16)) as 
declare emessage char(255) not null with default; rcount int; enumber 
int; begin select iirowcount, iierrornumber into :rcount, :enumber; if
( :enumber > 0 ) then emessage = 'procedure upd_segment_uuid failed' +
ascii(:enumber); raise error 50032 :emessage with destination = 
(session,error_log); return -1; endif; update "mdbadmin". 
tng_ip_interface from "mdbadmin". tng_managedobject m set 
segment_uuid=:segment_uuid where address >= :start_address and address
<= :end_address and tng_ip_interface.segment_uuid is null and 
m.interface_type=:iftype and class_name='IP_Interface' and 
m.uuid=tng_ip_interface.uuid; select iirowcount, iierrornumber into 
:rcount, :enumber; if (:enumber > 0) then emessage = 'upd_segment_uuid
 update of tng_ip_interface failed' + ascii(:enumber); raise error 
50019 :emessage with destination = (session,error_log); return -1; 
endif; return; end
\p\g
grant execute on procedure "mdbadmin".tng_upd_segment_uuid to group 
tngadmin
\p\g

	/* RULES */
create rule  cas_db_Application_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Application_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Column_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Column_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_DataType_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_DataType_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Field_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Field_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Gator_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Gator_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_GatorStar_db_Gator after delete from db_Gator 
execute procedure "mdbadmin". del_db_GatorStar_db_Gator(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_GatorStar_db_Star after delete from db_Star 
execute procedure "mdbadmin". del_db_GatorStar_db_Star(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Index_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Index_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_IndexCol_db_Column after delete from db_Column 
execute procedure "mdbadmin". del_db_IndexCol_db_Column(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_IndexCol_db_Index after delete from db_Index 
execute procedure "mdbadmin". del_db_IndexCol_db_Index(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_InfoBlob_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_InfoBlob_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Layout_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Layout_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Object_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Object_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Op_db_Object after delete from db_Object execute 
procedure "mdbadmin". del_db_Op_db_Object(arg = old.dbrep_IID)
\p\g
create rule  cas_db_OpSegment_db_Op after delete from db_Op execute 
procedure "mdbadmin". del_db_OpSegment_db_Op(arg = old.dbrep_IID)
\p\g
create rule  cas_db_Parameter_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Parameter_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Program_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Program_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_ProgramInstance_db_Object after delete from 
db_Object execute procedure "mdbadmin". 
del_db_ProgramInstance_db_Object(arg = old.dbrep_IID)
\p\g
create rule  cas_db_ProgramType_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_ProgramType_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_ProgramTypeMisc_db_Object after delete from 
db_Object execute procedure "mdbadmin". 
del_db_ProgramTypeMisc_db_Object(arg = old.dbrep_IID)
\p\g
create rule  cas_db_PSAFile_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_PSAFile_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_SeqColumn_db_Column after delete from db_Column 
execute procedure "mdbadmin". del_db_SeqColumn_db_Column(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_SeqTable_db_Table after delete from db_Table 
execute procedure "mdbadmin". del_db_SeqTable_db_Table(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_ServerType_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_ServerType_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Star_db_Object after delete from db_Object execute
procedure "mdbadmin". del_db_Star_db_Object(arg = old.dbrep_IID)
\p\g
create rule  cas_db_StarTable_db_Table after delete from db_Table 
execute procedure "mdbadmin". del_db_StarTable_db_Table(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_Table_db_Object after delete from db_Object 
execute procedure "mdbadmin". del_db_Table_db_Object(arg = 
old.dbrep_IID)
\p\g
create rule  cas_db_WKF_db_Object after delete from db_Object execute 
procedure "mdbadmin". del_db_WKF_db_Object(arg = old.dbrep_IID)
\p\g
create rule  cas_db_WKFConnection_db_Object after delete from 
db_Object execute procedure "mdbadmin". 
del_db_WKFConnection_db_Object(arg = old.dbrep_IID)
\p\g
create rule  cas_DDColumn_DDTable after delete from DDTable execute 
procedure "mdbadmin". del_DDColumn_DDTable(arg = old.DDTableId)
\p\g
create rule  cas_DDTable_Execution after delete from Execution execute
procedure "mdbadmin". del_DDTable_Execution(arg = old.ExecutionId)
\p\g
create rule  cas_DDTableModify_Execution after delete from Execution 
execute procedure "mdbadmin". del_DDTableModify_Execution(arg = 
old.ExecutionId)
\p\g
create rule  cas_Error_Execution after delete from Execution execute 
procedure "mdbadmin". del_Error_Execution(arg = old.ExecutionId)
\p\g
create rule  cas_Execution_LookOutServer after delete from 
LookOutServer execute procedure "mdbadmin". 
del_Execution_LookOutServer(arg = old.ServerId)
\p\g
create rule  cas_Execution_Request after delete from ipRequest execute
procedure "mdbadmin". del_Execution_Request(arg = old.RequestId)
\p\g
create rule  cas_LookOutControl_LookOutServer after delete from 
LookOutServer execute procedure "mdbadmin". 
del_LookOutControl_LookOutServer(arg = old.ServerId)
\p\g
create rule  cas_Object_IPUser after delete from IPUser execute 
procedure "mdbadmin". del_Object_IPUser(arg = old.UserId)
\p\g
create rule  cas_Permissions_Object after delete from ipObject execute
procedure "mdbadmin". del_Permissions_Object(arg = old.ObjectId)
\p\g
create rule  cas_Provider_Object after delete from ipObject execute 
procedure "mdbadmin". del_Provider_Object(arg = old.ObjectId)
\p\g
create rule  cas_RDBMS_Provider_Object after delete from ipObject 
execute procedure "mdbadmin". del_RDBMS_Provider_Object(arg = 
old.ObjectId)
\p\g
create rule  cas_Request_Object after delete from ipObject execute 
procedure "mdbadmin". del_Request_Object(arg = old.ObjectId)
\p\g
create rule  cas_RequestProvider_Provider after delete from ipProvider
execute procedure "mdbadmin". del_RequestProvider_Provider(arg = 
old.ProviderId)
\p\g
create rule  cas_RequestProvider_Request after delete from ipRequest 
execute procedure "mdbadmin". del_RequestProvider_Request(arg = 
old.RequestId)
\p\g
create rule  cas_RequestQueue_Request after delete from ipRequest 
execute procedure "mdbadmin". del_RequestQueue_Request(arg = 
old.RequestId)
\p\g
create rule  cas_ScriptMessageLog_Execution after delete from 
Execution execute procedure "mdbadmin". 
del_ScriptMessageLog_Execution(arg = old.ExecutionId)
\p\g
create rule  cas_SimpleRequest_Request after delete from ipRequest 
execute procedure "mdbadmin". del_SimpleRequest_Request(arg = 
old.RequestId)
\p\g
create rule  increment_seosdata AFTER INSERT ON SEOSDATA EXECUTE 
PROCEDURE "mdbadmin". increment_id
\p\g
create rule  rD_Cluster after DELETE from Cluster   execute procedure 
"mdbadmin". pD_Cluster ( oldClusterID=old.ClusterID, 
oldClusterName=old.ClusterName, oldClusterType=old.ClusterType, 
oldDescription=old.Description )
\p\g
create rule  rD_Collector after DELETE from Server_Collector   execute
procedure "mdbadmin". pD_Collector ( oldCollectorID=old.CollectorID, 
oldCollectorName=old.CollectorName, 
oldParentCollectorID=old.ParentCollectorID, oldHostName=old.HostName, 
oldServerName=old.ServerName, oldDBName=old.DBName, 
oldUserName=old.UserName, oldUserPsw=old.UserPsw, 
oldLogFileLocation=old.LogFileLocation, 
oldNeedRefresh=old.NeedRefresh, oldCollectorType=old.CollectorType, 
oldRawDataKeepInterval=old.RawDataKeepInterval, 
oldRawDataTimeFactor=old.RawDataTimeFactor, 
oldHourlyDataKeepInterval=old.HourlyDataKeepInterval, 
oldHourlyTimeFactor=old.HourlyTimeFactor, 
oldDailyDataKeepInterval=old.DailyDataKeepInterval, 
oldDailyTimeFactor=old.DailyTimeFactor, 
oldWeeklyDataKeepInterval=old.WeeklyDataKeepInterval, 
oldWeeklyTimeFactor=old.WeeklyTimeFactor, 
oldMonthlyDataKeepInterval=old.MonthlyDataKeepInterval, 
oldMonthlyTimeFactor=old.MonthlyTimeFactor, 
oldYearlyDataKeepInterval=old.YearlyDataKeepInterval, 
oldYearlyTimeFactor=old.YearlyTimeFactor, oldInactive=old.Inactive, 
oldTopNServers=old.TopNServers, oldTopNPersons=old.TopNPersons, 
oldTopNObjects=old.TopNObjects, oldAlertLimit=old.AlertLimit, 
oldIDFile1=old.IDFile1, oldIDFile2=old.IDFile2, 
oldOneIDFile=old.OneIDFile, oldIDFilePwd=old.IDFilePwd )
\p\g
create rule  rD_CollectorAction after DELETE from 
Server_CollectorAction   execute procedure "mdbadmin". 
pD_CollectorAction ( oldActionID=old.ActionID, 
oldActionName=old.ActionName, oldActionType=old.ActionType )
\p\g
create rule  rD_ColumnDefinition after DELETE from ColumnDefinition   
execute procedure "mdbadmin". pD_ColumnDefinition ( 
oldTableIdx=old.TableIdx, oldOrderOfColumn=old.OrderOfColumn, 
oldName=old.Name, oldTypeId=old.TypeId, oldRollUpType=old.RollUpType, 
oldReportLabel=old.ReportLabel )
\p\g
create rule  rD_ConnectorType after DELETE from ConnectorType   
execute procedure "mdbadmin". pD_ConnectorType ( 
oldConnectorTypeID=old.ConnectorTypeID, 
oldConnectorTypeName=old.ConnectorTypeName )
\p\g
create rule  rD_CounterDefinition after DELETE from CounterDefinition 
execute procedure "mdbadmin". pD_CounterDefinition ( 
oldCounterID=old.CounterID, oldUnitID=old.UnitID, 
oldFullCounterName=old.FullCounterName, 
oldCounterName=old.CounterName, oldDataType=old.DataType, 
oldClass=old.Class, oldSubClass=old.SubClass, 
oldInstance=old.Instance, oldCounterType=old.CounterType, 
oldValueType=old.ValueType, oldAlgoType=old.AlgoType )
\p\g
create rule  rD_CounterSource after DELETE from CounterSource   
execute procedure "mdbadmin". pD_CounterSource ( 
oldSourceID=old.SourceID, oldCollectorID=old.CollectorID, 
oldLocaleID=old.LocaleID, oldClusterID=old.ClusterID, 
oldSiteID=old.SiteID, oldSourceName=old.SourceName, 
oldSourceType=old.SourceType, oldHostName=old.HostName, 
oldActiveState=old.ActiveState, oldUserName=old.UserName, 
oldUserPwd=old.UserPwd, oldHostName1=old.HostName1, 
oldHostName2=old.HostName2, oldHostName3=old.HostName3, 
oldSrcTimeZone=old.SrcTimeZone, oldMailOrgID=old.MailOrgID )
\p\g
create rule  rD_DominoEventType after DELETE from DominoEventType   
execute procedure "mdbadmin". pD_DominoEventType ( 
oldDominoEventTypeID=old.DominoEventTypeID, 
oldDominoEventTypeName=old.DominoEventTypeName )
\p\g
create rule  rD_DominoLogEventType after DELETE from 
DominoLogEventType   execute procedure "mdbadmin". 
pD_DominoLogEventType ( 
oldDominoLogEventTypeID=old.DominoLogEventTypeID, 
oldDominoLogEventTypeName=old.DominoLogEventTypeName )
\p\g
create rule  rD_ErrorMessage after DELETE from ErrorMessage   execute 
procedure "mdbadmin". pD_ErrorMessage ( 
oldErrorMessageID=old.ErrorMessageID, oldSourceType=old.SourceType, 
oldMessageText=old.MessageText )
\p\g
create rule  rD_EventSeverity after DELETE from EventSeverity   
execute procedure "mdbadmin". pD_EventSeverity ( 
oldEventSeverityID=old.EventSeverityID, 
oldEventSeverityName=old.EventSeverityName )
\p\g
create rule  rD_EventType after DELETE from EventType   execute 
procedure "mdbadmin". pD_EventType ( oldEventTypeID=old.EventTypeID, 
oldEventTypeName=old.EventTypeName )
\p\g
create rule  rD_IndexTable after DELETE from IndexTable   execute 
procedure "mdbadmin". pD_IndexTable ( 
oldComponentMibIndexIdx=old.ComponentMibIndexIdx, 
oldTypeOfIndexRetrieval=old.TypeOfIndexRetrieval, 
oldIndexBaseOID=old.IndexBaseOID, oldIndexStartLoc=old.IndexStartLoc, 
oldIndexLength=old.IndexLength, oldColOidId=old.ColOidId )
\p\g
create rule  rD_MailConnector after DELETE from MailConnector   
execute procedure "mdbadmin". pD_MailConnector ( 
oldSourceID=old.SourceID, oldMailConnectorID=old.MailConnectorID, 
oldConnectorTypeID=old.ConnectorTypeID, 
oldMailConnectorName=old.MailConnectorName, 
oldDescription=old.Description )
\p\g
create rule  rD_MailDB after DELETE from MailDB   execute procedure 
"mdbadmin". pD_MailDB ( oldSourceID=old.SourceID, 
oldMailDBID=old.MailDBID, oldDBTitle=old.DBTitle, 
oldDBFileName=old.DBFileName, oldMailDBName=old.MailDBName, 
oldDescription=old.Description )
\p\g
create rule  rD_MailDisk after DELETE from MailDisk   execute 
procedure "mdbadmin". pD_MailDisk ( oldSourceID=old.SourceID, 
oldMailDiskID=old.MailDiskID, oldDiskSize=old.DiskSize, 
oldMailDiskName=old.MailDiskName, oldDescription=old.Description )
\p\g
create rule  rD_MailDomain after DELETE from MailDomain   execute 
procedure "mdbadmin". pD_MailDomain ( oldSourceID=old.SourceID, 
oldMailDomainID=old.MailDomainID, 
oldMailDomainName=old.MailDomainName, oldDescription=old.Description )
\p\g
create rule  rD_MailEvent after DELETE from MailEvent   execute 
procedure "mdbadmin". pD_MailEvent ( oldSourceID=old.SourceID, 
oldMailEventID=old.MailEventID, oldEventTypeID=old.EventTypeID, 
oldEventSeverityID=old.EventSeverityID, 
oldMailEventName=old.MailEventName, oldDescription=old.Description, 
oldEventID=old.EventID, 
oldDominoLogEventTypeID=old.DominoLogEventTypeID, 
oldDominoEventTypeID=old.DominoEventTypeID )
\p\g
create rule  rD_MailObject after DELETE from MailObject   execute 
procedure "mdbadmin". pD_MailObject ( oldSourceID=old.SourceID, 
oldMailObjectID=old.MailObjectID, 
oldMailObjectName=old.MailObjectName, 
oldMailObjectType=old.MailObjectType, oldDescription=old.Description )
\p\g
create rule  rD_MailOrganisation after DELETE from MailOrganisation   
execute procedure "mdbadmin". pD_MailOrganisation ( 
oldMailOrgID=old.MailOrgID, oldOrganisationName=old.OrganisationName )
\p\g
create rule  rD_MailQueue after DELETE from MailQueue   execute 
procedure "mdbadmin". pD_MailQueue ( oldSourceID=old.SourceID, 
oldMailQueueID=old.MailQueueID, oldQueueType=old.QueueType, 
oldMailQueueName=old.MailQueueName, oldDescription=old.Description )
\p\g
create rule  rD_MailService after DELETE from MailService   execute 
procedure "mdbadmin". pD_MailService ( oldSourceID=old.SourceID, 
oldMailServiceID=old.MailServiceID, 
oldMailServiceName=old.MailServiceName, oldDescription=old.Description
)
\p\g
create rule  rD_mib after DELETE from network_mib   execute procedure 
"mdbadmin". pD_mib ( oldID=old.ID, oldname=old.name, oldbody=old.body 
)
\p\g
create rule  rD_MIBDefinition after DELETE from MIBDefinition   
execute procedure "mdbadmin". pD_MIBDefinition ( oldMibIdx=old.MibIdx,
oldMibType=old.MibType, oldDescription=old.Description, 
oldCollection=old.Collection, oldmib_id=old.mib_id )
\p\g
create rule  rD_MibStructure after DELETE from MibStructure   execute 
procedure "mdbadmin". pD_MibStructure ( oldMibIdx=old.MibIdx, 
oldOidIdxForMIB=old.OidIdxForMIB, oldOID=old.OID, oldType=old.Type, 
oldDiscoveryKey=old.DiscoveryKey, oldIsIfIndex=old.IsIfIndex, 
oldIsStatus=old.IsStatus, 
oldComponentMibIndexIdx=old.ComponentMibIndexIdx )
\p\g
create rule  rD_MibVariableType after DELETE from MibVariableType   
execute procedure "mdbadmin". pD_MibVariableType ( 
oldTypeId=old.TypeId, oldCategory=old.Category, 
oldSubcategory=old.Subcategory, oldDescription=old.Description, 
oldBaseTypeIdx=old.BaseTypeIdx, oldCollectable=old.Collectable )
\p\g
create rule  rD_Objects after DELETE from Objects   execute procedure 
"mdbadmin". pD_Objects ( oldObjectID=old.ObjectID, 
oldObjectType=old.ObjectType, oldObjectName=old.ObjectName, 
oldDescription=old.Description, oldObjectSourceID=old.ObjectSourceID, 
oldClusterID=old.ClusterID, oldDomainSourceID=old.DomainSourceID, 
oldMailObjectID=old.MailObjectID, 
oldServiceSourceID=old.ServiceSourceID, 
oldMailDomainID=old.MailDomainID, oldMailServiceID=old.MailServiceID, 
oldConnectorSourceID=old.ConnectorSourceID, 
oldMailConnectorID=old.MailConnectorID, oldDBSourceID=old.DBSourceID, 
oldMailDBID=old.MailDBID, oldEventSourceID=old.EventSourceID, 
oldMailEventID=old.MailEventID, oldQueueSourceID=old.QueueSourceID, 
oldMailQueueID=old.MailQueueID, oldDiskSourceID=old.DiskSourceID, 
oldMailDiskID=old.MailDiskID )
\p\g
create rule  rD_Person after DELETE from Server_Person   execute 
procedure "mdbadmin". pD_Person ( oldSourceID=old.SourceID, 
oldPersonID=old.PersonID, oldPersonName=old.PersonName, 
oldDescription=old.Description, oldDisplayName=old.DisplayName, 
oldMailFile=old.MailFile )
\p\g
create rule  rD_Report after DELETE from Management_Report   execute 
procedure "mdbadmin". pD_Report ( oldReportID=old.ReportID, 
oldTitle=old.Title, oldTableName=old.TableName, 
oldAllColumns=old.AllColumns, oldIsDistinct=old.IsDistinct, 
oldReportType=old.ReportType )
\p\g
create rule  rD_ReportColumn after DELETE from ReportColumn   execute 
procedure "mdbadmin". pD_ReportColumn ( oldColumnID=old.ColumnID, 
oldReportID=old.ReportID, oldThresholdColumnID=old.ThresholdColumnID, 
oldThresholdReportID=old.ThresholdReportID, 
oldColumnName=old.ColumnName, oldIsVisible=old.IsVisible, 
oldSortBy=old.SortBy, oldFormula=old.Formula, 
oldIsDistinct=old.IsDistinct, oldIsGroup=old.IsGroup, 
oldTitle=old.Title, oldPresentation=old.Presentation, 
oldUnitID=old.UnitID, oldInWorkSpace=old.InWorkSpace )
\p\g
create rule  rD_ReportTableDefinition after DELETE from 
ReportTableDefinition   execute procedure "mdbadmin". 
pD_ReportTableDefinition ( oldReportTableID=old.ReportTableID, 
oldReportTableName=old.ReportTableName, oldAlgoType=old.AlgoType )
\p\g
create rule  rD_Site after DELETE from Server_Site   execute procedure
"mdbadmin". pD_Site ( oldSiteID=old.SiteID, 
oldMailOrgID=old.MailOrgID, oldSiteName=old.SiteName )
\p\g
create rule  rD_SolutionDescription after DELETE from 
SolutionDescription   execute procedure "mdbadmin". 
pD_SolutionDescription ( 
oldSolutionDescriptionID=old.SolutionDescriptionID, 
oldSolutionText=old.SolutionText )
\p\g
create rule  rD_SourceLocale after DELETE from SourceLocale   execute 
procedure "mdbadmin". pD_SourceLocale ( oldLocaleID=old.LocaleID, 
oldLocaleName=old.LocaleName, oldLangCode=old.LangCode, 
oldSourceType=old.SourceType, oldJavaLocale=old.JavaLocale )
\p\g
create rule  rD_TableDefinition after DELETE from TableDefinition   
execute procedure "mdbadmin". pD_TableDefinition ( 
oldTableIdx=old.TableIdx, oldNameOfTable=old.NameOfTable )
\p\g
create rule  rD_tau_mdb after DELETE from tau_mdb   execute procedure 
"mdbadmin". pD_tau_mdb ( oldmdbMajorVersion=old.mdbMajorVersion, 
oldmdbMinorVersion=old.mdbMinorVersion, 
oldreleaseDate=old.releaseDate, oldinstallDate=old.installDate )
\p\g
create rule  rD_tau_product after DELETE from tau_product   execute 
procedure "mdbadmin". pD_tau_product ( oldproductName=old.productName,
oldproductMajorVersion=old.productMajorVersion, 
oldproductMinorVersion=old.productMinorVersion, 
oldreleaseDate=old.releaseDate, oldinstallCount=old.installCount )
\p\g
create rule  rD_Unit after DELETE from Unit   execute procedure 
"mdbadmin". pD_Unit ( oldUnitID=old.UnitID, oldUnitName=old.UnitName, 
oldPrec=old.Prec, oldUnitShortName=old.UnitShortName )
\p\g
create rule  rI_Alert after INSERT into Management_Alert   execute 
procedure "mdbadmin". pI_Alert ( newCounterID=new.CounterID, 
newSourceID=new.SourceID, newAlertID=new.AlertID, 
newSource=new.Source, newTStamp=new.TStamp, newObjectID=new.ObjectID, 
newPersonSourceID=new.PersonSourceID, newPersonID=new.PersonID, 
newStatus=new.Status, newDescription=new.Description, 
newThreshold=new.Threshold, newPrevStatus=new.PrevStatus, 
newIsSent=new.IsSent, newCounterValue=new.CounterValue, 
newStringValue=new.StringValue, newDateValue=new.DateValue )
\p\g
create rule  rI_Collector after INSERT into Server_Collector   execute
procedure "mdbadmin". pI_Collector ( newCollectorID=new.CollectorID, 
newCollectorName=new.CollectorName, 
newParentCollectorID=new.ParentCollectorID, newHostName=new.HostName, 
newServerName=new.ServerName, newDBName=new.DBName, 
newUserName=new.UserName, newUserPsw=new.UserPsw, 
newLogFileLocation=new.LogFileLocation, 
newNeedRefresh=new.NeedRefresh, newCollectorType=new.CollectorType, 
newRawDataKeepInterval=new.RawDataKeepInterval, 
newRawDataTimeFactor=new.RawDataTimeFactor, 
newHourlyDataKeepInterval=new.HourlyDataKeepInterval, 
newHourlyTimeFactor=new.HourlyTimeFactor, 
newDailyDataKeepInterval=new.DailyDataKeepInterval, 
newDailyTimeFactor=new.DailyTimeFactor, 
newWeeklyDataKeepInterval=new.WeeklyDataKeepInterval, 
newWeeklyTimeFactor=new.WeeklyTimeFactor, 
newMonthlyDataKeepInterval=new.MonthlyDataKeepInterval, 
newMonthlyTimeFactor=new.MonthlyTimeFactor, 
newYearlyDataKeepInterval=new.YearlyDataKeepInterval, 
newYearlyTimeFactor=new.YearlyTimeFactor, newInactive=new.Inactive, 
newTopNServers=new.TopNServers, newTopNPersons=new.TopNPersons, 
newTopNObjects=new.TopNObjects, newAlertLimit=new.AlertLimit, 
newIDFile1=new.IDFile1, newIDFile2=new.IDFile2, 
newOneIDFile=new.OneIDFile, newIDFilePwd=new.IDFilePwd )
\p\g
create rule  rI_CollectorPolling after INSERT into CollectorPolling   
execute procedure "mdbadmin". pI_CollectorPolling ( 
newCollectorID=new.CollectorID, newCounterID=new.CounterID )
\p\g
create rule  rI_ColumnDefinition after INSERT into ColumnDefinition   
execute procedure "mdbadmin". pI_ColumnDefinition ( 
newTableIdx=new.TableIdx, newOrderOfColumn=new.OrderOfColumn, 
newName=new.Name, newTypeId=new.TypeId, newRollUpType=new.RollUpType, 
newReportLabel=new.ReportLabel )
\p\g
create rule  rI_ComponentOfIndex after INSERT into ComponentOfIndex   
execute procedure "mdbadmin". pI_ComponentOfIndex ( 
newComponentMibIndexIdx=new.ComponentMibIndexIdx, 
newComponentOfIndexOrder=new.ComponentOfIndexOrder, 
newMibIdx=new.MibIdx, newOidIdxForMIB=new.OidIdxForMIB, 
newIndexStart=new.IndexStart, newIndexLength=new.IndexLength, 
newImplied=new.Implied )
\p\g
create rule  rI_CounterData after INSERT into CounterData   execute 
procedure "mdbadmin". pI_CounterData ( newCounterID=new.CounterID, 
newSourceID=new.SourceID, newCounterDataID=new.CounterDataID, 
newTStamp=new.TStamp, newObjectID=new.ObjectID, 
newPersonSourceID=new.PersonSourceID, newPersonID=new.PersonID, 
newDelta=new.Delta, newWarningThreshold=new.WarningThreshold, 
newCriticalThreshold=new.CriticalThreshold, newIsSent=new.IsSent, 
newTimeInterval=new.TimeInterval, newCounterValue=new.CounterValue, 
newStringValue=new.StringValue, newDateValue=new.DateValue )
\p\g
create rule  rI_CounterPolling after INSERT into CounterPolling   
execute procedure "mdbadmin". pI_CounterPolling ( 
newSourceID=new.SourceID, newCounterID=new.CounterID )
\p\g
create rule  rI_CounterSource after INSERT into CounterSource   
execute procedure "mdbadmin". pI_CounterSource ( 
newSourceID=new.SourceID, newCollectorID=new.CollectorID, 
newLocaleID=new.LocaleID, newClusterID=new.ClusterID, 
newSiteID=new.SiteID, newSourceName=new.SourceName, 
newSourceType=new.SourceType, newHostName=new.HostName, 
newActiveState=new.ActiveState, newUserName=new.UserName, 
newUserPwd=new.UserPwd, newHostName1=new.HostName1, 
newHostName2=new.HostName2, newHostName3=new.HostName3, 
newSrcTimeZone=new.SrcTimeZone, newMailOrgID=new.MailOrgID )
\p\g
create rule  rI_CounterTitle after INSERT into CounterTitle   execute 
procedure "mdbadmin". pI_CounterTitle ( newLocaleID=new.LocaleID, 
newCounterID=new.CounterID, newSourceType=new.SourceType, 
newFullCounterName=new.FullCounterName )
\p\g
create rule  rI_DiscoveryVariable after INSERT into DiscoveryVariable 
execute procedure "mdbadmin". pI_DiscoveryVariable ( 
newMibIdx=new.MibIdx, newTypeId=new.TypeId, 
newOidIdxForMIB=new.OidIdxForMIB, newDiscGet=new.DiscGet, 
newDiscRespLocation=new.DiscRespLocation, 
newDiscRespValue=new.DiscRespValue, newOper=new.Oper, 
newDescription=new.Description )
\p\g
create rule  rI_ErrorSolution after INSERT into ErrorSolution   
execute procedure "mdbadmin". pI_ErrorSolution ( 
newErrorMessageID=new.ErrorMessageID, 
newSolutionDescriptionID=new.SolutionDescriptionID )
\p\g
create rule  rI_GDCDiscovery after INSERT into GDCDiscovery   execute 
procedure "mdbadmin". pI_GDCDiscovery ( 
newserver_addr=new.server_addr, newprobe_addr=new.probe_addr, 
newMibIdx=new.MibIdx, newIntervalDateTime=new.IntervalDateTime, 
newDiscovered=new.Discovered )
\p\g
create rule  rI_MailConnector after INSERT into MailConnector   
execute procedure "mdbadmin". pI_MailConnector ( 
newSourceID=new.SourceID, newMailConnectorID=new.MailConnectorID, 
newConnectorTypeID=new.ConnectorTypeID, 
newMailConnectorName=new.MailConnectorName, 
newDescription=new.Description )
\p\g
create rule  rI_MailDB after INSERT into MailDB   execute procedure 
"mdbadmin". pI_MailDB ( newSourceID=new.SourceID, 
newMailDBID=new.MailDBID, newDBTitle=new.DBTitle, 
newDBFileName=new.DBFileName, newMailDBName=new.MailDBName, 
newDescription=new.Description )
\p\g
create rule  rI_MailDisk after INSERT into MailDisk   execute 
procedure "mdbadmin". pI_MailDisk ( newSourceID=new.SourceID, 
newMailDiskID=new.MailDiskID, newDiskSize=new.DiskSize, 
newMailDiskName=new.MailDiskName, newDescription=new.Description )
\p\g
create rule  rI_MailDomain after INSERT into MailDomain   execute 
procedure "mdbadmin". pI_MailDomain ( newSourceID=new.SourceID, 
newMailDomainID=new.MailDomainID, 
newMailDomainName=new.MailDomainName, newDescription=new.Description )
\p\g
create rule  rI_MailEvent after INSERT into MailEvent   execute 
procedure "mdbadmin". pI_MailEvent ( newSourceID=new.SourceID, 
newMailEventID=new.MailEventID, newEventTypeID=new.EventTypeID, 
newEventSeverityID=new.EventSeverityID, 
newMailEventName=new.MailEventName, newDescription=new.Description, 
newEventID=new.EventID, 
newDominoLogEventTypeID=new.DominoLogEventTypeID, 
newDominoEventTypeID=new.DominoEventTypeID )
\p\g
create rule  rI_MailObject after INSERT into MailObject   execute 
procedure "mdbadmin". pI_MailObject ( newSourceID=new.SourceID, 
newMailObjectID=new.MailObjectID, 
newMailObjectName=new.MailObjectName, 
newMailObjectType=new.MailObjectType, newDescription=new.Description )
\p\g
create rule  rI_MailQueue after INSERT into MailQueue   execute 
procedure "mdbadmin". pI_MailQueue ( newSourceID=new.SourceID, 
newMailQueueID=new.MailQueueID, newQueueType=new.QueueType, 
newMailQueueName=new.MailQueueName, newDescription=new.Description )
\p\g
create rule  rI_MailService after INSERT into MailService   execute 
procedure "mdbadmin". pI_MailService ( newSourceID=new.SourceID, 
newMailServiceID=new.MailServiceID, 
newMailServiceName=new.MailServiceName, newDescription=new.Description
)
\p\g
create rule  rI_MIBDefinition after INSERT into MIBDefinition   
execute procedure "mdbadmin". pI_MIBDefinition ( newMibIdx=new.MibIdx,
newMibType=new.MibType, newDescription=new.Description, 
newCollection=new.Collection, newmib_id=new.mib_id )
\p\g
create rule  rI_MibStructure after INSERT into MibStructure   execute 
procedure "mdbadmin". pI_MibStructure ( newMibIdx=new.MibIdx, 
newOidIdxForMIB=new.OidIdxForMIB, newOID=new.OID, newType=new.Type, 
newDiscoveryKey=new.DiscoveryKey, newIsIfIndex=new.IsIfIndex, 
newIsStatus=new.IsStatus, 
newComponentMibIndexIdx=new.ComponentMibIndexIdx )
\p\g
create rule  rI_MibVariableType after INSERT into MibVariableType   
execute procedure "mdbadmin". pI_MibVariableType ( 
newTypeId=new.TypeId, newCategory=new.Category, 
newSubcategory=new.Subcategory, newDescription=new.Description, 
newBaseTypeIdx=new.BaseTypeIdx, newCollectable=new.Collectable )
\p\g
create rule  rI_Objects after INSERT into Objects   execute procedure 
"mdbadmin". pI_Objects ( newObjectID=new.ObjectID, 
newObjectType=new.ObjectType, newObjectName=new.ObjectName, 
newDescription=new.Description, newObjectSourceID=new.ObjectSourceID, 
newClusterID=new.ClusterID, newDomainSourceID=new.DomainSourceID, 
newMailObjectID=new.MailObjectID, 
newServiceSourceID=new.ServiceSourceID, 
newMailDomainID=new.MailDomainID, newMailServiceID=new.MailServiceID, 
newConnectorSourceID=new.ConnectorSourceID, 
newMailConnectorID=new.MailConnectorID, newDBSourceID=new.DBSourceID, 
newMailDBID=new.MailDBID, newEventSourceID=new.EventSourceID, 
newMailEventID=new.MailEventID, newQueueSourceID=new.QueueSourceID, 
newMailQueueID=new.MailQueueID, newDiskSourceID=new.DiskSourceID, 
newMailDiskID=new.MailDiskID )
\p\g
create rule  rI_Person after INSERT into Server_Person   execute 
procedure "mdbadmin". pI_Person ( newSourceID=new.SourceID, 
newPersonID=new.PersonID, newPersonName=new.PersonName, 
newDescription=new.Description, newDisplayName=new.DisplayName, 
newMailFile=new.MailFile )
\p\g
create rule  rI_PollRowDefinition after INSERT into PollRowDefinition 
execute procedure "mdbadmin". pI_PollRowDefinition ( 
newRowId=new.RowId, newMibIdx=new.MibIdx, 
newOidIdxForMIB=new.OidIdxForMIB, newOidOrder=new.OidOrder, 
newRowDesc=new.RowDesc )
\p\g
create rule  rI_ReportColumn after INSERT into ReportColumn   execute 
procedure "mdbadmin". pI_ReportColumn ( newColumnID=new.ColumnID, 
newReportID=new.ReportID, newThresholdColumnID=new.ThresholdColumnID, 
newThresholdReportID=new.ThresholdReportID, 
newColumnName=new.ColumnName, newIsVisible=new.IsVisible, 
newSortBy=new.SortBy, newFormula=new.Formula, 
newIsDistinct=new.IsDistinct, newIsGroup=new.IsGroup, 
newTitle=new.Title, newPresentation=new.Presentation, 
newUnitID=new.UnitID, newInWorkSpace=new.InWorkSpace )
\p\g
create rule  rI_ReportTable after INSERT into ReportTable   execute 
procedure "mdbadmin". pI_ReportTable ( newCounterID=new.CounterID, 
newReportTableID=new.ReportTableID )
\p\g
create rule  rI_ResourceMonitoring after INSERT into 
ResourceMonitoring   execute procedure "mdbadmin". 
pI_ResourceMonitoring ( newserver_addr=new.server_addr, 
newprobe_addr=new.probe_addr, 
newIntervalDateTime=new.IntervalDateTime, newMibIdx=new.MibIdx, 
newMonitor=new.Monitor, newIndex1=new.Index1, newIndex2=new.Index2, 
newIndex3=new.Index3, newIndex4=new.Index4, newIndex5=new.Index5 )
\p\g
create rule  rI_Schedule after INSERT into Server_Schedule   execute 
procedure "mdbadmin". pI_Schedule ( newCollectorID=new.CollectorID, 
newActionID=new.ActionID, newScheduleType=new.ScheduleType, 
newStartDateTime=new.StartDateTime, newOccurs=new.Occurs, 
newDailyFrequency=new.DailyFrequency, newEvery=new.Every, 
newEndDateTime=new.EndDateTime, newSun=new.Sun, newMon=new.Mon, 
newTue=new.Tue, newWen=new.Wen, newThur=new.Thur, newFri=new.Fri, 
newSat=new.Sat, newDayType=new.DayType, 
newIntervalUnit=new.IntervalUnit, newDayOfMonth=new.DayOfMonth, 
newWeekNumber=new.WeekNumber, newWeekDay=new.WeekDay, 
newLastRunDate=new.LastRunDate, newTimeEvery=new.TimeEvery, 
newInScale=new.InScale )
\p\g
create rule  rI_Site after INSERT into Server_Site   execute procedure
"mdbadmin". pI_Site ( newSiteID=new.SiteID, 
newMailOrgID=new.MailOrgID, newSiteName=new.SiteName )
\p\g
create rule  rI_TablesDescription after INSERT into TablesDescription 
execute procedure "mdbadmin". pI_TablesDescription ( 
newOidIdxForMIB=new.OidIdxForMIB, newMibIdx=new.MibIdx, 
newTableIdx=new.TableIdx, newOrderOfColumn=new.OrderOfColumn, 
newTypeOfSaving=new.TypeOfSaving, newCollectable=new.Collectable )
\p\g
create rule  rI_tau_mdb_product after INSERT into tau_mdb_product   
execute procedure "mdbadmin". pI_tau_mdb_product ( 
newmdbMajorVersion=new.mdbMajorVersion, 
newmdbMinorVersion=new.mdbMinorVersion, 
newproductName=new.productName, 
newproductMajorVersion=new.productMajorVersion, 
newproductMinorVersion=new.productMinorVersion )
\p\g
create rule  rU_Alert after UPDATE of Management_Alert   execute 
procedure "mdbadmin". pU_Alert ( oldCounterID=old.CounterID, 
oldSourceID=old.SourceID, oldAlertID=old.AlertID, 
oldSource=old.Source, oldTStamp=old.TStamp, oldObjectID=old.ObjectID, 
oldPersonSourceID=old.PersonSourceID, oldPersonID=old.PersonID, 
oldStatus=old.Status, oldDescription=old.Description, 
oldThreshold=old.Threshold, oldPrevStatus=old.PrevStatus, 
oldIsSent=old.IsSent, oldCounterValue=old.CounterValue, 
oldStringValue=old.StringValue, oldDateValue=old.DateValue, 
newCounterID=new.CounterID, newSourceID=new.SourceID, 
newAlertID=new.AlertID, newSource=new.Source, newTStamp=new.TStamp, 
newObjectID=new.ObjectID, newPersonSourceID=new.PersonSourceID, 
newPersonID=new.PersonID, newStatus=new.Status, 
newDescription=new.Description, newThreshold=new.Threshold, 
newPrevStatus=new.PrevStatus, newIsSent=new.IsSent, 
newCounterValue=new.CounterValue, newStringValue=new.StringValue, 
newDateValue=new.DateValue )
\p\g
create rule  rU_Cluster after UPDATE of Cluster   execute procedure 
"mdbadmin". pU_Cluster ( oldClusterID=old.ClusterID, 
oldClusterName=old.ClusterName, oldClusterType=old.ClusterType, 
oldDescription=old.Description, newClusterID=new.ClusterID, 
newClusterName=new.ClusterName, newClusterType=new.ClusterType, 
newDescription=new.Description )
\p\g
create rule  rU_Collector after UPDATE of Server_Collector   execute 
procedure "mdbadmin". pU_Collector ( oldCollectorID=old.CollectorID, 
oldCollectorName=old.CollectorName, 
oldParentCollectorID=old.ParentCollectorID, oldHostName=old.HostName, 
oldServerName=old.ServerName, oldDBName=old.DBName, 
oldUserName=old.UserName, oldUserPsw=old.UserPsw, 
oldLogFileLocation=old.LogFileLocation, 
oldNeedRefresh=old.NeedRefresh, oldCollectorType=old.CollectorType, 
oldRawDataKeepInterval=old.RawDataKeepInterval, 
oldRawDataTimeFactor=old.RawDataTimeFactor, 
oldHourlyDataKeepInterval=old.HourlyDataKeepInterval, 
oldHourlyTimeFactor=old.HourlyTimeFactor, 
oldDailyDataKeepInterval=old.DailyDataKeepInterval, 
oldDailyTimeFactor=old.DailyTimeFactor, 
oldWeeklyDataKeepInterval=old.WeeklyDataKeepInterval, 
oldWeeklyTimeFactor=old.WeeklyTimeFactor, 
oldMonthlyDataKeepInterval=old.MonthlyDataKeepInterval, 
oldMonthlyTimeFactor=old.MonthlyTimeFactor, 
oldYearlyDataKeepInterval=old.YearlyDataKeepInterval, 
oldYearlyTimeFactor=old.YearlyTimeFactor, oldInactive=old.Inactive, 
oldTopNServers=old.TopNServers, oldTopNPersons=old.TopNPersons, 
oldTopNObjects=old.TopNObjects, oldAlertLimit=old.AlertLimit, 
oldIDFile1=old.IDFile1, oldIDFile2=old.IDFile2, 
oldOneIDFile=old.OneIDFile, oldIDFilePwd=old.IDFilePwd, 
newCollectorID=new.CollectorID, newCollectorName=new.CollectorName, 
newParentCollectorID=new.ParentCollectorID, newHostName=new.HostName, 
newServerName=new.ServerName, newDBName=new.DBName, 
newUserName=new.UserName, newUserPsw=new.UserPsw, 
newLogFileLocation=new.LogFileLocation, 
newNeedRefresh=new.NeedRefresh, newCollectorType=new.CollectorType, 
newRawDataKeepInterval=new.RawDataKeepInterval, 
newRawDataTimeFactor=new.RawDataTimeFactor, 
newHourlyDataKeepInterval=new.HourlyDataKeepInterval, 
newHourlyTimeFactor=new.HourlyTimeFactor, 
newDailyDataKeepInterval=new.DailyDataKeepInterval, 
newDailyTimeFactor=new.DailyTimeFactor, 
newWeeklyDataKeepInterval=new.WeeklyDataKeepInterval, 
newWeeklyTimeFactor=new.WeeklyTimeFactor, 
newMonthlyDataKeepInterval=new.MonthlyDataKeepInterval, 
newMonthlyTimeFactor=new.MonthlyTimeFactor, 
newYearlyDataKeepInterval=new.YearlyDataKeepInterval, 
newYearlyTimeFactor=new.YearlyTimeFactor, newInactive=new.Inactive, 
newTopNServers=new.TopNServers, newTopNPersons=new.TopNPersons, 
newTopNObjects=new.TopNObjects, newAlertLimit=new.AlertLimit, 
newIDFile1=new.IDFile1, newIDFile2=new.IDFile2, 
newOneIDFile=new.OneIDFile, newIDFilePwd=new.IDFilePwd )
\p\g
create rule  rU_CollectorPolling after UPDATE of CollectorPolling   
execute procedure "mdbadmin". pU_CollectorPolling ( 
oldCollectorID=old.CollectorID, oldCounterID=old.CounterID, 
newCollectorID=new.CollectorID, newCounterID=new.CounterID )
\p\g
create rule  rU_ColumnDefinition after UPDATE of ColumnDefinition   
execute procedure "mdbadmin". pU_ColumnDefinition ( 
oldTableIdx=old.TableIdx, oldOrderOfColumn=old.OrderOfColumn, 
oldName=old.Name, oldTypeId=old.TypeId, oldRollUpType=old.RollUpType, 
oldReportLabel=old.ReportLabel, newTableIdx=new.TableIdx, 
newOrderOfColumn=new.OrderOfColumn, newName=new.Name, 
newTypeId=new.TypeId, newRollUpType=new.RollUpType, 
newReportLabel=new.ReportLabel )
\p\g
create rule  rU_ComponentOfIndex after UPDATE of ComponentOfIndex   
execute procedure "mdbadmin". pU_ComponentOfIndex ( 
oldComponentMibIndexIdx=old.ComponentMibIndexIdx, 
oldComponentOfIndexOrder=old.ComponentOfIndexOrder, 
oldMibIdx=old.MibIdx, oldOidIdxForMIB=old.OidIdxForMIB, 
oldIndexStart=old.IndexStart, oldIndexLength=old.IndexLength, 
oldImplied=old.Implied, 
newComponentMibIndexIdx=new.ComponentMibIndexIdx, 
newComponentOfIndexOrder=new.ComponentOfIndexOrder, 
newMibIdx=new.MibIdx, newOidIdxForMIB=new.OidIdxForMIB, 
newIndexStart=new.IndexStart, newIndexLength=new.IndexLength, 
newImplied=new.Implied )
\p\g
create rule  rU_ConnectorType after UPDATE of ConnectorType   execute 
procedure "mdbadmin". pU_ConnectorType ( 
oldConnectorTypeID=old.ConnectorTypeID, 
oldConnectorTypeName=old.ConnectorTypeName, 
newConnectorTypeID=new.ConnectorTypeID, 
newConnectorTypeName=new.ConnectorTypeName )
\p\g
create rule  rU_CounterData after UPDATE of CounterData   execute 
procedure "mdbadmin". pU_CounterData ( oldCounterID=old.CounterID, 
oldSourceID=old.SourceID, oldCounterDataID=old.CounterDataID, 
oldTStamp=old.TStamp, oldObjectID=old.ObjectID, 
oldPersonSourceID=old.PersonSourceID, oldPersonID=old.PersonID, 
oldDelta=old.Delta, oldWarningThreshold=old.WarningThreshold, 
oldCriticalThreshold=old.CriticalThreshold, oldIsSent=old.IsSent, 
oldTimeInterval=old.TimeInterval, oldCounterValue=old.CounterValue, 
oldStringValue=old.StringValue, oldDateValue=old.DateValue, 
newCounterID=new.CounterID, newSourceID=new.SourceID, 
newCounterDataID=new.CounterDataID, newTStamp=new.TStamp, 
newObjectID=new.ObjectID, newPersonSourceID=new.PersonSourceID, 
newPersonID=new.PersonID, newDelta=new.Delta, 
newWarningThreshold=new.WarningThreshold, 
newCriticalThreshold=new.CriticalThreshold, newIsSent=new.IsSent, 
newTimeInterval=new.TimeInterval, newCounterValue=new.CounterValue, 
newStringValue=new.StringValue, newDateValue=new.DateValue )
\p\g
create rule  rU_CounterPolling after UPDATE of CounterPolling   
execute procedure "mdbadmin". pU_CounterPolling ( 
oldSourceID=old.SourceID, oldCounterID=old.CounterID, 
newSourceID=new.SourceID, newCounterID=new.CounterID )
\p\g
create rule  rU_CounterSource after UPDATE of CounterSource   execute 
procedure "mdbadmin". pU_CounterSource ( oldSourceID=old.SourceID, 
oldCollectorID=old.CollectorID, oldLocaleID=old.LocaleID, 
oldClusterID=old.ClusterID, oldSiteID=old.SiteID, 
oldSourceName=old.SourceName, oldSourceType=old.SourceType, 
oldHostName=old.HostName, oldActiveState=old.ActiveState, 
oldUserName=old.UserName, oldUserPwd=old.UserPwd, 
oldHostName1=old.HostName1, oldHostName2=old.HostName2, 
oldHostName3=old.HostName3, oldSrcTimeZone=old.SrcTimeZone, 
oldMailOrgID=old.MailOrgID, newSourceID=new.SourceID, 
newCollectorID=new.CollectorID, newLocaleID=new.LocaleID, 
newClusterID=new.ClusterID, newSiteID=new.SiteID, 
newSourceName=new.SourceName, newSourceType=new.SourceType, 
newHostName=new.HostName, newActiveState=new.ActiveState, 
newUserName=new.UserName, newUserPwd=new.UserPwd, 
newHostName1=new.HostName1, newHostName2=new.HostName2, 
newHostName3=new.HostName3, newSrcTimeZone=new.SrcTimeZone, 
newMailOrgID=new.MailOrgID )
\p\g
create rule  rU_CounterTitle after UPDATE of CounterTitle   execute 
procedure "mdbadmin". pU_CounterTitle ( oldLocaleID=old.LocaleID, 
oldCounterID=old.CounterID, oldSourceType=old.SourceType, 
oldFullCounterName=old.FullCounterName, newLocaleID=new.LocaleID, 
newCounterID=new.CounterID, newSourceType=new.SourceType, 
newFullCounterName=new.FullCounterName )
\p\g
create rule  rU_DiscoveryVariable after UPDATE of DiscoveryVariable   
execute procedure "mdbadmin". pU_DiscoveryVariable ( 
oldMibIdx=old.MibIdx, oldTypeId=old.TypeId, 
oldOidIdxForMIB=old.OidIdxForMIB, oldDiscGet=old.DiscGet, 
oldDiscRespLocation=old.DiscRespLocation, 
oldDiscRespValue=old.DiscRespValue, oldOper=old.Oper, 
oldDescription=old.Description, newMibIdx=new.MibIdx, 
newTypeId=new.TypeId, newOidIdxForMIB=new.OidIdxForMIB, 
newDiscGet=new.DiscGet, newDiscRespLocation=new.DiscRespLocation, 
newDiscRespValue=new.DiscRespValue, newOper=new.Oper, 
newDescription=new.Description )
\p\g
create rule  rU_DominoEventType after UPDATE of DominoEventType   
execute procedure "mdbadmin". pU_DominoEventType ( 
oldDominoEventTypeID=old.DominoEventTypeID, 
oldDominoEventTypeName=old.DominoEventTypeName, 
newDominoEventTypeID=new.DominoEventTypeID, 
newDominoEventTypeName=new.DominoEventTypeName )
\p\g
create rule  rU_DominoLogEventType after UPDATE of DominoLogEventType 
execute procedure "mdbadmin". pU_DominoLogEventType ( 
oldDominoLogEventTypeID=old.DominoLogEventTypeID, 
oldDominoLogEventTypeName=old.DominoLogEventTypeName, 
newDominoLogEventTypeID=new.DominoLogEventTypeID, 
newDominoLogEventTypeName=new.DominoLogEventTypeName )
\p\g
create rule  rU_ErrorMessage after UPDATE of ErrorMessage   execute 
procedure "mdbadmin". pU_ErrorMessage ( 
oldErrorMessageID=old.ErrorMessageID, oldSourceType=old.SourceType, 
oldMessageText=old.MessageText, newErrorMessageID=new.ErrorMessageID, 
newSourceType=new.SourceType, newMessageText=new.MessageText )
\p\g
create rule  rU_ErrorSolution after UPDATE of ErrorSolution   execute 
procedure "mdbadmin". pU_ErrorSolution ( 
oldErrorMessageID=old.ErrorMessageID, 
oldSolutionDescriptionID=old.SolutionDescriptionID, 
newErrorMessageID=new.ErrorMessageID, 
newSolutionDescriptionID=new.SolutionDescriptionID )
\p\g
create rule  rU_EventSeverity after UPDATE of EventSeverity   execute 
procedure "mdbadmin". pU_EventSeverity ( 
oldEventSeverityID=old.EventSeverityID, 
oldEventSeverityName=old.EventSeverityName, 
newEventSeverityID=new.EventSeverityID, 
newEventSeverityName=new.EventSeverityName )
\p\g
create rule  rU_EventType after UPDATE of EventType   execute 
procedure "mdbadmin". pU_EventType ( oldEventTypeID=old.EventTypeID, 
oldEventTypeName=old.EventTypeName, newEventTypeID=new.EventTypeID, 
newEventTypeName=new.EventTypeName )
\p\g
create rule  rU_GDCDiscovery after UPDATE of GDCDiscovery   execute 
procedure "mdbadmin". pU_GDCDiscovery ( 
oldserver_addr=old.server_addr, oldprobe_addr=old.probe_addr, 
oldMibIdx=old.MibIdx, oldIntervalDateTime=old.IntervalDateTime, 
oldDiscovered=old.Discovered, newserver_addr=new.server_addr, 
newprobe_addr=new.probe_addr, newMibIdx=new.MibIdx, 
newIntervalDateTime=new.IntervalDateTime, newDiscovered=new.Discovered
)
\p\g
create rule  rU_IndexTable after UPDATE of IndexTable   execute 
procedure "mdbadmin". pU_IndexTable ( 
oldComponentMibIndexIdx=old.ComponentMibIndexIdx, 
oldTypeOfIndexRetrieval=old.TypeOfIndexRetrieval, 
oldIndexBaseOID=old.IndexBaseOID, oldIndexStartLoc=old.IndexStartLoc, 
oldIndexLength=old.IndexLength, oldColOidId=old.ColOidId, 
newComponentMibIndexIdx=new.ComponentMibIndexIdx, 
newTypeOfIndexRetrieval=new.TypeOfIndexRetrieval, 
newIndexBaseOID=new.IndexBaseOID, newIndexStartLoc=new.IndexStartLoc, 
newIndexLength=new.IndexLength, newColOidId=new.ColOidId )
\p\g
create rule  rU_MailConnector after UPDATE of MailConnector   execute 
procedure "mdbadmin". pU_MailConnector ( oldSourceID=old.SourceID, 
oldMailConnectorID=old.MailConnectorID, 
oldConnectorTypeID=old.ConnectorTypeID, 
oldMailConnectorName=old.MailConnectorName, 
oldDescription=old.Description, newSourceID=new.SourceID, 
newMailConnectorID=new.MailConnectorID, 
newConnectorTypeID=new.ConnectorTypeID, 
newMailConnectorName=new.MailConnectorName, 
newDescription=new.Description )
\p\g
create rule  rU_MailDB after UPDATE of MailDB   execute procedure 
"mdbadmin". pU_MailDB ( oldSourceID=old.SourceID, 
oldMailDBID=old.MailDBID, oldDBTitle=old.DBTitle, 
oldDBFileName=old.DBFileName, oldMailDBName=old.MailDBName, 
oldDescription=old.Description, newSourceID=new.SourceID, 
newMailDBID=new.MailDBID, newDBTitle=new.DBTitle, 
newDBFileName=new.DBFileName, newMailDBName=new.MailDBName, 
newDescription=new.Description )
\p\g
create rule  rU_MailDisk after UPDATE of MailDisk   execute procedure 
"mdbadmin". pU_MailDisk ( oldSourceID=old.SourceID, 
oldMailDiskID=old.MailDiskID, oldDiskSize=old.DiskSize, 
oldMailDiskName=old.MailDiskName, oldDescription=old.Description, 
newSourceID=new.SourceID, newMailDiskID=new.MailDiskID, 
newDiskSize=new.DiskSize, newMailDiskName=new.MailDiskName, 
newDescription=new.Description )
\p\g
create rule  rU_MailDomain after UPDATE of MailDomain   execute 
procedure "mdbadmin". pU_MailDomain ( oldSourceID=old.SourceID, 
oldMailDomainID=old.MailDomainID, 
oldMailDomainName=old.MailDomainName, oldDescription=old.Description, 
newSourceID=new.SourceID, newMailDomainID=new.MailDomainID, 
newMailDomainName=new.MailDomainName, newDescription=new.Description )
\p\g
create rule  rU_MailEvent after UPDATE of MailEvent   execute 
procedure "mdbadmin". pU_MailEvent ( oldSourceID=old.SourceID, 
oldMailEventID=old.MailEventID, oldEventTypeID=old.EventTypeID, 
oldEventSeverityID=old.EventSeverityID, 
oldMailEventName=old.MailEventName, oldDescription=old.Description, 
oldEventID=old.EventID, 
oldDominoLogEventTypeID=old.DominoLogEventTypeID, 
oldDominoEventTypeID=old.DominoEventTypeID, newSourceID=new.SourceID, 
newMailEventID=new.MailEventID, newEventTypeID=new.EventTypeID, 
newEventSeverityID=new.EventSeverityID, 
newMailEventName=new.MailEventName, newDescription=new.Description, 
newEventID=new.EventID, 
newDominoLogEventTypeID=new.DominoLogEventTypeID, 
newDominoEventTypeID=new.DominoEventTypeID )
\p\g
create rule  rU_MailObject after UPDATE of MailObject   execute 
procedure "mdbadmin". pU_MailObject ( oldSourceID=old.SourceID, 
oldMailObjectID=old.MailObjectID, 
oldMailObjectName=old.MailObjectName, 
oldMailObjectType=old.MailObjectType, oldDescription=old.Description, 
newSourceID=new.SourceID, newMailObjectID=new.MailObjectID, 
newMailObjectName=new.MailObjectName, 
newMailObjectType=new.MailObjectType, newDescription=new.Description )
\p\g
create rule  rU_MailOrganisation after UPDATE of MailOrganisation   
execute procedure "mdbadmin". pU_MailOrganisation ( 
oldMailOrgID=old.MailOrgID, oldOrganisationName=old.OrganisationName, 
newMailOrgID=new.MailOrgID, newOrganisationName=new.OrganisationName )
\p\g
create rule  rU_MailQueue after UPDATE of MailQueue   execute 
procedure "mdbadmin". pU_MailQueue ( oldSourceID=old.SourceID, 
oldMailQueueID=old.MailQueueID, oldQueueType=old.QueueType, 
oldMailQueueName=old.MailQueueName, oldDescription=old.Description, 
newSourceID=new.SourceID, newMailQueueID=new.MailQueueID, 
newQueueType=new.QueueType, newMailQueueName=new.MailQueueName, 
newDescription=new.Description )
\p\g
create rule  rU_MailService after UPDATE of MailService   execute 
procedure "mdbadmin". pU_MailService ( oldSourceID=old.SourceID, 
oldMailServiceID=old.MailServiceID, 
oldMailServiceName=old.MailServiceName, 
oldDescription=old.Description, newSourceID=new.SourceID, 
newMailServiceID=new.MailServiceID, 
newMailServiceName=new.MailServiceName, newDescription=new.Description
)
\p\g
create rule  rU_MIBDefinition after UPDATE of MIBDefinition   execute 
procedure "mdbadmin". pU_MIBDefinition ( oldMibIdx=old.MibIdx, 
oldMibType=old.MibType, oldDescription=old.Description, 
oldCollection=old.Collection, oldmib_id=old.mib_id, 
newMibIdx=new.MibIdx, newMibType=new.MibType, 
newDescription=new.Description, newCollection=new.Collection, 
newmib_id=new.mib_id )
\p\g
create rule  rU_MibStructure after UPDATE of MibStructure   execute 
procedure "mdbadmin". pU_MibStructure ( oldMibIdx=old.MibIdx, 
oldOidIdxForMIB=old.OidIdxForMIB, oldOID=old.OID, oldType=old.Type, 
oldDiscoveryKey=old.DiscoveryKey, oldIsIfIndex=old.IsIfIndex, 
oldIsStatus=old.IsStatus, 
oldComponentMibIndexIdx=old.ComponentMibIndexIdx, 
newMibIdx=new.MibIdx, newOidIdxForMIB=new.OidIdxForMIB, 
newOID=new.OID, newType=new.Type, newDiscoveryKey=new.DiscoveryKey, 
newIsIfIndex=new.IsIfIndex, newIsStatus=new.IsStatus, 
newComponentMibIndexIdx=new.ComponentMibIndexIdx )
\p\g
create rule  rU_MibVariableType after UPDATE of MibVariableType   
execute procedure "mdbadmin". pU_MibVariableType ( 
oldTypeId=old.TypeId, oldCategory=old.Category, 
oldSubcategory=old.Subcategory, oldDescription=old.Description, 
oldBaseTypeIdx=old.BaseTypeIdx, oldCollectable=old.Collectable, 
newTypeId=new.TypeId, newCategory=new.Category, 
newSubcategory=new.Subcategory, newDescription=new.Description, 
newBaseTypeIdx=new.BaseTypeIdx, newCollectable=new.Collectable )
\p\g
create rule  rU_Objects after UPDATE of Objects   execute procedure 
"mdbadmin". pU_Objects ( oldObjectID=old.ObjectID, 
oldObjectType=old.ObjectType, oldObjectName=old.ObjectName, 
oldDescription=old.Description, oldObjectSourceID=old.ObjectSourceID, 
oldClusterID=old.ClusterID, oldDomainSourceID=old.DomainSourceID, 
oldMailObjectID=old.MailObjectID, 
oldServiceSourceID=old.ServiceSourceID, 
oldMailDomainID=old.MailDomainID, oldMailServiceID=old.MailServiceID, 
oldConnectorSourceID=old.ConnectorSourceID, 
oldMailConnectorID=old.MailConnectorID, oldDBSourceID=old.DBSourceID, 
oldMailDBID=old.MailDBID, oldEventSourceID=old.EventSourceID, 
oldMailEventID=old.MailEventID, oldQueueSourceID=old.QueueSourceID, 
oldMailQueueID=old.MailQueueID, oldDiskSourceID=old.DiskSourceID, 
oldMailDiskID=old.MailDiskID, newObjectID=new.ObjectID, 
newObjectType=new.ObjectType, newObjectName=new.ObjectName, 
newDescription=new.Description, newObjectSourceID=new.ObjectSourceID, 
newClusterID=new.ClusterID, newDomainSourceID=new.DomainSourceID, 
newMailObjectID=new.MailObjectID, 
newServiceSourceID=new.ServiceSourceID, 
newMailDomainID=new.MailDomainID, newMailServiceID=new.MailServiceID, 
newConnectorSourceID=new.ConnectorSourceID, 
newMailConnectorID=new.MailConnectorID, newDBSourceID=new.DBSourceID, 
newMailDBID=new.MailDBID, newEventSourceID=new.EventSourceID, 
newMailEventID=new.MailEventID, newQueueSourceID=new.QueueSourceID, 
newMailQueueID=new.MailQueueID, newDiskSourceID=new.DiskSourceID, 
newMailDiskID=new.MailDiskID )
\p\g
create rule  rU_Person after UPDATE of Server_Person   execute 
procedure "mdbadmin". pU_Person ( oldSourceID=old.SourceID, 
oldPersonID=old.PersonID, oldPersonName=old.PersonName, 
oldDescription=old.Description, oldDisplayName=old.DisplayName, 
oldMailFile=old.MailFile, newSourceID=new.SourceID, 
newPersonID=new.PersonID, newPersonName=new.PersonName, 
newDescription=new.Description, newDisplayName=new.DisplayName, 
newMailFile=new.MailFile )
\p\g
create rule  rU_PollRowDefinition after UPDATE of PollRowDefinition   
execute procedure "mdbadmin". pU_PollRowDefinition ( 
oldRowId=old.RowId, oldMibIdx=old.MibIdx, 
oldOidIdxForMIB=old.OidIdxForMIB, oldOidOrder=old.OidOrder, 
oldRowDesc=old.RowDesc, newRowId=new.RowId, newMibIdx=new.MibIdx, 
newOidIdxForMIB=new.OidIdxForMIB, newOidOrder=new.OidOrder, 
newRowDesc=new.RowDesc )
\p\g
create rule  rU_ReportColumn after UPDATE of ReportColumn   execute 
procedure "mdbadmin". pU_ReportColumn ( oldColumnID=old.ColumnID, 
oldReportID=old.ReportID, oldThresholdColumnID=old.ThresholdColumnID, 
oldThresholdReportID=old.ThresholdReportID, 
oldColumnName=old.ColumnName, oldIsVisible=old.IsVisible, 
oldSortBy=old.SortBy, oldFormula=old.Formula, 
oldIsDistinct=old.IsDistinct, oldIsGroup=old.IsGroup, 
oldTitle=old.Title, oldPresentation=old.Presentation, 
oldUnitID=old.UnitID, oldInWorkSpace=old.InWorkSpace, 
newColumnID=new.ColumnID, newReportID=new.ReportID, 
newThresholdColumnID=new.ThresholdColumnID, 
newThresholdReportID=new.ThresholdReportID, 
newColumnName=new.ColumnName, newIsVisible=new.IsVisible, 
newSortBy=new.SortBy, newFormula=new.Formula, 
newIsDistinct=new.IsDistinct, newIsGroup=new.IsGroup, 
newTitle=new.Title, newPresentation=new.Presentation, 
newUnitID=new.UnitID, newInWorkSpace=new.InWorkSpace )
\p\g
create rule  rU_ReportTable after UPDATE of ReportTable   execute 
procedure "mdbadmin". pU_ReportTable ( oldCounterID=old.CounterID, 
oldReportTableID=old.ReportTableID, newCounterID=new.CounterID, 
newReportTableID=new.ReportTableID )
\p\g
create rule  rU_ResourceMonitoring after UPDATE of ResourceMonitoring 
execute procedure "mdbadmin". pU_ResourceMonitoring ( 
oldserver_addr=old.server_addr, oldprobe_addr=old.probe_addr, 
oldIntervalDateTime=old.IntervalDateTime, oldMibIdx=old.MibIdx, 
oldMonitor=old.Monitor, oldIndex1=old.Index1, oldIndex2=old.Index2, 
oldIndex3=old.Index3, oldIndex4=old.Index4, oldIndex5=old.Index5, 
newserver_addr=new.server_addr, newprobe_addr=new.probe_addr, 
newIntervalDateTime=new.IntervalDateTime, newMibIdx=new.MibIdx, 
newMonitor=new.Monitor, newIndex1=new.Index1, newIndex2=new.Index2, 
newIndex3=new.Index3, newIndex4=new.Index4, newIndex5=new.Index5 )
\p\g
create rule  rU_Schedule after UPDATE of Server_Schedule   execute 
procedure "mdbadmin". pU_Schedule ( oldCollectorID=old.CollectorID, 
oldActionID=old.ActionID, oldScheduleType=old.ScheduleType, 
oldStartDateTime=old.StartDateTime, oldOccurs=old.Occurs, 
oldDailyFrequency=old.DailyFrequency, oldEvery=old.Every, 
oldEndDateTime=old.EndDateTime, oldSun=old.Sun, oldMon=old.Mon, 
oldTue=old.Tue, oldWen=old.Wen, oldThur=old.Thur, oldFri=old.Fri, 
oldSat=old.Sat, oldDayType=old.DayType, 
oldIntervalUnit=old.IntervalUnit, oldDayOfMonth=old.DayOfMonth, 
oldWeekNumber=old.WeekNumber, oldWeekDay=old.WeekDay, 
oldLastRunDate=old.LastRunDate, oldTimeEvery=old.TimeEvery, 
oldInScale=old.InScale, newCollectorID=new.CollectorID, 
newActionID=new.ActionID, newScheduleType=new.ScheduleType, 
newStartDateTime=new.StartDateTime, newOccurs=new.Occurs, 
newDailyFrequency=new.DailyFrequency, newEvery=new.Every, 
newEndDateTime=new.EndDateTime, newSun=new.Sun, newMon=new.Mon, 
newTue=new.Tue, newWen=new.Wen, newThur=new.Thur, newFri=new.Fri, 
newSat=new.Sat, newDayType=new.DayType, 
newIntervalUnit=new.IntervalUnit, newDayOfMonth=new.DayOfMonth, 
newWeekNumber=new.WeekNumber, newWeekDay=new.WeekDay, 
newLastRunDate=new.LastRunDate, newTimeEvery=new.TimeEvery, 
newInScale=new.InScale )
\p\g
create rule  rU_Site after UPDATE of Server_Site   execute procedure 
"mdbadmin". pU_Site ( oldSiteID=old.SiteID, 
oldMailOrgID=old.MailOrgID, oldSiteName=old.SiteName, 
newSiteID=new.SiteID, newMailOrgID=new.MailOrgID, 
newSiteName=new.SiteName )
\p\g
create rule  rU_SolutionDescription after UPDATE of 
SolutionDescription   execute procedure "mdbadmin". 
pU_SolutionDescription ( 
oldSolutionDescriptionID=old.SolutionDescriptionID, 
oldSolutionText=old.SolutionText, 
newSolutionDescriptionID=new.SolutionDescriptionID, 
newSolutionText=new.SolutionText )
\p\g
create rule  rU_SourceLocale after UPDATE of SourceLocale   execute 
procedure "mdbadmin". pU_SourceLocale ( oldLocaleID=old.LocaleID, 
oldLocaleName=old.LocaleName, oldLangCode=old.LangCode, 
oldSourceType=old.SourceType, oldJavaLocale=old.JavaLocale, 
newLocaleID=new.LocaleID, newLocaleName=new.LocaleName, 
newLangCode=new.LangCode, newSourceType=new.SourceType, 
newJavaLocale=new.JavaLocale )
\p\g
create rule  rU_TableDefinition after UPDATE of TableDefinition   
execute procedure "mdbadmin". pU_TableDefinition ( 
oldTableIdx=old.TableIdx, oldNameOfTable=old.NameOfTable, 
newTableIdx=new.TableIdx, newNameOfTable=new.NameOfTable )
\p\g
create rule  rU_TablesDescription after UPDATE of TablesDescription   
execute procedure "mdbadmin". pU_TablesDescription ( 
oldOidIdxForMIB=old.OidIdxForMIB, oldMibIdx=old.MibIdx, 
oldTableIdx=old.TableIdx, oldOrderOfColumn=old.OrderOfColumn, 
oldTypeOfSaving=old.TypeOfSaving, oldCollectable=old.Collectable, 
newOidIdxForMIB=new.OidIdxForMIB, newMibIdx=new.MibIdx, 
newTableIdx=new.TableIdx, newOrderOfColumn=new.OrderOfColumn, 
newTypeOfSaving=new.TypeOfSaving, newCollectable=new.Collectable )
\p\g
create rule  rU_tau_mdb after UPDATE of tau_mdb   execute procedure 
"mdbadmin". pU_tau_mdb ( oldmdbMajorVersion=old.mdbMajorVersion, 
oldmdbMinorVersion=old.mdbMinorVersion, 
oldreleaseDate=old.releaseDate, oldinstallDate=old.installDate, 
newmdbMajorVersion=new.mdbMajorVersion, 
newmdbMinorVersion=new.mdbMinorVersion, 
newreleaseDate=new.releaseDate, newinstallDate=new.installDate )
\p\g
create rule  rU_tau_mdb_product after UPDATE of tau_mdb_product   
execute procedure "mdbadmin". pU_tau_mdb_product ( 
oldmdbMajorVersion=old.mdbMajorVersion, 
oldmdbMinorVersion=old.mdbMinorVersion, 
oldproductName=old.productName, 
oldproductMajorVersion=old.productMajorVersion, 
oldproductMinorVersion=old.productMinorVersion, 
newmdbMajorVersion=new.mdbMajorVersion, 
newmdbMinorVersion=new.mdbMinorVersion, 
newproductName=new.productName, 
newproductMajorVersion=new.productMajorVersion, 
newproductMinorVersion=new.productMinorVersion )
\p\g
create rule  rU_tau_product after UPDATE of tau_product   execute 
procedure "mdbadmin". pU_tau_product ( oldproductName=old.productName,
oldproductMajorVersion=old.productMajorVersion, 
oldproductMinorVersion=old.productMinorVersion, 
oldreleaseDate=old.releaseDate, oldinstallCount=old.installCount, 
newproductName=new.productName, 
newproductMajorVersion=new.productMajorVersion, 
newproductMinorVersion=new.productMinorVersion, 
newreleaseDate=new.releaseDate, newinstallCount=new.installCount )
\p\g
create rule  tng_td_class after delete into tng_class execute 
procedure "mdbadmin". tng_log_change_hist(v_operation = 'D', 
v_class_name = new.name, v_uuid = '0')
\p\g
create rule  tng_td_inclusion after delete from tng_inclusion execute 
procedure "mdbadmin". tng_td_inclusion ( uuid_old = old.uuid, 
parent_uuid_old = old.parent_uuid, child_uuid_old = old.child_uuid, 
parent_sequence_no_old = old.parent_sequence_no, child_sequence_no_old
= old.child_sequence_no )
\p\g
create rule  tng_td_jii_inclusion after delete from tng_Jii_Inclusion 
execute procedure "mdbadmin". tng_td_jii_inclusion( uuid = 
tng_Jii_Inclusion.uuid, parent_uuid = tng_Jii_Inclusion.parent_uuid, 
parent_sequence_no = tng_Jii_Inclusion.parent_sequence_no)
\p\g
create rule  tng_td_link after delete from tng_link execute procedure 
"mdbadmin". tng_td_link ( class_name_old = old.class_name, uuid_old = 
old.uuid, source_port_old = old.source_port, source_uuid_old = 
old.source_uuid, dest_port_old = old.dest_port, dest_uuid_old = 
old.dest_uuid, source_seq_old = old.source_seq, dest_seq_old = 
old.dest_seq, implied_new = new.implied)
\p\g
create rule  tng_td_managedobject after delete from tng_managedobject 
execute procedure "mdbadmin". tng_td_managedobject ( class_name_old = 
old.class_name, uuid_old = old.uuid)
\p\g
create rule  tng_ti_class after insert into tng_class execute 
procedure "mdbadmin". tng_log_change_hist(v_operation = 'I', 
v_class_name = new.name, v_uuid = '0')
\p\g
create rule  tng_ti_class_prop after insert into tng_class_ext execute
procedure "mdbadmin". tng_ti_class_prop(v_class_id = new.class_id)
\p\g
create rule  tng_ti_inclusion after insert into tng_inclusion execute 
procedure "mdbadmin". tng_ti_inclusion ( uuid_new = new.uuid, 
child_uuid_new = new.child_uuid, child_sequence_no_new = 
new.child_sequence_no )
\p\g
create rule  tng_ti_jii_inclusion after insert into tng_Jii_Inclusion 
execute procedure "mdbadmin". tng_ti_jii_inclusion( uuid = 
tng_Jii_Inclusion.uuid, parent_uuid = tng_Jii_Inclusion.parent_uuid, 
parent_sequence_no = tng_Jii_Inclusion.parent_sequence_no)
\p\g
create rule  tng_ti_link after insert into tng_link execute procedure 
"mdbadmin". tng_ti_link ( class_name_new = new.class_name, uuid_new = 
new.uuid )
\p\g
create rule  tng_ti_managedobject after insert into tng_managedobject 
execute procedure "mdbadmin". tng_ti_managedobject ( class_name_new = 
new.class_name, uuid_new = new.uuid, v_weight=new.weight, 
v_severity=new.severity, v_prop_sev=new.propagated_sev)
\p\g
create rule  tng_tu_class_instance after insert into 
tng_property_definition execute procedure "mdbadmin". 
tng_ti_class_prop(v_class_id = new.class_id)
\p\g
create rule  tng_tu_class_prop after update into tng_class_ext execute
procedure "mdbadmin". tng_tu_class_prop(v_class_id = new.class_id)
\p\g
create rule  tng_tu_inclusion after update into tng_inclusion execute 
procedure "mdbadmin". tng_tu_inclusion ( uuid_old = old.uuid, uuid_new
= new.uuid, parent_class_old = old.parent_class, parent_class_new = 
new.parent_class, parent_uuid_old = old.parent_uuid, parent_uuid_new =
new.parent_uuid, parent_repository_old = old.parent_repository, 
parent_repository_new = new.parent_repository, child_class_old = 
old.child_class, child_class_new = new.child_class, child_uuid_old = 
old.child_uuid, child_uuid_new = new.child_uuid, child_repository_old 
= old.child_repository, child_repository_new = new.child_repository, 
parent_sequence_no_old = old.parent_sequence_no, child_sequence_no_old
= old.child_sequence_no, hidden_old = old.hidden, hidden_new = 
new.hidden, coord_type_old = old.coord_type, coord_type_new = 
new.coord_type, position_x_old = old.position_x, position_x_new = 
new.position_x, position_y_old = old.position_y, position_y_new = 
new.position_y, position_z_old = old.position_z, position_z_new = 
new.position_z, size_cx_old = old.size_cx, size_cx_new = new.size_cx, 
size_cy_old = old.size_cy, size_cy_new = new.size_cy, size_cz_old = 
old.size_cz, size_cz_new = new.size_cz )
\p\g
create rule  tng_tu_jii_inclusion after update into tng_Jii_Inclusion 
execute procedure "mdbadmin". tng_tu_jii_inclusion( uuid = 
tng_Jii_Inclusion.uuid, parent_uuid = tng_Jii_Inclusion.parent_uuid, 
parent_sequence_no = tng_Jii_Inclusion.parent_sequence_no)
\p\g
create rule  tng_tu_link_change_hist after update( label, name, 
source_class, source_uuid, source_repository, source_port, dest_class,
dest_uuid, dest_repository, dest_port, hidden, direction, unimplied) 
on tng_link execute procedure "mdbadmin". tng_tu_link_change_hist( 
v_class_name_old = old.class_name, v_uuid_old = old.uuid)
\p\g
create rule  tng_tu_link_del_implinks after update(unimplied) on 
tng_link execute procedure "mdbadmin". tng_tu_link_del_implinks_proc( 
v_old_unimplied = old.unimplied, v_new_unimplied = new.unimplied, 
v_uuid_old = old.uuid)
\p\g
create rule  tng_tu_link_status_hist after update (status_no, 
severity, alarmset_name) on tng_link execute procedure "mdbadmin". 
tng_tu_link_status_hist( v_class_name_new = new.class_name, v_uuid_new
= new.uuid, v_status_no_old = old.status_no, v_status_no_new = 
new.status_no, v_severity_old = old.severity, v_severity_new = 
new.severity, v_alarmset_name_old = old.alarmset_name, 
v_alarmset_name_new = new.alarmset_name, v_implied_new = new.implied)
\p\g
create rule  tng_tu_link_update_err after update (class_name, uuid, 
implied, parent_link) on tng_link execute procedure "mdbadmin". 
tng_tu_link_update_err
\p\g
create rule  tng_tu_manobj_change_hist after update( label, name, 
address, mac_address, address_type, interface_type, autoarrange_type, 
acknowledge, propagate_status, hidden, posted, ip_address_hex, 
subnet_mask, DSM_Server, admin_status, DSM_Address,weight, 
alarmset_name,override_imagelarge,override_imagesmall, 
override_imagedecal,override_imagetintbool,override_model, 
background_image) on tng_managedobject execute procedure "mdbadmin". 
tng_tu_manobj_change_hist( v_class_name_old = old.class_name, 
v_uuid_old = old.uuid, v_uuid_new = new.uuid, v_acknowledge_old = 
old.acknowledge, v_acknowledge_new = new.acknowledge, 
v_hidden_old=old.hidden, v_hidden_new=new.hidden, 
v_weight_old=old.weight, v_weight_new=new.weight)
\p\g
create rule  tng_tu_manobj_prop_hist after update (propagated_sev) on 
tng_managedobject execute procedure "mdbadmin". 
tng_tu_manobj_prop_hist( v_class_name_new = new.class_name, v_uuid_new
= new.uuid, v_status_no_new = new.propagated_status_no, 
v_propagated_sev_new = new.propagated_sev)
\p\g
create rule  tng_tu_manobj_status_hist after update (status_no, 
severity, alarmset_name) on tng_managedobject execute procedure 
"mdbadmin". tng_tu_manobj_status_hist( v_class_name_new = 
new.class_name, v_uuid_new = new.uuid, v_status_no_old = 
old.status_no, v_status_no_new = new.status_no, v_severity_old = 
old.severity, v_severity_new = new.severity, v_alarmset_name_old = 
old.alarmset_name, v_alarmset_name_new = new.alarmset_name, 
v_propagate_status_old = old.propagate_status, v_propagate_status_new 
= new.propagate_status, v_acknowledge_old = old.acknowledge, 
v_acknowledge_new = new.acknowledge)
\p\g
create rule  tng_tu_manobj_update_err after update (class_name, uuid) 
on tng_managedobject execute procedure "mdbadmin". 
tng_tu_manobj_update_err
\p\g
create rule  tng_tu_prop_instance after update into 
tng_property_definition execute procedure "mdbadmin". 
tng_tu_class_prop(v_class_id = new.class_id)
\p\g
