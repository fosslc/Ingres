/*
** Copyright (c) 2004 Ingres Corporation
**
*/
/*
**
**  Name: crscan.c -- scanner for INGRES configuration rule specification
**	syntax (ICRSS).
**
**  Description:
**	The functions defined in this module are functionally equivalent
**	to those generated by LEX.
**
**  History:
**	18-jan-93 (tyler)
**		Adapted from LEX scanner.
**	16-feb-93 (tyler)
**		Fixed bug which caused CRinit() not to find the default
**		rule file map.
**	24-may-93 (tyler)
**		Added argument to PMmInit() call.
**	21-jun-93 (tyler)
**		Switched to new interface for multiple context PM
**		functions.
**	23-jul-93 (tyler)
**		PMmInit() interface changed.  PMerror() is now passed
**		passed to PMmLoad() for better error reporting.
**		Include <util.h>.  Replaced embedded string with
**		message lookup.
**	20-sep-93 (tyler)
**		Support negative integers.
**	30-nov-93 (tyler)
**		Don't exit if the first rule file can't be found.
**	03-dec-93 (tyler)
**		yywrap() now reads the first line of each file it opens
**		and closes files when it's done.
**	27-nov-1995 (canor01)
**		Added EXEC_TEXT_STR type.  Return command to be executed
**		with proviso that it returns a string.
**	26-feb-1996 (canor01)
**		Added FILE and DIRECTORY constraints.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	07-Apr-2004 (gorvi01)
**	    Increment yyleng when a negative constraint is present. 
**	    This will resolve the bug where the MIN/MAX
**          value was cutoff at last. 
**	7-oct-2004 (thaju02)
**	    Added SIZE_TYPE.
*/

# include <compat.h>
# include <cv.h>
# include <st.h>
# include <er.h>
# include <si.h>
# include <nm.h>
# include <pc.h>
# include <cm.h>
# include <me.h>
# include <simacro.h>
# include <lo.h>
# include <pm.h>
# include <pmutil.h>
# include <util.h>
# include <erst.h>
# include "cr.h"
# include "crparse.h"

static char yybuf[ SI_MAX_TXT_REC + 1 ];
static char *yyp;
static char dummy = EOS;
static char file_name[ MAX_LOC + 1 ];
static PM_SCAN_REC rfm_scan;
static LOCATION loc;
static PM_CONTEXT *rulemap;
static char rulemap_buf[ MAX_LOC + 1 ];
static i4  yylineno;
static FILE *yyin = (FILE *) NULL;

GLOBALDEF char *rulemap_path;

static bool
yywrap( void )
{
	char *name, *value;

	/* initialize the line counter */
	yylineno = -1;

	while( TRUE )
	{
		/* get the name of next rule specification to be loaded */
		if( PMmScan( rulemap, NULL, &rfm_scan, NULL, &name,
			&value ) != OK )
		{
			if( yyin != (FILE *) NULL )
				(void) SIclose( yyin );
			return( TRUE ); /* no more files */
		}

		/* set up LOCATION of rule file */
		STcopy( value, file_name );
		NMloc( FILES, FILENAME, file_name, &loc );
		LOcopy( &loc, file_name, &loc );	

		if( yyin != (FILE *) NULL )
		{
			(void) SIclose( yyin );
			yyin = (FILE *) NULL;
		}

		/* try to open rule file */
		if( SIfopen( &loc, ERx( "r" ), SI_TXT, SI_MAX_TXT_REC, &yyin )
			== OK && SIgetrec( yybuf, sizeof( yybuf ), yyin )
			== OK )
		{
			break;	
		}
	}

	/* initialize input pointer */
	yyp = &dummy;

	/* another file was opened - so we're not done yet */
	return( FALSE );
}

void
yyinit( void )
{
	char *name, *value, *map_path;

	/* zero the line counter */
	yylineno = 0;

	if( rulemap_path == NULL )
	{
		NMloc( FILES, FILENAME, ERx( "default.rfm" ), &loc );
		LOcopy( &loc, file_name, &loc );	
		LOtos( &loc, &map_path );
	}
	else
	{
		STcopy( rulemap_path, file_name );
		LOfroms( FILENAME, file_name, &loc );
		map_path = rulemap_path;
	}

	(void) PMmInit( &rulemap );
	if( PMmLoad( rulemap, &loc, PMerror ) != OK )
		PCexit( FAIL );

	/* initiate scan of rule map */
	if( PMmScan( rulemap, ERx( ".*" ), &rfm_scan, NULL, &name, &value )
		!= OK )
	{
		F_ERROR( "Rule file map %s is empty.", map_path );
	}

	/* set up LOCATION of first rule file */
	STcopy( value, file_name );
	NMloc( FILES, FILENAME, file_name, &loc );
	LOcopy( &loc, file_name, &loc );	

	/* initialize input pointer */
	yyp = &dummy;

	/* open rule file */
	if( SIfopen( &loc, ERx( "r" ), SI_TXT, SI_MAX_TXT_REC, &yyin )
		!= OK && yywrap() )
	{
		ERROR( "No configuration rule files were found." );
	}
}

void
yyerror()
{
	SIfprintf( stderr, ERget( S_ST0410_crs_syntax_error ), yylineno,
		file_name );
	PCexit( FAIL );
}

i4
yylex()
{
	bool pattern;
	bool component;
	bool keyword;
	char *keyhead;
	char yytext[ SI_MAX_TXT_REC + 1 ];
	i4 yyleng;

	/* skip whitespace and comments */
	while( CMwhite( yyp ) || *yyp == EOS || *yyp == '-' )
	{
		/* check for comment */
		if( *yyp == '-' )
		{
			if( STbcompare( yyp, 2, ERx( "--" ), 2, FALSE ) == 0 )
			{
				while( *yyp != EOS )
					CMnext( yyp );
			}
			else
				break;
		}

		if( *yyp == EOS )
		{
			if( SIgetrec( yybuf, sizeof( yybuf ), yyin ) != OK &&
				yywrap() )
			{
				return( 0 );
			}
			else
			{
				yyp = yybuf;
				++yylineno;
			}
		}
		else
			CMnext( yyp );
	}

	/* check for a SYMBOL, PATTERN or keyword */
	yyleng = 0;
	pattern = FALSE;
	keyword = TRUE;
	keyhead = yyp;
	while( CMalpha( yyp ) || *yyp == '%' || *yyp == '$' || *yyp == '*' )
	{
		/* check for component of legal SYMBOL or PATTERN */ 
		component = FALSE;

		/* check for single-character component */
		switch( *yyp )
		{
			case '%':
				pattern = TRUE;
			case '*':
			case '$':
				component = TRUE;
				++yyleng;
				CMnext( yyp );
				if( *yyp == '.' )
				{
					++yyleng;
					CMnext( yyp );
					keyword = FALSE;
					continue;
				}
				else if( CMalpha( yyp ) )
					yyerror(); 
				continue;
		}

		while( CMalpha( yyp ) || CMdigit( yyp ) ||
			*yyp == '_' || *yyp == '-' )
		{
			++yyleng;
			CMnext( yyp );
			component = TRUE;
		}
		if( component )
		{
			if( *yyp == '.' )
			{
				++yyleng;
				CMnext( yyp );
				keyword = FALSE;
				continue;
			}
			continue;
		}
	}

	/* check for uneaten '.' */
	if( *yyp == '.' )
		yyerror();

	if( yyleng > 0 )
	{
		/* A keyword, SYMBOL or PATTERN was scanned */
		char *p;
		i4 i;

		/* put NULL-terminated copy in yytext */
		STlcopy( keyhead, yytext, yyleng );	
		for( p = yytext, i = 0; i <= yyleng; CMnext( p ), i++ );
		*p = EOS;	

		/* check for keywords */
		if( CMalpha( keyhead) && keyword )
		{
			if( STequal( ERx( "IF" ), yytext ) != 0 )
				return( IF );

			if( STequal( ERx( "ELSE" ), yytext ) != 0 )
				return( ELSE );

			if( STequal( ERx( "ELSEIF" ), yytext ) != 0 )
				return( ELSEIF );

			if( STequal( ERx( "ENDIF" ), yytext ) != 0 )
				return( ENDIF );

			if( STequal( ERx( "MIN" ), yytext ) != 0 )
				return( MIN );

			if( STequal( ERx( "MAX" ), yytext ) != 0 )
				return( MAX );

			if( STequal( ERx( "VALID" ), yytext ) != 0 )
				return( VALID );

			if( STequal( ERx( "PRIME" ), yytext ) != 0 )
				return( PRIME );

			if( STequal( ERx( "SIGNED_INT" ), yytext ) != 0 )
				return( SIGNED_INT );

			if( STequal( ERx( "DECIMAL" ), yytext ) != 0 )
				return( DECIMAL );

			if( STequal( ERx( "SIZETYPE" ), yytext ) != 0 )
				return( SIZETYPE );

			if( STequal( ERx( "POWER2" ), yytext ) != 0 )
				return( POWER2 );

			if( STequal( ERx( "REQUIRES" ), yytext ) != 0 )
				return( REQUIRES );

			if( STequal( ERx( "UNDEFINED" ), yytext ) != 0 )
				return( UNDEFINED );

			if( STequal( ERx( "SUM" ), yytext ) != 0 )
			{
				yylval.integer = SUM;
				return( SUM );
			}

			if( STequal( ERx( "ON" ), yytext ) != 0 )
			{
				yylval.real = 1;
				return( BOOL_CON );
			}

			if( STequal( ERx( "OFF" ), yytext ) != 0 )
			{
				yylval.real = 0;
				return( BOOL_CON );
			}

			if( STequal( ERx( "IS" ), yytext ) != 0 )
			{
				yylval.string = STalloc( yytext );
				return( COMPARE_OP );
			}

			if( STequal( ERx( "DIRECTORY" ), yytext ) != 0 )
				return( DIRECTORY );

			if( STequal( ERx( "FILE" ), yytext ) != 0 )
				return( FILESPEC );

		}
		/* valid SYMBOL or PATTERN */
		yylval.string = STalloc( yytext );
		if( pattern )
			return( PATTERN );
		/* don't accept a single '*' as SYMBOL */
		if( yyleng != 1 || *yytext != '*' )
			return( SYMBOL );

		/* push '*' back onto the input stream */
		CMprev( yyp, yybuf );
	}

	/* check for EXEC_TEXT, STR_CON, or EXEC_TEXT_STR */
	if( *yyp == '`' || *yyp == '"' )
	{
		int exec_str = 0;
		char *initstr = yyp;
		char *p = yyp, *text, *yyprev;

		if ( *yyp == '"' )
		{
			CMnext( yyp );
			if ( *yyp == '`' )
			{
				CMnext( p );
				exec_str = 1;
			}
			else
				yyp = p;
		}
		for( yyleng = 0, CMnext( yyp ), yyprev = ERx( "" );
			*yyp != *p || *yyprev == '\\';
			yyprev = ( *yyprev == EOS ) ? yyp : CMnext( yyprev ),
			CMnext( yyp ), ++yyleng )
		{
			if( *yyp == *p && *yyprev == '\\' )
			{
				/* remove escape character */
				char *p1, *p2;

				for( p1 = p2 = yyprev, CMprev( p1, p );
					p1 >= p; CMprev( p1, p ),
					CMprev( p2, p ) )
				{
					CMcpychar( p1, p2 );
				}
				--yyleng;
				CMnext( p );
			}

			if( *yyp == EOS )
				yyerror();
		}
		CMnext( yyp );
		if ( exec_str )
		{
			if ( *yyp == '"' )
				CMnext( yyp );
			else
			{
				/* keep scanning to final '"' */
				p = initstr;
				exec_str = 0;
				yyleng++;
				for( ; *yyp != *p || *yyprev == '\\';
					yyprev = ( *yyprev == EOS ) ? yyp : 
					CMnext( yyprev ),
					CMnext( yyp ), ++yyleng )
				{
					if( *yyp == EOS )
						yyerror();
				}
			}
		}
		text = p;
		CMnext( text );
		STlcopy( text, yytext, yyleng );
		yytext[ yyleng ] = EOS;
		yylval.string = STalloc( yytext );
		if( *p == '`' )
		{
			if ( exec_str )
				return( EXEC_TEXT_STR );
			return( EXEC_TEXT );
		}
		return( STR_CON );
	}

	/* check for NUM_CON */
	yyleng = 0;
	if( *yyp == '-' || CMdigit( yyp ) )
	{
		f8 factor;
		char *p = yyp;

		if( *yyp == '-' )
		{
			++yyleng;
			factor = -1;
			CMnext( yyp );
		}
		else
			factor = 1;
		
		if( !CMdigit( yyp ) )
			CMprev( yyp, yybuf );
		else
		{
			if( *yyp == '-' )
			{
				CMnext( yyp );	
				
			}
			else
				factor = 1;

			while( CMdigit( yyp ) )
			{
				++yyleng;
				CMnext( yyp );
			}

			if( *yyp == '.' )
			{
				++yyleng;
				CMnext( yyp );
				if( !CMdigit( yyp ) )
					yyerror();
				while( CMdigit( yyp ) )
				{
					++yyleng;
					CMnext( yyp );
				}
			}
			else if( *yyp == 'K' || *yyp == 'M' )
			{
				++yyleng;
				CMnext( yyp );
			}

			STlcopy( p, yytext, yyleng ); 
			yytext[ yyleng ] = EOS;

			if( yytext[ yyleng - 1 ] == 'K' )
			{
				factor = 1024;
				yytext[ yyleng - 1 ] = EOS;
			}
			else if( yytext[ yyleng - 1 ] == 'M' )
			{
				factor = 1048576;
				yytext[ yyleng - 1 ] = EOS;
			}
			CVaf( yytext, ERx( '.' ), &yylval.real );
			yylval.real *= factor;
			return( NUM_CON );
		}
	}

	if( STbcompare( yyp, 2, ERx( ">=" ), 2, FALSE ) == 0 )
	{
		yylval.string = STalloc( ERx( ">=" ) );
		CMnext( yyp );
		CMnext( yyp );
		return( COMPARE_OP );
	}
	if( STbcompare( yyp, 2, ERx( "<=" ), 2, FALSE ) == 0 )
	{
		yylval.string = STalloc( ERx( "<=" ) );
		CMnext( yyp );
		CMnext( yyp );
		return( COMPARE_OP );
	}
	/* check for COMPARE_OP */
	if( STbcompare( yyp, 1, ERx( "<" ), 1, FALSE ) == 0 )
	{
		yylval.string = STalloc( ERx( "<" ) );
		CMnext( yyp );
		return( COMPARE_OP );
	}
	if( STbcompare( yyp, 1, ERx( ">" ), 1, FALSE ) == 0 ) 
	{
		yylval.string = STalloc( ERx( ">" ) );
		CMnext( yyp );
		return( COMPARE_OP );
	}
	if( STbcompare( yyp, 2, ERx( "==" ), 2, FALSE ) == 0 )
	{
		yylval.string = STalloc( ERx( "==" ) );
		CMnext( yyp );
		CMnext( yyp );
		return( COMPARE_OP );
	}

	/* check for characters which get passed directly */
	switch( *yyp )
	{
		char *p;

		case '(':
		case ')':
		case '[':
		case ']':
		case '{':
		case '}':
		case ':':
		case ';':
		case ',':
		case '=':
			p = yyp;
			CMnext( yyp );
			return( *p );	

		case '+':
			yylval.string = STalloc( ERx( "+" ) );
			CMnext( yyp );
			return( *yylval.string );

		case '-':
			yylval.string = STalloc( ERx( "-" ) );
			CMnext( yyp );
			return( *yylval.string );

		case '*':
			yylval.string = STalloc( ERx( "*" ) );
			CMnext( yyp );
			return( *yylval.string );

		case '/':
			yylval.string = STalloc( ERx( "/" ) );
			CMnext( yyp );
			return( *yylval.string );
	}

	/* check for LOGIC_OP */
	if( STbcompare( yyp, 3, ERx( "&&" ), 3, FALSE ) == 0 )
	{
		yylval.string = STalloc( ERx( "&&" ) );
		CMnext( yyp );
		CMnext( yyp );
		return( LOGIC_OP );
	}
	if( STbcompare( yyp, 3, ERx( "||" ), 3, FALSE ) == 0 )
	{
		yylval.string = STalloc( ERx( "||" ) );
		CMnext( yyp );
		CMnext( yyp );
		return( LOGIC_OP );
	}

	/* anything else is an error */
	yyerror();

}
