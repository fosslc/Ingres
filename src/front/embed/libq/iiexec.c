/*
** Copyright (c) 2004 Ingres Corporation
*/

# include	<compat.h>
# include	<st.h>		/* 6-x_PC_80x86 */
# include	<er.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include	<generr.h>
# include	<gca.h>
# include	<iicgca.h>
# include	<iisqlca.h>
# include	<iilibq.h>
# include	<eqrun.h>
# include	<erlq.h>


/**
+*  Name: iiexec.c - Contains routines dealing with the execution of REPEAT
**		     queries.
**
**  Description:
**	This files contains all the routines that deal with the "loop-and-a-
**	half" construct generated by the preprocessors to define and execute
**	REPEAT queries.  Even though, documented for 6.0, where the first step
**	of query definition and execution use a special query id, this also
**	works for earlier versions where the first step in both those phases
**	just used a textual query name.  See the example below to see how the
**	calls into this file are generated.  Also refer to the EQUEL file
**	repeat.c for a lengthier discussion on how REPEAT queries work at 
**	run-time.
**
**  Defines:
**	IIsexec()		- Setup REPEAT query execution.
**	IInexec()		- Can we execute the next step in the control?
**	IIexDefine()		- Define the first part of the query.
**	IIexExec()		- Execute the first part of the query.
**
**  Example:
**	## int i; char *s;
**	## repeat append to emp (name=@s, age=@i);
**  Generates:
**	  int i;
**	  char *s;
**	  {
**	    IIsexec();
**	    while (IInexec() == 0) {
**	      IIexExec("file1",16154,53835);
**	      IIsetdom(1,32,0,s);
**	      IIsetdom(1,30,4,&i);
**	      IIsyncup((char *)0,0);
**	      if (IInexec() == 0) {
**	        IIexDefine("file1",16154,53835);
**	        IIwritedb("append to emp(name=");
**	        IIwritedb("$0 is c,age=");
**	        IIwritedb("$1 is i4)");
**	        IIsyncup((char *)0,0);
**	        if (IIerrtest() == 0) {
**	          IIsexec();
**	        } -- IIerrtest
**	      } -- IInexec
**	    } -- IInexec
**	  }
**
-*
**  History:
**	03-oct-1986 - Added IIexDefine and IIexExec. (mrw)
**	26-aug-1987 - Modified to use GCA. (ncg)
**	12-dec-1988 - Generic error processing. (ncg)
**	03-dec-1990 (barbara)
**	    Moved state (for INQUIRE_INGRES) from GLB_CB to LBQ_CB (bug 9160)
**	05-mar-1992 - corrected function return type of IIexQRead (seg)
**	18-Dec-97 (gordy)
**	    Added support for multi-threaded applications.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**/

static VOID	IIexQRead( II_LBQ_CB *, char *, i4, i4  );


/*{
+*  Name: IIsexec - Set up for REPEAT query execution.
**
**  Description:
**	Set up the state to allow REPEAT queries to be executed, by allowing
**	them into the IInexec step.
**
**  Inputs:
**	None
**
**  Outputs:
**	Returns:
**	    Void
**	Errors:
**	    None
**
**  Side Effects:
**	1. Changes the state of the global ii_lq_flags to II_L_REPEAT so that
**	   IInexec which checks that flag will let the program in (see example
**	   above).
-*	
**  History:
**	01-jan-1981	- Written.
*/

void
IIsexec()
{
    II_THR_CB	*thr_cb = IILQthThread();
    II_LBQ_CB	*IIlbqcb = thr_cb->ii_th_session;

    IIlbqcb->ii_lq_flags |= II_L_REPEAT;
}


/*{
+*  Name: IInexec - Return indication of whether the REPEAT query was
**		    successfully executed.
**
**  Description:
**	Based on the code generated by the preprocessor, this routine
**	assumes that it will be called either after IIsexec or after
**	an attempt has been made to execute a REPEAT query.
**
**  Inputs:
**	None
**
**  Outputs:
**	Returns:
**	    i4  - Value of whether query was executed (ii_lq_flags & REPEAT).
**		1 - Query was executed (so drop out of loop).
**		0 - Query was not executed (so it must be defined).
**		    Return 0 if REPEAT is on.
**	Errors:
**	    None
**
**  Side Effects:
**	1. Because this is called just before a query is initially executed
**	   we set the global flag to indicate this (this is just a safety step).
-*	
**  History:
**	01-jan-1981	- Written.
*/


i4
IInexec()
{
    II_THR_CB	*thr_cb = IILQthThread();
    II_LBQ_CB	*IIlbqcb = thr_cb->ii_th_session;

    if (IIlbqcb->ii_lq_flags & II_L_REPEAT)
	return 0;
    else
	return 1;
}


/*{
**  Name: IIexDefine - Emit the header for the "define" part of a repeat query.
**
**  Description:
**	Emit
**		"define query <qryname, qrynum1, qrynum2> is "
**
**	We expect to be followed by the text of the query itself; eg:
**	"append to emp (col1 = $0=i4, col2 = $1=c)".
**	We assume also that IIexExecute has already been called -- that's
**	the way repeat queries work.  Note that the queryid numbers have
**	to be copied to i4's, as they might be i2's (eg, on the PC).
**	Queryid's are guaranteed to fit in an i2, so all this will work.
**
**  Inputs:
**	what		- What to do.
**			  II_EXQREAD  - Read a query id.
**			  II_EXCURSOR - Send a query id.
**			  II_EXQUERY  - Send a cursor id.
**	name		- The textual name of the query.
**	num1		- The first identifying number of the query.
**	num2		- The second identifying number of the query.
**
**  Outputs:
**	Returns:
**	    Nothing.
**	Errors:
**	    None.
**
**  Side Effects:
**	
**  History:
**	03-oct-1986 - Written (mrw)
**	26-aug-1987 - Modified to use GCA. (ncg)
*/

void
IIexDefine( what, name, num1, num2 )
i4	what;		/* II_EXQREAD, II_EXQUERY, or II_EXCURSOR */
char	*name;
i4	num1;
i4	num2;
{
    II_THR_CB		*thr_cb = IILQthThread();
    II_LBQ_CB		*IIlbqcb = thr_cb->ii_th_session;
    DB_DATA_VALUE	dbv;
    IIDB_QRY_ID		dbid;
    register char	*qrystr;

    if (what == II_EXQREAD)	/* Read the returning DB query id */
    {
	IIexQRead( IIlbqcb, name, num1, num2 );
	return;
    }

    qrystr = (what == II_EXCURSOR) ?
		    ERx("define query open cursor ") : ERx("define query ");

    /*
    ** So we're either II_EXQUERY or II_EXCURSOR.
    */

  /* Define queries are GCA_DEFINE blocks */
    if (IIqry_start(GCA_DEFINE, 0, 0, qrystr) != OK)
	return;

  /* Emit the define header */
    II_DB_SCAL_MACRO(dbv, DB_QTXT_TYPE, STlength(qrystr), qrystr);
    IIcgc_put_msg(IIlbqcb->ii_lq_gca, FALSE, IICGC_VQRY, &dbv );

  /* Send the query id. */
    STmove(name, ' ', GCA_MAXNAME, dbid.gca_name);
    dbid.gca_index[0] = (i4)num1;
    dbid.gca_index[1] = (i4)num2;
    IIqid_send( IIlbqcb, &dbid );

  /* Emit the " is " or " for " */
    qrystr = what == II_EXCURSOR ? ERx(" for ") : ERx(" is ");
    II_DB_SCAL_MACRO(dbv, DB_QTXT_TYPE, STlength(qrystr), qrystr);
    IIcgc_put_msg(IIlbqcb->ii_lq_gca, FALSE, IICGC_VQRY, &dbv );

    /*
    ** So we've emitted:
    **	"define query <qryname, qrynum1, qrynum2> is "
    ** or
    **	"define query open cursor <qryname, qrynum1, qrynum2> for "
    ** and we're ready for the text of the query definition to follow.
    */

    /* Preserve full type compatibility (ie, null indicators) in IIputdomio */
    IIlbqcb->ii_lq_curqry |= II_Q_NULIND;
}

/*{
**  Name: IIexExec - Emit the header for the "execute" part of a repeat query.
**
**  Description:
**	Start an EXECUTE block and pass down the query id.
**	We'll be followed by (optional) calls to IIputdomio, and possibly
**	IIexDefine for the define phase of a repeat query (if the query cannot
**	be executed).  See the example code for this file above.
**
**  Inputs:
**	what		- Execution mode.
**			  II_EXCURSOR - Cursor repeat query.
**			  II_EXQUERY  - Regular query.
**	name		- The textual name of the query.
**	num1		- The first identifying number of the query.
**	num2		- The second identifying number of the query.
**
**  Outputs:
**	Returns:
**	    i4  - TRUE ==> query is executing, FALSE ==> query must be defined
**	Errors:
**	    None.
**
**  Side Effects:
**	
**  History:
**	03-oct-1986 - Written (mrw)
**	26-aug-1987 - Modified to use GCA. (ncg)
*/

i4
IIexExec( what, name, num1, num2 )
i4	what;			/* Unused */
char	*name;			/* Unused */
i4	num1;
i4	num2;
{
    II_THR_CB	*thr_cb = IILQthThread();
    II_LBQ_CB	*IIlbqcb = thr_cb->ii_th_session;
    IIDB_QRY_ID	*dbid;

    if ( ! (dbid = IIqid_find( IIlbqcb, TRUE, NULL, num1, num2 )) )
    {
	/*
	** Set this status so that IIqry_end will leave the REPEAT flag on.
	** We use the status so that later code behaves in the same way as
	** though the DBMS had told us it was not defined via the response
	** block.
	*/
	IIlbqcb->ii_lq_qrystat = GCA_RPQ_UNK_MASK;
	IIlbqcb->ii_lq_curqry = II_Q_QERR;	/* Do not |= II_Q_INQRY ! */
	return FALSE;		/* Don't send the parameters */
    }

    /* Start an execute query-or-cursor block */
    if (IIqry_start(GCA_INVOKE, 0, 0, ERx("execute")) != OK)
	return FALSE;	/* Don't send the parameters */

    /* Preserve full type compatibility (ie, null indicators) in IIputdomio */
    IIlbqcb->ii_lq_curqry |= II_Q_NULIND;

    /* Send the query id - followed by parameters (IIsetdoms and an IIsync) */
    IIqid_send( IIlbqcb, dbid );
    return TRUE;		/* Send the parameters */
}

/*{
+*  Name: IIexQRead - Flush a query and read the DB query ID coming back.
**
**  Description:
**
**  Inputs:
**	IIlbqcb		Current session control block.
**
**  Outputs:
**	Returns:
**	    Nothing.
**	Errors:
**	    UNDEFREP		- FE needs to define the query (not user error)
**	    REPDEF		- Error reading the QID or storing it.
-*
**  Side Effects:
**	
**  History:
**	29-oct-1986 - Written (mrw)
**	26-aug-1987 - Modified to use GCA. (ncg)
**	05-mar-1992 - corrected function return type (seg)
*/

static VOID
IIexQRead( II_LBQ_CB *IIlbqcb, char *name, i4  num1, i4  num2 )
{
    IIDB_QRY_ID		dbid;
    STATUS		stat;

    if (IIlbqcb->ii_lq_curqry & II_Q_INQRY)
	IIcgc_end_msg(IIlbqcb->ii_lq_gca);	/* Send query to DBMS */

  /* Was there a local error? */
    if (((IIlbqcb->ii_lq_curqry & II_Q_INQRY) == 0) ||
	(IIlbqcb->ii_lq_curqry & II_Q_QERR))
    {
	IIqry_end();			/* Will reset flags anyway */
	return;
    }

    stat = IIqry_read( IIlbqcb, GCA_QC_ID );

    /* 
    ** If an error occurred during the setup for reading the REPEAT query
    ** id, cleanup any returning data, as the preprocessor will exit
    ** the REPEAT definition loop.
    */
    if (stat == FAIL || II_DBERR_MACRO(IIlbqcb))
    {
      /* Assign error number to make sure preprocessor skips IIsexec */
	if (IIlbqcb->ii_lq_error.ii_er_num == IIerOK)
	{
	    IIlocerr(GE_LOGICAL_ERROR, E_LQ004B_UNDEFREP, II_ERR, 1, name);
	    IIlbqcb->ii_lq_curqry |= II_Q_QERR;
	}
	IIqry_end();
	return;			/* End of query */
    }

  /* Read the query id into dbid */
    if (IIqid_read( IIlbqcb, &dbid ) != OK)
    {
	if (IIlbqcb->ii_lq_error.ii_er_num == IIerOK)
	{
	    IIlocerr(GE_LOGICAL_ERROR, E_LQ004A_REPDEF, II_ERR, 0, (char *)0);
	    IIlbqcb->ii_lq_curqry |= II_Q_QERR;
	}
    }
    else if (IIqid_add( IIlbqcb, TRUE, num1, num2, &dbid ) != OK)
    {
	IIlocerr(GE_LOGICAL_ERROR, E_LQ004A_REPDEF, II_ERR, 0, (char *)0);
	IIlbqcb->ii_lq_curqry |= II_Q_QERR;
    }

    IIqry_end();			/* Done with query */
}
