/*
** Copyright (c) 2004 Ingres Corporation
*/

# include	<compat.h>
# include	<er.h>
# include	<gl.h>
# include	<sl.h>
# include	<me.h>
# include	<iicommon.h>
# include	<erlq.h>
# include	<generr.h>
# include	<gca.h>
# include	<si.h>		/* needed for iicxfe.h */
# include	<iicgca.h>
# include	<iisqlca.h>
# include	<iilibq.h>
# include	<iilibqxa.h>
# include       <iicx.h>
# include       <iicxfe.h>
# include       <xa.h>

/**
+*  Name: iixact.c - Routines for handling transaction blocks.
**
**  Description:
**	Because, under INGRES 6.0, transaction statements (without arguments)
**	send no text, the preprocessors generate a special call to this
**	routine.
**
**  Defines:
**	IIxact( flag )			- Interface to GCA for transactions
**	IIsqTPC( id, id )		- Interface to GCA for distrib xact.
-*
**  History:
**	03-oct-1986	- Written (mrw)
**	26-aug-1987 	- Modified to use GCA. (ncg)
**	14-mar-1989	- Updated for two-phase commit. (bjb)
**	02-aug-1989	- Set transaction flag after BEGIN TRANSACT. (bjb)
**	03-dec-1990 (barbara)
**	    Moved state (for INQUIRE_INGRES) from GLB_CB to LBQ_CB (bug 9160)
**      07-oct-1992 (nandak - rejoined by larrym)
**          Support for XA's 2PC protocol.  Added IIsqXATPC function.
**	02-dec-1992 (larrym)
**	    Added checks for XA - disallow xact calls unless in proper state.
**      18-jan-1993 (larrym)
**          Added <si.h>.  A modification to iicxfe.h required this
**      23-sep-1993 (iyer)
**          Modified IIsqXATPC to now pass the new message structure for
**          GCA_XA_SECURE message. The message is now based on the 
**          extended XA distributed transaction ID which now includes two
**          additional members.
**      23-apr-96 ( chech02)
**          fixed compiler errors for windows 3.1 port.
**	    IIlocerr() needs 5 arguments.
**	18-Dec-97 (gordy)
**	    Added support for multi-threaded applications.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**/

/*{
+*  Name: IIxact - Interface to GCA for transaction blocks.
**
**  Description:
**
**  Inputs:
**	what - i4  - Type of transaction (BEGIN TRAN, END TRAN, ABORT, COMMIT)
**
**  Outputs:
**	None
**
**	Returns:
**	    Nothing
**	Errors:
**
**  Side Effects:
**	After begining/terminating a transaction turn on/off the global
**	XACT flag (if query did NOT result in error)(.
-*	
**  History:
**	03-oct-1986	- Written (mrw)
**	26-aug-1987 	- Modified to use GCA. (ncg)
**	18-nov-1987	- GCA_ROLLBACK message added. (ncg)
**	30-aug-1988	- If terminating a transaction tweak II_L_XACT. (ncg)
**	12-dec-1988     - Free cursor memory if the end transaction was
**			  successful (if not we may not have been in a
**			  transaction so don't free). (ncg)
**	02-aug-1989	- Turn on XACT flag on BEGIN XACT. (Lyed)
*/

void
IIxact( what )
i4	what;
{
    II_THR_CB		*thr_cb = IILQthThread();
    II_LBQ_CB		*IIlbqcb = thr_cb->ii_th_session;
    DB_DATA_VALUE	dbv;
    GCA_TX_DATA		dummy_tx;		/* For begin transaction */
    bool		endxact = FALSE;	/* End transaction? */
    /*
    ** This array is dependent on the 0 to 3 values defined in eqrun.h for
    ** the "what" argument generated by EQUEL.
    */
    static struct {
	i4	gcatype;
	char	*qrystr;
    } xacts[4] = {
		{GCA_Q_BTRAN, ERx("begin transaction")},
		{GCA_Q_ETRAN, ERx("end transaction")},
		{GCA_ABORT,   ERx("abort")},	     /* May be GCA_ROLLBACK */
		{GCA_COMMIT,  ERx("commit")}
	      };

    if (IIXA_CHECK_IF_XA_MACRO)
    {
	/* transaction control only allowed if INGRES STATE is INTERNAL */
	if (IIXA_CHECK_SET_INGRES_STATE(IICX_XA_T_ING_INTERNAL))
	{
	    /* IIXA_CHECK_SET_INGRES_STATE generates an error */
	    return;
        }
    }

    if (   xacts[what].gcatype == GCA_ABORT
	&& IIlbqcb->ii_lq_dml == DB_SQL)
    {
    	_VOID_ IIqry_start(GCA_ROLLBACK, 0, 0, ERx("rollback"));
    }
    else
    {
	_VOID_ IIqry_start(xacts[what].gcatype, 0, 0, xacts[what].qrystr);
    }
    if (xacts[what].gcatype == GCA_Q_BTRAN)   /* Send dummy transaction id */
    {
	dummy_tx.gca_tx_id.gca_index[0] = 11;
	dummy_tx.gca_tx_id.gca_index[1] = 22;
	dummy_tx.gca_tx_id.gca_name[0] = '?';
	dummy_tx.gca_tx_id.gca_name[1] = EOS;
	IIqid_send( IIlbqcb, (IIDB_QRY_ID *)&dummy_tx.gca_tx_id );

	dummy_tx.gca_tx_type = 33;
	II_DB_SCAL_MACRO(dbv,DB_INT_TYPE,sizeof(i4),&dummy_tx.gca_tx_type);
	IIcgc_put_msg(IIlbqcb->ii_lq_gca, FALSE, IICGC_VVAL, &dbv);
    }
    else					/* Turn off transaction state */
    {
	endxact = TRUE;
    } /* if begin transaction */
    IIsyncup((char *)0, 0);
    if (IIlbqcb->ii_lq_error.ii_er_num == IIerOK)
    {
	if (endxact)
	{
	    IIlbqcb->ii_lq_flags &= ~II_L_XACT;
	    IIcsAllFree( IIlbqcb );		/* Free cursor state memory */
	}
	else
	{
	    IIlbqcb->ii_lq_flags |= II_L_XACT;
	}
    }
}

/*{
+*  Name: IIsqTPC - Interface to GCA for distributed transaction.
**
**  Description:
**	This routine is called when the application issues a PREPARE
**	TO COMMIT statement.  The application is acting as coordinator
**	in a distributed transaction.  This routine builds the GCA_SECURE
**	message and its associated data to send to GCA.
**
**  Inputs:
**	highdxid - i4  - High order bytes of distributed xact id.
**	lowdxid  - i4  - Low order bytes of distributed xact id.
**
**  Outputs:
**	None
**
**	Returns:
**	    Nothing
**	Errors:
**
**  Side Effects:
**	None
**
**  Generated code:
**	EXEC SQL PREPARE TO COMMIT WITH HIGHDXID = int, LOWDXID = int;
**
**	IIsqInit( &sqlca );
**	IIsqTPC( int, int );
-*	
**  History:
**	14-mar-1989	- Written (bjb)
**	02-dec-1992 (larrym)
**	    Added XA support.
*/

void
IIsqTPC(highdxid, lowdxid)
i4	highdxid;
i4	lowdxid;
{
    II_THR_CB		*thr_cb = IILQthThread();
    II_LBQ_CB		*IIlbqcb = thr_cb->ii_th_session;
    DB_DATA_VALUE	dbv;
    GCA_TX_DATA		dxid_tx;

    if (IIXA_CHECK_IF_XA_MACRO)
    {
	/* normal 2PC not allowed in XA */
	IIlocerr( GE_LOGICAL_ERROR, E_LQ00D5_XA_ILLEGAL_STMT, II_ERR, 0, (PTR)0 );
	return;
    }

    _VOID_ IIqry_start(GCA_SECURE, 0, 0, ERx("prepare to commit"));
    dxid_tx.gca_tx_id.gca_index[0] = (i4)highdxid;
    dxid_tx.gca_tx_id.gca_index[1] = (i4)lowdxid;
    dxid_tx.gca_tx_id.gca_name[0] = '?';
    dxid_tx.gca_tx_id.gca_name[1] = EOS;
    IIqid_send( IIlbqcb, (IIDB_QRY_ID *)&dxid_tx.gca_tx_id );
    dxid_tx.gca_tx_type = GCA_DTX;
    II_DB_SCAL_MACRO(dbv,DB_INT_TYPE,sizeof(i4),&dxid_tx.gca_tx_type);
    IIcgc_put_msg(IIlbqcb->ii_lq_gca, FALSE, IICGC_VVAL, &dbv);
    IIsyncup((char *)0, 0);
}

/*{
**  Name: IIsqXATPC - Interface to GCA for XA's distributed transaction.
**
**  Description:
**	This routine is called by LIBQXA when the TP monitor issues an
**      xa_prepare call.
**	This routine builds the GCA_XA_SECURE message and its associated data
**      to send to GCA.
**
**  Inputs:
**	xa_xid_p - *XID - Pointer to the XA version of XID.
**
**  Outputs:
**	None
**
**	Returns:
**	    Nothing
**	Errors:
**
**  Side Effects:
**	None
**
**  Generated code:
-*	
**  History:
**	07-oct-1992	- Written (nandak)
**      23-sep-1993 (iyer)
**                  The function has been changed to accept two additional
**                  parameters, a branch_seqnum and a branch_flag both of type
**                  "nat". The message for GCA_XA_SECURE is now based on
**                   the extended XA distributed structure.  
**	29-Mar-02 (gordy)
**	    GCA now independent but similiar to DBMS definitions.  The XID
**	    can no longer be a structure assign, so use MEcopy() instead.
*/

void
IIsqXATPC(xa_xid_p, branch_seqnum, branch_flag)
XID	*xa_xid_p;
i4      branch_seqnum;
i4      branch_flag;
{
    II_THR_CB		*thr_cb = IILQthThread();
    II_LBQ_CB		*IIlbqcb = thr_cb->ii_th_session;
    DB_DATA_VALUE	dbv;
    GCA_XA_DIS_TRAN_ID	gca_xa_dis_tran_id;
    _VOID_ IIqry_start(GCA_XA_SECURE, 0, 0, ERx("xa - prepare to commit"));
    MEcopy( (PTR)xa_xid_p,
	    sizeof(DB_XA_DIS_TRAN_ID), (PTR)&gca_xa_dis_tran_id );
    gca_xa_dis_tran_id.branch_seqnum = branch_seqnum;
    gca_xa_dis_tran_id.branch_flag   = branch_flag;
    II_DB_SCAL_MACRO(dbv,0,sizeof(GCA_XA_DIS_TRAN_ID),&gca_xa_dis_tran_id);
    IIcgc_put_msg(IIlbqcb->ii_lq_gca, FALSE, IICGC_VDBV, &dbv);
    IIsyncup((char *)0, 0);
}

