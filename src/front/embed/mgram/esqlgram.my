%{

/*
** Copyright (c) 2004, 2008 Ingres Corporation
*/

/* %L language - Which language are we using for symbol table? */

# include	<compat.h>
# include	<er.h>
# include	<si.h>
# include	<st.h>
# include	<me.h>
# include	<cm.h>
# include	<gl.h>
# include	<sl.h>
# include	<cv.h>
# include	<iicommon.h>
# include	<fe.h>			/* for FE_MAXNAME */
/* Files from EQUEL preprocessor */
# include	<equel.h>
# include	<eqlang.h>
# include	<equtils.h>
# include	<eqsym.h>
# include	<eqgen.h>
# include	<eqstmt.h>
# include	<eqscan.h>
# include	<ereq.h>
# include	<eqgr.h>
# include	<eqfw.h>	
# include	<eqtgt.h>	
# include	<g4consts.h>
# include	<g4defs.h>

/* Special ESQL overlay */
# include	<eqesql.h>

# if defined(hp3_us5)
	# pragma OPT_LEVEL 1
# endif /* hp3_us5 */

static bool   set_role=FALSE;

%}

/*
+* Filename:	ESQLGRAM.Y 
** Purpose:	Higher level and language independent ESQL grammar.
**
-* Defines:	yyparse - Yacc parser for ESQL.
**
** History:	
**		10-jan-1985 - Written for EQUEL (ncg)
**		09-aug-1985 - Modified (together with the SQL grammar)
**			      to work for ESQL (ncg)
**		22-sep-1986 - Added INGRES/STAR statements (ncg)
**		31-mar-1987 - Modified for native ESQL 6.0 (mrw)
**		03-may-1988 - Added database procedures for 6.1 (whc)
**		20-may-1988 - Added forms with clause to MESSAGE, PROMPT,
**			      and DISPLAY.  (marge)
**		25-may-1988 - Added dynamic FRS statements (bjb)
**		06-jun-1988 - Added Star statements - DIRECT [DIS]CONNECT.
**			      Modified the way literals were parsed for
**			      form system. (ncg)
**		12-jul-1988 - Bug #2681: added tCONTINUE to right-hand-side
**			      of copy with clause.  (marge) 
**		04-aug-1988 - In MESSAGE and PROMPT changed fm_string to (new)
**			      fm_qstring which requires string literals to be
**			      quoted.  (marge)
**		30-aug-1988 - Added language support for performance features.
**			      New SET_INGRES statement, new Dynamic SQL USING
**			      clause. (ncg)
**		29-dec-1988 - Added ANSI <dynamic using clause> updates. (ncg)
**		30-jan-1989 - Added warning message to be produced when the
**			      '-wcommon' flag is given and an INGRES only
**			      command is encountered. (marian)
**		24-feb-1989 - Added dynamic cursor names; fixed '-wcommon'
**			      error msgs. (bjb)
**		27-feb-1989 - Added FROM list to UPDATE statement. (teresa) 
**		13-mar-1989 - Added two-phase commit support for distributed
**			      transactions (bjb)
**              15-mar-1989 - Added owner.tablename to COPY, DELETE, INSERT,
**                            SELECT, and UPDATE statements. (teresa)
**              17-mar-1989 - Fixed subquery to accept DISTINCT or ALL keyword.
**                            (teresa)
**		14-mar-1989 - Added GRANT enhancements (bjb)
**		31-mar-1989 - Add modifications for generating IISQMODS for
**			      repeated singleton selects. (teresa)
**		19-apr-1989 - Added owner.tablename construct to REGISTER
**			      command and removed FROM hostvariable. (teresa)	
**		21-apr-1989 - Modifications to drop/create for terminator (bjb)
**		12-may-1989 - Terminator changes: removed ADT statements,
**			      changed APPLICATION_ID to ROLE, fixed bug in
**			      grant_object rule. (bjb)
**		16-may-1989 - Bug fix on create_rule; changed errmessage from
**			      COMMON to OPEN (bjb)
**		23-may-1989 - Multiple connects: allow session id on connect
**			      and disconnect statements. Also took away
**			      OPEN SQL error msg for UNION ALL. (bjb)
**		24-may-1989 - Dynamic SQL support for EXECUTE PROCEDURE (ncg)
**		23-aug-1989 - Added B1 security statements (teresal)
**              29-aug-1989 - Bug fixes for terminator (bjb)
**		01-sep-1989 - FIPS flagger (bjb)
**		05-sep-1989 - Dynamic select support (bjb)
**              12-sep-1989 - Changed EQ0126 error message to explain about
**                            commas between list elements in a WITH clause.
**                            (Bug 7871). (sylviap)
**              04-oct-1989 - Fixed bug 7392.  Also removed 'AFTER' as keyword.
**              05-oct-1989 - Fixed bug 5676.  Updatable cursors shouldn't in-
**                            clude subselects in disallowing > 1 table. (bjb)
**              09-oct-1989 - B 8174: For DG only, added error message and
**                            SYNTAX ERROR if user is trying to do multiple
**              16-oct-1989 - Modifications for entry activation (teresa)
**              16-oct-1989 - Modified for Emerald: added support for setting
**                            the _STATE of a tablefield row, accept CURRENT as
**                            valid screenwidth option, and accept 'ACTIVATE
**                            FRSKEY0' (iff -c command flag). (teresa)
**		09-nov-1989   Add ability to parameterize FRS keys by adding
**			      'ACTIVATE FRSKEY integer_variable'. (teresa)
**		27-nov-1989   Fixed problem with 'with null/def' parsing. (bjb)
**		29-nov-1989 - Add ALTER TABLE statement and Outer Join syntax
**			      to SELECT and UPDATE statements. (teresal)	
**		11-dec-1989 - Phoenix/Alerters statements. 	(barbara)
**		02-jan-1990 - Make the BY clause of the B1 CREATE SECURITY_ALARM
**			      command optional. (teresal)
**		02-jan-1990 - Bug 8651 fix for problem where DELETE statement
**			      with a variable cursor name wasn't working 
**			      because of owner.tablename code. (teresal)
**		11-jan-1990 - Flag function refs as non-OPEN SQL (barbara).
**		15-mar-1990 - Fixed bug 8447 (time on SAVE command is
**			      optional). (bjb)
**		24-mar-1990 - Fixed bug 9501 (allow a sign on constants used
**			      in 'with null' clause on COPY). (bjb)
**		17-apr-1990 - Add 'location:table' to modify command (teresal).
**		17-apr-1990 - Add support for multi-location sorting (teresal).
**		08-jun-1990 - Add Decimal. (teresal)
**		20-aug-1990 - Fixed bug 32674 (allow LEFT and RIGHT function
**			      names). (teresal)
**		08-aug-1990 - Added with clause on loadtable and insertrow for
**			      setting per value display attributes. (barbara)
**		03-oct-1990 - Bug 33032 (allow GROUP BY/HAVING clause in 
**			      sub-select of comparison predicate. 
**			      Changed "compare_cond" rule:
**			      replaced "singleton_set" with "col_subqry" and 
**			      removed singleton_set rule. (the only reference 
**			      to singleton_set was in compare_cond rule).
**			      The only difference between singleton_set and
**			      col_subqry, is that col_subqry includes an
**			      optional HAVING/GROUP BY clause. (kathryn)
**		12-oct-1990 - Add Erorr message to compare_cond rule for OPEN
**			      SQL warning.(kathryn)
**		16-oct-1990 - Added COMMENT ON statements with warning flags
**			      for non-FIPS, and non-OPEN SQL. (kathryn)
**		14-nov-1990 - Updated REVOKE/GRANT statement to accept "ON 
**			      INSTALLATION" instead of "ALL DATABASES". 
**			      Added "ALL [PRIVILEGES]" to REVOKE. Modified
**			      ALTER USER to allow username to be optional.
**			      (Teresa)
**		12-feb-1991 - Bug fix 35410: allow "double precision" data
**			      type in CREATE TABLE and DECLARE TABLE
**			      statements.  Add to INITTABLE later on when
**			      FRS supports this. (teresal)
**		13-feb-1991 - Flag "!=" and "^=" operators as non-OPEN
**			      SQL. (teresal)
**		04-mar-1991 - Added SET SESSION syntax for 6.3/04. (barbara)
**		05-mar-1991 - Flag as error dynamic WHERE clauses on repeat
**			      queries and generate garbage in query. (barbara)
**		06-mar-1991 - Add support for DISCONNECT ALL statement.
**			      (teresal)
**		15-mar-1991 - Added generic target list rule for 
**			      inquire/set_sql stmts.(kathryn)
**              16-mar-1991 - Flag old-style FRS statements as errors
**                            rather than warnings. (teresal)
**		24-mar-1991 - Added COPYHANDLER support for internal use only.
**			      Convert "copyhandler" to "function" for dbms
**			      for now.  Generate LIBQ call to register handler.
**			      Also removed SQLCA handling from SET_SQL stmt.
**			      (barbara)
**		03-apr-1991 - Changes to COPYHANDLER code. (barbara)
**		19-apr-1991 - COPYHANDLER code generation change. (barbara)
**		15-apr-1991 - Add Alerter support for FRS - also modify
**			      Alerters for 3GL by changing the GET EVENT 
**			      syntax. (teresal)
**		26-apr-1991 - Fixed bug 37243 (Allow LEFT and RIGHT functions 
**			      in insert statements; related to bug 32674).
**			      (davel)
**		03-may-1991 - Fix GET EVENT so it generates IIsqInit once 
**			      again.  I inadvertently removed it with my 
**			      previous alerter change.  (teresal)
**		05-jun-1991 - Change GRANT and REVOKE syntax "ON INSTALLATION"
**			      to "ON CURRENT INSTALLATION". Fix Bug where
**			      "REVOKE priv ON <anything> from name"  generated
**			      "REVOKE priv ON INSTALLATION from name" (kathryn)
**		02-jul-1991 - Fix ACTIVATE EVENT statement so that a
**			      error will be displayed if the statement
**			      is in a submenu block. (teresal)
**		12-jul-1991 - Allow location name in WITH clause to be a
**			      string variable, e.g., "WITH LOCATION = (:loc1)".
**			      Fix for bug 35797. (teresal)
**		19-jul-1991 - Change EVENT to DBEVENT. (teresal)
**		19-aug-1991 - Added hp3_us5 pragma to use the highest possible
**			      optimization level and thus avoiding a compiler
**			      failure in hp-ux 8.0. (johnr)
**		13-nov-1991 - Fixed bug 40902: initialize indicator variable
**			      symbol for SET_SQL if a constant is used - this 
**			      will avoid generating incorrect code.(teresal)
**      	29-Apr-92     (purusho)
**          		      Amdahl C compiler cribs about # pragma OPT_LEVEL 1
**			      starting at column 1 and hence inserted a tab 
**			      character
**		15-Jun-1992 - Added "GRANT OPTION FOR" and "RESTRICT|CASCADE"
**			      clauses to REVOKE.  Also allow SELECT, DELETE,
**			      INSERT, UPDATE, RAISE, REGISTER, EXECUTE, as well
**			      as ON tablename, ON DBEVENT, ON PROCEDURE, in the
**			      REVOKE statement.  Also removed an erroneous
**			      comment. (lan)
**		15-Jun-1992 - Removed GRANT OPTION as a double keyword. (lan)
**		23-Jun-1992 - Fixed bug 45006 where ESQL generates incorrect
**			      code for the "REVOKE... on database.." statement.
**			      Added new rule revoke_obj_name. (lan)
**		24-Jun-1992 - "RESTRICT|CASCADE" clause in the REVOKE statement
**			      is optional.  Also updated comments on the REVOKE
**			      syntax. (lan)
**		02-Jul-1992 - Added "DECLARE GLOBAL TEMPORARY TABLE" statement.
**			      This statement is non-FIPS and non-OpenSQL. (lan)
**		02-Jul-1992 - Allow USER in the INSERT statement, bug 45512.
**			      (lan)
**		07-Jul-1992 - Added two new statements:  CREATE SYNONYM and
**			      DROP SYNONYM. (lan)
**		08-jul-1992 - Add support for SET USER AUTHORIZATION and SET
**                            [NO]GROUP.  (larrym)
**		08-jul-1992 - Added session_key to set_whval to handle SET 
**		              LOCKMODE x WHERE y = SESSION; (larrym)
**		09-jul-1992 - Cleaned up open/sql flagging code in SET
**			      statement.  Currently only SET AUTOCOMMIT is 
**			      allowed in open/sql. (larrym)
**		10-Jul-1992 - Fix problems where normal uses of the words 
**			      SESSION and ROWS in SQL and FORMS statements 
**			      cause syntax errors. (lan)
**		30-Jul-1992 - Added CREATE SCHEMA statement.  Added two new
**			      keywords, AUTHORIZATION and SCHEMA.  Also added
**			      a flag bit, ESQ_CRE_SCHEMA, for esq->flag.  This
**			      is used to know whether a statement is within a
**			      CREATE SCHEMA statement. (lan)
**		04-Aug-1992 - Added ALTER SECURITY_AUDIT statement with
**			      warning flags for non-FIPS and non-OpenSQL. (lan)
**		26-Aug-1992 - Added ESQL grammar support for table constraints 
**			      and user-defined defaults.  Modified the following
**			      statements:
**			      o alter table (add/drop constraint)
**			      o grant and revoke (allow privilege references)
**			      o create rule (column list for the update clause)
**			      o create table (allow constraints)
**			      (lan)
**              08-Sep-1992 - Added schema.objectname to
**			      CREATE DBEVENT/INDEX/INTEGRITY/RULE/TABLE/VIEW,
**			      DECLARE TABLE, DROP, EXECUTE PROCEDURE, GRANT,
**			      MODIFY, SET JOURNALING/LOCKMODE.
**			      Also added schema.tablename.columnname to
**			      the target list in the SELECT statement,
**			      column references in a search condition,
**			      aggregate functions, GROUP BY clause. (lan)
**		21-Sep-1992 - Allow long varchar(iconst) as type in the
**			      CREATE TABLE statement. (lan)
**		24-sep-1992 - Enhance FIPS flagger to flag illegal FIPS
**			      identifiers including: ids that match ANSI SQL2
**			      reserved words (not reserved by ingres), 
**			      identifiers that are too long, and ids
**			      which contain Ingres only special chars. 
**			      As part of this change add PUBLIC as keyword.
**			      (teresal)
**	02-oct-1992 (larrym)
**		Added ability to use reserved words in a host variable 
**		reference.  When we see a colon, we set a global to turn off
**		keyword lookups.  All but one of the semantics for this are
**		in the slave grammers; the exception is indicator variables.
**		For details on this change, look in a slave grammer under
**		HOST VARIABLE USAGE.  I also updated the Copywrite notice to
**		conform to the standard and have started using the new history
**		format.
**	07-oct-1992 (lan)
**		Added tEXISTS to frs_constname.
**	14-oct-1992 (lan)
**		Added EXEC SQL ENDDATA.  Added new rule, sql_frs_stmt.
**	01-nov-1992 (kathryn)
**		Added EXEC SQL GET DATA and EXEC SQL PUT DATA statements.
**	06-nov-1992 (lan)
**		FIPS flagger.  Flag all non-FIPS syntax.
**	09-nov-1992 (lan)
**		Added DATAHANDLER syntax.
**	16-nov-1992 (lan)
**		Added arguments to db_var and rep_add calls.  Also for
**		datahandler update, db_var is called instead of erec_mem_add
**		and then erec_use.
**	19-nov-1992 (lan)
**		Made the argument name in the datahandler clause optional.
**	24-nov-1992 (lan)
**		Allow owner.table syntax in the REGISTER and CREATE LINK
**		statements.  Also allow single quotes around owner name.
**	24-nov-1992 (lan)
**		Added owner.table syntax to the references clause and the
**		create security_alarm, drop security_alarm statements.  Allow
**		float constants in the default clause.  Allow references
**		privilege without a column list in the grant statement.
**	2-dec-1992 (Mike S) Add SEND USEREVENT
**	08-dec-1992 (lan)
**		Fixed a problem with the datahandler clause.
**	09-dec-1992 (lan)
**		Added SET SESSION AUTHORIZATION syntax.
**	14-dec-1992 (lan)
**		Added support for delimited identifiers.
**	15-dec-1992 (larrym)
**	    added BYREF parameters to database procedures.
**	16-dec-1992 (larrym)
**	    added SQLCODE & SQLSTATE support to preprocessors.  This included
**	    moving the esq_struct definition to a header file, and also 
**	    added a gen statement to the SET_SQL (SESSION) statement.
**	18-dec-1992 (larrym)
**	    Fixed problem where SQLSTATE symbol was being gen'd for every
**	    set_sql (session) statement when no SQLSTATE was declared.
**	08-jan-1993 (lan)
**	    Fixed bug where correct uses of mnemonic constants "off", "on",
**	    and "bell" in set_frs statements were not accepted.
**	    Also added COLUMN and FIELD to frs_constobj.
**	12-jan-1993 (lan)
**	    Fixed problem where incorrect code was generated for constants
**	    "on", "off", and "bell" used in set_frs statements.
**	14-jan-1993 (lan)
**	    Allow host variables in the "SET SESSION AUTHORIZATION" statement.
**	    Allow the keywords CURRENT_USER, SYSTEM_USER, SESSION_USER,
**	    INITIAL_USER wherever the keyword USER was currently allowed as a
**	    constant.  Flag the uses of the USER keywords as non-FIPS.  Removed
**	    rules for "SET USER AUTHORIZATION".
**	27-jan-1993 (lan)
**	    Fixed a merge_project problem.
**	11-feb-1993 (lan)
**	    Modified the gen_diaginit section (removed gen_call).
**	24-feb-1993 (lan)
**	    Fixed bug 45987 where the escape clause in the like predicate was
**	    not flagged as non Open SQL.
**	09-mar-1993 (larrym)
**	    added connection name support, CONNECT TO dbname AS 'conname'
**	    SET CONNECTION 'conname', and DISCONNECT 'conname'.  SET CONNECTION
**	    was added under SET_SQL and not under SET.
**	11-mar-1993 (lan)
**	    Fixed miscellaneous bugs where the owner.objectname construct and
**	    delimited identifiers were not accepted in a few statements.  Also
**	    allow the datahandler syntax in the using clause of the execute
**	    statement.
**	14-mar-1993 (larrym)
**	    fixed bug with set connection :hostvar.
**	30-mar-1993 (davel)
**	    fixed EXEC 4GL CALLFRAME now that BYREF is a reserved word.
**	10-apr-1993 (kathryn)
**	    Add mandatory cascade/restrict clause to drop constraint clause
**	    of ALTER TABLE statment:
**	    	ALTER TABLE <tname> DROP CONSTRAINT <c_name> CASCADE|RESTRICT.
**	26-apr-1993 (lan)
**	    Fixed a NIST bug where the union of a column specification with a
**	    literal was not flagged by the FIPS flagger.
**	20-may-1993 (kathryn)
**	    Don't set ESQ_NOPRT bit of the esq->flag for the DECLARE CURSOR
**	    statement. Although this statement does not produce output we
**	    still need to db_key the USER keyword so it can be buffered for 
**	    the OPEN CURSOR statement.
**	26-may-1993 (kathryn)
**	    Change above fix to turn on the ESQ_NOPRT flag before the call
**	    to gr_mechanism and at the end of the stmt so that a set of
**	    empty braces are not generated in "C".  
**	10-jun-1993 (kathryn)  FIPS
**	    When EQ_ENDIF flag is set, generate code to close an IF stmt.
**          This flag is set (in Fortran Only) when we find an SQL statement
**	    on the same line as a logical if:    if (x) exec sql ...
**	    Since fortran only allows one executable stmt in a logical if, 
**	    and one SQL stmt may generate multiple fortran stmts we must change
**	    the "logical if" stmt to a "block if" stmt.  We generated  
**	    "if (x) then" when we scanned the host stmt, so we must now 
**	    generate the "end if" even if the SQL stmt did not gen any code.
**	10-jun-1993 (kathryn)
**	    FIPS - Add support for ANSI SQL retrieval assignment rules. When
**	    the pre-processor flag to indicate FIPS assignment rules is set,
**	    add calls to IIsqMods around statements that retrieve data into
**	    application host variables.  This will set the runtime behavior.
**	    to blank-pad as well as EOS terminate C fixed length vars.
**	    Since the scope of this behavior is a module (file), we need to
**	    Turn it on, get the data and turn it off before giving control
**	    back to the user, the application may call into another file
**	    which was not preprocessed with the startup flag from within
**	    select loops, datahandlers, etc..
**	25-jun-1993 (kathryn)
**	    Move check for ENDIF flag from xstatement rule to estatement rules.
**	    For stmts which may do lookahead (select and execute), use
**	    gr_flag to hold ENDIF flag, so that if lookahead is new host stmt 
**	    which also needs ENDIF the current stmt won't unset it when it gens
**	    the END IF.
**      25-jun-1993 (kathryn)   Bug 52932
**          Changed datahdlr_cls and datahdlr_arg rules and removed
**          datahdlr_head and datahdlr_tail rules, to allow more than just
**          tNAME for DATAHANDLER argument.  Use sc_eat to skip datahandler 
**	    argument.
**	25-jun-93 (robf)
**	    Secure 2.0:
**		Add SET SESSION WITH SECURITY_LABEL = statement
**	13-jul-1993 (kathryn)
**	    Added $DBA and $INGRES as valid user constants. Added new rule
**	    ing_user for user constants which are Ingres only (non-FIPS/OPEN):
**	    $DBA, $INGRES, and INITIAL_USER.
**	15-jul-1993 (kathryn)
**	    Added new ANY aggregate function for select taget list and
**	    the having clause of the SELECT statement.
**	22-jul-1993 (seiwald)
**		Added in rule for remote system_user remote system_passwd 
**		connect syntax.
**	07/28/93 (dkh) - Added support for the PURGETABLE and RESUME
**			 NEXTFIELD/PREVIOUSFIELD statements.
**	10-aug-1993 (kathryn) 
**	    Bug 54008 - changed ins_scalar_bif rule to allow three arguments 
**	    to decimal function. Also added sql_opt_excl rule for GRANT stmt. 
**	8/93 (Mike S)
**	    Pass the correct string to gr_mechanism for EXEC 4GL CALLPROC
**	    and CALLFRAME.  Previously, the generated comment would be
**	    wrong if a dynamic name were used for the call, since gr->gr_id
**	    had been re-used.
**	18-aug-1993 (kathryn)
**	    "USER" constant is FIPS compliant - No longer flag this.
**	8-sep-93 (robf)
**	    Add better support for SET TRACE POINT statement, now allows
**	    two optional following integer values (sql_trace_point)
**	14-sep-93 (robf)
**	    Add support CREATE/ALTER/DROP PROFILE statements
**	11-oct-1993 (teresal)
**	    Put in fix so delimited cursor names are generated correctly.
**	    This fix affects any delimited id that is generated directly,
**	    i.e., not using db_key() this includes procedure names, rules,
**	    permits, describe & execute statements, and table name in the
**	    DELETE statement. Bug 53. Bug 53409.
**	12-oct-93 (donc)
**	    For 6.5 OpenSQL was enhanced w/ statements such as GRANT, REVOKE,
**	    the ESCAPE modifier in LIKE clauses, and etc., I made it so that
**	    these statements are will not be flagged as non-OpenSql when the
**	    preprocessor is run with the -wsql=open option.
**	13-oct-93 (donc)
**	    Some of the proposed additions to OpenSQL didn't get in, added
**	    back warnings GRANT and REVOKE. Added a warning for CREATE SCHEMA.
**	    This was an LRC decision (10/13/93)
**	28-oct-93 (teresal)
**	    To comply with ANSI SQL2 (and to pass the NIST tests), made
** 	    AS optional before the result column of a SELECT statement, e.g.,
**	    allow the following:
**		"SELECT a + b AS col1, c + d col2, myid col3 
**			INTO :col1var, :col2var, :col3var
**			FROM t1;".
**	    This fixes bug #55916.
**	9-nov-93 (robf)
**           Add support for session priority in SET SESSION statement (allow
**	     signed values)
**	     Add DBMS PASSWORD clause to CONNECT statement
**	9-dec-93 (robf)
**           Reworked CREATE/DROP SECURITY_ALARM for new extended syntax
**	16-nov-93 (teresal)
**	    To comply with ANSI SQL2, allow the escape character to be
**	    a string variable. Bug fix 55914.
**	17-dec-93 (donc) Bug 56875
**	    Modify production used to generate PREPARE ... INTO :sqlda
**	    to use new ARG_PSTRUCT arg type when passing a sqlda declaration
**	    to libq from UNIX/Fortran. We need to call new function
**	    IIps in order to dereference the the sqlda structure pointer
**	    in this instance.
**	21-dec-93 (teresal)
**	    FIPS - Add support for checking EOS for C strings. This support
**	    is implemented in a very similar way to the "-blank_pad" flag; 
**	    the "-check_eos" preprocessor flag causes calls to IIsqMods to
**	    be generated around statements that send data from application 
**	    host variables. This sets/resets the runtime behavior to 
**	    examine C strings for the null terminator. Statements affected:
**	    DELETE, DECLARE CURSOR, FETCH, INSERT, PUT DATA, SELECT, SET_SQL,
**	    UPDATE, DELETEROW, INITIALIZE, INSERTROW, LOADTABLE, PUTFORM
**	    PUTROW, SET_FRS, CALLFRAME, CALLPROC, INSERTROW, SET_ATTRIBUTE,
**	    SET_GLOBAL_VARIABLE, SET_GLOBAL_CONSTANT, SET_4GL.
**	    Bug #55915.
**	18-jan-94 (lan)
**	    Fixed bug #58171 - When using the '-wsql=entry_sql92' flag,
**	    ESQL did not generate a warning message when a GROUP BY clause
**	    in a sub-select of a comparison predicate of an SQL statement
**	    was encountered.  Now, warning message E_EQ0511 is generated.
**	14-feb-94 (lan)
**	    Fixed bug #59272 - Get syntax error for cursor declared with
**	    FOR UDPATE without a column list.
**	17-feb-94 (geri)
**	    Changed CONNECT...IDENTIFIED by to work with delimited ids
**	    (bug 56277)
**	08-mar-1994 (mgw) Bug #59881
**	    Remember to turn off the GR_NOSYNC flag after ENDDATA processing
**	    with it on.
**	9-mar-94 (robf)
**          Rework CREATE/ALTER ROLE, SET ROLE, GRANT/REVOKE for 
**	    new/extended syntax.
**	15-mar-94 (timt) bug 57353
**          Accept $ingres or $dba as valid schema name in the 
**          schema.object or schema.tablename.columname construct.
**          Search for b57353tt to see all the changes.
**	17-mar-94 (teresal)
**	    Fix a problem with '-check_eos" flag so that the correct 
**	    IIsqMods() calls are generated when multiple cursors
**	    are opened. (bug 60593)
**	21-mar-94 (robf)
**          With SET ROLE WITH PASSWORD=:var, make sure the password is
**	    sent to the DBMS as a quoted string.
**    	24-mar-94 (timt) bug 57771
** 	   Problem:
**          gen_sqmakesconst uses the same static storage to
**	    hold the modified string constant, in this case, the 
** 	    delimited ids.  If there is another call to        
**	    gen_sqmakesconst, the modified string constant will be
** 	    overwritten.
**	   Fix:        
**          Place the delimited ids (with quotes and escape 
**          characters) in buffers of the string table work space to
**          avoid being overwritten.
**	    Search for b57771tt to see all the changes.
**	06-mar-94 (geri)
**	    Bug 63226: use macro eq_genlang() to generate the host
**	    language arguments to runtime calls so that the C++ 
**	    language is specified correctly to the runtime layer as C
**	    rather than C++.
**	17-may-94 (timt)	Bug 60279
**	    Fix incorrect grammar for the BY clause and the IF clause in
**	    the CREATE SECURITY_ALARM statement.
**	    See tt60279 for all the changes.
**	17-may-94 (timt)	Bug 60282
**	    Hardcoded USER as audit_type in ENABLE/DISABLE SECURITY_AUDIT
**	    statement since USER is a reserved word for sql_id.
**	    See tt60282 for all the changes.
**	23-may-1994 (sylviap)  SIR #62779
**          Changed the grammar so the following statement is valid:
**              EXEC 4GL INLCUDE ...
**      06-dec-1994 (chech02) Bug 60688
**          'UPDATE REPEATED .... DATAHANDLER()..' will generate
**          IILQldh_LoDataHandler() twice. Changed to call rep_add() only
**          if repeat flag is on. Otherwise just call db_var().
**      12-mar-1996 (thoda04)
**          Added cv.h and eqtgt.h for function prototype checking.
**          Corrected rep_close() calls: FALSE, not NULL ptr.
**          Cast frs_parentname()'s last parm to proper type.
**          Cast EQFWsuboption()'s last parm to proper type.
**          Cast eqtl_add()'s parms to proper types.
**          Corrected ret_add() call with too few arguments.
**          Corrected frs_setval() call with too few arguments.
**	10-may-1996 (kch)
**	    Added grammar for the long varchar, long byte and byte varying copy
**	    formats. This change fixes bug 74322.
**      7-April-1997 consi01 bug 81399
**          Changed rule for INITTABLE statement to use the token tDEFAULT
**          which was added on 26-aug-1992. Prior to this the word 'default'
**          was classified as a tNAME. Also removed hard coded test for
**          "default" as it is no longer required.
**	27-Feb-1997 (jenjo02)
**	    Added grammar for SET TRANSACTION <isolation level> | <access mode>.
**	    Extended <set session> statement to support <session access mode>
**	    (READ ONLY | READ WRITE).
**	24-Mar-1997 (jenjo02)
**	    In disp_mode production, add tREAD now that "read" is a token.
**	26-Mar-1997 (jenjo02)
**	    Add grammar for MODIFY TABLE ... TO PRIORITY <cache_priority>
**	    Added tREAD keyword to setf_targlist.
**	25-apr-97 (inkdo01)
**	    Fixed Jon's spelling and added support for "SESSION.tablename"
**	    as an "execute procedure" parameter.
**	7-may-97 (inkdo01)
**	    Added syntax for statement level rule definition.
**	8-may-97 (inkdo01)
**	    Changed tSTATEMENT to double word token so statement doesn't
**	    become a reserved word.
**	17-oct-1997 (nanpr01)
**	    Allow cursor delete for temporary tables. Bug # 86504
**	20-oct-1997 (nanpr01)
**	    yacc stack is getting clobbered with my previous change
**	    causing declare global temp to fail.
**      14-oct-1997 (stial01)
**          Added SET SESSION ISOLATION LEVEL, SET SESSION accessmode,
**          both before the SET SESSION WITH.
**	03-Nov-1997 (shero03)
**	    Added RTree range clause as part of Create Index with clause
**	11-Nov-1997 (nanpr01)
**	    bug 86778 : revoke statement with schema.obj fails to precompile.
**	18-Dec-97 (gordy)
**	    Added support for NONE identifier for SET CONNECTION NONE,
**	    SET_SQL( SESSION = NONE ).
**	12-dec-98 (inkdo01)
**	    Added optional "from" in fetch.
**	17-june-99 (inkdo01)
**	    Added group by expressions, and belatedly added order by expressions.
**	15-sep-99 (inkdo01)
**	    Added case expressions.
**	25-feb-00 (inkdo01)
**	    Added row-producing procedure support ("result row" clause, "endexecute"
**	    statement).
**	10-mar-00 (inkdo01)
**	    Added parallel index support.
**	24-mar-00 (inkdo01)
**	    Added support for constraint index, referential action enhancements,
**	    tidied column definitions, DECLARE TABLE.
**	11-may-00 (inkdo01)
**	    Added reserved word "row" to list of things in "frs_object" (used to
**	    parse as a tNAME).
**	22-sep-00 (inkdo01)
**	    Added "first n ..." syntax to select statement.
**	04-apr-01 (toumi01)
**	    Added rules to allow tROW in these statements:
**		exec sql set lockmode session where level = row (Bug # 104419)
**		exec sql create index ... with unique_scope = row
**		exec sql create table ... with label_granularity = row
**		exec sql modify ... with unique_scope = row
**		exec sql disable security_audit row
**		exec sql enable security_audit row
**	17-apr-01 (toumi01)
**	    Fix syntax error in EXEC 4GL GETROW ... (OBJ: = ROW) caused
**	    by addition of "row" as an esqlc keyword.  Modify rule for
**	    getrow4gl_params to parse for tROW instead of tNAME.  Also,
**	    remove test of token for match against "row" and issuing of
**	    error E_EQ0081_TL_ATTR_UNKNOWN if not a match; we have an ipso
**	    facto match if the grammar is satisfied.
**	18-apr-2001 (abbjo03)
**	    Add support for an ESCAPE clause using a wchar_t character.
**	2-may-01 (inkdo01)
**	    Fixes for row procs - new code to allow detection of mismatched
**	    result row clause cardinality and handle singleton row procs.
**	10-may-01 (inkdo01)
**	    Added substring function to esql grammar.
**	21-aug-01 (inkdo01)
**	    Added 2nd "left nest" token to sc_tokeat call to allow recognition
**	    of "case" funcs in "create procedure" statements without premature 
**	    termination of proc def.
**	28-aug-01 (inkdo01)
**	    Altered position of ProcStatus call loop end to avoid extra
**	    GCA1_INVPROC message.
**	23-oct-01 (inkdo01)
**	    Added optional AS between table name and correlation name.
**	20-Dec-2001 (bolke01)
**	   bug: 106708 Added a call to the break function to enable a flush
**	   this is required to correct a sync-up problem that exhibits
**	   itself as a process hang or the return of the first record of the 
**	   data-stream when executed in a REPEATED SELECT LOOP.
**	20-Dec-2001 (bolke01)
**	   Revoke above fix. The use of the IIBREAK after the
**	   new IIFLUSH causes problems for CURSORS with nested SELECT LOOPS.
**	   (b106889)
**	20-mar-02 (inkdo01)
**	    Added grammar for sequence support.
**	17-oct-02 (toumi01) bug 108958
**	    Add additional "arg_int_add( 0 );" call to result_clause: rule
**	    to avoid bogus E_EQ0317 precompiling a COBOL program with a
**	    procedure that has no result rows.
**	25-oct-02 (toumi01)
**	    Back out previous change to add arg_int_add in result_clause as
**	    it fixes COBOL but breaks C.
**	29-oct-02 (toumi01)
**	    Reinstate bug 108958 fix conditional on language = COBOL.
**	19-mar-03 (inkdo01)
**	    Updates for ESQL grammar for sequences (fixes insert and 
**	    "next value for a.b" in all DMLs).
**	20-mar-03 (inkdo01)
**	    Fix double IIrtEn labels from singleton RPPs.
**	25-mar-03 (inkdo01)
**	    More sequence syntax fixes (+/- in front of max/min/start/...).
**	25-mar-03 (inkdo01)
**	    Add support of REVOKE for sequence authorizations.
**	12-dec-03 (inkdo01)
**	    Fix colspec's to support "character/binary large object" and
**	    "national character large object".
**	09-jan-04 (inkdo01)
**	    Added support of "set joinop timeout nnn".
**	05-mar-04 (inkdo01)
**	    Added support of ANSI CAST, POSITION, TRIM functions.
**	17-Mar-04 (karbh01)    
**	    Added support for ** (Exp operator) in esqlc 
**	29-apr-04 (srisu02)
**	    Fixed grammar errors in crcol_spec - Added a target rule to it, 
**	    fixed minor errors in the target statement 
**	29-Apr-2004 (schka24)
**	    Parse PARTITION with-clause, PARTITION table name modifier
**	    in modify.  Fix typo in "base table structure".  Redo a
**	    couple productions to get rid of reduce/reduce errors.
**	18-May-2004 (jenjo02)
**	    Added SET SESSION WITH ON_LOGFULL = ABORT|COMMIT|NOTIFY
**	01-jun-04 (inkdo01)
**	    Various fixes - "with index = base table structure" to align 
**	    with backend, support negative default column values and fix
**	    "modify <table> to x = y" where x and y are both names.
**	24-aug-04 (toumi01)
**	    Support RESTRICT option for ALTER TABLE DROP column.
**	6-jan-05 (inkdo01)
**	    Add ASYMMETRIC/SYMMETRIC options to BETWEEN predicate.
**	6-jan-05 (inkdo01)
**	    Add collate clause to column creation.
**      08-apr-05 (ashco01) INGEMB#138
**          Incomplete C code written to output file can be syntactically 
**          correct because the ...SYNTAX ERROR message is written within the
**          SQL statement double-quote delimited string. This allows the C
**          file to be successfully compiled although pre-compilation detected
**          an SQL syntax error. Added leading double-quote delimiter to the
**          ...SYNTAX ERROR message to terminate SQL statement and force C
**          compilation error.
**	8-dec-05 (inkdo01)
**	    Added tUCONST to "constant" for Unicode literal support.
**	16-jan-06 (inkdo01)
**	    Added "when" as synonym for "where" in rule definition.
**	17-jan-06 (dougi)
**	    Added additional "defaults" syntax to insert, update.
**	29-jan-06 (dougi)
**	    Added derived tables (subselect in the FROM clause).
**	2-feb-06 (dougi)
**	    Added collate clause to CAST function.
**      30-Mar-2006 (huazh01)
**          Reset 'gr_nlid' and 'gr_nlsym' after we finishes
**          the SELECT statement. This fixes 114309.
**	3-may-06 (dougi)
**	    Added "x(y,z)" hints to SELECT WITH clause.
**	7-Jun-2006 (kschendel)
**	    implement DESCRIBE INPUT.
**	14-Jun-2006 (kschendel)
**	    Add sequence defaults to create/declare table.  This required
**	    adding "noprint" tests in a bunch of silly places, lest
**	    "declare table" screw up an executable esql statement.
**	23-june-06 (dougi) SIR 116270
**	    Add BEFORE to "create rule" syntax.
**	8-sep-06 (toumi01)
**	    Support optional "SESSION." in precompiler GTT declaration.
**	17-jan-2007 (dougi)
**	    Add scrollable cursor option.
**	8-mar-2007 (dougi)
**	    Change to subfields in eqgr.h to avoid breaking VMS.
**	05-apr-2007 (toumi01)
**	    Add support for the Ada ' tick operator.
**	03-aug-2007 (toumi01)
**	    Since embed SQL support for scrollable cursor is a work in
**	    progress (especially libq support) turn it off for now.
**	    Look for "DISABLE SCROLL CURSOR" to find the code that is
**	    commented out.
**	13-aug-2007 (dougi)
**	    Update grammar to support date/time type declarations.
**	11-dec-2007 (dougi)
**	    Add grammar for "fetch first n rows only" and "offset n".
**	21-Jan-2008 (kiria01) b119806
**	    Extend grammar for postfix operators beyond IS NULL
**	25-jan-2008 (dougi)
**	    Slight fix to allow "fetch first n ..." when n is a parameter.
**	05-Feb-2008 (kiria01) b119856
**	    Add USING clause to join syntax
**	26-feb-2007 (dougi) b120005
**	    Add offset/first "n" to cursor select's, create table as ...
**	    and insert into ... select ...
**	5-march-2008 (dougi)
**	    Add "set session <sql_name>" for [no]cache_dynamic.
**	18-march-2008 (dougi)
**	    Add "order by" to CTAS.
**	26-march-2008 (dougi)
**	    Add missing CROSS JOIN syntax and the long missing optional 
**	    OUTER keyword.
**      12-May-2008 (hanal04) Bug 120359
**          sql_reg_id can now be tINTERVAL OR tNAME. This allows the column
**          name 'interval' to be used with the need to delimit the column
**          name.
**	2-june-2008 (dougi)
**	    Add grammar to support identity columns.
**	29-Jun-2008 (kiria01) b120570
**	    Added expression code for IF(bool,[expr][,expr])
**	21-Jul-2008 (kiria01) b120473
**	    Added new word forms for the LIKE family of predicates and
**	    the WITH/WITHOUT CASE modifier along with the ESCAPE.
**	    Restructure/renamed the elements inpare to match that in the 
**	    main parser.
**      10-Sep-2008 (hanal04) Bug 120799
**          Correct the grammar definintions used for the TRIM() function.
**      18-sept-2008 (huazh01)
**          Turn off the flag GR_HOSTCODE after we have done with the
**          SELECT loop. (bug 120920)
**      17-oct-2008 (huazh01)
**          Turn off GR_HOSTCODE after we processed the 'EXEC SQL INCLUDE ...'
**          line. This allows a #line directive to be issued. 
**          (bug 121091)
**	30-Oct-2008 (kiria01) b120569
**	    Add || concatenator operator support.
**      06-feb-2008 (stial01)
**          Fix size of buffers dependent on DB_MAXNAME
**	8-feb-2009 (dougi) bug 121690
**	    Add table procedure syntax to ESQL.
**	21-feb-2009 (dougi) bug 121689
**	    Fix identity column syntax.
**	26-feb-2009 (dougi) bug 121690
**	    Forgot unnamed parameters.
**	5-march-2009 (dougi) bug 121689
**	    And forgot "overriding" syntax for INSERT.
**	29-march-2009 (dougi) bug 121690
**	    And forgot other subtleties of table procedure syntax.
**      11-Aug-2009 (horda03) B122442
**          The generated code for a DBprocedure call places the END label in the
**          wrong place. After an error, IILQprsProcStatus() should be called once
**          more to clean up. The algorithm for the DBProc call had the IIFlush
**          inside the loop - but this should be outside. Generated code now
**          matches the EXECUTE PROCEDURE algorithm.
**      10-nov-2009 (joea)
**          Add tFALSE, tTRUE, and tUNKNOWN tokens and sql_boolconst and
**          proc_arg_boolconst productions.
**       19-Jan-2010 (horda03) B122756
**          Precompiling a COBOL program which uses a Row Producing procedure
**          errors with E_EQ0317. At the end of a gen_loop(IIPROCSTAT) another
**          call is made to IILQprsProcStatus - and this requires he same parameter
**          that was used when the loop started.
**       25-Jan-2010 (frima01) B123172
**          Split up sql_cast to allow the cast command to be written in the
**          generated file, cause it was erroneously omitted so far.
**	 28-Mar-2010 (gupsh01) B123444
**	    Added Alter table rename table/column .. and rename parsing.
**       23-Apr-2010 (smeke01) b123626
**          Added explicit derived_table production to enable a derived table
**          to appear on the right hand side of a join operator.
**	 26-Aug-2010 (miket) SIR 122403 SD 146503
**	    Add support for encryption, and make TO optional in MODIFY as
**	    it is in the back end grammar, to allow statements like
**	    "MODIFY FOO ENCRYPT WITH PASSPHRASE='this is a secret'".
**
** Rules to apply when writing new grammar parts:
**
** 0. NEVER start a statement with a Null generator - causes Yacc error
**    recovery to allow only that statement as the next rule on a syntax error.
** 1. Whenever introducing an "error" rule always make sure you have tested
**    the rule with ESQL/FORTRAN.  Since FORTRAN does NOT have terminators,
**    YACC has a problem reducing the error rule together with the terminator.
**    ESQL/FORTRAN fakes a terminator while in DML_EXEC mode, consequently
**    there can be no error rules in the middle of statements that attempt
**    to recover before the host terminator - this will cause FORTRAN to go
**    into an infinite loop of pushing back terminators.
** 2. If new statement or any part of statement is not part of OPEN SQL,
**    call er_write() with E_EQ0504_OPEN_WARN warning.
**
** Conventions used in appearance of the statements:
** 
** 1. All major rules should be commented with a description of their syntax 
**    (capitalize reserved words) and what they generate etc.
** 2. All main rules are in alphabetical order.
** 3. Note the stylized comments that begin with:
**    /* %L object [begin|end]
**    All these comments are used by the merging tool eqmerge.
**    Usage: eqmerge [tokens|grammar|language] Gfile Lfile output.
*/

/* SQL keywords (some QUEL in these too) */
%token	tABORT		tCOPY		tHELP		tMODIFY		
	tPRINT		tREGISTER	tRELOCATE	tREMOVE
	tSAVE		tSAVEPOINT	tSET
	tCOLLATE	tCOMMIT		tROLLBACK	tREVOKE
	tBYREF		tDISTINCT
	tOF		tNULL		tNOT
	tLIKE		tNOTLIKE	tBEGINNING	tNOTBEGINNING
	tCONTAINING	tNOTCONTAINING	tENDING		tNOTENDING
	tSIMILAR	tNOTSIMILAR
	tESCAPE		tEXCLUDING	tGRANT
	tUSING		tFIRST		tKEYSET		tOFFSET
	tABSOLUTE	tLAST		tPRIOR		tRELATIVE
	tEXECUTE	tIMMED		tONLY
	tDESCRIBE	/* Also a forms keyword (DESCRIBE TABLE) */
	tPREPARE	tDESCRIPTOR
	tREPEAT		tENDSELECT
	tINDICATOR
	tALWAYS		tGENERATED	tIDENTITY	tAUTOINCREMENT
	tOVERRIDING	tSYSTEM		tVALUE
	tBEGIN 		tEND
	tANY		tAS		tAVG		tADD
	tASYMMETRIC	tBETWEEN	tCASE		tCAST
	tCOUNT		tCREATE		tDELETE		tDISTINCT 
	tDROP		tELSE		tOUTER
	tEXISTS		tFULL		tGROUP		tHAVING 
	tINDEX		tINNER		tINSERT		tINTEGRITY
	tINTERVAL	tJOIN		tLEFT		tCROSS
	tMAX		tMIN		tNATURAL	tORDER
	tPERMIT 	tRIGHT		tSUBSTRING	tSYMMETRIC
	tSELECT		tSUM		tTABLE		tTHEN
	tUNION		tUNIQUE		tUPDATE		tVALUES
	tCURRVAL	tNEXTVAL	tVIEW		tWHEN
	tRESTRICT	tCASCADE
	tGLOBAL		tTEMPORARY	tSESSION	tPRESERVE
	tROWS		tSYSTEM_MAINTAINED
	tAUTHORIZATION	tSCHEMA
	tCONSTRAINT	tFOREIGN	tPRIMARY	tREFERENCES
	tDEFAULT	tCHECK		tKEY		tUSER
	tPUBLIC
	tDATAHANDLER
	tCACHE		tCYCLE		tINCREMENT	tMAXVALUE
	tMINVALUE	tNOCACHE	tNOCYCLE	tNOMAXVALUE
	tNOMINVALUE	tNOORDER	tRESTART	tSTART
	tSYSTEM_USER	tSESSION_USER	tCURRENT_USER	tINITIAL_USER
	tUNCOMMITTED	tCOMMITTED	tREPEATABLE
	tSERIALIZABLE	tREAD		tPARTITION
	tWITHOUT	tWITHCASE	tWOCASE
        tFALSE          tTRUE           tUNKNOWN	tRENAME
	tENCRYPT

/* Special embedded SQL keywords (directives, cursors, control flow etc.) */
%token	tCALL		tCLOSE		tCONNECT	tCONTINUE
	tCURRENT	tCURSOR		tDECLARE	tDISCONNECT
	tEND_EXEC	tFETCH		tGOTO		tIDENTIFIED
	tOPEN		tPROCEDURE	tSECTION	tSTOP
	tWHENEVER	tIIPRINTF
	tINQ_INGRES	tSET_INGRES	tSET_CONNECT
        tREM_SYS_USER	tREM_SYS_PASS
	tENDEXECUTE	tRESULT		tROW

/* Forms keywords */
%token	tFORMS		tFORMINIT	tADDFORM	tFORMDATA	
	tDISPLAY	tINITIALIZE	tFINALIZE	tACTIVATE	
	tPUTFORM	tGETFORM	tGETOPER	tREDISPLAY	
	tMESSAGE	tSLEEP		tCLEAR		tHELPFILE	
	tPROMPT		tSUBMENU	tVALIDATE	tRESUME
	tENDFORMS	tENDDISPLAY	tBREAKDISPLAY	tENDDATA
	tENDLOOP
	tSET_FRS	tINQ_FRS	tPUTOPER	tPRINTSCREEN
	tHELP_FRS
	tIIPROMPT	tIIMESSAGE

/* Table Field keywords */
%token	tCLEARROW	tDELETEROW	tINSERTROW	tGETROW		
	tPUTROW		tLOADTABLE	tINITTABLE	tVALIDROW	
	tUNLOADTABLE	tSCROLL		tTABLEDATA	tPURGETBL

/* SQL and Forms Noise keywords */
%token	tALL		tBY		tFROM		tIN		
	tINTO		tIS		tOF		tON		
	tTO		tWHERE		tUNTIL		tAT		
	tNOTRIM		tWITH		tFOR		tIF
	tSQL

/* Forms and Table Fields noise keywords */
%token	tFIELD		tMENUITEM	tCOMMAND	tNEXT		
	tSCREEN		tUP		tDOWN		tOUT		
	tCOLUMN		tSCROLLUP	tSCROLLDOWN

/* Equel Constants and Special Objects from scanner (see tok_special) */
%token	tINTCONST	tFLTCONST	/* Numeric constants from scanner */
	tNAME		tSCONST		/* User names and string constants */
	tHEXCONST			/* Hexadecimal integer constants */
	tDECCONST			/* Decimal constant */
	tUCONST				/* Unicode literals */
	tDTCONST			/* Date/time literals */
	tIVCONST			/* interval literals */
	tHOSTCODE			/* Program code */
	tINCLUDE			/* Include file (or Eof of one) */
	tEOFINC
	tQUOTE				/* Token to trigger string constants */
	tCOMMENT			/*	 and comment skipping	     */
	tTERMINATE			/* Statement terminators */
	tWHITESPACE			/* whitespace -- raw mode only */
	tDELIMID
	tATICK				/* Ada ' tick operator */

/* ESQL Punctuation */
%token	tCOMMA		tLPAREN		tRPAREN		tPERIOD
	tCOLON		tDOLLAR

/* EXEC 4GL keywords. */
	tREMOVEROW	tSETROW		tCALLFRAME	tCALLPROC
	tINQ_4GL	tSET_4GL	tINSERTROW_4GL	tDESCRIBE_4GL
	tGETROW_4GL	

/* Double reserved words */
%token
	tALT_GROUP	tALT_LOCATION	tALT_ROLE	tALT_TABLE
	tALT_USER	tALT_DEFAULT	tALT_SEQUENCE
	tBEG_DECLARE
	tBEG_EXCLUDE	tEND_EXCLUDE
	tBEG_XACT	tCOM_ON		tCRE_DBEVENT
	tCRE_LINK	tCRE_ROLE	tCRE_DOM	tCRE_SEQUENCE
	tCRE_RULE	tCRE_LOCATION	tCRE_SEC_ALARM	tCRE_USER
	tDESC_FORM	tDESC_INPUT
	tDIS_SEC_AUDIT	tDROP_DBEVENT
	tDROP_LINK	tDROP_ROLE	tDROP_RULE	tDROP_SEQUENCE
	tDROP_LOCATION	tDROP_SEC_ALARM tDROP_USER
	tENA_SEC_AUDIT
	tEND_XACT	
	tGET_ATTR	tGET_GLOBAL	tGET_DATA	tGET_DBEVENT
	tSET_ATTR	tSET_GLOBAL	tSETROW_DEL	tCLEAR_ARRAY
	tHLP_INTEGRITY	tHLP_PERMIT	tHLP_VIEW	tHLP_ALL
	tDIR_EXECUTE	tDIR_CONNECT	tDIR_DISCONNECT
	tDROP_DOM	tRAISE_DBEVENT	tREM_DBEVENT	tREG_DBEVENT
	tONCOMMIT	tPUT_DATA	tONDATABASE
	tCRE_SYNONYM	tDROP_SYNONYM
	tALT_SEC_AUDIT	tSEND_USEREVENT
	tCRE_PROFILE	tALT_PROFILE	tDROP_PROFILE
	tDBMS_PASSWORD
	tREAD_ONLY	tREAD_WRITE	tISO_LEVEL	tSET_TRANS
	tEACH_ROW	tEACH_STATEMENT
	tWTIME		tWLOCAL		tWOTIME		tREN_TABLE
    /*
    ** Not currently used
    **	tDROP_INTEGRITY tDROP_PERMIT	tDROP_TABLE	tDROP_LNKTEMP
    */

/* %L fake begin - Dummy tokens to support some rules defined in L */
%token	tH_DECLARE	tH_TERM 
%token	tL_BLK_BEGIN	tL_BLK_END
/* %L fake end */

/* %L tokens */

/* Operators */
%token		tOR		tAND
%token		tLT		tGT		tNE
		tLE		tGE		tEQOP
%token		tPLUS		tMINUS		tSTAR		tSLASH
		tEXP		tCONCAT
%token		tUNARYOP

/* Ascending Precedence for Operators */
%left		tOR
%left		tAND
%left		tNOT
%nonassoc	tLT		tGT
		tNE		tLE		tGE		tEQOP
%left		tPLUS		tMINUS
%left		tSTAR		tSLASH
%left		tEXP		tCONCAT
%left
%left		tUNARYOP
%left		tPERIOD

%start	program

%{	

/* 
** SQL-specific support from the original SQL grammar.
*/

/*
** ESQL-specific support for the SQL statements that are embedded (not FRS).
**
** This information is only valid on a per-statement level, and should be 
** zero-ed out after each statement. See GR_STMTFREE.
*/

/* structure definition has been moved to front.hdr.hdr.eqesql.h */
GLOBALDEF struct esq_struct _esq_struct ZERO_FILL;
GLOBALDEF struct esq_struct *esq = &_esq_struct;
GLOBALDEF char	 session_temp[100];

/* Flag bits for esq->flag */
# define	ESQ_CURSOR	0x001	/* declaring or using a cursor */
# define	ESQ_DISTINCT	0x002
# define	ESQ_NOPRT	0x004
# define	ESQ_DECLCSR	0x008	/* declaring a cursor */
# define	ESQ_REG_SELECT	0x010	/* A non-repeat SELECT */
# define	ESQ_DESC_SEL	0x020	/* A dynamic SELECT using DESCRIPTOR */
# define        ESQ_FROM_CHK    0x040    /* In FROM clause of csr select */
# define	ESQ_CRE_SCHEMA	0x080	/* In CREATE SCHEMA statement */
# define	ESQ_PROC_BYREF	0x100	/* DBproc call is passing parms byref */
# define	ESQ_UNION_SEL	0x200	/* check target list */
# define	ESQ_WITHABLE_CONSTRAINT 0x400 /* just parsed unique/fkey constr */
# define	ESQ_PROC_RESULT	0x800	/* DBproc call has "result row" */

/* Macro to tell if we are using or declaring a cursor */
# define	ESQ_CSRDEC(x)	(x->flag & ESQ_CURSOR)

/* Macro to tell if we are DECLARING a cursor */
# define	ESQ_DCLCSR(x) \
	(((x)->flag & (ESQ_CURSOR|ESQ_DECLCSR)) == (ESQ_CURSOR|ESQ_DECLCSR))

/* Flag bits returned by csr_select_sub and friends */
# define CSR_STATIC	0x00	/* WHERE clause static (or missing) */
# define CSR_NO_FROM	0x01	/* No FROM clause */
# define CSR_NO_WHERE	0x02	/* No WHERE clause */
# define CSR_WHERE_VAR	0x04	/* if there was a WHERE clause in a variable */
# define CSR_UPDATE	0x08	/* if there was an UPDATE clause */
# define CSR_UPD_LIST	0x10	/* if an UPDATE list in the UPDATE clause */
# define CSR_UPDATE_LIST (CSR_UPDATE|CSR_UPD_LIST) /* UPD_LIST implies UPDATE */

/* Convenience string comparison macro: ignore case, check entire string */
# define ESQ_EQSTR(a, b)	(STbcompare((a), 0, (b), 0, TRUE) == 0)

/* Flag bits returned by dec_nullfmt and children */
# define CRE_OK		0x00	/* FIPS and OPEN-SQL compliant */
# define CRE_WDEF	0x01	/* WITH DEFAULT is non-FIPS and non-OPEN SQL */
# define CRE_NDEF	0x02	/* NOT DEFAULT is non-FIPS and non-OPEN SQL */
# define CRE_WSYS	0x04	/* WITH SYSTEM_MAINTAINED non-FIPS, non-OPEN */
# define CRE_NSYS	0x08	/* NOT SYSTEM_MAINTAINED non-FIPS, non-OPEN */
# define CRE_WNUL	0x10	/* WITH NULL is non-FIPS */
# define CRE_OBJKEY	0x20	/* OBJECT_KEY is non-FIPS non-OPEN SQL */
# define CRE_TBLKEY	0x40	/* TABLE_KEY is non-FIPS non-OPEN SQL */
# define CRE_NFIPS	0x80	/* non-FIPS */
# define CRE_CONWTH	0x100	/* constraint WITH clause */

/* Flag bits returned by from_list */
# define FRM_OK		0x00	/* FIPS and OPEN-SQL compliant */
# define FRM_JOIN	0x01	/* FROM with Outer Join non-Fips, non-OPEN SQL*/

/* Stucture for EXEC 4GL INSERTROW */
typedef struct insrow4gl_parms
{
    char *rownumber;		/* String for rownumber */
    char *row;			/* String for object to insert */
    char *row_state;		/* String for state of new row */
} INSROW4GL_PARMS;
static VOID set_insrow_param(
   char *name, char *value, i4  type, SYM *symbol, INSROW4GL_PARMS *param);

%}

%{

/* %L locals - Include L locals and global gr structure */

/* %L fake begin - Dummy declaration of gr to allow compilation */
struct	gr_state {
	/* Members known to both G and L */
	SYM	*gr_sym;
	char	*gr_id;		/* Last full name used */
	i4	gr_type;
	i4	gr_flag;	/* Certain state information */
	i4	gr_func;	/* I/O Function constant */
	i4	gr_mode;	/* Mode of statement before entering block */
	i4	gr_adjective;	/* Block modifier */
	SYM	*gr_nlsym;	/* Symtab pointer to indicator var */
	char	*gr_nlid;	/* Id of indicator var */
	i4	gr_nltype;	/* Type of indicator var */
	SYM	*gr_null;	/* Generic null symbol (for "=null" assgnmts) */
	i4	gr_rcnt;	/* Count of result row entries */
};
extern struct gr_state *gr;
extern struct gr_state tempgr;
/* %L fake end */

%}

/*
+* ---- Statements ----
*/

%%
/* Program Control Structure */

program:	program statement
		{
		    /* 
		    ** Note that FRS blocks fall through to this rule too, so
		    ** if you add actions here, do it at block_stmt too.
		    */
		    gr_mechanism( GR_STMTFREE );
		}
	|	/* No statement */
;

statement:	xstatement
		{
		    gr->gr_func = 0;	/* No current function */
		}
;
xstatement:	estatement			/* Embedded statements */
	|	include_stmt			/* Include open and close */
	|	host_declare			/* Declare block defined by L */
	|	host_code			/* Defined by L */
;

/* Statements beginning with EXEC {SQL | FRS} */

estatement:	sql_statement host_term		/* SQL statements */
		{
		    if (eq->eq_flags & EQ_CHREOS) /* Turn EOS checking Off */
			esq_eoscall(IImodNOCEOS);
		    if ((gr->gr_flag & GR_NOSYNC) == 0)
		    {
			if (gr->gr_flag & GR_REPEAT)
			    rep_close( IISYNCUP, NULL, FALSE );
			else
			{
			    if (gr->gr_flag & GR_COPY_PROG)
			    /* 
			    ** If COPY FROM/INTO PROGRAM, check that handler has
			    ** been declared.
			    */
			    {
				db_send();
				if ((gr->gr_flag & GR_SEENCPYHND) == 0)
				{
				    er_write(E_EQ0091_COPYHANDLER, EQ_ERROR, 0);
				    eqtl_init(IISETSQL);
				    eqtl_add(ERx("0"), (PTR)0, (PTR)0, (PTR)0,
					T_NONE, ERx("copyhandler"));
				}
				eqgen_tl(IISETSQL);
				gr->gr_flag &= ~(GR_SEENCPYHND|GR_COPY_PROG);
			    }
			    db_close( IISYNCUP );
			}
		    }
		    gr->gr_flag &= ~(GR_SQL|GR_REPEAT|GR_NOSYNC);
		    if ((gr->gr_flag & GR_PROCEXEC) == 0)
			gen_sqlca( sqcaGEN );
		    else
			gr->gr_flag &= ~GR_PROCEXEC;
		    gen_eqstmt( G_CLOSE, (char *)0 );
                    if (eq->eq_flags & EQ_ENDIF)
                    {
                        gen_if( G_CLOSE, 0, C_0, 0 );
                        eq->eq_flags &= ~EQ_ENDIF;
                    }
		}
	|	cursor_statement host_term	/* Cursor manipulation */
		{
		    if (eq->eq_flags & EQ_FIPS)
			_VOID_ eqck_tgt( 0, 0 );	/* clear */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			gen_sqlca( sqcaGEN );
			gen_eqstmt( G_CLOSE, (char *)0 );
		    }
		    gr->gr_flag &= ~(GR_SQL|GR_REPEAT);
                    if (eq->eq_flags & EQ_ENDIF)
                    {
                        gen_if( G_CLOSE, 0, C_0, 0 );
                        eq->eq_flags &= ~EQ_ENDIF;
                    }
		}
	|	esql_statement host_term	/* ESQL specific statements */
		{
		    if (eq->eq_flags & EQ_CHREOS) /* Turn EOS checking Off */
			esq_eoscall(IImodNOCEOS);
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			if ($1.i)
			{
			    
			    /* GET DBEVENT must not generate DBEVENT condition */
		            if ((gr->gr_flag & GR_GETEVT) == 0)
			    {
			        gen_sqlca( sqcaGEN );
			    }
			    else
			    {
				gen_sqlca( sqcaGETEVT );
				gr->gr_flag &= ~GR_GETEVT;
			    }
			}
			gen_eqstmt( G_CLOSE, (char *)0 );
		    }
		    gr->gr_flag &= ~(GR_ESQL);
                    if (eq->eq_flags & EQ_ENDIF)
                    {
                        gen_if( G_CLOSE, 0, C_0, 0 );
                        eq->eq_flags &= ~EQ_ENDIF;
                    }
		}
	|	sql_frs_stmt
	        {
    		    gen_eqstmt( G_CLOSE, (char *)0 );
                    if (eq->eq_flags & EQ_ENDIF)
                    {
                        gen_if( G_CLOSE, 0, C_0, 0 );
                        eq->eq_flags &= ~EQ_ENDIF;
                    }
		}
	|	execute		/* May take a select block with own term */
		{
		    if ((gr->gr_flag & GR_NOSYNC) == 0)
		    {
			db_close( IISYNCUP );
		    }
		    gr->gr_flag &= ~GR_NOSYNC;
		    esq->flag &= ~ESQ_REG_SELECT;
		    esq->flag &= ~ESQ_DESC_SEL;
		    gen_sqlca( sqcaGEN );
		    gen_eqstmt( G_CLOSE, (char *)0 );
                    if (gr->gr_flag & GR_ENDIF)
                    {
                        gen_if( G_CLOSE, 0, C_0, 0 );
                        gr->gr_flag &= ~GR_ENDIF;
                    }
		}
	|	select_embed		/* Like FRS, block has own term */
		{
		    if (eq->eq_flags & EQ_FIPS)
			_VOID_ eqck_tgt( 0, 0 );	/* clear */
		    gr->gr_flag &= ~(GR_ESQL|GR_REPEAT);
		    esq->flag &= ~ESQ_REG_SELECT;
		    gen_sqlca( sqcaGEN );
		    gen_eqstmt( G_CLOSE, (char *)0 );
		    if (gr->gr_flag & GR_ENDIF)
		    {
			gen_if( G_CLOSE, 0, C_0, 0 );
			gr->gr_flag &= ~GR_ENDIF;
		    }
		}
	|	proc_exec   		/* Like FRS, block has own term */
		{
		    if (eq->eq_flags & EQ_FIPS)
			_VOID_ eqck_tgt( 0, 0 );	/* clear */
		    if (eq->eq_flags & EQ_CHREOS) /* Turn EOS checking Off */
			esq_eoscall(IImodNOCEOS);
		    if ((gr->gr_flag & GR_NOSYNC) == 0)
		    {
			if (gr->gr_flag & GR_REPEAT)
			    rep_close( IISYNCUP, NULL, FALSE );
		    }
		    gr->gr_flag &= ~(GR_ESQL|GR_REPEAT|GR_NOSYNC);
		    if ((gr->gr_flag & GR_PROCEXEC) == 0)
			gen_sqlca( sqcaGEN );
		    else
			gr->gr_flag &= ~GR_PROCEXEC;
		    gen_eqstmt( G_CLOSE, (char *)0 );
		    if (gr->gr_flag & GR_ENDIF)
		    {
			gen_if( G_CLOSE, 0, C_0, 0 );
			gr->gr_flag &= ~GR_ENDIF;
		    }
		}
	|	frs_statement			/* Forms statements */
		{
		    /* The stmts have their own host_term because of blocks */
		    gr->gr_flag &= ~GR_ESQL;
		    gen_eqstmt( G_CLOSE, (char *)0 );
                    if (eq->eq_flags & EQ_ENDIF)
                    {
                        gen_if( G_CLOSE, 0, C_0, 0 );
                        eq->eq_flags &= ~EQ_ENDIF;
                    }
		}
	|	exec4gl_statement host_term	/* 4GL access statements */
		{
		    gr->gr_flag &= ~GR_ESQL;
		    gen_eqstmt( G_CLOSE, (char *)0 );
                    if (eq->eq_flags & EQ_ENDIF)
                    {
                        gen_if( G_CLOSE, 0, C_0, 0 );
                        eq->eq_flags &= ~EQ_ENDIF;
                    }
		}
	|	error host_term		/* Attempt to synchronize output */
		{
		    if (   (gr->gr_flag & GR_NOSYNC) == 0
			&& (gr->gr_flag & GR_SQL))
		    {
			db_op( ERx("\"...SYNTAX ERROR") );
			if (gr->gr_flag & GR_REPEAT)
			    rep_close( IISYNCUP, NULL, FALSE );
			else
			    db_close( IISYNCUP );
		    }
		    arg_free();
		    id_free();
		    gen_host( G_H_NEWLINE, (char *)0 );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    if ((esq->flag & ESQ_NOPRT) == 0 && 
			    (gr->gr_flag & (GR_SQL|GR_ESQL)))
			gen_eqstmt( G_CLOSE, (char *)0 );
		    if (esq->flag & ESQ_REG_SELECT)
			esl_clean();
		    gr->gr_flag &=
		       ~(GR_SQL|GR_ESQL|GR_REPEAT|GR_NOSYNC|GR_PROCEXEC);
		    gr_mechanism( GR_ERROR );
		}
;

/*
+* ---- INCLUDE Statements ----
*/

/*
+* Statement:	EXEC SQL INCLUDE {string | name | SQLCA | SQLDA}
-* Note:	When seeing INCLUDE alone then this is probably an eof of
**		an included file.
**		Otherwise try to include the file (must use the terminator).
**	
**		Because of the sc_reset we call here, we must make sure
**		that the scanner is synced up.	Consequently we have
**		host_incterm in order for FORTRAN not to have to back up
**		a terminator here too.
**
**	We now allow EXEC SQL INCLUDE <name>.  In order to tell the scinclude
**	routines that we parsed an "angled" file name we use gr_adjective
**	to be set to TRUE/FALSE (angled/regular) which the include routines
**	use to process include files.
*/
include_stmt:	include_key include_name host_incterm
		{
		    /* 
		    ** Strip to end of line, but ensure scanner is synchronized
		    ** via 'lex_newline' - see yylex routines.	This is because
		    ** the newline is the EXEC trigger.
		    */
		    sc_reset();
		    if (   $2.s
			&& inc_parse_name($2.s, gr->gr_adjective) == SC_INC)
			inc_push_file();
		    gr->gr_adjective = 0;
		}
	|	tEOFINC			/* Eof of an included file */
		{
		    /* 
		    ** Better be "<EOF>" else Yacc will produce syntax error.
		    ** File closed by scanner - allowed because of statement
		    ** terminator.
		    */
		    dml->dm_exec = DML_HOST;
		}
;
include_key:	tINCLUDE
		{
                    /* Accept either EXEC SQL | 4GL INCLUDE */

                    if ((dml->dm_exec != (DML_EXEC|DML__SQL)) &&
                        (dml->dm_exec != (DML_EXEC|DML__4GL)))
                        er_write( E_EQ0127_sqEXECMD, EQ_ERROR, 2, ERx("SQL"),
                                                            ERx("INCLUDE") );
		}
;
include_name:	inc_name
		{
		    if (ESQ_EQSTR($1.s, ERx("sqlca")))
		    {
			gen_sqlca( sqcaSQL );
			esq->inc |= sqcaSQL;
			$$.s = (char *)0;
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ050A_FIPS_EXTSN, EQ_WARN,
					    1, ERx("INCLUDE SQLCA") );
		    } else if (ESQ_EQSTR($1.s, ERx("sqlda")))
		    {
			gen_sqlca( sqcaSQLDA );
			esq->inc |= sqcaSQLDA;
			$$.s = (char *)0;
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
					    1, ERx("INCLUDE SQLDA") );
		    } else
		    {
			$$.s = $1.s;
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
					    1, ERx("INCLUDE") );
		    }
		    gr->gr_adjective = FALSE;
		    gr->gr_flag &= ~GR_HOSTCODE;
		}
	|	tLT	/* name(s) tGT <name> */
		{
		    /* Eat the name till right angle bracket */
		    sc_eat(id_add, SC_STRIP, ERx(">"), '<', '>');
		    $$.s = str_add(STRNULL, id_getname());
		    id_free();
		    gr->gr_adjective = TRUE;
		}
;
inc_name:	tSCONST
		{
		    $$.s = $1.s;
		}
	|	tNAME
		{
		    $$.s = $1.s;
		}
;

/* 
+* ---- SQL statements ----
-*
** sql_statement - Statements from the SQL terminal monitor.
*/

sql_statement:	abort
	|	alter_role
	|	alter_group
	|	alter_location
	|	alter_security
	|	alter_sequence
	|	alter_table
	|	alter_user
	|	alter_profile
	|	begin_xact
	|	comment_on
	|	commit
	|	copy 
	|	create_role
	|	create_domain
	|	create_dbevent
	|	create_group
	|	create_index
	|	create_integrity
	|	create_location
	|	create_link
	|	create_permit
	|	create_schema
	|	create_sec_alarm
	|	create_sequence
	|	create_synonym
	|	create_table
	|	create_user
	|	create_profile
	|	create_view
	|	decl_sess_tbl
	|	delete
	|	describe
	|	desc_input
	|	direct_stmt
	|	disable_security
	|	drop	 
	|	enable_security
	|	endselect
	|	endexecute
	|	end_xact
	|	grant
	|	help 
	|	insert
	|	modify 
	|	prepare
	|	pre_commit
	|	print 
	|	proc_create
/* 	|	proc_exec */
	|	raise_dbevent
	|	register
	|	register_dbevent
	|	register_ind
	|	relocate
	|	remove
	|	rename_tbl
	|	revoke
	|	rollback
	|	rule_create
	|	save
	|	savepoint 
	|	set
	|	set_trans
	|	update
;

/*
** cursor_statement -	All statements that manipulate cursors.
**			Cursor delete and update are in the delete
**			and update rules.
*/
cursor_statement: close
	|	declare_cursor
	|	fetch
	|	open
;

/*
** esql_statement - Strictly embedded statements that interact with the 
**		    preprocessor, or run-time routines.	 No database
** manipulation is done.
** Returns whether a gen_sqlca is required after the statement if the 
** statement generates output.
*/
esql_statement: call
		{
		    $$.i = 1;
		}
	|	connect
		{
		    $$.i = 1;
		}
	|	copy_sqlerr
		{
		    $$.i = 0;
		}
	|	declare_stmt
		{
		    $$.i = 0;
		}
	|	declare_table
		{
		    $$.i = 0;
		}
	|	disconnect
		{
		    $$.i = 1;
		}
	|	get_data
		{
		    $$.i = 1;
		}
	|	get_dbevent
		{
		    $$.i = 1;
		}
	|	iiprintf
		{
		    $$.i = 0;
		}
	|	inquire_ingres
		{
		    $$.i = 0;
		}
	|	put_data
		{
		    $$.i = 1;
		}
	|	set_ingres
		{
		    $$.i = 0;
		}
	|	whenever
		{
		    $$.i = 0;
		}
;
sql_frs_stmt:	enddata host_term
;

/*
+* ---- QUEL-equivalent SQL Statements ----
-*
** SQL statement rules
*/

/*
+* Statement:	EXEC SQL ALTER ROLE role {,role} WITH With_Clause
-* Note that ALTER ROLE is a double reserved word.
*/
alter_role:     alt_role_key sql_user_list alt_user_clauses
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER ROLE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ALTER ROLE"));
		}
;
alt_role_key:	tALT_ROLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
/*
+* Statement:	EXEC SQL ALTER GROUP group_id {,group_id}
**		    ADD USERS  (userid {,userid})
**		  | DROP USERS (userid {,userid})
**		  | DROP ALL
-* Note that ALTER GROUP is a double reserved word.
*/
alter_group:    alt_grp_key sql_user_list alt_add_drop
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER GROUP"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ALTER GROUP"));
		}
;
alt_grp_key:	tALT_GROUP
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
alt_add_drop:	alt_ad_users sql_lparen sql_user_list sql_rparen
	|	tDROP tALL	
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
;
alt_ad_users:	alt_ad_key tNAME
		{
    		    if (STbcompare($2.s, 0, ERx("users"), 5, TRUE) != 0)
    		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
				     ERx("ALTER GROUP"), ERx("USERS") );
		    }
		    db_key( ERx("users") );
		}
;
alt_ad_key:	sql_add
	|	sql_drop
;

/*
+* Statement:	EXEC SQL ALTER LOCATION loc_name WITH USAGE = (usage {,usage})
-* Note that ALTER LOCATION is a double reserved word.
*/
alter_location:	alt_loc_key sql_id_sconst sql_with_clause
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER LOCATION"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ALTER LOCATION"));
		}
;
alt_loc_key:	tALT_LOCATION
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;

/*
+* Statement:	EXEC SQL ALTER SECURITY_AUDIT [audit_opt]
**		[WITH security_op {, security_op}]
-* Note that ALTER SECURITY_AUDIT is a double reserved word.
**
*/
alter_security:	alt_sec_audit alt_sec_audit_clauses
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER SECURITY_AUDIT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				    EQ_WARN, 1, ERx("ALTER SECURITY_AUDIT"));
		}
;
alt_sec_audit:	tALT_SEC_AUDIT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
alt_sec_audit_clauses: alt_sec_audit_op
		| alt_sec_audit_op sql_with_clause
		| sql_with_clause

alt_sec_audit_op:  tNAME
			{ db_key($1.s);}
		|  tRESUME
			{ db_key($1.s);}
		|  tSTOP
			{ db_key($1.s);}

/*
+* Statement:	EXEC SQL ALTER SEQUENCE seqname 
**			[RESTART WITH integer] [INCREMENT BY integer] ...
*/
alter_sequence: alt_seq schema_obj seq_opt_list
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER SEQUENCE"));
		}
;
alt_seq:	tALT_SEQUENCE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
/*
+* Statement:	EXEC SQL ALTER TABLE [owner.]table 
**			  ADD columnname format
**			| ADD table_constraint [WITH with_clause]
**			| DROP columnname [CASCADE]
**			| DROP CONSTRAINT constraint_name
**			| RENAME TO table
**			| RENAME columnname TO columnname 
-* Note that ALTER TABLE is a double reserved word.
*/
alter_table:	alt_tbl_key owner_tbl add_drop_col_rename
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER TABLE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ALTER TABLE"));
		}
;
alt_tbl_key:	tALT_TABLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
add_drop_col_rename:	sql_add crcol_spec
	|	sql_add tbl_constraint_def cons_with1
	|	sql_drop sql_id alt_drop_opt
	|	sql_drop constr_name_def res_cas
	|	sql_rename sql_id ren_to sql_id 
	|	sql_rename tCOLUMN owner_tbl ren_to owner_tbl 
	|	sql_rename ren_to owner_tbl 
;
alt_drop_opt:	/* Empty */
	|	tCASCADE
		{
		    db_key( ERx("cascade") );
		}
	|	tRESTRICT
		{
		    db_key( ERx("restrict") );
		}
;
ren_to:		tTO
	{
		    db_key($1.s);
	}
;
/*
+* Statement:	EXEC SQL ALTER USER [user_name] 
**		[ADD PRIVILEGES ( priv {,priv})  |
**		 DROP PRIVILEGES ( priv {,priv}) ]
**		[WITH [GROUP = group_name]
**		   	[PRIVILEGES = (priv {,priv})]
-*
* Note that ALTER USER is a double reserved word.
*/
alter_user:	alt_user_key alt_opt_user alt_user_clauses
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER USER"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ALTER USER"));
		}
;
alt_user_key:	tALT_USER
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
alt_opt_user:	/* Empty */
	|	sql_id_sconst
;
alt_user_clauses:   user_adp 
		|   user_adp sql_with_clause
		| sql_with_clause

/*
+* Statement:	EXEC SQL ALTER [DEFAULT] PROFILE [profile_name] 
**		[ADD PRIVILEGES ( priv {,priv})  |
**		 DROP PRIVILEGES ( priv {,priv}) ]
**		[WITH [GROUP = group_name]
**		   	[PRIVILEGES = (priv {,priv})...]
-*
* Note that ALTER PROFILE is a double reserved word.
*/
alter_profile:	alt_profile_key alt_opt_user alt_user_clauses
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ALTER PROFILE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ALTER PROFILE"));
		}
;
alt_profile_key:	tALT_PROFILE
	{
	    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
	}
	|
	tALT_DEFAULT tNAME
	{
	    if (!ESQ_EQSTR($2.s, ERx("profile")))
		er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
				    ERx("ALTER DEFAULT"), ERx("PROFILE") );
	    gr_mechanism( GR_EQSTMT, GR_sSQL, "alter default profile ", NULL );
	}

;
user_adp:	sql_add user_priv_word sql_lparen sql_with_idlist sql_rparen
	| sql_drop user_priv_word sql_lparen sql_with_idlist sql_rparen
	;

user_priv_word: tNAME 
		{
		    if (!ESQ_EQSTR($1.s, ERx("privileges")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					    ERx("ALTER USER/PROFILE"), ERx("PRIVILEGES") );
		    db_key( ERx("privileges") );
		}
		;
/*
+* Statement:	EXEC SQL COMMENT ON TABLE [user.]tablename IS string_const
**		EXEC SQL COMMENT ON COLUMN [user.]tablename.columnname 
**							IS string_const
-* Note that COMMENT ON is a double reserved word.
*/
comment_on:	comment_xon
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				  ERx("COMMENT ON"));
	 	    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1, 
				  ERx("COMMENT ON "));
		}
;
comment_xon:	com_on_key com_tab owner_tbl sql_is sql_sconst
	|       com_on_key com_col comcol_spec sql_is sql_sconst	
;
com_on_key:	tCOM_ON
		{
			gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
com_tab:	tTABLE
		{
		    db_key($1.s);
		}
;
com_col:	tCOLUMN
		{
		    db_key($1.s);
		}
;
comcol_spec:	sql_id sql_dot sql_id
	|	sql_id sql_dot sql_id sql_dot sql_id
	|	ing_id_dbkey sql_dot sql_id sql_dot sql_id
		/* ($ingres|$dba).tablename.columname      b57353tt */
;

/*
+* Statement:	EXEC SQL CREATE ROLE role {,role} WITH With_Clause
-* Note that CREATE ROLE is a double reserved word.
*/
create_role:    cre_role sql_user_list sql_with_clause
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("CREATE ROLE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE ROLE"));
		}
;
cre_role:	tCRE_ROLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;

/*
+* Statement:	EXEC SQL CREATE SEQUENCE seqname [AS seq_type]
**			[START WITH integer] [INCREMENT BY integer] ...
*/
create_sequence: cre_seq schema_obj seq_opt_list
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("CREATE SEQUENCE"));
		}
;
cre_seq:	tCRE_SEQUENCE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
seq_opt_list:	seq_opt_list1
		|	/* empty */
;
seq_opt_list1:	seq_opt
		| seq_opt_list1 seq_opt
;
seq_opt:	sql_as seq_type
		| common_seq_opt
;
common_seq_opt_list: sql_lparen common_seq_opt_list1 sql_rparen
		|	/* empty */
;
common_seq_opt_list1: common_seq_opt
		| common_seq_opt_list1 common_seq_opt
;
common_seq_opt:	sql_start sql_with seq_iconst
		| sql_restart sql_with seq_iconst
		| sql_increment sql_by seq_iconst
		| sql_maxvalue seq_iconst
		| sql_minvalue seq_iconst
		| sql_cache sql_iconst
		| sql_cycle
		| sql_order
		| sql_nomaxvalue
		| sql_nominvalue
		| sql_nocache
		| sql_nocycle
		| sql_noorder
;
seq_type:	sql_name
		| sql_name sql_lparen sql_iconst sql_rparen
;

/*
+* Statement:	EXEC SQL CREATE GROUP groupid {,groupid}
**				[WITH USERS = (userid {,userid})]
*/
create_group:   cre_group sql_user_list sql_opt_with_clause
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("CREATE GROUP"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE GROUP"));
		}
;
cre_group:	tCREATE tGROUP
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		}
;

/*
+* Statement:	EXEC SQL CREATE DOMAIN dom_name IS base_type_name
**		[WITH [CHECK   = (constraint)] [,]
-*		      [DEFAULT = [literal | USER | etc]]
*/
create_domain:	cre_dom sql_id sql_is domcol_spec sql_opt_with_clause
;
cre_dom:	tCRE_DOM
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("CREATE DOMAIN"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE DOMAIN"));
		}
;
domcol_spec:	sql_id dom_nullfmt
	|	sql_id sql_lparen sql_iconst sql_rparen dom_nullfmt
	|	sql_id sql_lparen sql_iconst sql_comma
			sql_iconst sql_rparen dom_nullfmt
;
dom_nullfmt:	/* Empty */
	|	sql_not sql_null
;

/*
+* Statement:	EXEC SQL CREATE DBEVENT eventname;
-*
*/
create_dbevent:	cre_evt_key schema_obj
;
cre_evt_key:	tCRE_DBEVENT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("CREATE DBEVENT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE DBEVENT"));
		}
;

/*
+* Statement:	EXEC SQL CREATE [UNIQUE] INDEX [location:]indexname 
**			ON table-name
**			(columnname [ASC|DESC] {, columnname [ASC|DESC]})
**			[WITH With_Clause]
**	or (for parallel index building):
**		EXEC SQL CREATE [UNIQUE] INDEX ([location:]indexname
**			ON table-name 
**			(columnname [ASC|DESC] {, columnname [ASC|DESC]})
**			[UNIQUE] [WITH With_Clause])
**			{, ([location:]indexname ON table-name
**			(columnname [ASC|DESC] {, columnname [ASC|DESC]})
**			[UNIQUE] [WITH With_Clause])}
-*
**	Old pieces of the WITH clause:
**			[PCTFREE integer]
**			[CLUSTER] [AS BTREE|CBTREE|ISAM|CISAM|HASH|CHASH]
*/
create_index:	create_ndxhead create_ndxbody
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE INDEX"));
		}
;
create_ndxhead: tCREATE tUNIQUE tINDEX
		{
		    STprintf( esq->sbuf, ERx("%s %s"), $1.s, $2.s );
		    gr_mechanism( GR_EQSTMT, GR_sSQL, esq->sbuf, $3.s );
		}
	|	tCREATE tINDEX
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		}
;
create_ndxbody:	create_ndxelem
	|	create_ndxlist
create_ndxlist:	sql_lparen create_ndxelem sql_rparen
	|	create_ndxlist sql_comma sql_lparen create_ndxelem sql_rparen
;
create_ndxelem:	loc_tblname sql_on schema_obj
		sql_lparen crilist sql_rparen
		/* crifree_optclause crilst_optclause crias_optclause */
		sql_opt_unique
		sql_opt_with_clause
;
crilist:	criitem
	|	crilist sql_comma criitem
;
criitem:	sql_id sql_order_opt_sort
;

/*
+* Statement:	EXEC SQL CREATE INTEGRITY ON table-name IS search-condition
*/
create_integrity: create_int_key sql_on tbl_corr_id sql_is predicate
;
create_int_key: tCREATE tINTEGRITY
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE INTEGRITY"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE INTEGRITY"));
		}
;

/*
+* Statement:	EXEC SQL CREATE LOCATION location_name 
**				WITH AREA = area_name
**				     [,USAGE = (usage {,usage})]
-* Note that CREATE LOCATION is a double reserved word.
*/
create_location: creloc_key sql_id_sconst sql_with_clause
;
creloc_key:	tCRE_LOCATION
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE LOCATION"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE LOCATION"));
		}
;

/*
+* Statement:	EXEC SQL CREATE LINK link_name [(column list)]
**			[WITH with_clause];
-* Note that CREATE LINK is a double reserved word.
*/
create_link:	crelink_key schema_obj crp_unq_coln_list sql_opt_with_clause
;
crelink_key:	tCRE_LINK
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE LINK"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE LINK"));
		}
;

/* 
+* Statement:	EXEC SQL CREATE PERMIT operation-list {ON|OF|TO} table
**			[(column-list)] TO user [AT terminal]
**			[FROM time TO time] [ON day TO day]
**			[WHERE search-condition]
*/
create_permit:	create_per_key crp_op_list crprep tbl_corr_id
		    crp_unq_coln_list crp_to_cl crat_clause crp_from_clause
		    on_clause where_clause
;
create_per_key: tCREATE tPERMIT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE PERMIT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE PERMIT"));
		}
;
crp_op_list:	crp_op
		{
		    db_key( $1.s );
		}
	|	crp_op_list sql_comma crp_op
		{
		    db_key( $3.s );
		}
	|	sql_all
;
crp_op:		tSELECT		/* { $$.s = $1.s; } */
	|	tUPDATE		/* { $$.s = $1.s; } */
	|	tDELETE		/* { $$.s = $1.s; } */
	|	tINSERT		/* { $$.s = $1.s; } */
;
crprep:		tON
		{
		    db_key( $1.s );
		}
	|	tOF
		{
		    db_key( $1.s );
		}
	|	tTO
		{
		    db_key( $1.s );
		}
;
crp_unq_coln_list:
		sql_lparen crunq_coln_list sql_rparen
	|	/* No column list */
;
crunq_coln_list:
		crunq_col_name
	|	crunq_coln_list sql_comma crunq_col_name
;
crp_to_cl:	tTO sql_reg_or_delim
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	tTO tALL
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	tTO tSCONST
		{
		    db_key( $1.s );
		    db_sconst( $2.s );
		}
;
crat_clause:	tAT tNAME
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	/* No AT clause */
;
crp_from_clause:
		tFROM tINTCONST tCOLON tINTCONST tTO tINTCONST tCOLON tINTCONST
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_op( $3.s );
		    db_key( $4.s );
		    db_key( $5.s );
		    db_key( $6.s );
		    db_op( $7.s );
		    db_key( $8.s );
		}
	|	/* No FROM clause */
;
on_clause:	tON tNAME tTO tNAME
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		    db_key( $4.s );
		}
	|	/* No ON clause */
;

/*
+* Statement: EXEC SQL CREATE RULE rulename 
**		AFTER UPDATE[(col_list)] | DELETE | INSERT
**			{, UPDATE[(col_list)] | DELETE | INSERT}
**		    ON tablename
**		    [REFERENCING [OLD AS old_cor_name] [NEW AS new_cor_name]]
**		    [WHERE qualification]
**		    [FOR EACH ROW | STATEMENT]
**	      | AT time REPEAT interval
-*	        EXECUTE PROCEDURE procname(plist)
*/

rule_create:	rule_head rule_cond rule_for rule_exec rule_proc_args
;
rule_head:	tCRE_RULE sql_reg_or_delim
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    db_key( $2.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE RULE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE RULE"));
		}
	|	tCRE_RULE schema_id tPERIOD sql_reg_or_delim 
		/* owner.rulename */
		/* ($ingres|$dba).rulename                 b57353tt */
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    db_key( $2.s );
		    db_op( $3.s );
		    db_key( $4.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE RULE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE RULE"));
		}
;
schema_id:	sql_reg_or_delim
	|	ing_id
;     
rule_cond:	rule_tab_cond
	|	rule_time_cond
;
rule_exec:	rule_exec_keys schema_obj
;
rule_exec_keys:	tEXECUTE tPROCEDURE
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
;
rule_proc_args:	/* Empty */
	|	sql_lparen rule_plist sql_rparen
;
rule_plist: 	rule_named_arg
	|	rule_plist sql_comma rule_named_arg
;
rule_named_arg: sql_strvar sql_eq rule_arg_var
	|	sql_id sql_eq rule_arg_var
;
rule_arg_var:	constant
	|	sql_plus constant
	|	sql_minus constant
	|	rule_scalar_bif
	|	schema_obj	
	|	sql_expr_var
;
rule_scalar_bif:sql_id sql_lparen sql_rparen
	|	sql_id sql_lparen rule_arg_var sql_rparen
	|	sql_id sql_lparen rule_arg_var sql_comma rule_arg_var sql_rparen
;
rule_tab_cond:	rule_when rule_stmt_list rule_tab_prep schema_obj rule_ref
		rule_where_clause
;
rule_when:	tNAME
		{
		    if (ESQ_EQSTR($1.s, ERx("before")))
			db_key( ERx("before") );
		    else if (ESQ_EQSTR($1.s, ERx("after")))
			db_key( ERx("after") );
		    else
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
				    ERx("CREATE RULE"), ERx("AFTER") );
			db_key( ERx("after") );
		    }
		}
;
rule_where_clause: where_clause
	|	sql_when predicate
		{
		    $$.i = CSR_STATIC;
		}
;
rule_stmt_list:	rule_stmt
	|	rule_stmt_list sql_comma rule_stmt
;
rule_stmt:	update_key
	|	update_key sql_lparen sql_idlist sql_rparen
	|	insert_key
	|	delete_key
;
rule_tab_prep:  sql_into
	|	sql_from
	|	sql_of
	|	sql_on
;
rule_ref:	/* Empty */
	|	rule_ref_word rule_new_old sql_as sql_id	
	|	rule_ref_word rule_new_old sql_as sql_id rule_new_old 
		sql_as sql_id
;
rule_ref_word:	tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("referencing")))
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
				    ERx("CREATE RULE"), ERx("REFERENCING") );
		    }
		    db_key( ERx("referencing") );
		}
;
rule_new_old:	tNAME
		{
		    if (   !ESQ_EQSTR($1.s, ERx("old"))
			&& !ESQ_EQSTR($1.s, ERx("new"))
		       )
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
				    ERx("CREATE RULE"), ERx("OLD") );
			db_key( ERx("old") );
		    }	
		    else
		    {
			db_key( $1.s );
		    }
		}
;
rule_time_cond:	rule_at sql_sconst rule_repeat sql_sconst
;
rule_at:	tAT
		{
		    db_key( $1.s );
		}
;
rule_repeat:	tREPEAT
		{
		    db_key( $1.s );
		}
;
rule_for:	/* Empty */
		| tFOR rule_rowst
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
;
rule_rowst:	tEACH_ROW
		| tEACH_STATEMENT
;
/* 
** Statement: EXEC SQL [ CREATE ] PROCEDURE procname 
**	[ ( pname { , pname } [=] type { ; pname { , pname } [=] type } ) ]
**	[ AS | = ]
**	[ DECLARE  vname [ = ] type { , vname [ = ] type } ; ]
**	BEGIN
**		{ sql-stmt ; }
**	END
**	[ WITH with-options ]
**
** Action: hose up the procedure body (stripping comments) until the 
**		terminating END token, send to the backend at runtime as a 
**		create procedure command.
** Generates:
*/

proc_create: proc_create_key sql_reg_or_delim /* procedure-body END */ 
		{
		    arg_int_add( IIPROC_CREATE );
		    arg_str_add( ARG_CHAR, $2.s );
		    gen_call( IIPROCINIT );

		    db_key( $2.s );

		    /* gobble up the tokens until we see the END */
		    sc_tokeat(SC_NEST, tEND, tBEGIN, tCASE, tEND);
		}
	    sql_opt_with_clause
;
proc_create_key:	tCREATE tPROCEDURE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE PROCEDURE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE PROCEDURE"));
		}
	|	tPROCEDURE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("PROCEDURE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("PROCEDURE"));
		}
;

/*
+* Statement:	EXEC SQL CREATE SCHEMA AUTHORIZATION auth_ident
-*				[ schema_element {, schema_element}]
*/
create_schema:	cre_schema_key schema_nm_cls
	|	cre_schema_key schema_nm_cls schema_elm_list
;
cre_schema_key:	tCREATE tSCHEMA
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
 		    if (eq->eq_flags & EQ_COMMON)
 			er_write( E_EQ0504_OPEN_WARN,
 				EQ_WARN, 1, ERx("CREATE SCHEMA") );
		    esq->flag |= ESQ_CRE_SCHEMA;
		}
;
schema_nm_cls:	authorization_key schema_auth_id
;
authorization_key:tAUTHORIZATION
		{
		    db_key( $1.s );
		    if (gr->gr_func == tSET)
		    	erec_setup( 1 );
		}
;
schema_auth_id:	sql_id
;
schema_elm_list:schema_elm
	|	schema_elm_list schema_elm
;
schema_elm:	create_table
	|	create_view
	|	grant
;

/*
+* Statement:	EXEC SQL CREATE SECURITY_ALARM [name] ON [obj_type] obj_list
**			 [IF condition_list]
**			 [WHEN alarm_priv_list]
**			 [BY [auth_type] [auth_list] ]
**			 [RAISE DBEVENT [owner].event ['text']
-* Note that CREATE SECURITY_ALARM is a double reserved word.
*/
create_sec_alarm: crs_alarm_key crs_opt_name alarm_object
			crs_opt_if crs_opt_when crs_opt_by
			crs_opt_dbevent
;
crs_opt_name:	sql_id_sconst
	    |	/* no name */
;
crs_alarm_key:	tCRE_SEC_ALARM
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				EQ_WARN, 1, ERx("CREATE SECURITY_ALARM"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("CREATE SECURITY_ALARM"));
		}
;
crs_opt_if:	crs_if_cond
	|	/* Empty */
;
crs_if_cond:	sql_if crs_cond_list
/* removed empty rule since it was superfluous, given EMPTY option above */
;
crs_cond_list:	crs_cond
	|	crs_cond sql_comma crs_cond
;
crs_cond:	tNAME
		{
		    if (ESQ_EQSTR($1.s, ERx("failure")))
		    {
		        db_key( ERx("failure") );
		    }
		    else
		    {
		        if (!ESQ_EQSTR($1.s, ERx("success")))
			    er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
				ERx("CREATE SECURITY_ALARM"), ERx("SUCCESS") );
		        db_key( ERx("success") );
		    }
		}
;
crs_opt_when:	sql_when alarm_prv_list
	|	/* No When clause */
;
alarm_prv_list: alarm_prv
	|	alarm_prv_list sql_comma alarm_prv	
;
alarm_prv:	tSELECT
		{
		    db_key( $1.s );
		}
	|	tDELETE
		{
		    db_key( $1.s );
		}
	|	tINSERT
		{
		    db_key( $1.s );
		}
	|	tUPDATE
		{
		    db_key( $1.s );
		}
	|	tCONNECT
		{
		    db_key( $1.s );
		}
	|	tDISCONNECT
		{
		    db_key( $1.s );
		}
;
crs_opt_by:	sql_by grant_whom
	|	/* No By clause */
;
crs_opt_dbevent: crs_raise_kw schema_obj event_text 
	|	/* No Event clause */
;
crs_raise_kw: tRAISE_DBEVENT
			{db_key( $1.s);}
;

alarm_object:	sql_on_table  schema_obj
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			/* FIPS allows ON to be followed only by <tablename> */
			STprintf( esq->sbuf, ERx("%s %s"), ERx("ON"), $2.s );
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, esq->sbuf, ERx("CREATE/DROP SECURITY_ALARM") );
		    }
		}
	|	sql_on_database schema_obj
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			/* FIPS allows ON to be followed only by <tablename> */
			STprintf( esq->sbuf, ERx("%s %s"), ERx("ON"), $2.s );
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, esq->sbuf, ERx("CREATE/DROP SECURITY_ALARM") );
		    }
		}
	|  sql_on schema_obj
		{
		    if (eq->eq_flags & EQ_FIPS && $2.i == 1)
		    {
			/* List of tables is non-FIPS */
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
			    2, ERx("ON <table_list>"), ERx("CREATE/DROP SECURITY_ALARM") );
		    }
		}
	|	sql_on tCURRENT tNAME
		{
		    db_key( $2.s );
		    db_key( $3.s );
		    if (!ESQ_EQSTR($3.s, ERx("installation")))
		    {
			er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $3.s,
				ERx("GRANT"));
		    }
		    /* ON CURRENT INSTALLATION is non-FIPS */
		    else if (eq->eq_flags & EQ_FIPS)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
				ERx("ON CURRENT INSTALLATION"), ERx("CREATE/DROP SECURITY_ALARM") );
		    }
		}
;
sql_on_database:  tONDATABASE
		{ 
			db_key($1.s);
		}
;
sql_on_table:	tON tTABLE
		{
			db_key($1.s);
			db_key($2.s);
		}
;
/*
+* Statement:	EXEC SQL CREATE SYNONYM synonymname FOR [owner.]tablename
-* Note that CREATE SYNONYM is a double reserved word.
*/
create_synonym:	cre_syn schema_obj sql_for owner_tbl
;
cre_syn:	tCRE_SYNONYM
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("CREATE SYNONYM"));
		}
;

/*
** EXEC SQL CREATE TABLE ... see below for 2 formats
*/
create_table:	create_regtab
;
create_tabkey:	tCREATE tTABLE
		{
		    if (esq->flag & ESQ_CRE_SCHEMA)	/* in CREATE SCHEMA */
		    {
			db_key( $1.s );
			db_key( $2.s );
		    }
		    else
		    {
		    	gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("CREATE TABLE"));
		    }
		    esq->flag &= ~ESQ_WITHABLE_CONSTRAINT;
		}
;
loc_tblname:	owner_tbl
	|	sql_id sql_colon schema_obj
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				    2, ERx("location"), ERx("CREATE TABLE") );
		}
;

/*
+* EXEC SQL CREATE TABLE [location:]table (column-format-pair-list) 
**	[WITH with_clause]
** EXEC SQL CREATE TABLE [location:]table (column-format-pair-list) 
**	AS FullSelect [WITH with_clause]
** EXEC SQL CREATE TABLE [location:]table (column-namelist) AS FullSelect
**	[WITH with_clause]
*/
create_regtab:	create_tabkey loc_tblname creat_col_spec sql_opt_with_clause
		{
		    /* With clause is non-FIPS compliant */
		    if ($4.i == 1 && eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
					2, ERx("WITH"), ERx("CREATE TABLE") );
		}
;
creat_col_spec: sql_lparen crcol_spec_list sql_rparen
		{
		    if (eq->eq_flags & EQ_COMMON)
		    {
			if ($2.i & CRE_TBLKEY)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				ERx("CREATE TABLE ... TABLE_KEY"));
 			else if ($2.i & CRE_WDEF)
 			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
 				ERx("CREATE TABLE ... WITH DEFAULT"));
 			else if ($2.i & CRE_NDEF)
 			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
 				ERx("CREATE TABLE ... NOT DEFAULT"));
			else if ($2.i & CRE_OBJKEY)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				ERx("CREATE TABLE ... OBJECT_KEY"));
			else if ($2.i & CRE_WSYS)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("CREATE TABLE ... WITH SYSTEM_MAINTAINED"));
			else if ($2.i & CRE_NSYS)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("CREATE TABLE ... NOT SYSTEM_MAINTAINED"));
			else if ($2.i & CRE_CONWTH)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("CREATE TABLE ... UNIQUE/FKEY WITH ..."));
		    }
		    if (eq->eq_flags & EQ_FIPS)
		    {
			if ($2.i & CRE_WNUL)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
				ERx("WITH NULL"), ERx("CREATE TABLE") );
			else if ($2.i & CRE_OBJKEY)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
				ERx("OBJECT_KEY"), ERx("CREATE TABLE") ); 
			else if ($2.i & CRE_TBLKEY)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
				ERx("TABLE_KEY"), ERx("CREATE TABLE") ); 
			else if ($2.i & CRE_NDEF)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
				ERx("NOT DEFAULT"), ERx("CREATE TABLE") );
			else if ($2.i & CRE_WDEF)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
				ERx("WITH DEFAULT"), ERx("CREATE TABLE") );
			else if ($2.i & CRE_WSYS)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			     ERx("WITH SYSTEM_MAINTAINED"),ERx("CREATE TABLE"));
			else if ($2.i & CRE_NSYS)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			      ERx("NOT SYSTEM_MAINTAINED"),ERx("CREATE TABLE"));
			else if ($2.i & CRE_CONWTH)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
				ERx("UNIQUE/REFERENCES WITH ..."),
				ERx("CREATE TABLE"));
			else if ($2.i & CRE_NFIPS)
			    er_write( E_EQ050C_FIPS_DATTYP, EQ_WARN, 1,
			      ERx("CREATE TABLE"));
		    }
		}
	|	crp_unq_coln_list sql_as select_full select_order
					select_off_fetch
		{
		    if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			        ERx("AS SELECT"), ERx("CREATE TABLE") );
		}
	|	sql_lparen crcol_spec_list sql_rparen sql_as select_full
					select_order select_off_fetch
		{
		    if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			        ERx("AS SELECT"), ERx("CREATE TABLE") );
		}
;
/*
** The syntax of the table_elements (the crcol_spec_list) on a CREATE TABLE
** statement is:
**      colname type [ NOT NULL [column_constraint] | format ] [collate]
**           {,colname type [NOT NULL [column_constraint] | format] [collate]
**                      | table_constraint}
**
** A column_constraint has the following syntax:
**      [CONSTRAINT constraint_name] UNIQUE | PRIMARY KEY or
**	[CONSTRAINT constraint_name] REFERENCES tablename [(colname,{,colname)] 
**	and both may be followed by an optional WITH clause.
**
** A table_constraint has the following syntax:
**      [CONSTRAINT constraint_name] UNIQUE | PRIMARY KEY(colname,{colname}) or 
**	[CONSTRAINT constraint_name] FOREIGN KEY (colname,{colname}) 
**		REFERENCES tablename [(colname,{,colname)] and both
**	may be followed by an optional WITH clause.
**
** A collate clause has the following syntax:
**	COLLATE collation_name
**
** Note that the crcol_spec rule (without the cr_uniq_clause) is
** inherited by the REGISTER and ALTER TABLE statements.
*/
crcol_spec_list: crcol_spec
		{
		    $$.i = $1.i;		/* Info on dec_nullfmt */
		}
	|	crcol_spec sql_comma crcol_xspec_list
		{
		    $$.i = $1.i | $3.i;		/* Info on dec_nullfmt */
		}
;
crcol_xspec_list:crcol_spec_constrt
		{
		    $$.i = $1.i;
		}
	|	crcol_xspec_list sql_comma crcol_spec_constrt
		{
		    $$.i = $1.i | $3.i;
		}
;
crcol_spec_constrt: crcol_spec
		{
		    $$.i = $1.i;
		}
	|	tbl_constraint_def cons_with1
		{
		    $$.i = $1.i;
		}
;
crcol_spec:	sql_id crcol_type crcol_collate crcol_encrypt
{
		    $$.i = $2.i;
}
;
crcol_type:	sql_name dec_nullfmt_list
		{
		    if ( ESQ_EQSTR($1.s, ERx("table_key")) )
		    {
			$$.i = CRE_TBLKEY;
		    }
		    else if ( ESQ_EQSTR($1.s, ERx("object_key")) )
		    {
			$$.i = CRE_OBJKEY;
		    }
		    else if ( !ESQ_EQSTR($1.s, ERx("smallint"))
				&& !ESQ_EQSTR($1.s, ERx("integer"))
				&& !ESQ_EQSTR($1.s, ERx("float")) )
		    {
			$$.i = CRE_NFIPS;
		    }
		    else
		    {
			$$.i = $2.i;
		    }
		}
	|	sql_name sql_name dec_nullfmt_list
		{
		    $$.i = $3.i;
		}
	|	sql_name sql_name sql_name dec_nullfmt_list
		{
		    $$.i = $4.i;
		}
	|	sql_name sql_name sql_name sql_name dec_nullfmt_list
		{
		    $$.i = $5.i;
		}
/* Next few are the various forms of date/time declaration */
	|	sql_name wquals sql_name dec_nullfmt_list
		{
		    $$.i = $4.i;
		}
	|	sql_name sql_lparen sql_iconst sql_rparen wquals sql_name dec_nullfmt_list
		{
		    $$.i = $7.i;
		}
	|	sql_interval sql_name sql_to sql_name dec_nullfmt_list
		{
		    $$.i = $5.i;
		}
	|	sql_interval sql_name sql_to sql_name sql_lparen sql_iconst sql_rparen dec_nullfmt_list
		{
		    $$.i = $8.i;
		}
	|	sql_name sql_name sql_lparen sql_iconst sql_rparen
			dec_nullfmt_list
		{
		    $$.i = $6.i;
		}
	|	sql_name sql_lparen sql_iconst sql_rparen dec_nullfmt_list
		{
		    if ( !ESQ_EQSTR($1.s, ERx("char"))
				&& !ESQ_EQSTR($1.s, ERx("varchar"))
				&& !ESQ_EQSTR($1.s, ERx("float")) )
		    {
			$$.i = CRE_NFIPS;
		    }
		    else
		    {
		    	$$.i = $5.i;
		    }
		}
	|	sql_name sql_lparen sql_iconst sql_comma
			sql_iconst sql_rparen dec_nullfmt_list

		{
		    $$.i = $7.i;
		}
;
crcol_collate:	/* nothing */
	|	sql_collate sql_name
;
crcol_encrypt:	/* nothing */
	|	sql_encrypt
	|	sql_encrypt sql_name
;
tbl_constraint_def:tbl_constraint
		{
		    esq->flag |= ESQ_WITHABLE_CONSTRAINT;
		}
	|	constr_name_def tbl_constraint
		{
		    esq->flag |= ESQ_WITHABLE_CONSTRAINT;
		}
;
tbl_constraint: cr_uniq_clause
	|	references_constr_def
	|	check_constr_def
;
cr_uniq_clause:	unique_constr sql_lparen sql_idlist sql_rparen
		{
		    $$.i = 0;
		}
;
references_constr_def:foreign_constr references_constr
;
references_constr:references_key schema_obj sql_lparen sql_idlist sql_rparen 
		ref_action_list 
	|	references_key schema_obj ref_action_list 
;
foreign_constr: foreign_key sql_lparen sql_idlist sql_rparen
;
ref_action_list:    /* rien */
	| on_key ref_action
	| on_key ref_action on_key ref_action
;
on_key		: tON
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
;
ref_action	: ref_stmt ref_action_item
;
ref_stmt	: tDELETE
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
	| tUPDATE
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
;
ref_action_item	: tCASCADE
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
	| tRESTRICT
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
	| tSET tNULL
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
			db_key($2.s);
		    }
		}
	| tNAME tNAME
		{
		    /* This clause must be "no action". */
		    if (!ESQ_EQSTR($1.s, ERx("no")) ||
			!ESQ_EQSTR($2.s, ERx("action")))
		     er_write(E_EQ006A_grxBADWORD, EQ_ERROR, 2, $1.s,
			ERx("referential action"));

		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
			db_key($2.s);
		    }
		}
;
check_constr_def:check_key predicate	/* CHECK (<search condition>) */
;
unique_constr:	tUNIQUE
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
	|	tPRIMARY tKEY
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
			db_key($2.s);
		    }
		}
;
foreign_key:	tFOREIGN tKEY
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
			db_key($2.s);
		    }
		}
;
constraint_key:	tCONSTRAINT
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
;
references_key:	tREFERENCES
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
;
check_key:	tCHECK
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		}
;
cons_with1	:	/* empty */
	|	cons_with
;

/*
** Statement:	EXEC SQL CREATE USER user_name 
**				[ WITH [GROUP = group_name]
**				       [PRIVILEGES = (priv {,priv})] ];
-* Note that CREATE USER is a double reserved word.
*/
create_user:	creuser_key sql_id_sconst sql_opt_with_clause
;
creuser_key:	tCRE_USER
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE USER"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE USER"));
		}
;
/*
+* EXEC SQL CREATE VIEW view-name [(column-list)] AS FullSelect
**	[WITH with_clause]
*/
create_view:	create_vkey schema_obj crp_unq_coln_list sql_as select_full
		sql_opt_with_clause
		{
		    /* UNION views are non-FIPS */
		    if (eq->eq_flags & EQ_FIPS && $5.i == 1)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			        ERx("UNION"), ERx("CREATE VIEW") );
		}
;
/*
** Statement:	EXEC SQL CREATE PROFILE profile_name 
**				[ WITH [GROUP = group_name]
**				       [PRIVILEGES = (priv {,priv})] ];
-* Note that CREATE PROFILE is a double reserved word.
*/
create_profile:	creprofile_key sql_id_sconst sql_opt_with_clause
;
creprofile_key:	tCRE_PROFILE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("CREATE PROFILE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("CREATE PROFILE"));
		}
;
create_vkey:	tCREATE tVIEW
		{
		    if (esq->flag & ESQ_CRE_SCHEMA)	/* in CREATE SCHEMA */
		    {
			db_key( $1.s );
			db_key( $2.s );
		    }
		    else
		    {
		        gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("CREATE VIEW"));
		    }
		}

/*
+* EXEC SQL DECLARE GLOBAL TEMPORARY TABLE SESSION.table_name
**		(columnname format [, columnname format])
**		[AS subselect]
**		ON COMMIT PRESERVE ROWS
**		WITH NORECOVERY [, with_clause]
-*
*/
decl_sess_tbl:	declare_part sess_id creat_col_spec on_part sql_with_clause
;
declare_part:	tDECLARE tGLOBAL tTEMPORARY tTABLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    db_key( $2.s );
		    db_key( $3.s );
		    db_key( $4.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
			    EQ_WARN, 1, ERx("DECLARE GLOBAL TEMPORARY TABLE") );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
			    EQ_WARN, 1, ERx("DECLARE GLOBAL TEMPORARY TABLE") );
		}
;
sess_id:	session_key sql_dot sql_id
		{
		    STpolycat(3, $1.s, $2.s, $3.s, session_temp);
		    $$.s = session_temp;
		}
	|	sql_id
		{
		    $$.s = $1.s;
		}
;
session_key:	tSESSION
		{
		    db_key( $1.s );
		}
;
on_part:	tONCOMMIT tPRESERVE tROWS
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		}
;

/*
+* EXEC SQL [REPEATED] DELETE FROM [owner.]table [correlname]
**	[WHERE search-condition]
** EXEC SQL DELETE FROM [owner.]table WHERE CURRENT OF cursor
-*
** Notes: 1. We can't factor the common left-side (DELETE FROM table),
** 	     because the cursor case has different semantics.	 Sigh.
**	  2. [owner.] isn't specified for DELETE cursor, but that
**	     statement inherits it because of the common left-side.
*/
delete:		/* no WHERE clause, or a correlation name, means non-cursor */
		del_repkey del_from del_own_tbl			/* non-cursor */
		{
		    gr->gr_flag &= ~GR_NOSYNC;	/* error output ok now */
		    if ($1.i)
			gr_mechanism(GR_EQSTMT, GR_sREPEAT, ERx("repeat"),
					ERx("delete"));
		    else
			gr_mechanism( GR_EQSTMT, GR_sSQL, ERx("delete"), NULL );
		    db_key( $2.s );
		    db_key( $3.s );		/* owner.tablename */
		}
	|	del_repkey del_from del_own_tbl tWHERE		/* non-cursor */
		{
		    gr->gr_flag &= ~GR_NOSYNC;	/* error output ok now */
		    if ($1.i)
			gr_mechanism(GR_EQSTMT, GR_sREPEAT, ERx("repeat"),
					ERx("delete"));
		    else
			gr_mechanism( GR_EQSTMT, GR_sSQL, ERx("delete"), NULL );
		    db_key( $2.s );
		    db_key( $3.s );		/* owner.tablename */
		    db_key( $4.s );
		}
		del_where			/* <=== <<<MORE RULE HERE>>> */
	|	del_repkey del_from del_own_tbl sql_reg_or_delim	
		/* non-cursor */
		{
		    gr->gr_flag &= ~GR_NOSYNC;	/* error output ok now */
		    if ($1.i)
			gr_mechanism(GR_EQSTMT, GR_sREPEAT, ERx("repeat"),
					ERx("delete"));
		    else
			gr_mechanism( GR_EQSTMT, GR_sSQL, ERx("delete"), NULL );
		    db_key( $2.s );
		    db_key( $3.s );	/* owner.tablename */
		    db_key( $4.s );
		}
		where_clause			/* <=== <<<MORE RULE HERE>>> */
	|	del_repkey del_from del_own_tbl tWHERE tCURRENT tOF
		csr_name 					/* cursor */
		{
		    /* gr->gr_flag &= ~GR_NOSYNC;*/ /* error output ok now */
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, ERx("delete"),
					$3.s );	/* owner.tablename */
		    esq_init();
		    ecs_delete( $7.s, $3.s, gr->gr_sym != (SYM *)0 );
		    if( $1.i )
			er_write( E_EQ0423_csBADREPEAT, EQ_ERROR, 1,
								ERx("DELETE") );
		}
;
del_repkey:	tDELETE
		{
		    gr->gr_flag |= GR_NOSYNC;	/* no error output yet */
		    $$.i = 0;
		}
	|	tREPEAT tDELETE
		{
		    gr->gr_flag |= GR_NOSYNC;	/* no error output yet */
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1, 
			        ERx("REPEATED DELETE") );
		    $$.i = 1;
		}
;
/* handle common error */
del_from:	/* EMPTY */
		{
		    er_write( E_EQ0070_grMISSWORD, EQ_ERROR, 2, ERx("FROM"),
								ERx("DELETE") );
		    $$.s = ERx("from");
		}
	|	tFROM		/* { $$.s = ERx("from"); } */
;
del_own_tbl:	sql_reg_or_delim
		{
		    $$.s = $1.s;
		}
	|	schema_id tPERIOD sql_reg_or_delim	
		/* owner.tablename */
		/* ($ingres|$dba).tablename                b57353tt */
		{
		    STprintf( esq->sbuf, ERx("%s.%s"), $1.s, $3.s );
		    $$.s = esq->sbuf;
		}
	|	tSESSION tPERIOD sql_reg_or_delim	
		/* session.tablename */
		{
		    STprintf( esq->sbuf, ERx("%s.%s"), $1.s, $3.s );
		    $$.s = esq->sbuf;
		}
;
del_where:	predicate
	|	sql_strvar
		{
		    if ( gr->gr_flag & GR_REPEAT )
		    {
			db_op( ERx("...SYNTAX ERROR") );
			er_write( E_EQ0378_repWHERE, EQ_ERROR, 0 );
		    }
		}
;

/*
+* Statement:	EXEC SQL DISABLE SECURITY_AUDIT audit_type
-* Note that DISABLE SECURITY_AUDIT is a double reserved word.
*/
disable_security: dis_sec_audit audit_type
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("DISABLE SECURITY_AUDIT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				    EQ_WARN, 1, ERx("DISABLE SECURITY_AUDIT"));
		}
;
dis_sec_audit:	tDIS_SEC_AUDIT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
/*
+* Statement:	EXEC SQL ENABLE SECURITY_AUDIT audit_type
-* Note that ENABLE SECURITY_AUDIT is a double reserved word.
*/
enable_security: ena_sec_audit audit_type
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				    EQ_WARN, 1, ERx("ENABLE SECURITY_AUDIT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				    EQ_WARN, 1, ERx("ENABLE SECURITY_AUDIT"));
		}
;
ena_sec_audit:	tENA_SEC_AUDIT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
audit_type:	tALL
		{
		    db_key( $1.s );
		}
	|	tROW
		{
		    db_key( $1.s );
		}
	|	tTABLE
		{
		    db_key( $1.s );
		}
	|	tVIEW
		{
		    db_key( $1.s );
		}
	|	tPROCEDURE
		{
		    db_key( $1.s );
		}
	|	user_key
		/* hardcoded USER in this grammar statement since
		   USER is a reserved word in sql_id.  	tt60282
		*/
	|	sql_id
;


/*
+* Statement:	EXEC SQL ENDSELECT
-* Action:	Break out of retrieve loop, ending any other nested loops.
** Generates:	IIbreak();
**		goto IIret_end1;
** Note:	May also generate breakout code of active Equel loops.
*/
endselect:	tENDSELECT
		{
		    i4  ret_no;

		    gr->gr_flag |= GR_NOSYNC;
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    if ((ret_no = lbl_gen(LBLmRETLOOP, TRUE)) == LBL_NOLEV)
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
								ERx("SELECT") );
		    else
		    {
			gen_call( IIBREAK );
			gen_goto( G_IF, L_RETEND, 
				  lbl_value(LBLmRETLOOP, ret_no) );
		    }
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1, 
			        ERx("ENDSELECT") );
		    $$.i = 1;
		}
;


/*
+* Statement:	EXEC SQL ENDEXECUTE
-* Action:	Break out of proc exec loop, ending any other nested loops.
** Generates:	IIbreak();
**		goto IIret_end1;
** Note:	May also generate breakout code of active Equel loops.
*/
endexecute:	tENDEXECUTE
		{
		    i4 ret_no;

		    gr->gr_flag |= GR_NOSYNC;
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    if ((ret_no = lbl_gen(LBLmEXECLOOP, TRUE)) == LBL_NOLEV)
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							ERx("EXECUTE PROCEDURE") );
		    else
		    {
			gen_call( IIBREAK );
			gen_goto( G_IF, L_RETEND, 
				  lbl_value(LBLmEXECLOOP, ret_no) );
		    }
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1, 
			        ERx("ENDEXECUTE") );
		    $$.i = 1;
		}
;

/* 
+* Statement:	EXEC SQL [REPEATED] INSERT INTO [owner.]table [(column-list)] 
**			{VALUES (expression-list)  | sub-select }
*/
insert:		ins_repkey sql_into owner_tbl crp_unq_coln_list opt_override
		insert_val
;
ins_repkey:	tINSERT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
	|	tREPEAT tINSERT
		{
		    gr_mechanism( GR_EQSTMT, GR_sREPEAT, $1.s, $2.s );
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1, 
			        ERx("REPEATED INSERT") );
		}
;
insert_val:	tDEFAULT tVALUES
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	insert_obj
;
insert_obj:	ins_val_key sql_lparen ins_expr_list sql_rparen
	|	select_sub select_order select_off_fetch
;
opt_override:	/* empty */
	|	tOVERRIDING tSYSTEM tVALUE
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		}
	|	tOVERRIDING tUSER tVALUE
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		}
;
ins_val_key:	tVALUES
		{
		    db_key( $1.s );
		    erec_setup( 1 );
		}
	|	tOVERRIDING tSYSTEM tVALUE tVALUES
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		    db_key( $4.s );
		    erec_setup( 1 );
		}
	|	tOVERRIDING tUSER tVALUE tVALUES
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		    db_key( $4.s );
		    erec_setup( 1 );
		}
;
ins_expr_list:	ins_expr_elem
	|	ins_expr_list sql_comma ins_expr_elem
;
/*
** Expressions like "1+:structvar", ":structvar*:var",
** "-:structvar", and "(:structvar/3)" are illegal;
** we won't complain if "structvar" has just one component,
** though.  Note that just plain ":structvar" is legal;
** the rules are stratified in order to allow this, and to guarantee
** that the error message is given at most once per element.
*/
ins_expr_elem:	ins_compound_expr
		{
		    if ($1.i > 1)
			er_write( E_EQ0132_sqILLSTRUCTEXPR, EQ_ERROR, 0 );
		}
	|	ins_primary	/* struct vars legal here */
;
ins_expr:	ins_compound_expr	/* { $$.i = $1.i; } */
	|	ins_primary		/* { $$.i = $1.i; } */
;
/* returns the number of vars to which this expanded */
ins_compound_expr:
		ins_expr ins_arith_op ins_primary
		{
		  /* return the max num of struct elems on one side */
		    $$.i = ($1.i > $3.i) ? $1.i : $3.i;
		}
 	|	ins_expr ins_arith_op sql_lparen ins_expr sql_rparen
 		{
 		  /* return the max num of struct elems on one side */
 		    $$.i = ($1.i > $4.i) ? $1.i : $4.i;
 		}
	|	sql_lparen ins_expr sql_rparen
		{
		    $$.i = $2.i;	/* Might be a structure */
		}
	|	sql_minus ins_expr			%Prec tUNARYOP
		{
		    $$.i = $2.i;	/* Might be a structure */
		}
	|	sql_plus ins_expr			%Prec tUNARYOP
		{
		    $$.i = $2.i;	/* Might be a structure */
		}
;
ins_arith_op:	sql_star
	|	sql_exp
	|	sql_slash
	|	sql_plus
	|	sql_minus
	|	sql_concat
;
/* returns the number of vars to which this expanded */
ins_primary:	host_insvar sql_opt_ind
		{
		    $$.i = erec_vars();
		    erec_use( IISETDOM, gr->gr_flag & GR_REPEAT, ERx(",") );
		    erec_setup( 1 );		/* end of variable */
		    if ( (gr->gr_type == T_STRUCT) && (eq->eq_flags & EQ_FIPS) )
			er_write( E_EQ050D_FIPS_VAR, EQ_WARN, 0 );
		}
	|	ins_non_variable
		{
		    $$.i = 0;		/* Not a structure */
		}
	|	datahdlr_cls sql_opt_ind		/* Datahandler */
		{
		    erec_use( IISETDOM, gr->gr_flag & GR_REPEAT, ERx(",") );
		    erec_setup( 1 );
		}
	|	col_subqry
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0509_FIPS_FUNC, EQ_WARN, 1, ERx("Scalar Subselect") );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0510_OPEN_FUNC, EQ_WARN, 1, ERx("Scalar Subselect") );
		}
;
ins_non_variable:
		constant
	|	ins_scalar_bif
		{
		    if (   !ESQ_EQSTR($1.s, ERx("dbmsinfo")) 
		        && eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0510_OPEN_FUNC, EQ_WARN, 1, $1.s );
		    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0509_FIPS_FUNC, EQ_WARN, 1, $1.s );
		}
	|	sql_notrim
	|	sql_id
		{
		    er_write( E_EQ0129_sqVARCOLON, EQ_ERROR, 0 );
		    YYERROR;
		}
	|	seq_expr
;
ins_scalar_bif: sname_lparen sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sname_lparen ins_expr sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sname_lparen ins_expr sql_comma ins_expr sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sname_lparen ins_expr sql_comma ins_expr sql_comma 
		ins_expr sql_rparen
		{
		    $$.s = $1.s;
		}
;

/* 
+* EXEC SQL [REPEATED] UPDATE [owner.]table [correlname] [FROM from_source] 
**	SET column-is-value-list [WHERE search-condition]
** EXEC SQL UPDATE [owner.]table SET column-is-value-list
**	WHERE CURRENT OF cursor
-*
** To avoid a shift/reduce conflict, the left-hand side is common until
** the cursor part.  Note that we put out an error if a FROM clause or 
** a REPEATED keyword is found in a cursor UPDATE statement.
*/
update:		upd_repkey update_body
;
upd_repkey:	tUPDATE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    gr->gr_func = tUPDATE;
		}
	|	tREPEAT tUPDATE
		{
		    gr_mechanism( GR_EQSTMT, GR_sREPEAT, $1.s, $2.s );
		    gr->gr_func = tUPDATE;
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1, 
			        ERx("REPEATED UPDATE") );
		}
;
update_body:	update_csr_body
	|	update_reg_body
;
update_csr_body:
		own_tbl_corr from_clause sql_set updcol_asgn_list 
			update_csr_where
		{
		    if (gr->gr_flag & GR_REPEAT)
		    {
			/*
			** Disallow repeated cursor, but leave as regular
			** query (for generation).
			*/
			er_write( E_EQ0423_csBADREPEAT, EQ_ERROR, 1,
								ERx("UPDATE") );
		    }
		    else if ($2.i != CSR_NO_FROM)
		    {
			/*
			** Disallow FROM clause 
			*/
			er_write( E_EQ0429_csBADFROM, EQ_ERROR, 1, 
								ERx("UPDATE") );
		    }	
		    else			
		    {
			db_send();
			ecs_colrslv( TRUE );	    /* check all column names */
  						    /* check legality */
			ecs_replace( TRUE, $5.s, gr->gr_sym != (SYM *)0 ); 
						    /* generate IIcsERplace */
			ecs_replace( FALSE, $5.s, gr->gr_sym != (SYM *)0 );
			gr->gr_flag |= GR_NOSYNC;
			if ($1.s)
			    er_write( E_EQ0424_csILLCORRELNAME, EQ_ERROR, 2,
						$1.s, ERx("UPDATE") );
		    }
		    esq->flag &= ~ESQ_CURSOR;
		}
;
update_reg_body:
		own_tbl_corr from_clause sql_set updcol_asgn_list 
			update_where
		{
		    ecs_colrslv( FALSE );	/* toss all the column names */
						/* check for FROM clause */
		    if (($2.i != CSR_NO_FROM) && (eq->eq_flags & EQ_COMMON))
			er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("UPDATE ... FROM"));
		    if ($2.i != CSR_NO_FROM && eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			        ERx("FROM"), ERx("UPDATE") );
		}
;
update_where:	where_clause
;
update_csr_where:
		tWHERE tCURRENT tOF csr_name
		{
		    esq->flag |= ESQ_CURSOR;
		    $$.s = $4.s;
		}
;
updcol_asgn_list:
		updcol_asgn
	|	updcol_asgn_list sql_comma updcol_asgn
;
updcol_asgn:	crunq_col_name sql_eq expr_or_subqry
;

/*
+* ---- SELECT statements ----
-*
**	There are three kinds of SELECT statements:
**
**	(1) Embedded selects.  This is the normal SQL singleton select
**	    or the RTI extension of a "select loop", analogous to the EQUEL
**	    retrieve loop.  We also allow UNION clauses.
**	(2) Sub selects. Used in UNION and EXISTS clauses, CREATE TABLE,
**	    CREATE VIEW, and INSERT statements.	 When parenthesized or used
**	    in a UNION clause they are known as a full select.
**	(3) Cursor selects.  Used only in a DECLARE CURSOR statement.
*/

/*
+* Statement:	EXEC SQL [REPEATED] SELECT [ALL|DISTINCT] expression-list 
**			INTO result-variables
**			[FROM from_source]
**			[WHERE search-condition]
**			[GROUP BY expression-list]
**			[HAVING search-condition]
**			{UNION Full_Select}
**			[ORDER BY order-list]
**			[BEGIN Block END]
-* Action:	Set up single-tuple SELET from database.
** Generates:	SQL SELECT loop with no user-code within the loop.
**		IIwritedb("select name,... into var,... from e,... where ...");
**		IIsqInit();
**		if (IIerrtest() == 0) {
**		    if	(IInextget() != 0) {
**			IIretdom( vardesc1, var1 );
**			IIretdom( vardesc2, var2 ); ...
**		    }
**		    IIsqFlush();
**		}
**	or
**		IIwritedb("select name,... into var,... from e,... where ...");
**		IIsqInit();
**		while (IIerrtest() == 0) {
**		    if	(IInextget() != 0) {
**			IIretdom( vardesc1, var1 );
**			IIretdom( vardesc2, var2 ); ...
**			if (IIerrtest() == 0)
**			{
**				... host code ...
**			}
**		    }
**		}
**		IIflush();
**
** Notes:
**  1. Strictly embedded form of the SELECT statement. This is not a 
**     sub-select that is included in other db statements, but a restricted 
**     form of the SELECT statement as defined for DB2, as extended by RTI.
*/
select_embed:	select_embed_body host_term select_block
		{
		    if ($3.i)
		    {
		      /* SELECT LOOP - gen WHILE */
			/* Close retrieve loop */
			gen_loop( G_CLOSE, L_RETBEG, L_RETFLUSH,
				    lbl_current(LBL_RET), IINEXTGET, C_0, 0 );
			gen_call( IIFLUSH );
			gen_label( G_NOLOOP, L_RETEND, lbl_current(LBL_RET) );

                        /* b114309 */
                        gr->gr_nlid = (char *)0;
                        gr->gr_nlsym = (SYM *)0;

			gr->gr_flag &= ~GR_RETRIEVE;/* Done with SELECT loop */
			gr->gr_flag &= ~GR_HOSTCODE; 
		    } else
		    {
		      /* SINGLETON SELECT - gen IF */
			if (eq->eq_flags & EQ_CHREOS)
			    esq_eoscall(IImodNOCEOS);
			/* Open retrieve loop */
			/* gen_if( G_OPEN, IIERRTEST, C_EQ, 0 ); */
			gen_if( G_OPEN, IINEXTGET, C_NOTEQ, 0 );
			if (eq->eq_flags & EQ_CHRPAD)
			    esq_sqmods(IImodCPAD);
			/* Generate variable retrieval in loop */
			ret_close();
			if (eq->eq_flags & EQ_CHRPAD)
			    esq_sqmods(IImodNOCPAD);
			gen_if( G_CLOSE, IINEXTGET, C_0, 0 );
			gen_call( IISQFLUSH );
			/* gen_if( G_CLOSE, IIERRTEST, C_0, 0 ); */

                        /* b114309 */
                        gr->gr_nlid = (char *)0;
                        gr->gr_nlsym = (SYM *)0;
		    }
		}
;
select_embed_body:
		eselect_head into_clause select_tail select_union select_order
				select_offset select_fetch select_hint
;
eselect_head:	eselect_repkey select_firstn select_all esubselect_tgt
		{
		    /* don't set until after call to gr_mechanism */ 
		}
;
eselect_repkey: tSELECT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    esq->flag |= ESQ_REG_SELECT;
		    esl_query( ESL_START_QUERY );
		    /* special case for singleton select */
		    if (eq->eq_flags & EQ_ENDIF)
		    {
			gr->gr_flag |= GR_ENDIF;
			eq->eq_flags &= ~EQ_ENDIF;
		    }		
		}
	|	tREPEAT tSELECT
		{
		    gr_mechanism( GR_EQSTMT, GR_sREPEAT, $1.s, $2.s );
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1, 
			        ERx("REPEATED SELECT") );
		}
;
select_firstn:	/* EMPTY */
	|	select_firstkey sql_iconst
;
select_firstkey: tFIRST
		{
		    db_key( $1.s );
		}
;
select_all:	/* EMPTY */
	|	sql_all
	|	distinct_key
		{
		    /* DISTINCT makes a cursor Read-Only */
		    if (ESQ_DCLCSR(esq))
			ecs_csrset( NULL, ECS_UNIQUE );
		}
;
distinct_key:	tDISTINCT
		{
		    db_key( $1.s );
		}
;
esubselect_tgt: tSTAR
		{
		    db_key( $1.s ); /* db_key 'cause we want spaces around it */
		}
	|	esubselect_tgt_list
;
esubselect_tgt_list:
		esubselect_tgt_elm
	|	esubselect_tgt_list sql_comma esubselect_tgt_elm
;
esubselect_tgt_elm:
		sql_id sql_eq select_expr
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("<= result_column_name>"), ERx("SELECT") );
		}
	|	select_expr
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			if ($1.s)
			{
			    if (*$1.s)		/* name */
			    {
				if (esq->flag & ESQ_UNION_SEL)
				    /* check and flag */
				    _VOID_ eqck_tgt( 3, 3 );
				else
				    _VOID_ eqck_tgt( 2, 3 );	/* fill */
			    }
			    else		/* expression */
			    {
				if (esq->flag & ESQ_UNION_SEL)
				    /* check and flag */
				    _VOID_ eqck_tgt( 3, 2 );
				else
				    _VOID_ eqck_tgt( 2, 2 );	/* fill */
			    }
			}
			else			/* constant */
			{
			    if (esq->flag & ESQ_UNION_SEL)
				/* check and flag */
				_VOID_ eqck_tgt( 3, 1 );
			    else
				_VOID_ eqck_tgt( 2, 1 );	/* fill */
			}
		    }
		}
	|	select_expr sql_opt_as sql_id
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("<result_column_name AS>"), ERx("SELECT") );
		}
	|	col_subqry
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("Scalar subselect"), ERx("SELECT") );
		}
	|	col_subqry sql_opt_as sql_id
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("Scalar subselect"), ERx("SELECT") );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("<result_column_name AS>"), ERx("SELECT") );
		
		}
	|	sql_id sql_dot sql_star
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			if (esq->flag & ESQ_UNION_SEL)
			    _VOID_ eqck_tgt( 3, 2 );	/* check and flag */
			else
			    _VOID_ eqck_tgt( 2, 2 );	/* fill */
		    }
		}
;

select_hint:	/* nothing */
	|	sql_with select_hint_list
;

select_hint_list:	select_hint_elm
	|	select_hint_list sql_comma select_hint_elm
;

select_hint_elm:	sql_name
	|	sql_name sql_lparen sql_name sql_comma sql_name sql_rparen
;

/*
** ESQL generated block.  For example:
**	EXEC SQL SELECT column-list FROM table;
**	EXEC SQL BEGIN;
**	    user code
**	EXEC SQL END;
*/

select_block:	/* EMPTY */
		{
		    if (gr->gr_flag & GR_REPEAT)
		    {
			gr->gr_flag &= ~GR_REPEAT;
			/* Dump repeated query */
			rep_close( IIRETINIT, NULL, TRUE );
		    }
		    else
		    {
			db_close( IIRETINIT );
		    }
		    /* Add all the INTO variables and indicators */
		    if ((esq->flag & ESQ_DESC_SEL) == 0)
			erec_use( IIRETDOM, gr->gr_flag & GR_REPEAT, NULL );

		    if (esq->flag & ESQ_REG_SELECT)
		    {
			esl_query( ESL_SNGL_STOP_QUERY );   /* Dump the query */
			esq->flag &= ~ESQ_REG_SELECT;
		    }
		    $$.i = 0;
		}
	|	select_block_begin block_stmts select_block_end
		{
		    $$.i = 1;
		}
;
select_block_begin:
		tBEGIN host_term
		{
		    i4		cur_ret;

		    if (eq->eq_flags & EQ_CHREOS)
			 esq_eoscall(IImodNOCEOS);
		    if (gr->gr_flag & GR_REPEAT)
		    {
			gr->gr_flag &= ~GR_REPEAT;
			/* Dump repeated query */
			rep_close( IIRETINIT, NULL, FALSE );
		    } else
			db_close( IIRETINIT );

		    /* Add all the INTO variables and indicators */
		    if ((esq->flag & ESQ_DESC_SEL) == 0)
			erec_use( IIRETDOM, gr->gr_flag & GR_REPEAT, NULL );

		    if (esq->flag & ESQ_REG_SELECT)
		    {
			esl_query( ESL_BULK_STOP_QUERY );   /* Dump the query */
			esq->flag &= ~ESQ_REG_SELECT;
		    }

		    /* Here's generic block-begin code */
		    _VOID_ lbl_next( LBL_RET );
		    lbl_enter_block();
		    lbl_set_mode( LBLmRETLOOP );
		    lbl_adset( LBL_NOLEV, gr->gr_adjective );
		    gr->gr_mode = 0;
		    gr->gr_adjective = 0;
		    gr->gr_flag &= ~(GR_SQL|GR_ESQL);

		    /* Here's SELECT-specific block-begin code */
		    cur_ret = lbl_current( LBL_RET );
		    gen_if_goto( IIERRTEST, C_NOTEQ, 0, L_RETEND, cur_ret );
		    /* Open retrieve loop */
		    gen_label( G_LOOP, L_RETBEG, cur_ret );
		    gen_loop( G_OPEN, L_RETBEG, L_RETFLUSH, cur_ret,
			IINEXTGET, C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    if (esq->flag & ESQ_DESC_SEL)
			/* Descriptor retrieval */
			erec_desc( NULL );
		    else
			ret_close();		/* Variable retrieval */
		    if (eq->eq_flags & EQ_CHRPAD)
			 esq_sqmods(IImodNOCPAD);
		    gen_if_goto( IIERRTEST, C_NOTEQ, 0, L_RETBEG, cur_ret );
		    gr->gr_flag &= ~GR_SQL;
		    gr->gr_flag |= GR_RETRIEVE; /* Prevent nesting queries */
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			        ERx("BEGIN"), ERx("SELECT") );
		}
;
select_block_end:
		tEND host_term
		{
		    lbl_exit_block();
		}
;

/* 
** into_clause - INTO hostvar {, hostvar} 
**
** The INTO clause builds a separate name list on the side.
** Upon completion of the SELECT statement the IIret calls are generated with
** the user variables.
**
** The INTO list can also be used for the FETCH statement, which will have
** set the flag argument to interface with the cursor routines at the lower
** host_intovar rule.
**
** The host_intovar can be a structure which will cause assignment to its names.
*/

into_clause:	/* No INTO clause */
		{
		    /* error must have INTO clause before FROM clause */
		    er_write( E_EQ0070_grMISSWORD, EQ_ERROR, 2, ERx("INTO"),
							ERx("SELECT/FETCH") );
		    YYERROR;
		}
	|	into_key into_list
		{
		    erec_setup( 0 );	/* Done with list */
		}
;
into_key:	tINTO
		{
		    erec_setup( 1 );	/* Initialize struct indicators stuff */
		}
;
into_list:	into_elm
	|	into_list into_comma into_elm
;
into_comma:	tCOMMA
		{
		    erec_setup( 0 );	/* Done with one element */
		}
;
into_elm:	host_intovar sql_opt_ind
		{
		    if ( (gr->gr_type == T_STRUCT) && (eq->eq_flags & EQ_FIPS) )
			er_write( E_EQ050D_FIPS_VAR, EQ_WARN, 0 );
		}
	|	datahdlr_cls sql_opt_ind
;
datahdlr_cls:   tDATAHANDLER tLPAREN tNAME datahdlr_arg tRPAREN
                {
                    char        *argname = NULL;

                    if ((  (argname = str_add( STRNULL, id_getname())) != NULL)
			&& (*argname != EOS))
                        id_free();
                    else
                        argname = ERx("0");

                    if (gr->gr_func == tUPDATE || gr->gr_func == tEXECUTE)
                    {
                        gr->gr_id = $3.s;
                        $$.s = argname;
                    }
                    else
                    {
                        erec_mem_add( $3.s, (SYM *) 0, T_HDLR );
                        erec_arg_add( argname );
			$$.s = $3.s;
                    }
                }
;

datahdlr_arg:	tLPAREN /* argument tRPAREN */
		{
		    sc_eat(id_add,SC_STRIP|SC_NEST|SC_SEEN,ERx(")"), '(', ')');
		}
;


/*
** select_tail returns:
**	CSR_STATIC	(0x0)	either no WHERE clause, or a static one
**	CSR_NO_FROM	(0x1)	if there wasn't a FROM clause at all
**	CSR_WHERE_VAR	(0x4)	if there was a WHERE clause in a variable
** Return value is used only by declcsr_body, via csr_select_sub,
** csr_select_full, and csr_select_full_elm.
*/
select_tail:	from_clause where_clause grouping_clause having_clause
		{
		    if ($1.i == CSR_NO_FROM)
		    {
			/*
			** If there isn't a FROM clause, then the WHERE,
			** GROUP BY, and HAVING clauses are illegal.
			** We accept them in order to give a good error message.
			** For DECLARE CURSOR, the GROUP BY and HAVING clauses
			** will mark the cursor as read-only, but that's okay.
			*/
			$$.i = CSR_NO_FROM;
			if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0507_FIPS_NOTOP, EQ_WARN, 2, 
			        ERx("FROM"), ERx("SELECT") );
			else if ($2.i != CSR_NO_WHERE || $3.i || $4.i)
			    er_write( E_EQ0133_sqNOFROM, EQ_ERROR, 0 );
		    } else
		    {
		      /* No WHERE clause is same as static clause after this */
			if ($2.i == CSR_NO_WHERE)
			    $$.i = CSR_STATIC;
			else
			    $$.i = $2.i;
		    }
		}
;
/*
** From_clause is 
**
**	FROM from_source {,from_source}
**
** where from_source is
**
**	tablename [corr_name]
** or 
**    	[(] from_source [NATURAL] [INNER|LEFT|RIGHT|FULL|CROSS] JOIN from_source
**			[ON search-condition] [)]
**
*/
from_clause:	sql_from from_list
		{
		    if ($2.i & FRM_JOIN)	
		    {
		        if (eq->eq_flags & EQ_COMMON)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				ERx("SELECT/UPDATE ... FROM ... JOIN"));
		        if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			        ERx("FROM ... JOIN"), ERx("SELECT/UPDATE") );
		    }
		    $$.i = CSR_STATIC;
		}
	|	/* EMPTY */
		{
		    $$.i = CSR_NO_FROM;
		}
;
from_list:	from_source
		{
		    $$.i = $1.i;
		}
	|	from_list sql_comma from_source
		{
		    $$.i = $1.i | $3.i;
		}
;
from_source:	from_item
		{
		    $$.i = $1.i;
		}
	|	from_source sql_opt_natural join_type from_item opt_join_cond
		{
		    $$.i = FRM_JOIN;
		}
;

derived_table:	sql_lparen select_full sql_rparen dt_corr
		{
		    $$.i = $2.i;
		}
;
dt_corr:	/* nothing */
	|	sql_optas sql_id dt_collist
		{
		    $$.s = $2.s;
		}
;
dt_collist:	/* nothing */
	|	sql_lparen dt_collist1 sql_rparen
;
dt_collist1:	sql_id
	|	dt_collist1 sql_comma sql_id
;
from_item:	own_tbl_corr
		{
		    $$.i = FRM_OK;
		}
	|	sql_lparen from_source sql_rparen
		{
		    $$.i = $2.i;
		}
	|	derived_table
		{
		    $$.i = $$.i;
		}
;
opt_tproc_spec:	/* Nothing ... */
	|	sql_lparen tproc_arg_list_or_empty sql_rparen
;
tproc_arg_list_or_empty: /* nothing */
	|	tproc_arg_list
;
tproc_arg_list: tproc_named_or_unnamed_arg
	|	tproc_arg_list sql_comma tproc_named_or_unnamed_arg
;
tproc_named_or_unnamed_arg: tproc_named_arg
	|	tproc_arg_var
;
tproc_named_arg:	sql_name sql_eq tproc_arg_var
;
tproc_arg_var:	select_expr
;
join_type:	tJOIN
		{
		    db_key( $1.s );
		}
	|	tINNER tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	tFULL tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	tLEFT tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	tRIGHT tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	tFULL tOUTER tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		}
	|	tLEFT tOUTER tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		}
	|	tRIGHT tOUTER tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		    db_key( $3.s );
		}
	|	tCROSS tJOIN
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
;
opt_join_cond:	sql_on predicate
	|	sql_using sql_lparen col_list sql_rparen
	|	/* Empty */
;
col_list:	sql_id
	|	col_list sql_comma sql_id
;
own_tbl_corr:	sql_id opt_tproc_spec
		{
		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
			ecs_addtab( NULL, $1.s );
		    $$.s = (char *)0;
		}
	|	sql_id opt_tproc_spec sql_optas sql_id
		{
		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
			ecs_addtab( NULL, $1.s );
		    $$.s = $4.s;
		}
	|	sql_id sql_dot sql_id opt_tproc_spec
		{
		    char tbuf[100 + 2*DB_MAXNAME]; /* buf for owner.tablename */

		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
			ecs_addtab( NULL, STpolycat(3,$1.s,$2.s,$3.s,tbuf) );
		    $$.s = (char *)0;
		}
	|       sql_id sql_dot sql_id opt_tproc_spec sql_optas sql_id
		{
		    char tbuf[100 + 2*DB_MAXNAME]; /* buf for owner.tablename */
		
		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
		        ecs_addtab( NULL, STpolycat(3,$1.s,$2.s,$3.s,tbuf) );
		    $$.s = $6.s;
		}			     
	|	ing_id_dbkey sql_dot sql_id
		/* ($ingres|$dba).objectname               b57353tt */
		{
		    char tbuf[100 + 2*DB_MAXNAME]; /* buf for owner.tablename */

		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
			ecs_addtab( NULL, STpolycat(3,$1.s,$2.s,$3.s,tbuf) );
		    $$.s = (char *)0;
		}
	|       ing_id_dbkey sql_dot sql_id sql_optas sql_id
		/* ($ingres|$dba).objectname               b57353tt */
		{
		    char tbuf[100 + 2*DB_MAXNAME]; /* buf for owner.tablename */
		
		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
		        ecs_addtab( NULL, STpolycat(3,$1.s,$2.s,$3.s,tbuf) );
		    $$.s = $5.s;
		}			     
	|	sess_id
		{
		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
			ecs_addtab( NULL, $1.s );
		    $$.s = (char *)0;
		}
	|	sess_id sql_optas sql_id
		{
		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
		        ecs_addtab( NULL, $1.s );
		    $$.s = $3.s;
		}
;
sql_optas:	sql_as
	|
;
tbl_corr_id:	schema_obj
	|	schema_obj sql_id
;

/*
** where_clause returns
**	CSR_STATIC	(0x0):	A static WHERE clause
**	CSR_NO_WHERE	(0x2):	No WHERE clause
**	CSR_WHERE_VAR	(0x4):	WHERE clause was in a variable
*/
where_clause:	sql_where predicate
		{
		    $$.i = CSR_STATIC;
		}
	|	sql_where sql_strvar
		{
		    $$.i = CSR_WHERE_VAR;
		    if ( gr->gr_flag & GR_REPEAT )
		    {
			db_op( ERx("...SYNTAX ERROR") );
			er_write( E_EQ0378_repWHERE, EQ_ERROR, 0 );
		    }
		}
	|	/* No WHERE clause */
		{
		    $$.i = CSR_NO_WHERE;
		}
;
/* Return value used only by select_tail, col_subqry */
grouping_clause: sql_group sql_by sql_group_list
		{
		    /* GROUP BY makes a cursor Read-Only */
		    if (ESQ_DCLCSR(esq))
			ecs_csrset( NULL, ECS_GROUP );
		    $$.i = 1;
		}
	|	/* No GROUP BY clause */
		{
		    $$.i = 0;
		}
;
sql_group_list: simple_expr
		{
		    $$.i = 0;
		}
	|	sql_group_list sql_comma simple_expr
		{
		    $$.i = 1;
		}
;
schema_obj_lst:	schema_obj
		{
		    $$.i = 0;
		}
	|	schema_obj_lst sql_comma schema_obj
		{
		    $$.i = 1;
		}
;
schema_obj:	sql_id sql_dot sql_id sql_dot sql_id
		/* schema.tablename.columnname */
		{
		    $$.s = $3.s;
		}
	|	sql_id sql_dot sql_id
		/* schema.objectname */
		{
		    $$.s = $3.s;
		}
	|	sql_id
		{
		    $$.s = $1.s;
		}
	|	ing_id_dbkey sql_dot sql_id sql_dot sql_id
		/* ($ingres|$dba).tablename.columname      b57353tt */
		{
		    $$.s = $3.s;
		}
	|	ing_id_dbkey sql_dot sql_id
		/* ($ingres|$dba).objectname               b57353tt */
		{
		    $$.s = $3.s;
		}
;
crunq_col_name: sql_id
		{
		    if (esq->flag & ESQ_CURSOR)
		    {
			ecs_colupd( NULL, $1.s, ECS_CHK );
			if (gr->gr_func == tUPDATE)
			    ecs_coladd( $1.s ); /* might be a cursor */
		    }
		}
;
/* Return value used only by select_tail, col_subqry */
having_clause:	sql_having predicate
		{
		    /* HAVING makes a cursor Read-Only */
		    if (ESQ_DCLCSR(esq))
			ecs_csrset( NULL, ECS_HAVING );
		    $$.i = 1;
		}
	|	/* No HAVING clause */
		{
		    $$.i = 0;
		}
;
select_union:	/* EMPTY */
	|	sql_union select_full
;
select_order:	/* EMPTY */
	|	sql_order sql_by select_order_list
;
select_order_list:
		select_order_elm
	|	select_order_list sql_comma select_order_elm
;
select_order_elm:
		simple_expr sql_order_opt_sort
;
select_off_fetch: select_offset select_fetch
;	
select_offset:	/* EMPTY */
	|	sql_offset const_or_parm
;
select_fetch:	/* EMPTY */
	|	sql_fetch first_or_next const_or_parm row_or_rows sql_only
;
first_or_next:	sql_name
    {
	if (!ESQ_EQSTR($1.s, ERx("first")))
	    er_write( E_EQ0244_yySYNWRD, EQ_ERROR, 1, $1.s );
    }
	|	tNEXT
    {
	db_key( $1.s );
    }
;
row_or_rows:	tROW
    {
	db_key( $1.s );
    }
	|	tROWS
    {
	db_key( $1.s );
    }
;
const_or_parm:	sql_iconst
	|	sql_expr_var
;

/*
** select_full - a UNION of subselects
*/

select_full:	select_full_elm
		{
		    $$.i = $1.i;	/* UNION info for CREATE VIEW rule */
		}
	|	select_full sql_union select_full_elm
		{
		    $$.i = 1;		/* UNION info for CREATE VIEW rule */
		}
;
select_full_elm: select_sub
		{
		    $$.i = 0;		/* UNION info used by CREATE VIEW */
		}
	|	sql_lparen select_full sql_rparen
		{
		    $$.i = $1.i;	/* UNION info used by CREATE VIEW */
		}
;

/*
** select_sub - a subselect, used as a component of other queries,
**		except for cursor declarations.
*/

select_sub:	select_head select_tail
;
select_head:	select_key select_firstn select_all esubselect_tgt
;

/*
** csr_select_sub
**	- a subselect, modified for use in DECLARE CURSOR
**	- returns a bit mask:
**	CSR_NO_FROM	(0x01)	No FROM clause
**	CSR_WHERE_VAR	(0x04)	if there was a WHERE clause in a variable
**	CSR_UPDATE	(0x08)	if there was an UPDATE clause
**	CSR_UPD_LIST	(0x10)	if there was a UPDATE list in the UPDATE clause
**	CSR_UPDATE_LIST (0x18)	UPD_LIST always implies UPDATE
*/
csr_select_sub: csr_select_full csr_select_order csr_select_offset 
	csr_select_fetch csr_sel_update
		{
		    if ($1.i == CSR_NO_FROM)
		    {
			/*
			** If there isn't a FROM clause, then the FOR UPDATE
			** clause is illegal.
			** We accept it in order to give a good error message.
			*/
			if ($5.i != CSR_STATIC)
			    er_write( E_EQ0133_sqNOFROM, EQ_ERROR, 0 );
			$$.i = $1.i;
		    } else
		    {
			$$.i = $1.i | $5.i;
		    }
		}
;
/*
** csr_select_full returns
**	CSR_STATIC	(0x0):	either no WHERE clause, or a static one
**	CSR_NO_FROM	(0x1):	No FROM clause
**	CSR_WHERE_VAR	(0x4):	WHERE clause was in a variable
*/
csr_select_full:
		csr_select_full_elm
		{
		    $$.i = $1.i;
		}
	|	csr_select_full sql_union csr_select_full_elm
		{
		    if ($1.i == CSR_NO_FROM || $3.i == CSR_NO_FROM)
			$$.i = CSR_NO_FROM;
		    else
			$$.i = $1.i | $3.i; /* MRW: probably just return $3.i */
		    ecs_csrset( NULL, ECS_UNION );
		}
;
/*
** csr_select_full_elm returns
**	CSR_STATIC	(0x0):	either no WHERE clause, or a static one
**	CSR_NO_FROM	(0x1):	No FROM clause
**	CSR_WHERE_VAR	(0x4):	WHERE clause was in a variable
*/
csr_select_full_elm:
		cselect_head select_tail
		{
		    $$.i = $2.i;
		}
	|	sql_lparen select_full sql_rparen
		{
		    $$.i = $2.i;	/* MRW: probably can just return 0 */
		}
;
cselect_head:	cselect_repkey cselect_firstn select_all csubselect_tgt
;
cselect_repkey: tSELECT
		{
		    db_key( $1.s );
		}
	|	tREPEAT tSELECT
		{
		    gr->gr_flag |= GR_REPEAT;
		    rep_begin( ERx("repeat"), ecs_id_curcsr() );
		    ecs_csrset( NULL, ECS_REPEAT );
		    db_key( $2.s );
		    /* 
		    ** No need for FIPS message because ecs_csrset will
		    ** give a general message.
		    */
		}
;
cselect_firstn:	/* EMPTY */
	|	select_firstkey sql_iconst
;
csubselect_tgt: tSTAR
		{
		    db_key( $1.s ); /* db_key 'cause we want spaces around it */
		    _VOID_ ecs_colupd( NULL, ERx(""), ECS_ADD|ECS_ISWILD );
		}
	|	csubselect_tgt_list
;
csubselect_tgt_list:
		csubselect_tgt_elm
	|	csubselect_tgt_list sql_comma csubselect_tgt_elm
;
/*
** Note that select_expr returns:
**	NULL:	constant
**	"\0":	expression
**	name:	[table.]name
*/
csubselect_tgt_elm:
		sql_id sql_eq select_expr
		{
		    if ($3.s)
		    {
			if (*$3.s)
			    _VOID_ ecs_colupd( NULL, $1.s, ECS_ADD );
			else
			    _VOID_ ecs_colupd( NULL, $1.s, ECS_ADD|ECS_EXPR );
		    } else
			_VOID_ ecs_colupd( NULL, $1.s, ECS_ADD|ECS_CONSTANT );

		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("<= result_column_name>"), ERx("SELECT") );
		}
	|	select_expr
		{
		    if ($1.s)
		    {
			if (*$1.s)
			{
			    _VOID_ ecs_colupd( NULL, $1.s, ECS_ADD );
			    if (eq->eq_flags & EQ_FIPS)
			    {
				if (esq->flag & ESQ_UNION_SEL)
			    	    /* check and flag */
				    _VOID_ eqck_tgt( 3, 3 );
				else
				    _VOID_ eqck_tgt( 2, 3 );	/* fill */
			    }
			}
			else
			{
			    _VOID_ ecs_colupd( NULL, $1.s, ECS_ADD|ECS_EXPR );
			    if (eq->eq_flags & EQ_FIPS)
			    {
				if (esq->flag & ESQ_UNION_SEL)
			    	    /* check and flag */
				    _VOID_ eqck_tgt( 3, 2 );
				else
				    _VOID_ eqck_tgt( 2, 2 );	/* fill */
			    }
			}
		    } else
		    {
			_VOID_ ecs_colupd( NULL, ERx(""),
						ECS_ADD|ECS_CONSTANT );
			if (eq->eq_flags & EQ_FIPS)
			{
			    if (esq->flag & ESQ_UNION_SEL)
			        /* check and flag */
				_VOID_ eqck_tgt( 3, 1 );
			    else
				_VOID_ eqck_tgt( 2, 1 );	/* fill */
			}
		    }
		}
	|	select_expr sql_as sql_id
		{
		    if ($1.s)
		    {
			if (*$1.s)
			    _VOID_ ecs_colupd( NULL, $3.s, ECS_ADD );
			else
			    _VOID_ ecs_colupd( NULL, $3.s, ECS_ADD|ECS_EXPR );
		    } else
			_VOID_ ecs_colupd( NULL, $3.s, ECS_ADD|ECS_CONSTANT );

		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("<result_column_name AS>"), ERx("SELECT") );
		}
	|	sql_id sql_dot sql_star
		{
		    STprintf( esq->sbuf, ERx("%s.%s"), $1.s, $3.s );
		    _VOID_ ecs_colupd( NULL, str_add(STRNULL, esq->sbuf),
				ECS_ADD|ECS_ISWILD );
		    if (eq->eq_flags & EQ_FIPS)
		    {
			if (esq->flag & ESQ_UNION_SEL)
			    _VOID_ eqck_tgt( 3, 2 );	/* check and flag */
			else
			    _VOID_ eqck_tgt( 2, 2 );	/* fill */
		    }
		}
;
csr_select_order: /* EMPTY */
	|	sql_order sql_by select_order_list
		{
		    ecs_csrset( NULL, ECS_SORTED );
		}
;
csr_select_offset: select_offset
;
csr_select_fetch: select_fetch
;
csr_sel_update: /* EMPTY */
		{
		    $$.i = CSR_STATIC;
		}
	|	sql_for csr_upd_mode update_key sql_of csr_col_list
		{
		    if (eq->eq_flags & EQ_COMMON)
		    {
			if ($2.i == ECS_DIRECTU) 
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("DECLARE CURSOR ... FOR DIRECT UPDATE"));
			else if ($2.i == ECS_DEFERRU)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("DECLARE CURSOR ... FOR DEFERRED UPDATE"));
		    }
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
				ERx("FOR UPDATE"), ERx("DECLARE CURSOR") );
		    ecs_csrset( NULL, $2.i );
		    $$.i = CSR_UPDATE_LIST;
		}
		/* fix bug #59272 - allow FOR UDPATE without column list */
	|	sql_for csr_upd_mode update_key
		{
		    if (eq->eq_flags & EQ_COMMON)
		    {
			if ($2.i == ECS_DIRECTU) 
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("DECLARE CURSOR ... FOR DIRECT UPDATE"));
			else if ($2.i == ECS_DEFERRU)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("DECLARE CURSOR ... FOR DEFERRED UPDATE"));
		    }
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
				ERx("FOR UPDATE"), ERx("DECLARE CURSOR") );
		    ecs_csrset( NULL, $2.i );
		    $$.i = CSR_UPDATE;
		}
;
/*
** Cursor Column Update List
**
** Each element can be either "table_name.column_name" or "column_name".
** Neither "table_name" nor "column_name" may be in a variable.
** The "column_name" has NO other restrictions on it; the server uses this
** as the name of a real live column, not just as a result-column name.
** All the code that checks for non-updatable columns here (now removed)
** is because we thought that the server used them as result-column names.
*/
csr_col_list:	csr_col_elm
	|	csr_col_list sql_comma csr_col_elm
;
csr_col_elm:	csr_xcol_elm
	|	csr_atthead csr_xcol_elm
;
csr_atthead:	sql_id sql_dot
		{
		    ecs_addtab( NULL, $1.s );
		}
;
csr_xcol_elm:	sql_id
		{
		    i4		stat;		/* status of this column */
		    i4		is_wild;	/* csr had var|* in tgt list? */

		    /*
		    ** Variables in the update list are not allowed in ESQL.
		    */

		    is_wild = ecs_colupd(NULL, ERx(""), ECS_CHK|ECS_ISWILD) 
				    & ECS_EXISTS;
		    stat = ecs_colupd( NULL, $1.s, ECS_CHK );

		  /* Column not mentioned in target list? */
		    if (!(stat & ECS_EXISTS))
		    {
#if 0
		      /* No '*'s in target list means an error. */
			if (!is_wild)
			    er_write( E_EQ0406_csUPDXIST, EQ_ERROR, 2, $1.s,
								ecs_namecsr() );
#endif
		      /* Add it in any case. */
			_VOID_ ecs_colupd( NULL, $1.s, ECS_ADD|ECS_UPD );
		    }
#if 0
		    else if (stat & ECS_EXPR)
			er_write( E_EQ0403_csUPDEXPR, EQ_ERROR, 2, $1.s,
								ecs_namecsr() );
		    else if (stat & ECS_MANY)
			er_write( E_EQ0404_csUPDMANY, EQ_ERROR, 2, $1.s,
								ecs_namecsr() );
		    else if (stat & ECS_CONSTANT)
			er_write( E_EQ0405_csUPDCONST, EQ_ERROR, 2, $1.s,
								ecs_namecsr() );
#endif
		    else
			_VOID_ ecs_colupd( NULL, $1.s, ECS_CHK|ECS_UPD );
		}
	|	sql_all
		{
		    er_write( E_EQ0411_csUPDALL, EQ_ERROR, 1, ecs_namecsr() );
		}
;
csr_upd_mode:	/* EMPTY */
		{
		    $$.i = ECS_UPDATE;
		}
	|	sql_name
		{
		    if (ESQ_EQSTR($1.s, ERx("direct")))
			$$.i = ECS_DIRECTU;
		    else if (ESQ_EQSTR($1.s, ERx("deferred")))
			$$.i = ECS_DEFERRU;
		    else
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
						ERx("UPDATE"), ERx("DIRECT") );
			$$.i = ECS_DIRECTU;
		    }
		}
;
update_key:	tUPDATE
		{
		    db_key( $1.s );
		}
;

/*
+* ---- Predicates ----
-*	__________
*/

predicate:
		select_expr comparison select_expr
	|	select_expr comparison any_lparen col_sqry_body sql_rparen
	|	select_expr comparison sql_all col_subqry
	|	between_cond
	|	in_cond
	|	exists_cond
	|	postfix_cond
	|	predicate sql_and predicate		%Prec tAND
	|	predicate sql_or predicate		%Prec tOR
	|	sql_not predicate			%Prec tNOT
	|	sql_lparen predicate sql_rparen
	|	select_expr comparison col_subqry
		{
		    if ($3.i == 1)
		    {
		    	if (eq->eq_flags & EQ_FIPS)
				er_write( E_EQ0511_FIPS_SUBCLAUSE, EQ_WARN,0);
		    	if (eq->eq_flags & EQ_COMMON)
				er_write( E_EQ0512_OPEN_CLAUSE, EQ_WARN,2,
				ERx("GROUP BY/HAVING"), ERx("SELECT-Subqry"));
		    }
	        }
	|	col_subqry comparison select_expr
		{
		    if ($1.i == 1)
		    {
		    	if (eq->eq_flags & EQ_FIPS) 
				er_write( E_EQ0511_FIPS_SUBCLAUSE, EQ_WARN,0);
		    	if (eq->eq_flags & EQ_COMMON)
				er_write( E_EQ0512_OPEN_CLAUSE, EQ_WARN,2,
				ERx("GROUP BY/HAVING"), ERx("SELECT-Subqry"));
		    }
		}
	|	select_expr like select_expr like_modifier
	|	col_subqry like select_expr like_modifier
		{
		    if ($1.i == 1)
		    {
		    	if (eq->eq_flags & EQ_FIPS) 
				er_write( E_EQ0511_FIPS_SUBCLAUSE, EQ_WARN,0);
		    	if (eq->eq_flags & EQ_COMMON)
				er_write( E_EQ0512_OPEN_CLAUSE, EQ_WARN,2,
				ERx("GROUP BY/HAVING"), ERx("SELECT-Subqry"));
		    }
		}
;
comparison:	tLT
		{
		    db_op( $1.s );
		}
	|	tGT
		{
		    db_op( $1.s );
		}
	|	tEQOP
		{
		    db_op( $1.s );
		}
	|	tNE
		{
		    db_op( $1.s );
		    if (!ESQ_EQSTR($1.s, ERx("<>")))
		    {
		        if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0508_FIPS_OP, EQ_WARN, 1, $1.s );
			if (eq->eq_flags & EQ_COMMON)
			    er_write( E_EQ0513_OPEN_OP, EQ_WARN, 1, $1.s );
		    }		
		}
	|	tLE
		{
		    db_op( $1.s );
		}
	|	tGE
		{
		    db_op( $1.s );
		}
;

/* Subset of compare-op for partition RANGE */
range_op:	tLT
		{
		    db_op( $1.s );
		}
	|	tGT
		{
		    db_op( $1.s );
		}
	|	tLE
		{
		    db_op( $1.s );
		}
	|	tGE
		{
		    db_op( $1.s );
		}
/*
** Escape clause is:
**
** 	ESCAPE escape_char
**
** Where escape_char is a string constant or a string variable.
**
** No verification  is done to confirm that:
** 1. The string constant or string variable is 1 character long;
** 2. That this clause only appears for the LIKE
**    operator.
*/

like_modifier:
		like_modifier sql_withcase
	|	like_modifier sql_wocase
	|	like_modifier sql_escape sql_sconst
	|	like_modifier sql_escape sql_uconst
	|	like_modifier sql_escape host_setvar	/* Allow escape char to be variable */
		{
		    if (gr->gr_sym)
		    {
			db_var( DB_STRING, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
			if (gr->gr_type != T_CHAR && gr->gr_type != T_WCHAR &&
				gr->gr_type != T_UNDEF)
			    er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else	/* Error already from host_setvar */
			db_key( gr->gr_id );
		}
;
	|	/* Empty */
;
like:		sql_like
        |       sql_beginning
        |       sql_containing
        |       sql_ending
	|	sql_similar sql_to
        |       sql_notlike
        |       sql_notbeginning
        |       sql_notcontaining
        |       sql_notending
	|	sql_notsimilar sql_to
;

between_cond:	select_expr sql_between sql_sym select_expr sql_and select_expr
	|	select_expr sql_not sql_between sql_sym select_expr sql_and select_expr
;
sql_sym:	/* nothing */
	|	sql_asymmetric
	|	sql_symmetric
;

in_cond:	select_expr sql_not_in sql_lparen in_expr_list sql_rparen
	|	select_expr sql_not_in col_subqry
	|	select_expr sql_not_in select_expr
;
sql_not_in:	sql_not sql_in
	|	sql_in
;
in_expr_list:	select_expr sql_comma in_expr_list_body
;
in_expr_list_body:
		select_expr
	|	in_expr_list_body sql_comma select_expr
;

exists_cond:	sql_exists sql_lparen select_sub sql_rparen
;
/*
** is postfix op:
**
** <expr> IS [ NOT ] NULL
** <expr> IS [ NOT ] [ INTEGER | DECIMAL | FLOAT ]
** <expr> IS [ NOT ] OF ( [ INTEGER | DECIMAL | FLOAT ] )
*/
postfix_cond:	select_expr is_postfix_op
;
is_postfix_op:  sql_is is_name
        |       sql_is sql_of sql_lparen is_name sql_rparen
        |       sql_is sql_not is_name
        |       sql_is sql_not sql_of sql_lparen is_name sql_rparen
;
is_name:        sql_null
        |       tNAME
		{
		    db_key($1.s);
		}
;

expr_or_subqry:	col_subqry
		{
		    if ($1.i == 1)
		    {
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0511_FIPS_SUBCLAUSE, EQ_WARN,0);
			if (eq->eq_flags & EQ_COMMON)
			    er_write( E_EQ0512_OPEN_CLAUSE, EQ_WARN,2,
				ERx("General SQL"), ERx("SELECT-Subqry"));
		    }
		}
	|	select_expr
;
		
col_subqry:	sql_lparen col_sqry_body sql_rparen
		{
		    $$.i = $2.i;		/* bug #58171 */
		}
;
col_sqry_body:	scalar_select_clause from_clause where_clause grouping_clause 
			having_clause 
		{
		    if ($2.i == CSR_NO_FROM)
		    {
			if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0507_FIPS_NOTOP, EQ_WARN, 2, 
			        ERx("FROM"), ERx("SELECT") );
			/*
			** If there isn't a FROM clause, then the WHERE,
			** GROUP BY, and HAVING clauses are illegal.
			** We accept them in order to give a good error message.
			*/
			if ($3.i != CSR_NO_WHERE || $4.i || $5.i)
			    er_write( E_EQ0133_sqNOFROM, EQ_ERROR, 0 );
		    }
		    $$.i = $4.i || $5.i;
		}
;

scalar_select_clause:
		select_key sub_select_all expr_or_subqry
;

sub_select_all:	/* Empty */
	|	sql_all
	|	distinct_key
;

/*
** select_expr returns:
**	NULL:	constant
**	"\0":	expression
**	name:	[table.]name
** This is used only by csubselect_tgt_elm
*/
select_expr:	select_expr select_arith_op select_primary
		{
		    $$.s = ERx("");
		}
	|	select_primary
		{
		    $$.s = $1.s;
		}
;
select_arith_op:
		sql_star
	|	sql_slash
	|	sql_plus
	|	sql_minus
	|	sql_exp
	|	sql_concat
;
select_primary: sql_lparen select_expr sql_rparen
		{
		    $$.s = ERx("");
		}
	|	select_exp_value
		{
		    $$.s = $1.s;
		}
	|	sql_minus select_expr			%Prec tUNARYOP
		{
		    $$.s = ERx("");
		}
	|	sql_plus select_expr			%Prec tUNARYOP
		{
		    $$.s = ERx("");
		}
;
select_exp_value:
		function_ref
		{
		    $$.s = ERx("");
		    /* functions make a cursor Read-Only */
		    if (ESQ_DCLCSR(esq) && (esq->flag & ESQ_FROM_CHK))
			ecs_csrset( NULL, ECS_FUNCTION );
		}
	|	primary
		{
		    $$.s = $1.s;
		}
;

/*
** a simple_expr is a select_expr, except that set functions (aggregates)
** are not allowed.
*/
simple_expr:	simple_expr select_arith_op simple_primary
	|	simple_primary
;
simple_primary: sql_lparen simple_expr sql_rparen
	|	sql_minus simple_expr			%Prec tUNARYOP
	|	sql_plus simple_expr			%Prec tUNARYOP
	|	primary
;
primary:	schema_obj
		{
		    $$.s = $1.s;
		}
	|	primary_composite
		{
		    $$.s = $1.s;
		}
;
primary_composite:
		constant
		{
		    $$.s = NULL;
		}
	|	case_function
		{
		    $$.s = ERx("");
		}
	|	scalar_bif
		{
		    if (   !ESQ_EQSTR($1.s, ERx("dbmsinfo")) 
		        && eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0510_OPEN_FUNC, EQ_WARN, 1, $1.s );
		    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0509_FIPS_FUNC, EQ_WARN, 1, $1.s );
		    $$.s = ERx("");
		}
	|	sql_cast_expr
		{
		    $$.s = ERx("");
		}
	|	seq_expr
		{
		    $$.s = ERx("");
		}
	|	sql_expr_var
		{
		    $$.s = ERx("");
		}
	|	sql_notrim
		{
		    $$.s = ERx("");
		}
;
constant:	sql_iconst
	|	sql_sconst
        |       sql_boolconst
	|	tHEXCONST
		{
		    db_hexconst( $1.s );
		}
	|	sql_uconst
	|	tFLTCONST
		{
		    db_key( $1.s );
		}
	|	tDECCONST
		{
		    db_key( $1.s );
		}
	|	dt_interval_const
	|	tNULL
		{
		    db_key( $1.s );
		}
	|	all_user_keys
	|	tDEFAULT
		{
		    db_key( $1.s );
		}
;
dt_interval_const:	tDTCONST
		{
		    db_dtconst( $1.s );
		}
	|	sql_interval tSCONST interval_type
;
interval_type:	interval_field1 interval_junk1 interval_junk2
;
interval_field1:	tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("year")) &&
			!ESQ_EQSTR($1.s, ERx("month")) &&
			!ESQ_EQSTR($1.s, ERx("day")) &&
			!ESQ_EQSTR($1.s, ERx("hour")) &&
			!ESQ_EQSTR($1.s, ERx("minute")) &&
			!ESQ_EQSTR($1.s, ERx("second")))
			er_write( E_EQ0233_scILIT, EQ_ERROR, 0);

		    db_key( $1.s );
		}
;
interval_junk1:	/* nuffin' */
	|	sql_lparen sql_iconst sql_rparen
	|	sql_lparen sql_iconst sql_comma sql_iconst sql_rparen
;
interval_junk2:	/* yet more nuffin' */
	|	sql_to interval_terminator sql_lparen sql_iconst sql_rparen
	|	sql_to interval_terminator
;
interval_terminator: tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("month")) &&
			!ESQ_EQSTR($1.s, ERx("hour")) &&
			!ESQ_EQSTR($1.s, ERx("minute")) &&
			!ESQ_EQSTR($1.s, ERx("second")))
			er_write( E_EQ0233_scILIT, EQ_ERROR, 0);

		    db_key( $1.s );
		}
;
case_function:	sql_case case_body sql_end
	|	sql_if sql_lparen if_body sql_rparen
;
case_body:	searched_case
	|	select_expr simple_case
;
simple_case:	simple_when_list case_else
;
simple_when_list: simple_when_list_item
  	|	simple_when_list simple_when_list_item 
;
simple_when_list_item: sql_when select_expr sql_then select_expr
;
searched_case:	searched_when_list case_else
;
searched_when_list: searched_when_list_item
  	|	searched_when_list searched_when_list_item 
;
searched_when_list_item: sql_when predicate sql_then select_expr
;
case_else:	/* empty */
  	|	sql_else select_expr
;
if_body:	if_then_else
;
if_then_else:	test_then else_part
;
test_then:	boolean_expr sql_comma sel_expr_or_null
;
else_part:	sql_comma sel_expr_or_null
	|	/* nothing */
;
sel_expr_or_null: select_expr
	|	sql_null
;
boolean_expr:	predicate
;
function_ref:	count_lparen sql_star sql_rparen
	|	count_lparen agg_distinct_cl simple_expr sql_rparen
	|	function_name sql_lparen agg_distinct_cl simple_expr sql_rparen
	|	any_lparen agg_distinct_cl simple_expr sql_rparen
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0509_FIPS_FUNC, EQ_WARN, 1, ERx("ANY"));
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0510_OPEN_FUNC, EQ_WARN, 1, ERx("ANY"));
		}
;
count_lparen:	tCOUNT tLPAREN
		{
		    db_key( $1.s );
		    db_op( $2.s );
		}
;
any_lparen:	tANY tLPAREN
		{
		    db_key( $1.s );
		    db_op( $2.s );
		}
;
function_name:	tSUM
		{
		    db_key( $1.s );
		}
	|	tAVG
		{
		    db_key( $1.s );
		}
	|	tMIN
		{
		    db_key( $1.s );
		}
	|	tMAX
		{
		    db_key( $1.s );
		}
;

agg_distinct_cl: tDISTINCT
		{
		    db_key( $1.s );
		}
	|	tALL
		{
		    db_key( $1.s );
		}
	|	/* ALL is the default */
;

sql_cast_expr:	sql_cast sql_lparen select_expr sql_as crcol_type 
				crcol_collate sql_rparen
;

sql_cast:	tCAST
		{
		    db_key( $1.s );
		}
;

scalar_bif:	sname_lparen sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sname_lparen select_expr sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sname_lparen select_expr sql_comma select_expr sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sname_lparen select_expr sql_comma select_expr 
		sql_comma select_expr sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sql_substr sql_lparen select_expr sql_from select_expr sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sql_substr sql_lparen select_expr sql_from select_expr sql_for select_expr sql_rparen
		{
		    $$.s = $1.s;
		}
	|	sname_lparen select_expr sql_in select_expr sql_rparen
		{
		    if (!ESQ_EQSTR($1.s, ERx("position")))
			er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $1.s,
				ERx("query"));
		    $$.s = $1.s;
		}
	|	sname_lparen trim_spec sql_from select_expr sql_rparen
		{
		    if (!ESQ_EQSTR($1.s, ERx("trim")))
			er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $1.s,
				ERx("query"));
		    $$.s = $1.s;
		}
;
trim_spec:	tNAME tSCONST
                {
                    if ((STbcompare($1.s, 0, "trailing", 0, TRUE) != 0) &&
                        (STbcompare($1.s, 0, "leading", 0, TRUE) != 0) &&
                        (STbcompare($1.s, 0, "both", 0, TRUE) != 0))
                    {
                        er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $1.s,
                                ERx("TRIM"));
                    }
                    db_key($1.s);
                    db_sconst( $2.s );
                }
        |       tNAME
                {
                    if ((STbcompare($1.s, 0, "trailing", 0, TRUE) != 0) &&
                        (STbcompare($1.s, 0, "leading", 0, TRUE) != 0) &&
                        (STbcompare($1.s, 0, "both", 0, TRUE) != 0))
                    {
                        er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $1.s,
                                ERx("TRIM"));
                    }
                    db_key($1.s);
                }
	|	sql_sconst
;
sname_lparen:	sname sql_lparen
		{
		    $$.s = $1.s;
		}
;
sname:		tLEFT
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
	|	tRIGHT
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
	|	tINTERVAL
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
	|	tNAME   /* Use tNAME here to avoid reduce/reduce conflict */
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
;
seq_expr:	ansiseq_expr
	|	oracleseq_expr
;
ansiseq_expr:	seq_kwd sql_for ansiseq_name
;
ansiseq_name:	sql_id sql_dot sql_id
		{
		    $$.s = $3.s;
		}
	|	sql_id
		{
		    $$.s = $1.s;
		}
;
oracleseq_expr:	sql_id sql_dot seq_kwd
;
seq_kwd:	sql_nextval
	|	sql_currval
;
seq_iconst:	sql_iconst
	|	sql_plus sql_iconst
	|	sql_minus sql_iconst
	|	tDECCONST
		{
		    db_key( $1.s );
		}
	|	sql_plus tDECCONST
		{
		    db_key( $2.s );
		}
	|	sql_minus tDECCONST
		{
		    db_key( $2.s );
		}
;

/*
## END SQL
*/

/* 
** sql_expr_var - Host variable within an sql expression. Send this variable 
**	to the backend. Requires a colon to distinguish it from 
**	(1) column names that are simple tNAME's, and 
**	(2) to avoid Yacc conflicts between tNAME () as the SQL built-in 
** functions and host variables that are subscripted by parens, such as 
** in PL/I or FORTRAN.	
*/
sql_expr_var:	host_setvar sql_opt_ind
		{
		    if (gr->gr_flag & GR_REPEAT )
			rep_param();
		    db_var( DB_REG, gr->gr_sym, gr->gr_id,
			    gr->gr_nlsym, gr->gr_nlid, (char *)0 );
		    if (gr->gr_flag & GR_REPEAT )
			rep_add( gr->gr_sym, gr->gr_id,
				gr->gr_nlsym, gr->gr_nlid, (char *)0 );
		    if ( (gr->gr_type == T_STRUCT) && (eq->eq_flags & EQ_FIPS) )
			er_write( E_EQ050D_FIPS_VAR, EQ_WARN, 0 );
		}
	|	datahdlr_cls sql_opt_ind
		{
		    if (gr->gr_flag & GR_REPEAT )
			rep_param();
			/* 60688 */
		    if (gr->gr_flag & GR_REPEAT )
			rep_add( gr->gr_sym, gr->gr_id,
				gr->gr_nlsym, gr->gr_nlid, $1.s );
                    else
		        db_var( DB_HDLR, gr->gr_sym, gr->gr_id,
			    gr->gr_nlsym, gr->gr_nlid, $1.s );
		}
;

/* 
** sql_notrim - Allowed in UPDATE and INSERT statements. Variable is
**		host_fsetvar (like the forms system) to allow for error
** if no colon.
*/
sql_notrim:	tNOTRIM tLPAREN host_fsetvar sql_opt_ind tRPAREN
		{
		    if (gr->gr_flag & GR_REPEAT )
			rep_param();
		    db_var( DB_NOTRIM, gr->gr_sym, gr->gr_id,
			    gr->gr_nlsym, gr->gr_nlid, (char *)0 );
		    if (gr->gr_flag & GR_REPEAT )
			rep_add( gr->gr_sym, gr->gr_id,
				gr->gr_nlsym, gr->gr_nlid, (char *)0 );
		    if (gr->gr_type != T_CHAR && gr->gr_type != T_UNDEF)
		    {
			er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1, gr->gr_id );
			gr->gr_sym = (SYM *)0;	/* Will be sent in db_key */
		    }
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0510_OPEN_FUNC, EQ_WARN, 1, $1.s );
		    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0509_FIPS_FUNC, EQ_WARN, 1, $1.s );
		}
;

/*
+* ---- CURSOR Statements ----
*/

/*
** Cursor Statements -	All statements that manipulate cursors.
**			The DELETE and UPDATE statements WHERE CURRENT OF
** are implemented under the SQL database statements.
*/

/* 
+* Statement:	EXEC SQL CLOSE cursor-name
-* Action:	Close cursor at run-time, and release the file.	 Keep the
**		query around for possible re-opening.
** Generates:	IIcsrClose( cursor-id );
*/

close:		tCLOSE csr_name
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, $2.s );
		    esq_init();
		    ecs_close( $2.s, gr->gr_sym != (SYM *)0 );
		}
;

/* 
+* Statement:	EXEC SQL DECLARE cursor-name CURSOR FOR
**		    [REPEATED] select-clause [FOR UPDATE OF column-list]
**		|   statement_name
-* Action:	Non-executable statement to inform preprocessor about the
**		query and properties associated with a cursor name.
** Generates:	None
*/

declare_cursor: declcsr_key declcsr_body
		{
		    db_send();
		    if (eq->eq_flags & EQ_CHREOS) /* Turn EOS check Off */
		        esq_eoscall(IImodNOCEOS);
		    ecs_query( NULL, ECS_STOP_QUERY );
		    if (gr->gr_flag & GR_REPEAT )
		    {
			rep_close( IICSQUERY, ecs_id_curcsr(), FALSE );
			ecs_query( NULL, ECS_END_QUERY );
		    }
		    esq->flag &= ~(ESQ_CURSOR|ESQ_FROM_CHK);
		    esq->flag |= ESQ_NOPRT;
		}
;
declcsr_key:	tDECLARE csr_name declcsr_scroll
		{
		  /* Don't print it */
		    esq->flag |= (ESQ_NOPRT|ESQ_CURSOR
				  |ESQ_DECLCSR|ESQ_FROM_CHK);
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, $2.s );
		    esq->flag &= ~ESQ_NOPRT;
		    ecs_declcsr( $2.s, gr->gr_sym );
		    if ($3.i > 0)
			ecs_csrset( $2.s, $3.i );
		    ecs_query( NULL, ECS_START_QUERY );
		}
;
declcsr_scroll:	/* empty */
		{
		    $$.i = 0;
		}
/*
   DISABLE SCROLL CURSOR - BEGIN
        |       declcsr_keyset tSCROLL
                {
		    $$.i = $1.i | ECS_SCROLL;
                }
   DISABLE SCROLL CURSOR - END
*/

;
declcsr_keyset:	/* empty */
		{
		    $$.i = 0;
		}
        |       tKEYSET
                {
		    $$.i = ECS_KEYSET;
                }
;
declcsr_body:	tCURSOR tFOR sql_id		/* dynamic cursor */
		{
		    ecs_csrset( NULL, ECS_DYNAMIC );
		}
	|	tCURSOR tFOR sql_strvar
		{
		    ecs_csrset( NULL, ECS_DYNAMIC );
		}
	|	tCURSOR tFOR csr_select_sub
		{
		    /*
		    ** csr_select_sub returns a bit mask:
		    ** CSR_STATIC	(0x00)	WHERE clause static or missing
		    ** CSR_NO_FROM	(0x01)	No FROM clause
		    ** CSR_WHERE_VAR	(0x04)	a WHERE clause in a variable
		    ** CSR_UPDATE	(0x08)	an UPDATE clause
		    ** CSR_UPD_LIST	(0x10)	an UPDATE list in UPDATE clause
		    ** CSR_UPDATE_LIST	(0x18)	UPD_LIST always implies UPDATE
		    */
		    if ($3.i & CSR_WHERE_VAR)	/* WHERE clause in a variable */
		    {
			/*
			** If the where clause is in a variable, then the
			** cursor is updatable.	 Additionally, if there wasn't
			** an update clause, then pretend we saw
			** "for update of (string_var)" since one may have been
			** tacked onto the end of the where-variable.
			*/
			ecs_csrset( NULL, ECS_UPDATE|ECS_WHERE );
			switch ($3.i & CSR_UPDATE_LIST)
			{
			  case CSR_UPDATE:/* Update clause but no update list */
			    break;
			  case CSR_STATIC:	/* No update clause */
			    ecs_csrset( NULL, ECS_UPDVAR );
			    /* FALL THROUGH! */
			  case CSR_UPD_LIST:/* Update clause with update list */
			  case CSR_UPDATE_LIST:
			    ecs_fixupd( NULL );
			    break;
			}
		    } else if ($3.i & CSR_UPD_LIST)	/* UPDATE list */
			ecs_fixupd( NULL );
		}
	|	error
		{
		    ecs_csrset( NULL, ECS_ERR );
		}
;

/* 
+* Statement:	EXEC SQL FETCH cursor-name
**			INTO result-variables
**		    |	USING DESCRIPTOR descriptor_name
-* Action:	Fetch current value of cursor into user variables.
** Generates:
**	-- FETCH csr INTO :ivar, :fvar, :strvar;
**		IIsqInit( &sqlca );
**		if (IIcsRetrieve(csr) != 0) {
**		    IIcsGet( TRUE, DB_INT_TYPE, sizeof(ivar), &ivar );
**		    IIcsGet( TRUE, DB_FLT_TYPE, sizeof(ivar), &fvar );
**		    IIcsGet( TRUE, DB_CHR_TYPE, 0, &strvar );
**		    IIcsERetrieve();
**		}
**
**	-- FETCH <orientation> FROM csr INTO :ivar, :fvar, :strvar;
**		IIsqInit( &sqlca );
**		if (IIcsRetScroll(csr, fetcho, fetchn) != 0) {
**		    IIcsGet( TRUE, DB_INT_TYPE, sizeof(ivar), &ivar );
**		    IIcsGet( TRUE, DB_FLT_TYPE, sizeof(ivar), &fvar );
**		    IIcsGet( TRUE, DB_CHR_TYPE, 0, &strvar );
**		    IIcsERetrieve();
**		}
**
**	-- FETCH csr USING DESCRIPTOR :sqlda;
**		IIsqInit( &sqlca );
**		if (IIcsRetrieve(csr) != 0) {
**		    IIcsDaGet( EQ_C, &sqlda );
**		    IIcsERetrieve();
**		}
**
*/

fetch:		fetch_head fetch_body
		{
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    ecs_eretrieve( NULL, $2.i );
		    esq->flag &= ~ESQ_CURSOR;
		}
;
fetch_head:	tFETCH from_noise csr_name
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, $3.s );
		    esq_init();
		    ecs_retrieve( $3.s, gr->gr_sym != (SYM *)0, $2.fet.intv1,
					$2.fet.intv2, $2.fet.s1, $2.fet.v1 );
		    if (eq->eq_flags & EQ_CHRPAD)
		  	esq_sqmods(IImodCPAD);
		    if (eq->eq_flags & EQ_CHREOS)
		  	esq_sqmods(IImodCEOS);
		    esq->flag |= ESQ_CURSOR;
		}
;
from_noise:     fetch_orientation tFROM
		|	/* nothing */
			{
			    $$.fet.intv1 = 0;
			}
;
fetch_orientation:
/*
   DISABLE SCROLL CURSOR - BEGIN
			tFIRST
			{
			    $$.fet.intv1 = fetFIRST;
			    $$.fet.intv2 = 1;
			    $$.fet.s1 = (SYM *)NULL;
			    $$.fet.v1 = (char *)NULL;
			}
		|	tLAST
			{
			    $$.fet.intv1 = fetLAST;
			    $$.fet.intv2 = -1;
			    $$.fet.s1 = (SYM *)NULL;
			    $$.fet.v1 = (char *)NULL;
			}
		|	tNEXT
			{
			    $$.fet.intv1 = fetNEXT;
			    $$.fet.intv2 = 1;
			    $$.fet.s1 = (SYM *)NULL;
			    $$.fet.v1 = (char *)NULL;
			}
		|	tPRIOR
			{
			    $$.fet.intv1 = fetPRIOR;
			    $$.fet.intv2 = -1;
			    $$.fet.s1 = (SYM *)NULL;
			    $$.fet.v1 = (char *)NULL;
			}
		|	tABSOLUTE fetch_constant
			{
			    $$.fet.intv1 = fetABSOLUTE;
			    $$.fet.intv2 = $2.i;
			    $$.fet.s1 = (SYM *)NULL;
			    $$.fet.v1 = (char *)NULL;
			}
		|	tABSOLUTE host_setvar
			{
			    $$.fet.intv1 = fetABSOLUTE;
			    $$.fet.intv2 = 0;
			    $$.fet.s1 = gr->gr_sym;
			    if (gr->gr_type != T_INT)
			    {
				er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
				    gr->gr_id );
				$$.fet.v1 = (char *)NULL;
			    }
			    else $$.fet.v1 = gr->gr_id;
			}
		|	tRELATIVE fetch_constant
			{
			    $$.fet.intv1 = fetRELATIVE;
			    $$.fet.intv2 = $2.i;
			    $$.fet.s1 = (SYM *)NULL;
			    $$.fet.v1 = (char *)NULL;
			}
		|	tRELATIVE host_setvar
			{
			    $$.fet.intv1 = fetRELATIVE;
			    $$.fet.intv2 = 0;
			    $$.fet.s1 = gr->gr_sym;
			    if (gr->gr_type != T_INT)
			    {
				er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
				    gr->gr_id );
				$$.fet.v1 = (char *)NULL;
			    }
			    else $$.fet.v1 = gr->gr_id;
			}
		|
   DISABLE SCROLL CURSOR - END
*/
			/* nothing */
			{
			    $$.i = 0;
			}
;
fetch_constant:	tMINUS tINTCONST
			{
			    CVan($2.s, &$$.i);
			    $$.i = -$$.i;
			}
		|	tINTCONST
			{
			    CVan($1.s, &$$.i);
			}
;
fetch_body:	into_clause
		{
		    erec_use( IICSGET, FALSE, NULL );
		    $$.i = 0;
		}
	|	fetch_using
		{
		    $$.i = 1;
		}
	|	error
		{
		    $$.i = 0;
		}
;
fetch_using:	tUSING tDESCRIPTOR host_sqlda
		{
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IICSDAGET );
		    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("USING DESCRIPTOR"), ERx("FETCH") );
		}
;

/* 
+* Statement:	EXEC SQL OPEN cursor-name [FOR READONLY]
**		    [USING variable {, variable} | DESCRIPTOR descriptor_name]
-* Action:	Open cursor at run-time, and send it the stored query.
** Generates:
**	-- EXEC SQL DECLARE c1 CURSOR FOR SELECT * FROM t1;
**	-- EXEC SQL OPEN c1;
**		IIsqInit( &sqlca );
**		IIcsOpen( "c1", num1, num2 )
**		IIwritio( 0, (short *)0, 1, 32, 0, "select * from t1" );
**		IIcsQuery( "c1", num1, num2 );	-- Implied select loop
**
**	-- EXEC SQL BEGIN DECLARE SECTION;
**	--     int	ivar;
**	--     float	fvar;
**	-- EXEC SQL END DECLARE SECTION;
**
**	-- EXEC SQL PREPARE s1 FROM
**	--	"SELECT * FROM t1 WHERE col1 = ? AND col2 = ?";
**	-- EXEC SQL DECLARE c1 CURSOR FOR s1;
**	-- EXEC SQL OPEN c1 FOR READONLY USING :ivar, :fvar;
**	    int ivar;
**	    float fvar;
**	    {
**	      IIsqInit((char *)0);
**	      IIsqPrepare(0,"s1",&sqlda,0,"select * fromt t1 where col1 = ? \
**		and col2 = ?");
**	      IIsyncup((char *)0,0);
**	    }
**	    {
**	      IIsqInit((char *)0);
**	      IIcsOpen("c1",40733,20743);
**	      IIwritio(0,(short *)0,1,32,0,"s1");
**	      IIwritio(0,(short *)0,1,32,0," for readonly ");
**	      IIsqExStmt((char *)0, 1);
**	      IIputdomio((short *)0,1,30,4,&ivar);
**	      IIputdomio((short *)0,1,31,4,&fvar);
**	      IIcsQuery("c1",40733,20743);	-- Implied select loop
**	    }
**
**	-- EXEC SQL OPEN c1 USING DESCRIPTOR :sqlda;
**	    {
**	      IIsqInit((char *)0);
**	      IIcsOpen("c1",40733,20743);
**	      IIwritio(0,(short *)0,1,32,0,"s1");
**	      IIsqDaIn(0,&sqlda);
**	      IIcsQuery("c1",40733,20743);	-- Implied select loop
**	    }
*/

open:		csr_open_head csr_using
		{
		    if ($1.s)	/* valid cursor name */
		    {
			i4		flags;

			flags = ecs_gcsrbits($1.s);

		      /* REPEATED cursor selects handle IIcsQuery themselves */
			if ((flags & ECS_REPEAT) == 0)
			    ecs_opquery( $1.s );
			if ($2.i)
			{
			    if ((flags & ECS_DYNAMIC) == 0)
				er_write( E_EQ0425_csUSINGDYN, EQ_ERROR, 1,
									$1.s );
			}
		    }
		}
;
csr_open_head:	tOPEN csr_name csr_rdo
		{
		    i4	value;

		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, $2.s );
		    value = ecs_gcsrbits( $2.s );
		    /*
		    ** If this was a bad cursor name then ecs_gcsrbits
		    ** printed an error message and returned ECS_NONEXIST.
		    ** Don't call ecs_open or it will print one too.
		    */
		    if ((value & ECS_NONEXIST) == 0)
		    {
		      /* repeat queries handle esq_init in the buffered text */
			if ((value & ECS_REPEAT) == 0)
			    esq_init();
			ecs_open( $2.s, $3.s,(SYM *)0, gr->gr_sym != (SYM *)0 );
			$$.s = $2.s;
		    } else
			$$.s = (char *)0;	/* flag invalid cursor name */
		}
;
/* csr_name - Cursor name in name form, string constant or variable */
csr_name:	sql_reg_or_delim
		{
		    $$.s = $1.s;
		    gr->gr_sym = (SYM *)0;
		}
	|	tSCONST
		{
		    $$.s = $1.s;
		    gr->gr_sym = (SYM *)0;
		}
	|	host_setvar
		{
		    $$.s = gr->gr_id;
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_CHAR)
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    gr->gr_sym = (SYM *)0;
			}
		    }
		}
;
csr_rdo:	/* Empty */
		{
		    $$.s = NULL;
		}
	|	tFOR tNAME
		{
		    $$.s = ERx(" for readonly ");
		    if (!ESQ_EQSTR($2.s, ERx("readonly")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
						ERx("OPEN"), ERx("READONLY") );
		    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("FOR READONLY"), ERx("OPEN cursor") );
		}
;
csr_using:	/* EMPTY */
		{
		    $$.i = 0;
		}
	|	csr_using_key execu_namelist
		{
		    $$.i = 1;
		}
	|	tUSING tDESCRIPTOR host_sqlda
		{
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IISQDAIN );
		    $$.i = 1;
		}
;
csr_using_key:	tUSING
		{
		    arg_str_add(ARG_CHAR, (char *)0);	/* no statement name */
		    arg_int_add( 1 );			/* using vars */
		    gen_call( IISQEXSTMT );
		    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
			    ERx("USING"), ERx("OPEN cursor") );
		}
;

/*
+* ---- QUEL-equivalent SQL Database Statements ----
-*
** QUEL(SQL) (database) statements:
**
** Statements:	EXEC SQL QUEL-like database statement
** Action:	Same as in QUEL
** Generates:	(C examples)
**
**	Keywords:		IIwritedb( "abort" );
**	Identifiers:		IIwritedb( "empno" );
**	Variables:		IIsetdom( variable, type, bytes );
**	       or:		IIwritedb( stringvar );
**
**	General form:		{ IIwritedb(); IIsetdom(); IIsyncup(); }
**	Write out data to the database (IIwritedb and IIsetdom) and process it 
**	when the syncronizing signal (IIsyncup) comes through.
**
** Notes:	The following section describes rules and statements that are
**		in INGRES/SQL but that are really copies of QUEL statements.
** Some of them are not exact copies (like the MODIFY statement), but some (like
** the BEGIN XACT) statement are the same.
*/

/*
+* Statement:	EXEC SQL ABORT [TO name | number]
-* Action:
** Generates:
*/

abort:		tABORT
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    er_write( E_EQ0135_sqXACT, EQ_WARN, 1, $1.s );
		    esq_init();
		    arg_int_add( IIxactABORT );		/* Close transaction */
		    gen_call( IIXACT );
		    gr->gr_flag |= GR_NOSYNC;	   /* No IIsync after this */
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("ABORT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ABORT"));
		}
	|	abort_key sql_to sql_id_iconst
;
abort_key:	tABORT 
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    er_write( E_EQ0135_sqXACT, EQ_WARN, 1, $1.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
				EQ_WARN, 1, ERx("ABORT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("ABORT"));
		}
;

/*
+* Statement:	EXEC SQL COMMIT [WORK]
-* Action:
** Generates:
*/

commit:		commit_key commit_work
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, $2.s );
		    esq_init();
		    arg_int_add( IIxactSCOMMIT );	/* Close transaction */
		    gen_call( IIXACT );
		    gr->gr_flag |= GR_NOSYNC;	   /* No IIsync after this */
		    if ($2.s == NULL && eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0507_FIPS_NOTOP, EQ_WARN, 2,
			    ERx("WORK"), ERx("COMMIT") );
		}
;
commit_key:	tCOMMIT 
		{
		    $$.s = $1.s;
		}
;
commit_work:	tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("work")))
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					    ERx("COMMIT WORK"), ERx("WORK") );
			$$.s = ERx("work");
		    }
		}
	|	/* EMPTY */
		{
		    $$.s = NULL;
		}
;


/* 
+* EXEC SQL DROP [TABLE|VIEW|INDEX] name-list [WITH with_clause]
** EXEC SQL DROP {PERMIT | INTEGRITY} ON [TABLE|APPLICATION|LOCATION|DBEVENT]
**	{number-list | ALL}
** EXEC SQL DROP LINK link_list
** EXEC SQL DROP PROCEDURE proc_list
** EXEC SQL DROP ROLE role_list
** EXEC SQL DROP DBEVENT event_name
** EXEC SQL DROP GROUP groupid_list
** EXEC SQL DROP RULE rulename
** EXEC SQL DROP DOMAIN dom_name
** EXEC SQL DROP LOCATION loc_name
** EXEC SQL DROP SECURITY_ALARM ON table alarm_number {, alarm_number}
** EXEC SQL DROP SEQUENCE seq_name
** EXEC SQL DROP SYNONYM synonymname {, synonymname}
** EXEC SQL DROP USER user_name
-* Notes:
** The DROP SECURITY_ALARM is not very useful in ESQL programs because
** ESQL cannot obtain the alarm number from the DBMS; however, it is added here
** for SQL language completeness.
*/

drop:		dropx
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1,
				ERx("DROP") );
		}
;
dropx:		drop_key drop_tb_types schema_obj_lst sql_opt_with_clause
		{
		    if (eq->eq_flags & EQ_COMMON)
		    {
		        if ($2.s == (char *)0)
			{
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				ERx("DROP name_list"));
			}
			else if ($3.i)
			{
			    if (ESQ_EQSTR($2.s, ERx("table")))
				er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				    ERx("DROP TABLE table_name_list"));
			    else if (ESQ_EQSTR($2.s, ERx("view")))
				er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				    ERx("DROP VIEW view_name_list"));
			    else
				er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				    ERx("DROP INDEX index_name_list"));
			}
		    }
		}
	|	drop_key permit_integ sql_on dr_opt_obj drop_list
	|	drop_link sql_idlist
	|	drop_link			/* tablename is 'link' */
	|	drop_proc
	|	drop_dbevent			/* tablename is 'dbevent' */
	|	drop_role sql_user_list
	|	drop_dbevent schema_obj
	|	drop_group sql_user_list
	|	drop_rule schema_obj
	|	drop_dom sql_id
	|	drop_loc sql_id_sconst
	|	drop_usr sql_id_sconst
	|	drop_profile sql_id_sconst opt_res_cas
	|	drop_security alarm_object drop_alarm_list
	|	drop_sequence schema_obj
	|	drop_key drop_tb_types sess_id_list
	|	drop_synonym schema_obj_lst
;
drop_key:	tDROP
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
drop_tb_types:	/* Empty */
		{
		    $$.s = (char *)0;
		}
	|	tTABLE
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
	|	tVIEW
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
	|	tINDEX
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
;
drop_link:	tDROP_LINK
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("DROP LINK"));
		}
;
drop_proc:	drop_proc_key schema_obj 
		{
		    arg_int_add( IIPROC_DROP );

		    /* use first name encountered. */
		    arg_str_add( ARG_CHAR, $2.s);
		    gen_call( IIPROCINIT );
		}
		dproc_opt_sql_idlist
;
drop_proc_key:	tDROP tPROCEDURE 
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s);
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("DROP PROCEDURE"));
		}
;
/* Hack Attack!!  Allows us to get the first name in the list. */
dproc_opt_sql_idlist:	/* empty */
	|	sql_comma schema_obj_lst
;

drop_role:	tDROP_ROLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
					EQ_WARN, 1, ERx("DROP ROLE"));
		}
;
drop_group:	tDROP tGROUP
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
				EQ_WARN, 1, ERx("DROP GROUP") );
		}
;
drop_dbevent:	tDROP_DBEVENT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
					EQ_WARN, 1, ERx("DROP DBEVENT"));
		}
;
drop_sequence:	tDROP_SEQUENCE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
					EQ_WARN, 1, ERx("DROP SEQUENCE"));
		}
;
permit_integ:	tINTEGRITY
		{
		    db_key( $1.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("DROP INTEGRITY"));
		}
	|	tPERMIT
		{
		    db_key( $1.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("DROP PERMIT"));
		}
;
dr_opt_obj:	tTABLE
		{
		    db_key( $1.s );
		}
		schema_obj			/* Rule continues here */
	|	tPROCEDURE
		{
		    db_key( $1.s );
		}
		schema_obj			/* Rule continues here */
	|	tNAME 
		{
		    db_key( $1.s );
		}
		schema_obj			/* Rule continues here */
	|	/* Nothing */ schema_obj
;
drop_alarm_list: sql_all
	|	drop_alarm_spec_list
;

drop_alarm_spec_list: drop_alarm_spec
	|  drop_alarm_spec_list sql_comma drop_alarm_spec
;

drop_alarm_spec:  sql_iconst
	|	  sql_id_sconst
;
drop_list:	drop_intlist
	|	sql_all
;
drop_intlist:	sql_iconst
	|	drop_intlist sql_comma sql_iconst
;
drop_rule:	tDROP_RULE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
				EQ_WARN, 1, ERx("DROP RULE") );
		}
;	
drop_dom:	tDROP_DOM
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
				EQ_WARN, 1, ERx("DROP DOMAIN") );
		}
;	
drop_loc:	tDROP_LOCATION
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
				EQ_WARN, 1, ERx("DROP LOCATION") );
		}
;	
drop_usr:	tDROP_USER
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
				EQ_WARN, 1, ERx("DROP USER") );
		}
;	
drop_profile:	tDROP_PROFILE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
				EQ_WARN, 1, ERx("DROP PROFILE") );
		}
;	
drop_security:	tDROP_SEC_ALARM
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN,
				EQ_WARN, 1, ERx("DROP SECURITY_ALARM") );
		}
;
drop_synonym:	tDROP_SYNONYM
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
sess_id_list:	sess_id
	|	sess_id_list sql_comma sess_id
;

/*
+* EXEC SQL REVOKE 
**		[GRANT OPTION FOR]
**		ALL [PRIVILEGES]
**		|    dbpriv_list 
**		ON 
**		|    DATABASE dbname_list 
**		|    CURRENT INSTALLATION
**		|    PROCEDURE procname_list
**		|    DBEVENT eventname_list
**		|    [TABLE] tablename_list
**		from grantee_type grantee_list
**	     	     | PUBLIC
-*		[RESTRICT | CASCADE]
*/

revoke:		revoke_key opt_grant_for revoke_privs revoke_obj
		sql_from grant_whom opt_res_cas
;
revoke_key:	tREVOKE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
 		    if (eq->eq_flags & EQ_COMMON)
 			er_write( E_EQ0504_OPEN_WARN,
 				EQ_WARN, 1, ERx("REVOKE") );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("REVOKE") );
		    gr->gr_func = tREVOKE;  /* Prevent err msg in grant_whom */
		}
;
opt_grant_for:	tGRANT tNAME tFOR
		{
		    db_key( $1.s );
		    if (!ESQ_EQSTR($2.s, ERx("option")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					    ERx("REVOKE"), ERx("OPTION") );
		    db_key( ERx("option") );
		    db_key( $3.s );
		}
	|	/* Null */
;
revoke_privs:	revoke_idlist
	|	sql_all
	|	sql_all revoke_priv_word
;
revoke_priv_word:
		tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("privileges")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					    ERx("REVOKE"), ERx("PRIVILEGES") );
		    db_key( ERx("privileges") );
		}
;
revoke_idlist:	revoke_id
	|	revoke_idlist sql_comma revoke_id
;
revoke_id:	sql_id	/* rule needed to allow ADA keyword ACCESS */
	|	select_key
	|	delete_key
	|	insert_key
	|	update_key
	|	update_key sql_lparen sql_idlist sql_rparen
	|	register_key
	|	exec_key
	|	references_key sql_lparen sql_idlist sql_rparen
;
revoke_obj:	sql_on revoke_obj_name schema_obj_lst
	|	sql_on tCURRENT tNAME
		{
		    if (!ESQ_EQSTR($3.s, ERx("installation")))
		    {
			er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $2.s,
					  ERx("REVOKE"));
		    }
		    db_key( $2.s );
		    db_key( $3.s );
		}
	|	sql_on_database sql_idlist
	|	sql_on schema_obj_lst
	|	/* Empty */

;
revoke_obj_name:tNAME
		{
		    if (ESQ_EQSTR($1.s, ERx("dbevent")))
		    {
			db_key( ERx("dbevent") );
		    }
		    else if (ESQ_EQSTR($1.s, ERx("sequence")))
		    {
			db_key( ERx("sequence") );
		    }
		    else
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					    ERx("REVOKE"), ERx("DATABASE") );
		        db_key( ERx("database") );
		    }
		}
	|	tPROCEDURE
		{
		    db_key( $1.s );
		}
	|	tTABLE
		{
		    db_key( $1.s );
		}
;
opt_res_cas:	res_cas
	|	/* Null */
;
res_cas:	tRESTRICT
		{
		    db_key( $1.s );
		}
	|	tCASCADE
		{
		    db_key( $1.s );
		}
;

/*
+* EXEC SQL SAVEPOINT {name | number}
*/

savepoint:	savept_key sql_id_iconst
;
savept_key:	tSAVEPOINT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("SAVEPOINT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("SAVEPOINT") );
		}
;

/* 
+* EXEC SQL BEGIN TRANSACTION
*/

begin_xact:	tBEG_XACT
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    er_write( E_EQ0135_sqXACT, EQ_WARN, 1, $1.s );
		    esq_init();
		    arg_int_add( IIxactBEGIN );		/* Begin transaction */
		    gen_call( IIXACT );
		    gr->gr_flag |= GR_NOSYNC;	   /* No IIsync after this */
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("BEGIN TRANSACTION"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("BEGIN TRANSACTION") );
		}
;

/*
+* EXEC SQL COPY TABLE [owner.]name ( copy-format-list ) {FROM | INTO}
**	file | PROGRAM [WITH with_clause]
-* Well, the TABLE keyword should be optional, but it conflicts with
** COPY SQLERROR.  This would be a bear to workaround, and as COPY SQLERROR
** will be going away, and we always used to require TABLE, we won't make
** it optional until COPY SQLERROR is buried.
*/

copy:		copytab_key owner_tbl sql_lparen copy_tl sql_rparen copy_dir
		copy_loc sql_opt_with_clause
;
copytab_key:	tCOPY tTABLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("COPY TABLE") );
		}
;
owner_tbl:	schema_obj
	|	sess_id
;
copy_tl:	copy_tl1
	|	/* No format list */
;
copy_tl1:	copy_elm
	|	copy_tl sql_comma copy_elm
;
copy_elm:	sql_id sql_eq copy_id copy_with
;						/* Examples:		   */
copy_id:	sql_name			/* c0			   */
	|	sql_sconst			/* "c0Z"		   */
	|	copy_parens			/* text(0) or decimal(5,2) */
	|	copy_parens sql_id		/* text(0)nl		   */
	|	copy_parens sql_sconst		/* text(0)"Z"		   */
	|	copy_parens sql_null		/* text(0)null		   */
	|	sql_name sql_name		/* long byte		   */
	|	sql_name copy_parens		/* long varchar(0)	   */
	|	sql_name copy_parens sql_id	/* byte varying(5)nl	   */
;
copy_parens:	sql_name tLPAREN tINTCONST tRPAREN
		{
		    db_op( $2.s );
		    db_key( $3.s );
		    db_op( $4.s );
		}
	|	sql_name tLPAREN tINTCONST tCOMMA tINTCONST tRPAREN
		{
		    db_op( $2.s );
		    db_key( $3.s );
		    db_op( $4.s );
		    db_key( $5.s );
		    db_op( $6.s );
		}
;
copy_with:	/* EMPTY */
	|	sql_with sql_null sql_lparen copy_const sql_rparen
	|	sql_with sql_null
;
copy_const:	constant
	|	sql_minus constant
	|	sql_plus constant
;
copy_dir:	tINTO
		{
		    db_key( $1.s );
		}
	|	tFROM
		{
		    db_key( $1.s );
		}
;
copy_loc:	sql_sconst
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			db_var( DB_STRING, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
			if (gr->gr_type != T_CHAR && gr->gr_type != T_UNDEF)
			    er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else	/* Error caught in host_setvar */
			db_sconst( gr->gr_id );
		}
	|	tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("program")))
		    {
			er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $1.s,
					    ERx("COPY") );
			db_sconst( $1.s );
		    }
		    else
		    {
			db_key( $1.s );
			gr->gr_flag |= GR_COPY_PROG;
		    }
		}
;

/* 
+* EXEC SQL END TRANSACTION 
-*
** For upward compatibilty, flag to run-time that a transaction is being
** closed (in order to close all cursors)
*/

end_xact:	tEND_XACT
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    er_write( E_EQ0135_sqXACT, EQ_WARN, 1, $1.s );
		    esq_init();
		    arg_int_add( IIxactCOMMIT );	/* Close transaction */
		    gen_call( IIXACT );
		    gr->gr_flag |= GR_NOSYNC;	   /* No IIsync after this */
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("END TRANSACTION"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				EQ_WARN, 1, ERx("END TRANSACTION") );
		}
;

/*
+* Statement:	EXEC SQL GRANT
**		    ALL [PRIVILEGES]
**		    |	EXECUTE|DELETE|INSERT[(col_list)]|SELECT
**			    |UPDATE([col-list)|REGISTER|RAISE|db_priv]
**			      {,EXECUTE|DELETE|INSERT[col_list)]|SELECT
**			    |UPDATE([col-list)]|REGISTER|RAISE|db_priv}
**		    |   REFERENCES(col-list)
**		    ON 
**	 	    |	[TABLE|PROCEDURE|APPLICATION|LOCATION|DBEVENT|DATABASE] 
**			    objname {, objname}
**		    |   CURRENT INSTALLATION
**		    TO  
**		    |   [USER] <username {, username}>
**		    |   GROUP <grant_id {, grant_id}>
**		    |   ROLE <role_id {, role_id}>
**		    |   PUBLIC
**		    [WITH with_clause]
-* Action:
** Generates:
*/

grant:		grant_key grant_privs grant_object sql_to grant_whom
		sql_opt_with_clause
;
grant_key:	tGRANT
		{
		    if (esq->flag & ESQ_CRE_SCHEMA)	/* in CREATE SCHEMA */
			db_key( $1.s );
		    else
		    {
		        gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
 		        if (eq->eq_flags & EQ_COMMON)
 			    er_write( E_EQ0504_OPEN_WARN, 
 					EQ_WARN, 1, ERx("GRANT"));
		    }
		}
;
grant_privs:	sql_all
		{
		    if (eq->eq_flags & EQ_FIPS) 
			er_write( E_EQ0507_FIPS_NOTOP, EQ_WARN,
				2, ERx("PRIVILEGES"), ERx("GRANT") );
		}
	|	sql_all grant_priv_word
	|	grant_privlist
;
grant_privlist:	grant_priv_type
	|	grant_privlist sql_comma grant_priv_type
;
grant_priv_type:delete_key
	|	insert_key
	|	insert_key sql_lparen sql_idlist sql_rparen
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, ERx("INSERT"), ERx("GRANT") );
		    }
		}
	|	select_key
	|	exec_key
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, ERx("EXECUTE"), ERx("GRANT") );
		    }
		}
	|	register_key
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, ERx("REGISTER"), ERx("GRANT") );
		    }
		}
	|	update_key
	|	update_key sql_opt_excl sql_lparen sql_idlist sql_rparen
	|	sql_id	/* Non-keyword table/db privileges */
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, $1.s, ERx("GRANT") );
		    }
		}
	|	sql_id sql_iconst
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, $1.s, ERx("GRANT") );
		    }
		}
	|	references_key sql_opt_excl sql_lparen sql_idlist sql_rparen
	|	references_key
;
grant_priv_word:
		tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("privileges")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					    ERx("GRANT"), ERx("PRIVILEGES") );
		    db_key( ERx("privileges") );
		}
;

sql_opt_excl:   /* Empty */
        |       tEXCLUDING
                {
                    db_key( $1.s );
                }
;
delete_key:	tDELETE
		{
		    db_key( $1.s );
		}
;
insert_key:	tINSERT
		{
		    db_key( $1.s );
		}
;
select_key:	tSELECT
		{
		    db_key( $1.s );
		}
;
exec_key:	tEXECUTE
		{
		    db_key( $1.s );
		}
;
register_key:	tREGISTER
		{
		    db_key( $1.s );
		}
;
grant_object:	sql_on schema_obj_lst
		{
		    if (eq->eq_flags & EQ_FIPS && $2.i == 1)
		    {
			/* List of tables is non-FIPS */
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
			    2, ERx("ON <table_list>"), ERx("GRANT/CREATE SECURITY_ALARM") );
		    }
		}
	|	sql_on_database schema_obj_lst
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			/* FIPS allows ON to be followed only by <tablename> */
			STprintf( esq->sbuf, ERx("%s %s"), ERx("ON"), $2.s );
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, esq->sbuf, ERx("GRANT/CREATE SECURITY_ALARM") );
		    }
		}
	|	sql_on grant_obj_name schema_obj_lst
		{
		}
	|	sql_on tCURRENT tNAME
		{
		    db_key( $2.s );
		    db_key( $3.s );
		    if (!ESQ_EQSTR($3.s, ERx("installation")))
		    {
			er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $3.s,
				ERx("GRANT"));
		    }
		    /* ON CURRENT INSTALLATION is non-FIPS */
		    else if (eq->eq_flags & EQ_FIPS)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2,
				ERx("ON CURRENT INSTALLATION"), ERx("GRANT/CREATE SECURITY_ALARM") );
		    }
		}
	|
		/* Empty for role grants */
;
grant_obj_name: tTABLE
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
	|	tPROCEDURE
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
	|	tNAME
		{
		    db_key( $1.s );
		    $$.s = $1.s;
		}
;
grant_whom:	sql_id sql_user_list
		{
		    if (eq->eq_flags & EQ_FIPS && gr->gr_func != tREVOKE)
		    {
			/* TO ROLE is non-FIPS */
			STprintf( esq->sbuf, ERx("%s %s"), ERx("TO"),
				$1.s );
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, esq->sbuf, ERx("GRANT") );
		    }
		}
	|	user_key sql_user_list
		{
		    if (eq->eq_flags & EQ_FIPS && gr->gr_func != tREVOKE)
		    {
			/* TO USER is non-FIPS */
			STprintf( esq->sbuf, ERx("%s %s"), ERx("TO"),
				$1.s );
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, esq->sbuf, ERx("GRANT") );
		    }
		}
	|	sql_public
	|	sql_group sql_user_list
		{
		    /* TO GROUP is non-FIPS */
		    if (eq->eq_flags & EQ_FIPS && gr->gr_func != tREVOKE)
			er_write( E_EQ0506_FIPS_CLAUSE,
				EQ_WARN, 2, ERx("TO GROUP"), ERx("GRANT") );
		}
	|	sql_user_list
		{
		    if (   eq->eq_flags & EQ_FIPS
			&& ESQ_EQSTR($1.s, ERx(","))	/* A list */
			&& gr->gr_func != tREVOKE)
		    {
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, ERx("TO <user_list>"),  ERx("GRANT") );
		    }
		}
;

/*
+* EXEC SQL HELP [ALL | [INTEGRITY|PERMIT|VIEW] table-list]
-* As of 6.0, all help statements are unsupported.
*/

help:		help_x
		{
		    er_write( E_EQ0076_grNOWUNSUPP, EQ_ERROR, 1, $1.s );
		}
;
help_x:		help_key	
	|	help_all
	|	help_key sql_idlist
	|	help_dblkey sql_idlist
;
help_key:	tHELP 
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
help_dblkey:	help_doublekey 
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
help_doublekey: tHLP_INTEGRITY
	|	tHLP_PERMIT
	|	tHLP_VIEW
;
help_all:	tHLP_ALL
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;

/*
+* EXEC SQL MODIFY [TABLE] [location:]table TO structure [UNIQUE] 
**	    [ON name-list] [WHERE|WITH density-list]
** EXEC SQL MODIFY [TABLE] [location:]table TO PRIORITY = <cache_priority>
*- EXEC SQL MODIFY [TABLE] [location:]table WITH With_Clause
*/

modify:		modify_key loc_tblname mod_opt_part sql_opt_to mod_type
		sql_opt_unique mod_keys mod_qual
	|	modify_key loc_tblname sql_with_clause
;
modify_key:	tMODIFY modify_table
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("MODIFY"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
				  EQ_WARN, 1, ERx("MODIFY") );
		}
;
modify_table:	tTABLE
	|	/* EMPTY */
;
/* optional PARTITION t.p.p. ... */
mod_opt_part:	/* empty */
	|	sql_partition sql_partition_path
;
/* Partition path is table.partition. ... */
sql_partition_path: sql_id
	|	sql_partition_path sql_dot sql_id
;

mod_type:	sql_id mod_opt_n
	|	tRELOCATE
		{
		    db_key( $1.s );
		}
	|	sql_encrypt
;
/* Hack so that "mod_type" can parse PRIORITY=n */
mod_opt_n:	/* empty */
	|	sql_eq sql_iconst
	|	sql_eq tNAME
;
mod_keys:	sql_on mod_keylist
	|	/* EMPTY */
;
mod_keylist:	modkey
	|	mod_keylist sql_comma modkey
;
modkey:		sql_id sql_order_opt_sort
;
mod_qual:	sql_where sql_with_list
	|	sql_with sql_with_list
	|	/* EMPTY */
;

/*
+* EXEC SQL PREPARE TO COMMIT 
-*	WITH HIGHDXID=int_val|:int_var, LOWDXID=int_val|:int_var;
** Action:	Allows an application to behave as coordinator in
**		committing a distributed transaction.
** Generates:	IIsqInit( &sqlca );
**		IIsqtpc( highdxid, lowdxid );
** Notes:	The application program supplies the unique transaction id.
*/
pre_commit:	pre_head tNAME tEQOP pre_id tCOMMA tNAME tEQOP pre_id
		{
		    gen_call( IISQTPC );
		    gr->gr_flag |= GR_NOSYNC;	   /* No IIsync after this */
		    if (!ESQ_EQSTR($2.s, ERx("highdxid")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
				    ERx("PREPARE TO COMMIT"), ERx("HIGHDXID") );
		    if (!ESQ_EQSTR($6.s, ERx("lowdxid")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $6.s,
				    ERx("PREPARE TO COMMIT"), ERx("LOWDXID") );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 
				1, ERx("PREPARE TO COMMIT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("PREPARE TO COMMIT"));
		}
;
pre_head:	tPREPARE tTO tCOMMIT tWITH
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		}
;
pre_id:		tINTCONST
		{
		    arg_str_add( ARG_INT, $1.s );
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_INT)
			{
			    arg_var_add( gr->gr_sym, gr->gr_id );
			}
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
				    gr->gr_id );
			    arg_int_add(0);
			}
		    }
		    else	/* Error in host_setvar */
		    {
			arg_int_add(0);
		    }
		}
;

;
/*
+* EXEC SQL PRINT table-list - Undocumented, but useful
-* As of 6.0, all print statements are unsupported.
*/

print:		print_key sql_idlist 
		{
		    er_write( E_EQ0076_grNOWUNSUPP, EQ_ERROR, 1, $1.s );
		}
;
print_key:	tPRINT
		{ 
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;

/*
+* Statement:	RAISE DBEVENT [event_owner.]event_name [event_text]
-*		    [WITH [NO]SHARE];
*/
raise_dbevent:	raise_evt_key owner_tbl event_text sql_opt_with_clause
		{
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("RAISE DBEVENT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("RAISE DBEVENT") );
		}	
;
raise_evt_key:	tRAISE_DBEVENT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
;
event_text:	/* No text */
	|	sql_sconst	
	|	host_setvar	/* Always as a string */
		{
		    if (gr->gr_sym)
		    {
			db_var( DB_STRING, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
			if (gr->gr_type != T_INT && gr->gr_type != T_CHAR &&
							gr->gr_type != T_UNDEF)
			    er_write( E_EQ0060_grINTSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else	/* Error already from host_setvar */
			db_key( gr->gr_id );
		}
;

/*
+* Statement:	EXEC SQL REGISTER [TABLE|VIEW|PROCEDURE] name
**		    [(col_name [format [IS 'ext_format']]
**		    {,col_name [format [IS 'ext_format']]})]
**		    AS LINK|IMPORT
**		    [FROM [owner.]source]
**		    [WITH with_clause]
**
** Statement:	EXEC SQL REGISTER [UNIQUE] INDEX indexname ON tablename 
**		    [(col_name [ASC|DESC] {, col_name [ASC|DESC]})]
**		    AS LINK|IMPORT
**		    [FROM [owner.]source]
**		    [WITH with_clause]
-*
** Notes:
** 1) These statements create an INGRES STAR link or import a
**	non-SQL gateway data object.
** 2) LINK/IMPORT are not reserved words.
** 3) The col_name clause, FROM source clause and WITH clause are 
**	mandatory on the REGISTER .. AS IMPORT commands but 
**	optional on the REGISTER .. AS LINK commands.  We leave it to 
**	the DBMS to enforce the syntax.
**
+* Statement:	EXEC SQL REGISTER DBEVENT [event_owner.]event_name;
-*
*/	

register:	reg_head schema_obj reg_opt_cols reg_as reg_opt_from 
		sql_opt_with_clause
;
reg_head:	tREGISTER reg_obj
		{
		    if ($2.s != (char *)0)
			gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    else
			gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("REGISTER") );
		}
;
reg_obj:	/* Empty */
		{
		    $$.s = (char *)0;
		}
	|	tTABLE
		{
		    $$.s = $1.s;
		}
	|	tPROCEDURE
		{
		    $$.s = $1.s;
		}
	|	tVIEW
		{
		    $$.s = $1.s;
		}
;
reg_opt_cols:	/* Empty */
	|	sql_lparen reg_col_list sql_rparen
		{
		    if (eq->eq_flags & EQ_COMMON)
		    {
			if ($2.i & CRE_TBLKEY)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				ERx("REGISTER ... TABLE_KEY"));
			else if ($2.i & CRE_OBJKEY)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
				ERx("REGISTER ... OBJECT_KEY"));
			else if ($2.i)
			    er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
			    	ERx("REGISTER ... DEFAULT/SYSTEM_MAINTAINED"));
		    }	
		}
;
reg_col_list:	reg_col_spec
		{
		    $$.i = $1.i;
		}
	|	reg_col_list sql_comma reg_col_spec
		{
		    $$.i = $1.i | $3.i;
		}
;
reg_col_spec:	reg_xcol_spec			/* REGISTER .. AS IMPORT */
		{
		    $$.i = $1.i;
		}
	|	reg_xcol_spec sql_is sql_sconst /* REGISTER .. AS IMPORT */
		{
		    $$.i = $1.i;
		}
	|	sql_id				/* REGISTER .. AS LINK */
;
reg_xcol_spec:	crcol_spec
		{
		    $$.i = $1.i;
		}
;
reg_as:		sql_as tNAME
		{
		    if (ESQ_EQSTR($2.s, ERx("import")))
		    {
			db_key( ERx("import") );
		    }
		    else
		    {
			db_key( ERx("link") );
		        if (!ESQ_EQSTR($2.s, ERx("link")))
		        {
			    er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					ERx("REGISTER"), ERx("LINK") );
			}
		    }
		}
;
reg_opt_from:	/* Empty */
	|	sql_from reg_owner_tbl
;

reg_owner_tbl:	schema_obj
	|	sql_id sql_dot sql_sconst
	|	sql_sconst
	|	sql_sconst sql_dot sql_sconst
	|	sql_sconst sql_dot sql_id
;

register_ind:	reg_ind_head sql_id sql_on sql_id reg_ind_opt_cols
		reg_as reg_opt_from sql_opt_with_clause
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("REGISTER INDEX") );
		}
;
reg_ind_head: 	tREGISTER tUNIQUE tINDEX
		{
		    STprintf( esq->sbuf, ERx("%s %s"), $1.s, $2.s );
		    gr_mechanism( GR_EQSTMT, GR_sSQL, esq->sbuf, $3.s );
		}
	|	tREGISTER tINDEX
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		}
;
reg_ind_opt_cols: /* Empty */
	|	sql_lparen reg_ind_col_list sql_rparen
;
reg_ind_col_list:sql_id sql_order_opt_sort
	|	reg_ind_col_list sql_comma sql_id sql_order_opt_sort
;

register_dbevent: reg_evt_key owner_tbl
;
reg_evt_key:	tREG_DBEVENT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("REGISTER DBEVENT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("REGISTER DBEVENT") );
		}
;

/*
+* EXEC SQL RELOCATE table TO place
*/

relocate:	relocate_key sql_id sql_to sql_id
;
relocate_key:	tRELOCATE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("RELOCATE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("RELOCATE"));
		}
;

/*
+* EXEC SQL REMOVE [TABLE|VIEW|INDEX|PROCEDURE|DBEVENT] objname
*/

remove:		remove_hdr owner_tbl
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT,
					EQ_WARN, 1, ERx("REMOVE"));
		}
;
remove_hdr:	tREMOVE remove_obj
		{
		    if ($2.s != (char *)0)
			gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    else
			gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
	|	tREM_DBEVENT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("REMOVE DBEVENT"));
		}
;
remove_obj:	/* Empty */
		{
		    $$.s = (char *)0;
		}
	|	tTABLE
		{
		    $$.s = $1.s;
		}
	|	tVIEW
		{
		    $$.s = $1.s;
		}
	|	tINDEX
		{
		    $$.s = $1.s;
		}
	|	tPROCEDURE
		{
		    $$.s = $1.s;
		}
;

/*
+* EXEC SQL RENAME [TABLE] objname TO newname
*/
rename_tbl:    ren_tbl_key owner_tbl ren_tbl_options
                {
                    if (eq->eq_flags & EQ_COMMON)
                        er_write( E_EQ0504_OPEN_WARN,
                                    EQ_WARN, 1, ERx("RENAME TABLE"));
                    if (eq->eq_flags & EQ_FIPS)
                        er_write( E_EQ0505_FIPS_STATMT,
                                        EQ_WARN, 1, ERx("RENAME TABLE"));
                }
;
ren_tbl_key:    tRENAME
		{
                    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		}
	|	tREN_TABLE
                {
                    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
                }
;
ren_tbl_options: 	ren_to owner_tbl 
;
/*
+* EXEC SQL ROLLBACK [WORK] [TO savepointname | integer]
*/

rollback:	tROLLBACK
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		    arg_int_add( IIxactABORT );		/* Close transaction */
		    gen_call( IIXACT );
		    gr->gr_flag |= GR_NOSYNC;	   /* No IIsync after this */
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0507_FIPS_NOTOP, EQ_WARN, 2,
			    		ERx("WORK"), ERx("ROLLBACK") );
		}
	|	tROLLBACK tNAME
		{
		    if (!ESQ_EQSTR($2.s, ERx("work")))
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					    ERx("ROLLBACK WORK"), ERx("WORK") );
			$2.s = ERx("work");
		    }
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, $2.s );
		    esq_init();
		    arg_int_add( IIxactABORT );		/* Close transaction */
		    gen_call( IIXACT );
		    gr->gr_flag |= GR_NOSYNC;	   /* No IIsync after this */
		}
	|	tROLLBACK tTO
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    db_key( $2.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 
				1, ERx("ROLLBACK TO SAVEPOINT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0507_FIPS_NOTOP, EQ_WARN, 2,
			    		ERx("WORK"), ERx("ROLLBACK") );
		}
		sql_id_iconst
	|	tROLLBACK tNAME tTO
		{
		    if (!ESQ_EQSTR($2.s, ERx("work")))
		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					ERx("ROLLBACK WORK TO"), ERx("WORK") );
			$2.s = ERx("work");
		    }
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    db_key( $3.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1, 
				ERx("ROLLBACK WORK TO SAVEPOINT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				2, ERx("TO SAVEPOINT"), ERx("ROLLBACK") );
		}
		sql_id_iconst
;

/*
+* EXEC SQL SAVE table [UNTIL name|number number number]
*/

save:		save_key sql_id save_until save_date
	|	save_key sql_id
;
save_key:	tSAVE
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("SAVE"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("SAVE") );
		}
;
save_until:	tUNTIL
		{
		    db_key( $1.s );
		}
;
save_date:	save_month sql_iconst sql_iconst
;
save_month:	tNAME
		{
		    db_key( $1.s );
		}
;

/*
+* EXEC SQL SET JOURNALING [ON table]
** EXEC SQL SET name [ string | int | [ON] name [WHERE|WITH set-qualification] ]
** EXEC SQL SET SESSION WITH ON_ERROR = ROLLBACK STATEMENT|TRANSACTION;
** EXEC SQL SET SESSION WITH ON_LOGFULL = ABORT|COMMIT|NOTIFY;
** EXEC SQL SET AUTOCOMMIT ON | OFF
** EXEC SQL SET TRACE POINT x [num [num]]
** EXEC SQL SET WORK LOCATIONS ADD  (location {, location})
**			     | DROP (location {, location})
**			     | USE  (location {, location})
** EXEC SQL SET SESSION AUTHORIZATION user_id | SESSION_USER | SYSTEM_USER
**				| CURRENT_USER | INITIAL_USER | USER
**				| host_variable
**				| string_constant
** EXEC SQL SET GROUP groupid | SESSION GROUP
** EXEC SQL SET NOGROUP
** EXEC SQL SET ROLE roleid [ WITH PASSWORD='pwd']
** EXEC SQL SET TRANSACTION ISOLATION LEVEL <isolation level>
**			  | <access mode>

-*
** In order not to reserve JOURNALING and AUTOCOMMIT, and in order to allow
** new SET statements to be easily added, we actually allow
**	EXEC SQL SET name
**		[ON] name [WHERE|WITH set-qualification]
**	|	ON
**      |       GROUP name
**      |       GROUP SESSION name
**	|	string
**	|	int
**	|	name name (set trace point)
**	|	name SESSION name
**	|	LOCATIONS ADD|DROP|name (location-list) 
**	|	WHERE|WITH set-qualification
**	|	-- EMPTY
*/

set:		set_key sql_name 
		{
		    /*
		    ** Check for SET ROLE, we need to handle
		    ** the WITH PASSWORD clause carefully.
		    */
		    if (ESQ_EQSTR($2.s, ERx("role")))
		    	set_role=TRUE;
		    else
		    	set_role=FALSE;
		}
		set_specs
		{
		    if (eq->eq_flags & EQ_COMMON)
		    {
			/*
			** We're flaggin non open/sql statements (-wopen)
			** Check for AUTOCOMMIT.  Flag all others.
			*/
		    	if (!ESQ_EQSTR($3.s, ERx("autocommit")))
			{
			   STprintf( esq->sbuf, ERx("%s %s"), ERx("SET"), $3.s);
			   er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, esq->sbuf );
			}
		    }
		}
        |       set_key sql_group sql_id
                {
                /* SET GROUP groupid */
                   if (eq->eq_flags & EQ_COMMON)
                   {
                       er_write( E_EQ0504_OPEN_WARN,
                                   EQ_WARN, 1, ERx("SET [NO]GROUP"));
                   }
                }
        |       set_key sql_group session_key sql_group
                {
                /* SET GROUP SESSION GROUP  */
                   if (eq->eq_flags & EQ_COMMON)
                   {
                       er_write( E_EQ0504_OPEN_WARN,
                                   EQ_WARN, 1, ERx("SET [NO]GROUP"));
                   }
                }
	|	set_key	session_key set_sess_specs
                {
		    if (eq->eq_flags & EQ_COMMON)
                    {
                        er_write( E_EQ0504_OPEN_WARN,
                                        EQ_WARN, 1, ERx("SET SESSION"));
                    }
                }

;
set_key:	tSET 
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    gr->gr_func = tSET;
                    if (eq->eq_flags & EQ_FIPS)
                        er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
                                        1, ERx("SET") );
		    set_role=FALSE;
		}
;

/* For SET SESSION:
**	SET SESSION AUTHORIZATION user_spec
**	SET SESSION 
**		[ ADD/DROP PRIVILEGES ()] 
**              [,READ ONLY / READ WRITE]
**              [,ISOLATION LEVEL isolation_level]
**              [WITH 
**                  [PRIVILEGES = ( priv {,priv} ) | ALL | DEFAULT ]
**	            [, NOPRIVILEGE] 
**                  [, ON_ERROR=ROLLBACK TRANSACTION|STATEMENT]
**                  [, ON_LOGFULL=ABORT|COMMIT|NOTIFY]
**	            [, SECURITY_LABEL=INITIAL_LABEL | 'security_label']
**	            [, NODESCRIPTION | DESCRIPTION = 'description']
**
** This differs from the basic set_specs in that a string variable in whval
** is sent as as string constant rather than as a value. The main use of
** this is to allow a security label  to be passed in a variable.
**
** Notice that the second form here ends up allowing <empty> ...
*/
set_sess_specs: authorization_key user_spec
	|	set_sess_opts set_sess_where
	;

set_sess_opts:	set_sess_opt
	|	set_sess_opt sql_comma set_sess_opt
	|       /* nothing */
	;

set_sess_opt:	 sql_add set_sess_priv_word sql_lparen sql_with_idlist sql_rparen
	| sql_drop set_sess_priv_word sql_lparen sql_with_idlist sql_rparen
	| set_trans_iso
	| set_access_mode
	| sql_name
	;

set_sess_priv_word: tNAME 
		{
		    if (!ESQ_EQSTR($1.s, ERx("privileges")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					    ERx("SET SESSION"), ERx("PRIVILEGES") );
		    db_key( ERx("privileges") );
		}
		;

set_sess_where:	sql_where set_sess_whlist
	|	sql_with set_sess_whlist
	|       /* Nothing */
;
set_sess_whlist:	set_sess_whelm
	|	set_sess_whlist sql_comma set_sess_whelm
	;

set_sess_whelm:	sql_name sql_eq set_sess_whval
	|	sql_name
	;

set_sess_whval:	
	|	tROLLBACK tNAME		
		{
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	sql_sconst
	|	sql_iconst
	|	sql_minus sql_iconst			%Prec tUNARYOP
	|	sql_all
	|	tDEFAULT
		{
			db_key ($1.s);
		}
	|	tNAME
		{
			db_key ($1.s);
		}
	|	tCOMMIT
		{
			db_key ($1.s);
		}
	|	tABORT
		{
			db_key ($1.s);
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			db_var( DB_STRING, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
			if (gr->gr_type != T_INT && gr->gr_type != T_CHAR &&
							gr->gr_type != T_UNDEF)
			    er_write( E_EQ0064_grQRSTRVAR, EQ_ERROR, 1,
						    gr->gr_id );
		    }
		    else	/* Error already from host_setvar */
			db_key( gr->gr_id );
		}
	|	sql_lparen sql_with_idlist sql_rparen
	;
	
set_access_mode: tREAD_ONLY
		{
		    db_key( $1.s );
		}
	|	tREAD_WRITE
		{
		    db_key( $1.s );
		}
	;

set_specs:	/* No set arguments */
	|	sql_on
	|	sql_on schema_obj set_opt_where
	|	sql_name_or_delim set_opt_where /* SET ROLE roleid */
	|	sql_trace_point
 	|	sql_joinop_nnn
	|	set_where
	|	sql_name set_work_opt sql_lparen sql_user_list sql_rparen
		{
		    /* Expecting SET WORK LOCATIONS command */		
		    if (!ESQ_EQSTR($1.s, ERx("locations")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					ERx("SET WORK"), ERx("LOCATIONS") );
		}
	|	tSCONST
		{ 
		    db_sconst( $1.s );
		}
	|	tINTCONST
		{ 
		    db_key( $1.s );
		}
	|	session_key sql_name /* (SET ROLE) SESSION ROLE */
	|	session_key set_opt_where /* (SET LOCKMODE) SESSION ... */
;
sql_trace_point: sql_name sql_name  
	| sql_name sql_name sql_id_ivar
	| sql_name sql_name sql_id_ivar sql_id_ivar
;
sql_joinop_nnn: sql_name sql_iconst
;
user_spec:	sql_id
	|	all_user_keys
	|	sql_sconst
	|	host_insvar
		{
		    erec_use( IISETDOM, gr->gr_flag & GR_REPEAT, ERx(",") );
		    erec_setup( 1 );
		}
;
set_opt_where:	/* No WHERE clause */
	|	set_where
;
set_where: 	sql_where set_whlist
	|	sql_with set_whlist
;
set_whlist:	set_whelm
	|	set_whlist sql_comma set_whelm
;
set_whelm:	sql_name sql_eq set_whval
;
set_whval:	sql_id_ivar
	|	session_key		/* for SET LOCKMODE */
	|	tROW
		{
		    db_key( $1.s );
		}
	|	tTABLE
		{
		    db_key( $1.s );
		}
	|	sql_sconst
	;

set_work_opt:	sql_add
	|	sql_drop
	|	sql_id		/* allow USE */
;
user_key:	tUSER
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
			db_key( $1.s );
		}
;
all_user_keys:	user_key
	|	tSYSTEM_USER
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
			db_key( $1.s );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ050F_FIPS_USE, EQ_WARN, 1,
					ERx($1.s) );
		}
	|	tSESSION_USER
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
			db_key( $1.s );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ050F_FIPS_USE, EQ_WARN, 1,
					ERx($1.s) );
		}
	|	tCURRENT_USER
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
			db_key( $1.s );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ050F_FIPS_USE, EQ_WARN, 1,
					ERx($1.s) );
		}
	|	ing_user
		{
                    /* Don't print if in DECLARE TABLE statement */
                    if ((esq->flag & ESQ_NOPRT) == 0)
                        db_key( $1.s );
		}
;
ing_user:	tINITIAL_USER
		{
		    $$.s = $1.s;
                    if (eq->eq_flags & EQ_FIPS)
                        er_write( E_EQ050F_FIPS_USE, EQ_WARN, 1, $1.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0510_OPEN_FUNC, EQ_WARN, 1, $1.s );
		}
	|	ing_id
		/* add for ($ingres|$dba).objectname       b57353tt */
		/* the only difference between ing_id		    */
		/* and ing_id_dbkey is the passing of               */
		/* $dba|$ingres to the buffer  			    */
;
ing_id:         tDOLLAR tNAME
		{
		    char   nbuf[50];

		    nbuf[0] = '$';
		    nbuf[1] = EOS;
		    $$.s = str_add( STRNULL, STcat(nbuf, $2.s) );

		    if ( (!ESQ_EQSTR($2.s, ERx("dba"))) &&
			 (!ESQ_EQSTR($2.s, ERx("ingres")))
		       )
                    {
                        er_write(  E_EQ0066_grSTR, EQ_ERROR, 1, $$.s);
                    }
                    if (eq->eq_flags & EQ_FIPS)
                        er_write( E_EQ050F_FIPS_USE, EQ_WARN, 1, $$.s );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0510_OPEN_FUNC, EQ_WARN, 1, $$.s );
		}
;
ing_id_dbkey:   ing_id
		{
		    db_key( $1.s ); 
		    $$.s = $1.s;
		}
;


/*
+* EXEC SQL SET TRANSACTION:
**	SET TRANSACTION ISOLATION LEVEL <isolation level>
**		      | <access mode>
-*
*/
set_trans:	trans_key set_trans_specs
;

set_trans_specs: set_trans_spec
	|	 set_trans_spec sql_comma set_trans_spec
;

set_trans_spec: set_trans_iso
	|	set_access_mode
;

set_trans_iso:	iso_key set_trans_iso_level
;

set_trans_iso_level: tREPEATABLE tREAD
		{
		    db_key($1.s);
		    db_key($2.s);
		}
	|	tREAD tUNCOMMITTED
		{
		    db_key($1.s);
		    db_key($2.s);
		}
	|	tREAD tCOMMITTED
		{
		    db_key($1.s);
		    db_key($2.s);
		}
	|	tSERIALIZABLE
		{
		    db_key($1.s);
		}
;

trans_key:	tSET_TRANS
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    gr->gr_func = tSET;
		}
;
iso_key:	tISO_LEVEL
		{
		    db_key($1.s);
		}
;

/* 
+* ---- SQL Utility Rules ----
-*
**	All rules must begin with 'sql_' 
*/

/* SQL single token utility productions and punctuation */

sql_add:	tADD
		{
		    db_key( $1.s );
		}
;
sql_all:	tALL
		{
		    db_key( $1.s );
		}
;
sql_and:	tAND
		{
		    db_key( $1.s );
		}
;
sql_as:		tAS
		{
		    db_key( $1.s );
		}
;
sql_opt_as:	/* Empty */
	|	tAS
		{
		    db_key( $1.s );
		}
;
sql_between:	tBETWEEN
		{
		    db_key( $1.s );
		}
;
sql_asymmetric:	tASYMMETRIC
		{
		    db_key( $1.s );
		}
;
sql_symmetric:	tSYMMETRIC
		{
		    db_key( $1.s );
		}
;
sql_beginning:	tBEGINNING
		{
		    db_key( $1.s );
		}
;
sql_by:		tBY
		{
		    db_key( $1.s );
		}
;
sql_cache:	tCACHE
		{
		    db_key( $1.s );
		}
;
sql_case:	tCASE 
		{
		    db_key( $1.s );
		}
;
sql_if:		tIF 
		{
		    db_key( $1.s );
		}
;
sql_comma:	tCOMMA
		{
		    db_op(ERx(", "));	/* Need a space for run-time */
		}
;
sql_concat:	tCONCAT 
		{
		    db_op( $1.s );
		}
;
sql_colon:	tCOLON
		{
		    db_op( $1.s );
		}
;
sql_containing:	tCONTAINING
		{
		    db_key( $1.s );
		}
;
sql_cycle:	tCYCLE
		{
		    db_key( $1.s );
		}
;
sql_currval:	tCURRVAL
		{
		if ((esq->flag & ESQ_NOPRT) == 0)
		    db_key( $1.s );
		}
;
sql_default:	tDEFAULT
		{
		    db_key( $1.s );
		}
;
sql_dot:	tPERIOD
		{
		if ((esq->flag & ESQ_NOPRT) == 0)
		    db_op( $1.s );
		}
;
sql_drop:	tDROP
		{
		    db_key( $1.s );
		}
;
sql_else:	tELSE 
		{
		    db_key( $1.s );
		}
;
sql_end:	tEND  
		{
		    db_key( $1.s );
		}
;
sql_ending:	tENDING
		{
		    db_key( $1.s );
		}
;
sql_eq:		tEQOP
		{
		    db_op( $1.s );
		}
;
sql_escape:	tESCAPE
		{
		    db_key( $1.s );
		}
;
sql_exists:	tEXISTS
		{
		    db_key( $1.s );
		}
;
sql_exp:	tEXP 
		{
		    db_op( $1.s );
		}
;
sql_fetch:	tFETCH
		{
		    db_key( $1.s );
		}
;
sql_for:	tFOR
		{
		if ((esq->flag & ESQ_NOPRT) == 0)
		    db_key( $1.s );
		}
;
sql_from:	tFROM
		{
		    db_key( $1.s );
		}
;
sql_generated:	tGENERATED
		{
		    db_key( $1.s );
		}
;
sql_group:	tGROUP
		{
		    db_key( $1.s );
		}
;
sql_having:	tHAVING
		{
		    db_key( $1.s );
		}
;
sql_identity:	tIDENTITY
		{
		    db_key( $1.s );
		}
;
sql_in:		tIN
		{
		    db_key( $1.s );
		}
;
sql_increment:	tINCREMENT
		{
		    db_key( $1.s );
		}
;
sql_interval:	tINTERVAL
		{
		    db_key( $1.s );
		}
;
sql_into:	tINTO
		{
		    db_key( $1.s );
		}
;
sql_is:		tIS
		{
		    db_key( $1.s );
		}
;
sql_like:	tLIKE
		{
		    db_key( $1.s );
		}
;
sql_lparen:	tLPAREN 
		{
		    db_op( $1.s );
		}
;
sql_maxvalue:	tMAXVALUE
		{
		    db_key( $1.s );
		}
;
sql_minus:	tMINUS 
		{
		    db_op( ERx(" -") );
		}
;
sql_minvalue:	tMINVALUE
		{
		    db_key( $1.s );
		}
;
sql_nextval:	tNEXTVAL
		{
		if ((esq->flag & ESQ_NOPRT) == 0)
		    db_key( $1.s );
		}
;
sql_nocache:	tNOCACHE
		{
		    db_key( $1.s );
		}
;
sql_nocycle:	tNOCYCLE
		{
		    db_key( $1.s );
		}
;
sql_nomaxvalue:	tNOMAXVALUE
		{
		    db_key( $1.s );
		}
;
sql_nominvalue:	tNOMINVALUE
		{
		    db_key( $1.s );
		}
;
sql_noorder:	tNOORDER
		{
		    db_key( $1.s );
		}
;
sql_not:	tNOT
		{
		    db_key( $1.s );
		}
;
sql_notbeginning:	tNOTBEGINNING
		{
		    db_key( $1.s );
		}
;
sql_notcontaining:	tNOTCONTAINING
		{
		    db_key( $1.s );
		}
;
sql_notending:	tNOTENDING
		{
		    db_key( $1.s );
		}
;
sql_notlike:	tNOTLIKE
		{
		    db_key( $1.s );
		}
;
sql_notsimilar:	tNOTSIMILAR
		{
		    db_key( $1.s );
		}
;
sql_null:	tNULL 
		{
		    db_key( $1.s );
		}
;
sql_of:		tOF 
		{
		    db_key( $1.s );
		}
;
sql_offset:	tOFFSET
		{
		    db_key( $1.s );
		}
;
sql_on:		tON 
		{
		    db_key( $1.s );
		}
;
sql_only:	tONLY
		{
		    db_key( $1.s );
		}
;
sql_or:		tOR
		{
		    db_key( $1.s );
		}
;
sql_order:	tORDER
		{
		    db_key( $1.s );
		}
;
sql_partition:	tPARTITION
		{
		    db_key( $1.s );
		}
;
sql_plus:	tPLUS 
		{
		    db_op( ERx(" +") );
		}
;
sql_public:	tPUBLIC
		{
		    db_key( $1.s );
		}
;
sql_restart:	tRESTART
		{
		    db_key( $1.s );
		}
;
sql_rparen:	tRPAREN 
		{
		    db_op( $1.s );
		}
;
sql_slash:	tSLASH 
		{
		    db_op( $1.s );
		}
;
sql_set:	tSET 
		{
		    db_key( $1.s );
		}
;
sql_similar:	tSIMILAR
		{
		    db_key( $1.s );
		}
;
sql_star:	tSTAR 
		{
		    db_op( $1.s );
		}
;
sql_start:	tSTART
		{
		    db_key( $1.s );
		}
;
sql_substr:	tSUBSTRING
		{
		    db_key( $1.s );
		}
;
sql_then:	tTHEN 
		{
		    db_key( $1.s );
		}
;
sql_to:		tTO 
		{
		    db_key( $1.s );
		}
;
sql_opt_to:	/* Empty */
	|	tTO
		{
		    db_key( $1.s );
		}
;
sql_using:	tUSING 
		{
		    db_key( $1.s );
		}
;
sql_values:	tVALUES 
		{
		    db_key( $1.s );
		}
;
sql_when:	tWHEN 
		{
		    db_key( $1.s );
		}
;
sql_where:	tWHERE 
		{
		    db_key( $1.s );
		    /*
		    ** Tables named in subselects in updatable cursors should
		    ** not contribute to the "> 1 table" error. (bug 5676)
		    */
		    if (ESQ_DCLCSR(esq))
			esq->flag &= ~ESQ_FROM_CHK;

		}
;
sql_union:	tUNION 
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			if ((eqck_tgt( 1, 0 )) == FALSE)	/* reset */
			    esq->flag |= ESQ_UNION_SEL;
		    }
		    db_key( $1.s );
		}
	|	tUNION tALL
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			if ((eqck_tgt( 1, 0 )) == FALSE)	/* reset */
			    esq->flag |= ESQ_UNION_SEL;
		    }
		    db_key( $1.s );
		    db_key( $2.s );
		}
	|	tUNION tDISTINCT
		{
		    if (eq->eq_flags & EQ_FIPS)
		    {
			if ((eqck_tgt( 1, 0 )) == FALSE)	/* reset */
			    esq->flag |= ESQ_UNION_SEL;
		    }
		    db_key( $1.s );
		    db_key( $2.s );
		}
;
sql_with:	tWITH 
		{
		    db_key( $1.s );
		}
;
sql_wocase:	tWOCASE
		{
		    db_key( $1.s );
		}
;
sql_withcase:	tWITHCASE
		{
		    db_key( $1.s );
		}
;
sql_without:	tWITHOUT
		{
		    db_key( $1.s );
		}
;
sql_collate:	tCOLLATE
		{
		    db_key( $1.s );
		}
;
sql_encrypt:	tENCRYPT
		{
		    db_key( $1.s );
		}
;
sql_rename:	tRENAME
		{
		    db_key( $1.s );
		}
;

/* General SQL value or variable objects */

/* 
** sql_id     	- SQL identifier object. Only use it if you are really
**                parsing an identifier otherwise use sql_name.
** sql_idlist 	- name {, name}
** sql_ansi_id  - SQL identifier object. (call db_key)
** sql_regid    - SQL regular identifier object.
** sql_delim_id - SQL delimited identifier object.
** sql_name     - SQL unquoted name - differs from an identifer in that it
**                can't be delimited and it isn't validated for FIPS.
**                this is used when parsing things like the SET statement
**                and WITH clause where we are parsing tNAMEs as opposed
**                to an actual identifier.
** sql_name_or_delim - Strange anomaly to allow for a delimited id but don't
**                validate the name because it might not be an
**                identifier - see SET statement.
** sql_reg_or_delim - SQL identifier object. (don't call db_key)
*/

sql_opt_id:	/* Empty */
	|	sql_id
;
sql_id:		sql_ansi_id
		{
		    $$.s = $1.s;
		    gr->gr_sym = (SYM *)0;
		}
;
sql_idlist:	sql_id
		{
		    $$.i = 0;
		}
	|	sql_idlist sql_comma sql_id
		{
		    $$.i = 1;
		}
;

sql_ansi_id:    sql_reg_id
                {
		    if ((esq->flag & ESQ_NOPRT) == 0)
			db_key( $1.s );
                    $$.s = $1.s;
                }
	|	sql_delim_id
		{
		    if ((esq->flag & ESQ_NOPRT) == 0)
			db_delimid( $1.s );
		    $$.s = $1.s;
		}
;
sql_reg_id:     tNAME
                {
                    $$.s = $1.s;
                    if (eq->eq_flags & EQ_FIPS)
                        eqck_regid($1.s); /* Check if id is FIPS compliant */
                }
        |       tINTERVAL
                {
                    $$.s = $1.s;
                    if (eq->eq_flags & EQ_FIPS)
                        eqck_regid($1.s); /* Check if id is FIPS compliant */
                }
;
sql_delim_id:	tDELIMID
		{
		    $$.s = $1.s;
		    if (eq->eq_flags & EQ_FIPS)
			eqck_delimid($1.s); /* Check if id is FIPS complaint */
		}
;

sql_reg_or_delim:sql_reg_id
	|	sql_delim_id
		{
		i4 dummy;

	  	/*
		** Put the quotes back for delimited ids and escape
		** them (\") so they will be generated correctly
		** later on. 
		*/
		/* Place the delimited ids (with quotes and escape 
		** characters) in buffers of the string table work space
		** to avoid being overwritten when there is another
		** call to gen_sqmakesconst within the same SQL 
		** statement.                 		b57771tt
		*/ 
		
		$$.s = str_add( STRNULL,
                       gen_sqmakesconst(G_DELSTRING, $1.s, &dummy) );

		}
;
sql_name_or_delim: sql_name
	|       sql_delim_id
;
sql_name:       tNAME
                {
                    db_key( $1.s );
                    $$.s = $1.s;
                    gr->gr_sym = (SYM *)0;
                }
;
wquals:		tWTIME
                {
                    db_key( $1.s );
                    $$.s = $1.s;
                    gr->gr_sym = (SYM *)0;
                }
	|	tWLOCAL
                {
                    db_key( $1.s );
                    $$.s = $1.s;
                    gr->gr_sym = (SYM *)0;
                }
	|	tWOTIME
                {
                    db_key( $1.s );
                    $$.s = $1.s;
                    gr->gr_sym = (SYM *)0;
                }
;


/* sql_sconst	- SQL string constant sent as a constant */

sql_sconst:	tSCONST 
		{
		    db_sconst( $1.s );
		    $$.s = $1.s;
		}
;

sql_uconst:	tUCONST
		{
		    db_uconst( $1.s );
		}
;

/* sql_id_sconst	- SQL id or string constant */

sql_id_sconst:	sql_id
		{
		    $$.s = $1.s;
		}
	|	sql_sconst
		{
		    $$.s = $1.s;
		}
;

/* sql_user_list - List of SQL ids or string constants */

sql_user_list:	sql_id_sconst
		{
		    $$.s = ERx(" ");
		}
	|	sql_user_list sql_comma sql_id_sconst
		{
		    $$.s = ERx(",");
		}
;

/* sql_boolconst - SQL boolean constant */

sql_boolconst:  tFALSE
                {
                    db_key($1.s);
                }
        |       tTRUE
                {
                    db_key($1.s);
                }
        |       tUNKNOWN
                {
                    db_key($1.s);
                }
;

/* 
** sql_iconst	- SQL integer constant.
*/

sql_iconst:	tINTCONST
		{
		    db_key( $1.s );
		}
;

/* 
** sql_id_iconst  - SQL integer constant or name.
** sql_id_ivar	  - SQL integer constant or variable, name or string variable.
** sql_id_sivar	  - SQL integer/string constant or variable, name or string var.
*/

sql_id_iconst:	tINTCONST
		{
		    db_key( $1.s );
		    if (gr->gr_flag & GR_CPYHNDDEF) 	/* Turned off above */
		    {
			eqtl_init(IISETSQL);
		        eqtl_add($1.s, (PTR)0, (PTR)0, (PTR)0, T_INT,
				ERx("copyhandler"));
			gr->gr_flag |= GR_SEENCPYHND;
		    }
		}
	|	tNAME
		{
		    db_key( $1.s );
		    if (gr->gr_flag & GR_CPYHNDDEF) 	/* Turned off above */
		    {
			eqtl_init(IISETSQL);
			eqtl_add($1.s, (PTR)0, (PTR)0, (PTR)0, T_NONE,
			        ERx("copyhandler"));
			gr->gr_flag |= GR_SEENCPYHND;
		    }
		}
	|	tDELIMID
		{
		    db_delimid( $1.s );
		    if (gr->gr_flag & GR_CPYHNDDEF) 	/* Turned off above */
		    {
			eqtl_init(IISETSQL);
			eqtl_add($1.s, (PTR)0, (PTR)0, (PTR)0, T_NONE,
			        ERx("copyhandler"));
			gr->gr_flag |= GR_SEENCPYHND;
		    }
		}
;
sql_id_ivar:	sql_id_iconst
	|	host_setvar
		{
		    i4		db_type;

		    if (gr->gr_sym)
		    {
			if(set_role)
			{
			    /*
			    ** This should be SET ROLE WITH PASSWORD=:pwd
			    ** We send pwd as a quoted string, so handle
			    ** as special case here. This avoids changes which
			    ** might affect existing user code which passes
			    ** unexpected values down in the variable
			    */
			    db_var( DB_STRING, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );

			    if (gr->gr_type != T_INT && gr->gr_type != T_CHAR &&
							gr->gr_type != T_UNDEF)
			           er_write( E_EQ0064_grQRSTRVAR, EQ_ERROR, 1,
						    gr->gr_id );
			}
			else
			{
			    db_type = gr->gr_type == T_CHAR ? DB_ID : DB_STRING;
			    db_var( db_type, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
			    if (gr->gr_type != T_INT && gr->gr_type != T_CHAR &&
							gr->gr_type != T_UNDEF)
			    	er_write( E_EQ0060_grINTSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			 }
		    }
		    else	/* Error already from host_setvar */
			db_key( gr->gr_id );
		}
;
sql_id_sivar:	sql_id_iconst
	|	sql_sconst
	|	sql_id sql_dot sql_id
	|	ing_id_dbkey sql_dot sql_id
		/* ($ingres|$dba).objectname               b57353tt */
	|	sql_id sql_dot sql_sconst
	|	sql_sconst sql_dot sql_sconst
	|	sql_sconst sql_dot sql_id
	|	host_setvar	/* Always as a string */
		{
		    if (gr->gr_sym)
		    {
			db_var( DB_STRING, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
			if (gr->gr_type != T_INT && gr->gr_type != T_CHAR &&
							gr->gr_type != T_UNDEF)
			    er_write( E_EQ0060_grINTSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else	/* Error already from host_setvar */
			db_key( gr->gr_id );
		}
;

/* 
** sql_strvar -	 SQL string variable (usually replaces complete objects or
**		target lists).
*/

sql_strvar:	host_setvar
		{
		    if (gr->gr_sym && gr->gr_type == T_CHAR)
			db_var( DB_ID, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
		    else
		    {
			if (gr->gr_type != T_UNDEF)
			    er_write( E_EQ0064_grQRSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			db_key( gr->gr_id );
		    }
		}
;

/*
** sql_name_or_strvar - SQL unquoted name or string variable.  Note that the
**			name is NOT passed through db_key.
*/
sql_name_or_strvar:
		sql_reg_or_delim
		{
		    arg_str_add(ARG_CHAR, $1.s);
		}
	|	schema_id tPERIOD sql_reg_or_delim /*schema.objectname*/
		/* ($ingres|$dba).objectname               b57353tt */
		{
		    STprintf( esq->sbuf, ERx("%s%s%s"), $1.s, $2.s, $3.s );
		    arg_str_add(ARG_CHAR, esq->sbuf);
		}
	|	host_setvar
		{
		    if (gr->gr_sym && gr->gr_type == T_CHAR)
			arg_var_add(gr->gr_sym, gr->gr_id);
		    else
		    {
			if (gr->gr_type != T_UNDEF)
			    er_write(E_EQ0067_grSTRVAR, EQ_ERROR, 1, gr->gr_id);
			arg_str_add(ARG_CHAR, gr->gr_id);
		    }
		}
;

/* SQL and Forms indicator variable rule */

sql_opt_ind:	/* no indicator */
		{
		    gr->gr_nlsym = (SYM *)0;	/* Initialize state vars */
		    gr->gr_nlid = (char *)0;
		    gr->gr_nltype = T_NONE; 
		}
	|	sql_ind
	|	sql_indicator sql_ind
;
sql_ind:	sql_ind_colon host_indvar
		{
		    SYM		*tmpsym;
		    char	*tmpid;
		    i4		tmptype;

		    /*
		    ** Assign indicator info to correct gr_state location
		    */
		    tmpsym = gr->gr_nlsym;
		    tmpid = gr->gr_nlid;
		    tmptype = gr->gr_nltype;
		    gr->gr_nlsym = gr->gr_sym;
		    gr->gr_nlid = gr->gr_id;
		    gr->gr_nltype = gr->gr_type;
		    gr->gr_sym = tmpsym;
		    gr->gr_id = tmpid;
		    gr->gr_type = tmptype;
		    if (gr->gr_nltype != T_UNDEF)	/* Don't cascade errs */
		    {
			if (gr->gr_nltype != T_INT
				|| sym_g_dsize(gr->gr_nlsym) != 2)
			    er_write( E_EQ0073_grINDVAR, EQ_ERROR, 1,
								gr->gr_nlid );
		    }
		}
;
sql_ind_colon:	tCOLON
		{
		    /* 
		    ** Save away variable information 
		    */
		    gr->gr_nlsym = gr->gr_sym;
		    gr->gr_nlid = gr->gr_id;
		    gr->gr_nltype = gr->gr_type;
		    /*
		    ** tell scanner it's a hostvar.  See slave grammers for
		    ** details (under HOST VARIABLE USAGE).
		    */
		    sc_hostvar = TRUE;
		}
;
sql_indicator:	tINDICATOR
;

/* SQL optional UNIQUE clause (MODIFY and REGISTER statements) */

sql_opt_unique:	tUNIQUE
		{
		    db_key( $1.s );
		}
	|	/* EMPTY */
;

/* SQL optional word in FROM_SOURCE clause (SELECT and UPDATE statements) */

sql_opt_natural: /* EMPTY */
	|	tNATURAL
		{
		    db_key( $1.s );
		}
;

/*
** SQL ordering clause
*/
sql_order_opt_sort:
		/* EMPTY */
	|	sql_order_sort
;
sql_order_sort: tNAME
		{
		    if (!ESQ_EQSTR($1.s, ERx("asc")) &&
					!ESQ_EQSTR($1.s, ERx("desc")))
			er_write( E_EQ0126_sqCOMMA, EQ_ERROR, 0);
		    db_key( $1.s );
		}
;
		

/*
** SQL WITH clause - 
**
** sql_with_clause, sql_opt_with_clause:
**	 Note that (1) sometimes the clause is optional, and (2) some
**	 of the clauses can include a "single" element ([no]journaling).
*/
sql_opt_with_clause:
		sql_with_clause
		{
		    $$.i = 1;
		}
	|       /* No WITH clause */
		{
		    $$.i = 0;
		}
;
sql_with_clause:
		sql_with sql_with_list
;
sql_with_list:	sql_with_elm
	|	sql_with_list sql_comma sql_with_elm
;

/*
** sql_with_elm:
**		left = [UNIQUE] id | string | int | (idlist)
**		PARTITION=(lotsa stuff)
**		CHECK OPTION
**		GRANT OPTION
**		[NO]JOURNALING
**		[NO]DUPLICATES
**		[NO]UPDATE
**		string_variable
+* WITH clause:
**	name = id | string_const | int	# WITH Database=dbdb, Node="rabbit@tr0"
**					# WITH structure = UNIQUE keyed
**					# WITH copyhandler = id
**	name = (name[sort]{,name[sort]})# WITH key = (age ASC,sal DESC,emp)
**					# WITH location = (:loc1, :loc2)
**	name  				# WITH range = ( (#,#), (#,#) )
**	name				# WITH Journaling
**	name name			# WITH Grant Option
*/
sql_with_elm:	sql_with_xelm
		{
		    gr->gr_flag &= ~GR_CPYHNDDEF;
		}
;
sql_with_xelm:	sql_wleft sql_eq sql_wright 
	|	sql_wleft			/* ie, JOURNALING */
	|	sql_wleft sql_name		/* ie, GRANT OPTION */
	|	sql_strvar
	|	sql_wpartition_def
;
sql_wleft:	tNAME
		{
		    if (   gr->gr_flag & GR_COPY_PROG
		        && ESQ_EQSTR($1.s, ERx("copyhandler")))
			gr->gr_flag |= GR_CPYHNDDEF;
		    db_key( $1.s );
		}
	|	tTABLE
		{
		    db_key( $1.s );
		}
	|	tROLLBACK
		{
		    db_key( $1.s );
		}
	|	tGRANT
		{
		    db_key( $1.s );
		}
	|	tUPDATE
		{
		    db_key( $1.s );
		}
	|	tGROUP
		{
		    db_key( $1.s );
		}
	|	tKEY
		{
		    db_key( $1.s );
		}
	|	tCHECK
		{
		    db_key( $1.s );
		}
	|	tINDEX
		{
		    db_key( $1.s );
		}
;
sql_wright:	sql_opt_unique sql_id_sivar sql_opt_id
	|	sql_lparen sql_with_idlist sql_rparen
	|	sql_null
	|	tALL 		/* WITH DEFAULT_PRIVILEGES = ALL */
		{
		    db_key( $1.s );
		}
	|	tROW		/* WITH LABEL_GRANULARITY = ROW */
		{
		    db_key( $1.s );
		}
	|	tTABLE		/* WITH LABEL_GRANULARITY = TABLE */
		{
		    db_key( $1.s );
		}
	|	tCONTINUE		/* Bug #2681 */
		{
		    db_key( $1.s );
		}
	|	tKEY		/* Allow WITH COMPRESSION = KEY */
		{
		    db_key( $1.s );
		}
;
sql_with_idlist:sql_with_id sql_order_opt_sort
	|	sql_with_idlist sql_comma sql_with_id sql_order_opt_sort
		/* range = ( low_range , high_range ) 	*/
        |       sql_lparen sql_with_rangelist sql_rparen sql_comma 
		sql_lparen sql_with_rangelist sql_rparen
;
sql_with_id:	sql_id_sconst
	|	tALL		/* Allow WITH USAGE = (ALL) */
		{
		    db_key( $1.s );
		}
	|	tKEY		/* Allow WITH COMPRESSION = (KEY) */
		{
		    db_key( $1.s );
		}
	|	sql_strvar	/* Allow WITH LOCATION = (:strvar,...) */
;
sql_with_rangelist:constant
	|	sql_with_rangelist sql_comma constant
;
/* A couple variants based on sql_with_id that omits some of the screwy
** stuff allowed in sql_with_idlist:
*/
sql_with_id_parenlist: sql_lparen sql_with_id_basiclist sql_rparen
;
sql_with_id_basiclist: sql_with_id
	|	sql_with_id_basiclist sql_comma sql_with_id
;
sql_opt_with_id: /* empty */
	|	sql_with_id
;

/* PARTITION= definition parsing.
** We'll be real sloppy with this since mostly we're just going to
** slog it on through to the DBMS server.  Luckily we can get away with
** just one added reserved word (namely, PARTITION).
*/

/* PARTITION=(stuff) */
sql_wpartition_def: sql_partition sql_eq sql_lparen sql_pdef_body sql_rparen
;
/* the body is one dim or several (dim) word (dim) ... */
sql_pdef_body:	sql_pdef_dim
	|	sql_pdef_dim_list
;
sql_pdef_dim_list: sql_lparen sql_pdef_dim sql_rparen
	|	sql_pdef_dim_list sql_name sql_lparen sql_pdef_dim sql_rparen
;
/* A dimension is rule optional-ON-list partition-list */
sql_pdef_dim: sql_name sql_pdef_opt_onlist sql_part_list
;
sql_pdef_opt_onlist: /* empty */
	|	sql_on sql_idlist
;
sql_part_list:	sql_log_partition
	|	sql_part_list sql_comma sql_log_partition
;
/* One logical partition definition, parse with three flavors.
** Note that the production chosen for partition names allows host-vars.
*/
sql_log_partition: sql_n_partitions sql_logpart_with
	|	sql_one_partition sql_logpart_with
	|	sql_values_partition sql_logpart_with
;
/* nnn PARTITION[s] (name-list) */
sql_n_partitions: sql_iconst sql_name sql_pdef_opt_pnames
;
sql_pdef_opt_pnames: /* empty */
	|	sql_with_id
	|	sql_with_id_parenlist
;
/* PARTITION (name) but we'll just use name-list */
sql_one_partition: sql_partition sql_pdef_opt_pnames
;
/* PARTITION [name] VALUES stuff
** "stuff" is either the list form: (value-list)
** or the range form: range-op one-value
*/
sql_values_partition: sql_partition sql_opt_with_id sql_values sql_lparen sql_part_vallist sql_rparen
	|	sql_partition sql_opt_with_id sql_values range_op sql_part_value
;
/* LIST style values and value lists include the keyword DEFAULT */
sql_part_vallist: sql_part_list_value
	|	sql_part_vallist sql_comma sql_part_list_value
;
sql_part_list_value: dec_default
	|	sql_part_value
;
/* RANGE values use this production directly, doesn't allow DEFAULT.
** A value is one constant.  This does not allow host variables.
** Host variables should probably be allowed at some point.
*/
sql_part_value:	constant
	|	sql_lparen sql_constant_list sql_rparen
;
sql_constant_list:	constant
	|	sql_constant_list sql_comma constant
;
/* and finally, the partition-WITH is, for now: with location=(list).
** Allow host variables in the list.
*/
sql_logpart_with: /* empty */
	|	sql_with sql_name sql_eq sql_with_id_parenlist
;


/*
+* ---- ESQL Statements ----
-*
**	Embedded statements that interact with the preprocessor, 
**	or run-time support routines.
*/

/* 
+* Statement:	EXEC SQL CALL system (name = val, name = val)
-* Action:	Call another system from within ESQL.
** Generates:	IIutsys( IIutPROG, system, NULL );
**		IIutsys( IIutARG, name, value ); ...
**		IIutsys( IIutEXE, NULL, NULL );
*/

call:		call_head call_prog call_tlist
		{
		    arg_int_add( IIutEXE );
		    arg_str_add( ARG_CHAR, (char *)0 );
		    arg_str_add( ARG_CHAR, (char *)0 );
		    gen_call( IIUTSYS );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
					1, ERx("CALL") );
		}
call_head:	tCALL 
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		    arg_int_add( IIutPROG );
		}
;
call_prog:	call_prog_args
		{
		    arg_str_add( ARG_CHAR, (char *)0 );
		    gen_call( IIUTSYS );
		}
;
call_prog_args: fm_string
;
call_tlist:	call_lparen call_arglist tRPAREN 
;
call_lparen:	tLPAREN
		{
		    arg_int_add( IIutARG );
		}
;
call_arglist:	call_elm
	|	call_arglist call_comma call_elm
;
call_elm:	call_left tEQOP fm_string
		{
		    gen_call( IIUTSYS );
		}
;
call_left:	fm_string
	|	tTABLE
		{
		    arg_str_add( ARG_CHAR, $1.s );
		}
	|	tCOMMAND
		{
		    arg_str_add( ARG_CHAR, $1.s );
		}
;
call_comma:	tCOMMA
		{
		    arg_int_add( IIutARG );
		}
;

/*
+* ---- SQL statements ----
*/

/* 
+* Statement:	EXEC SQL CONNECT database [SESSION integer]
**		[IDENTIFIED BY userid]
**		[REMOTE SYSTEM_USER = remote_user 
**		 REMOTE SYSTEM_PASSWORD = rem_passwd]
**		[DBMS PASSWORD = dbms_passwd]
**		[OPTIONS = string, string]
**		[WITH with_clause];
-* Action:	Open connection to INGRES database.
** Generates:	[ IIsquser( userid ); ]
**		[IIsqMods(IImodWITH); ]
**		IIsqconnect( language, database [,flags...], 0 );
**		[IIsqParms(flag, name, type, strval, intval);...]
** Notes:	The WITH clause may be a gateway with-clause or
**		a means of reassociating to a distributed transaction.
*/

connect:	connect_head connect_tail con_opt_with_clause
;
connect_head:	connect_key con_string 
	|	connect_key tTO con_string
;
connect_tail:	con_opt_name con_opt_ses con_opt_user 
			con_opt_rempw con_opt_dbmspw 
			con_options
;
con_opt_ses:	/* empty */
	|	con_ses
;
con_opt_name:	/* empty */
	|	con_name
;
con_opt_user:	/* empty */
	|	con_user
;
con_opt_rempw:	/* empty */
	|	connect_rempw
;

con_opt_dbmspw: /* empty */
	|	con_dbmspasswd

connect_key:	tCONNECT
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		    arg_int_add( eq_genlang(eq->eq_lang) );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ050A_FIPS_EXTSN, EQ_WARN,
					1, ERx("CONNECT") );
		}
;
con_ses:	con_sesname fm_int
		{
		    gen_call( IISQSESS );
		}
;
con_sesname:	tSESSION
		{
		    arg_push();
# ifdef DGC_AOS
		    /*
		    ** Multiple connects are not legal in Open SQL, so if
		    ** user tries to do multiple connects on DG, then a
		    ** SYNTAX error is generated.  The multiple connect code
		    ** is still generated, but with the SYNTAX ERROR msg.,
		    ** the user's source code cannnot be compiled. (B 8174)
		    */
		    er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $1.s,
			ERx("CONNECT") );
		    gen_host( G_H_OP|G_H_NEWLINE, ERx("...SYNTAX ERROR;") );
# endif /* DGC_AOS */
		}
;
con_name:	con_as_key fm_qstring
		{
		    gen_call( IISQCNNM );
		}
;
con_as_key:	tAS
		{
		    arg_push();
		}
;
con_user:	tIDENTIFIED tBY { arg_push(); } con_string
		{
		    gen_call( IISQUSER );
		}
;
connect_rempw: con_remuser con_rempasswd
;

con_remuser:  tREM_SYS_USER tEQOP
		{ 
		  arg_str_add(ARG_CHAR, ERx("-remote_system_user")); 
		}  
	        fm_string
;

con_rempasswd:  tREM_SYS_PASS tEQOP 
		{ 
		  arg_str_add(ARG_CHAR, ERx("-remote_system_password"));
		}  
	        fm_string
;
con_dbmspasswd: tDBMS_PASSWORD tEQOP
		{
		  arg_str_add(ARG_CHAR, ERx("-dbms_password"));
	        }
		fm_string
;
con_options:	con_nameeq con_optlist
	|	/* No OPTIONS */
;
con_nameeq:	tNAME tEQOP
		{
		    if (!ESQ_EQSTR($1.s, ERx("options")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					    ERx("CONNECT"), ERx("OPTIONS") );
		}
;
con_optlist:	con_string
	|	con_optlist tCOMMA con_string
;
con_string:	fm_string
;
con_w_string:	con_w_xstring
		{
		    /*
		    ** Can't mix transaction ids for 2-phase commit and
		    ** other with elements on connect
		    */
		    if (gr->gr_flag & GR_HIGHX && gr->gr_flag & GR_LOWX)
			er_write( E_EQ0079_grCONNECTID, EQ_ERROR, 0 );
		    if (ESQ_EQSTR($1.s, ERx("highdxid")))
			gr->gr_flag |= GR_HIGHX;
		    else if (ESQ_EQSTR($1.s, ERx("lowdxid")))
			gr->gr_flag |= GR_LOWX;
		}
;
con_w_xstring: 	tNAME
		{
		    arg_str_add( ARG_CHAR, $1.s );
		}
	|	tSCONST
		{
		    arg_str_add( ARG_CHAR, $1.s );
		}
;
con_opt_with_clause:
		con_with con_with_clause
		{
		    arg_int_add(IIsqpEND);
		    arg_str_add(ARG_CHAR, (char *)0);
		    arg_int_add(0);
		    arg_str_add(ARG_CHAR, (char *)0);
		    arg_int_add(0);
		    gen_call(IISQPARMS);
		}
	|	/* No WITH clause */
		{
		    gen_call( IISQCONNECT );
		}
;
con_with:	tWITH
		{
		    esq_sqmods(IImodWITH);  	/* force in modifier */
		    gen_call( IISQCONNECT );	/* Close CONNECT */

		    arg_int_add(IIsqpINI);

		  /* Initialize for 2PC with-clause */
		    gr->gr_flag &= ~(GR_HIGHX|GR_LOWX);	
		}
;
con_with_clause:	fm_strvar
		{
			/* All specified in string variable */
			arg_int_add(DB_CHR_TYPE);
			arg_str_add(ARG_CHAR, (char *)0);
			arg_int_add(0);
			gen_call(IISQPARMS);
		}
	|	con_with_list
		{
		    if (   (gr->gr_flag & GR_HIGHX || gr->gr_flag & GR_LOWX)
			&& !(gr->gr_flag & GR_HIGHX && gr->gr_flag & GR_LOWX)
		       )
		    {
			er_write( E_EQ0079_grCONNECTID, EQ_ERROR, 0 );
		    }
		}
;
con_with_list:	con_with_elm
	|	con_with_list con_comma con_with_elm
;
con_comma:	tCOMMA
		{
			/* Start the next call */
			arg_int_add(IIsqpADD);
		}
;
con_with_elm:	con_w_string tEQOP con_right
		{
		    /* End the current call */
		    gen_call(IISQPARMS);
		}
;
con_right:	tSCONST
		{
		    arg_int_add(DB_CHR_TYPE);
		    arg_str_add( ARG_CHAR, form_sconst($1.s) );
		    arg_int_add(0);
		    if (gr->gr_flag & GR_HIGHX || gr->gr_flag & GR_LOWX)
			er_write( E_EQ0079_grCONNECTID, EQ_ERROR, 0 );
		}
	|	tNAME
		{
		    arg_int_add(DB_CHR_TYPE);
		    arg_str_add( ARG_CHAR, $1.s );
		    arg_int_add(0);
		    if (gr->gr_flag & GR_HIGHX || gr->gr_flag & GR_LOWX)
			er_write( E_EQ0079_grCONNECTID, EQ_ERROR, 0 );
		}
	|	tINTCONST
		{
		    arg_int_add(DB_INT_TYPE);
		    arg_str_add( ARG_CHAR, (char *)0 );
		    arg_str_add( ARG_INT, $1.s );
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_CHAR)
			{
			    arg_int_add(DB_CHR_TYPE);
			    arg_var_add( gr->gr_sym, gr->gr_id );
			    arg_int_add(0);
			    if (gr->gr_flag & GR_HIGHX || gr->gr_flag & GR_LOWX)
				er_write( E_EQ0079_grCONNECTID, EQ_ERROR, 0 );
			}
			else if (gr->gr_type == T_INT)
			{
			    arg_int_add(DB_INT_TYPE);
			    arg_str_add( ARG_CHAR, (char *)0 );
			    arg_var_add( gr->gr_sym, gr->gr_id );
			}
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0060_grINTSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    arg_int_add(DB_CHR_TYPE);
			    arg_str_add( ARG_CHAR, gr->gr_id );
			    arg_int_add(0);
			}
		    }
		    else	/* Error in host_setvar */
		    {
			arg_int_add(DB_CHR_TYPE);
			arg_str_add( ARG_CHAR, gr->gr_id );
			arg_int_add(0);
		    }
		}
;

/* 
+* Statement:	EXEC SQL COPY sqlerror INTO buffer [WITH length];
-* Action:	Format SQL error into user buffer.
** Generates:	IIeqiqio( (short *)0, vardesc, var, "errortext" );
** Notes:	We simulate "## INQUIRE_EQUEL (buffer="errortext")"
*/

copy_sqlerr:	copy_err_key ce_into ce_buf ce_with
		{
		    arg_str_add( ARG_CHAR, ERx("errortext") );
		    gen_call( IIEQINQ );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("COPY SQLERROR"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("COPY SQLERROR") );
		}
;
copy_err_key:	tCOPY tNAME
		{
		    if (!ESQ_EQSTR($2.s, ERx("sqlerror")))
		    {
			er_write( E_EQ0070_grMISSWORD, EQ_ERROR, 2,
						ERx("TABLE"), ERx("COPY") );
			YYERROR;
		    }
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, $2.s );
		    arg_int_add( 0 );	/* No NULL indicator */
		}
;
ce_buf:		host_retvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_CHAR)
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			}
		    } else	/* Error in host_retvar */
			;
		    arg_var_add( gr->gr_sym, gr->gr_id );
		}
;

/* Length spec is now ignored */
ce_with:	tWITH tINTCONST
	|	tWITH host_setvar
	|	/* Use default */
;
ce_into:	tINTO
	|	/* Missing */
		{
		    er_write( E_EQ0070_grMISSWORD, EQ_ERROR, 2, ERx("INTO"),
							ERx("COPY SQLERROR") );
		}
;

/* 
+* Statement:	EXEC SQL DECLARE name TABLE ( name-type-list )
-* Action:	Documentative statement only (checks types).
** Generates:	None
*/

declare_table:	declare_tabnm tTABLE tLPAREN dectab_list tRPAREN
		{
		    if ($4.i && eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, EQ_WARN, 1,
			    ERx("DECLARE TABLE ... DEFAULT/SYSTEM_MAINTAINED"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("DECLARE TABLE") );
		}
;
declare_tabnm:  tDECLARE dec_tbl_name
		{
		    esq->flag |= ESQ_NOPRT;	/* Suppress printing */
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, $2.s );
		}
	|	tDECLARE dec_owner_name tPERIOD dec_tbl_name
		{
		    esq->flag |= ESQ_NOPRT;	/* Suppress printing */
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, $2.s );
		}
;
dec_tbl_name:   tNAME
	|	tDELIMID
; 
dec_owner_name: tNAME
	|	tDELIMID 
	|	ing_id  
		/* ($ingres|$dba).tablename                b57353tt */
;
dectab_list:	dectab_elm
		{
		    $$.i = $1.i;
		}
	|	dectab_list tCOMMA dectab_elm
		{
		    $$.i = $1.i || $3.i;	/* DEFAULT keyword */
		}
;
dectab_elm:	name_string dectab_type dec_nullfmt_list
		{
		    id_free();
		    $$.i = $3.i;
		}
	|	name_string dectab_type tLPAREN tINTCONST tRPAREN dec_nullfmt_list
		{
		    id_free();
		    $$.i = $6.i;
		}
	|	name_string dectab_type tLPAREN tINTCONST tCOMMA 
		tINTCONST tRPAREN dec_nullfmt_list	/* Allow decimal(p,s) */
		{
		    id_free();
		    $$.i = $8.i;
		}
;
name_string:	tNAME
	|	tDELIMID
;
dectab_type:	tNAME		/* Some languages may add more */
	|	tNAME tNAME	/* Allow "double precision" */
;
/*
** End of an column type specification:
**	[ WITH NULL [WITH | NOT SYSTEM_MAINTAINED]
**	  | NOT NULL [WITH | NOT DEFAULT] [WITH | NOT SYSTEM_MAINTAINED]
**	  | column_constraint
**	]
** Where a column_constraint has the following syntax:
**      [CONSTRAINT constraint_name] UNIQUE | PRIMARY KEY or
**	[CONSTRAINT constraint_name] REFERENCES tablename [(colname,{,colname)] 
**	and both may be followed by an optional WITH clause.
**
**  Notes:
**    1.  FIPS doesn't allow (on CREATE statement):
**		WITH | NOT DEFAULT
**		WITH | NOT SYSTEM_MAINTAINED
**		WITH NULL
**		column_constraint WITH clause
**    2.  OPEN SQL doesn't allow (on CREATE, REGISTER and DECLARE statements)
**		WITH | NOT DEFAULT
**		WITH | NOT SYSTEM_MAINTAINED
**		column_constraint WITH clause
**    3.  The warnings are not issued at this level because we have
**	  no context.  Also, FIPS will warn about REGISTER and DECLARE
**	  statements as a whole, so no need to warn about the individual
**	  clauses.
*/
dec_nullfmt_list: /* nuffin dere */
	|	dec_nullfmt_list1
		{
		    $$.i = $1.i;
		}
;
dec_nullfmt_list1:	dec_nullfmt1
		{
		    $$.i = $1.i;
		}
	|	dec_nullfmt_list1 dec_nullfmt1
		{
		    $$.i = $2.i;
		}
;
dec_nullfmt1:	dec_withnull
		{
		    $$.i = $1.i;
		    esq->flag &= ~ESQ_WITHABLE_CONSTRAINT;
		}
	|	dec_system
		{
		    $$.i = $1.i;
		    esq->flag &= ~ESQ_WITHABLE_CONSTRAINT;
		}
	|	dec_default_cls
		{
		    $$.i = $1.i;
		    esq->flag &= ~ESQ_WITHABLE_CONSTRAINT;
		}
	|	dec_constr_def
		{
		    $$.i = $1.i;
		    esq->flag |= ESQ_WITHABLE_CONSTRAINT;
		}
	|	cons_with
		{
		    $$.i = $1.i;
		    esq->flag &= ~ESQ_WITHABLE_CONSTRAINT;
		}
; 
cons_with:	tWITH
		{
		    /* Assure we're following a constraint definition. */
		    if (!(esq->flag & ESQ_WITHABLE_CONSTRAINT))
		     er_write(E_EQ006B_WITH_NOCONS, EQ_ERROR, 0);
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
		    }
		    $$.i = CRE_CONWTH;
		}
		cons_with_list
;
cons_with_list:	tNAME tINDEX
		{
		    if (!ESQ_EQSTR($1.s, ERx("no")))
			er_write(E_EQ006A_grxBADWORD, EQ_ERROR, 2,
			    $1.s, ERx("with no index"));
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
			db_key($2.s);
		    }
		    $$.i = $2.i;
		}
	|	tINDEX tEQOP tNAME tTABLE tNAME
		{
		    if (!ESQ_EQSTR($3.s, ERx("base")))
			er_write(E_EQ006A_grxBADWORD, EQ_ERROR, 2,
			    $3.s, ERx("with index = base table structure"));
		    else if (!ESQ_EQSTR($5.s, ERx("structure")))
			er_write(E_EQ006A_grxBADWORD, EQ_ERROR, 2,
			    $5.s, ERx("with index = base table structure"));
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
			db_key($1.s);
			db_op($2.s);
			db_key($3.s);
			db_key($4.s);
			db_key($5.s);
		    }
		    $$.i = $1.i;
		}
	|	sql_with_elm
		{
		    $$.i = $1.i;
		}
	|	sql_lparen sql_with_list sql_rparen
		{
		    $$.i = $2.i;
		}
;
dec_withnull:	tWITH tNULL
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
		    	db_key( $1.s );
		    	db_key( $2.s );
		    }
		}
;
dec_notnull:	tNOT tNULL
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
		    	db_key( $1.s );
		    	db_key( $2.s );
		    }
		}
;
dec_default_cls:dec_withdefault
		{
		    $$.i = CRE_WDEF;
		}
	|	dec_withdefault dec_default_opt
		{
		    $$.i = CRE_WDEF;
		}
	|	dec_default dec_default_opt
		{
		    $$.i = CRE_OK;
		}
	|	dec_notdefault
		{
		    $$.i = CRE_NDEF;
		}
	|	dec_identity
		{
		    $$.i = CRE_OK;
		}
;
dec_withdefault:tWITH tDEFAULT
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
		    	db_key( $1.s );
		    	db_key( $2.s );
		    }
		}
;
dec_default:	tDEFAULT
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    	db_key( $1.s );
		}
;
dec_notdefault:	tNOT tDEFAULT
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
		    	db_key( $1.s );
		    	db_key( $2.s );
		    }
		}
;
dec_identity:	sql_generated dec_identity_opt sql_as dec_identity_opt_sname
					sql_identity common_seq_opt_list
	|	tAUTOINCREMENT
		{
		    	db_key( $1.s );
		}
;
dec_identity_opt: tALWAYS
		{
		    	db_key( $1.s );
		}
	|	sql_by sql_default
;
dec_identity_opt_sname: /* nothing ... */
	|	sql_id
;
dec_default_opt:sql_iconst
	|	tNULL
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    	db_key( $1.s );
		}
	|	all_user_keys
	|	tSCONST
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    	db_sconst( $1.s );
		}
	|	tDECCONST
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    	db_key( $1.s );
		}
	|	tFLTCONST
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    	db_key( $1.s );
		}
	|	seq_expr
;
dec_system:	tWITH tSYSTEM_MAINTAINED
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
		    	db_key( $1.s );
		    	db_key( $2.s );
		    }
		    $$.i = CRE_WSYS;
		}
	|	tNOT tSYSTEM_MAINTAINED
		{
		    /* Don't print if in DECLARE TABLE statement */
		    if ((esq->flag & ESQ_NOPRT) == 0)
		    {
		    	db_key( $1.s );
		    	db_key( $2.s );
		    }
		    $$.i = CRE_NSYS;
		}
;
dec_constr_def:	dec_constr
	|	constr_name_def dec_constr
;
constr_name_def:constraint_key sql_id
;
dec_constr:	dec_notnull
	|	unique_constr
	|	references_constr
	|	check_constr_def
;

/* 
+* Statement:	EXEC SQL DECLARE statementname {, statementname} STATEMENT
-* Action:	Documentative statement only.
** Generates:	None
*/

/* use declare_tabnm to avoid shift/reduce conflicts */
declare_stmt:	declare_tabnm declare_tab_list tNAME
		{
		    if (!ESQ_EQSTR($3.s, ERx("statement")))
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $3.s,
					    ERx("DECLARE"), ERx("STATEMENT") );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				1, ERx("DECLARE STATEMENT") );
		}
;
declare_tab_list:	
		tCOMMA dcltab_list
	|	/* EMPTY */
;
dcltab_list:	tNAME
	|	dcltab_list tCOMMA tNAME
	|	tDELIMID
	|	dcltab_list tCOMMA tDELIMID
;

/* 
+* Statement:	EXEC SQL DISCONNECT [ ALL 
**				    | CURRENT
**				    | SESSION session_identifier 
**				    | connection_name]
-* Action:	Close connection to INGRES database.
** Generates:	IIsqexit();
*/

disconnect:	discon_key discon_sess
		{
		    gen_call( IISQEXIT );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ050A_FIPS_EXTSN, EQ_WARN,
					1, ERx("DISCONNECT") );
		}
;
discon_key:	tDISCONNECT
		{ 
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    esq_init();
		}
;
discon_sess:	tSESSION fm_int
		{
		    gen_call( IISQSESS );
		}
	|	tALL	/* Disconnect all sessions */
		{
		    arg_int_add ( IIsqdisALL );	
		    gen_call( IISQSESS );
		}
	|	fm_qstring
		{
		    /* connection name */
		    gen_call( IISQCNNM );
		}
	|	tCURRENT
	|	/* No session identifier */
;

/* 
+* Statement:	EXEC SQL GET DATA (outlist) [WITH MAXLENGTH = int_val|int_var]
**		  outlist:     :var = target_elem {, :var = taget_elem}
**		  target_elem: SEGMENT| SEGMENTLENGTH | DATAEND
**
** Action:	Retrieve a segment of a large object from the DBMS.
**
** Generates:   IILQlgd_LoGetData(segment, maxlength, segmentlength, dataend)
*/
get_data:	get_dat_key sql_out_tl opt_getdat_with
		{
		    eqgen_tl(IIGETDATA);
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		}
;
get_dat_key:	tGET_DATA
		{
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    gr->gr_func = IIGETDATA;
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 
				1, ERx("GET DATA") );
		    eqtl_init(IIGETDATA);
		}
;

opt_getdat_with: /* empty */
	|	tWITH tNAME tEQOP tl_int
		{
		    if (STbcompare($2.s, 0, ERx("maxlength"), 9, TRUE) != 0)
		    {
			er_write( E_EQ006A_grxBADWORD, EQ_ERROR, 2, $2.s,
                                          ERx("GET DATA"));
		    }
		    eqtl_add(gr->gr_id, (PTR)gr->gr_sym, gr->gr_nlid, 
			(PTR)gr->gr_nlsym, gr->gr_type, $2.s);
		}
;

/*
+* Statement:   EXEC SQL PUT DATA (in_list);
**			in_list: in_elem = :var | val {, in_elem = :var | val}
**			in_elem: SEGMENT | SEGMENTLENGTH | DATAEND
**
** Action:	Sends a segment of a large object to the DBMS.
**
** Generates:	IILQlpd_LoPutData(segment, segmentlength, dataend)
*/
put_data:       put_dat_key sql_in_tl
                {
                    eqgen_tl(IIPUTDATA);
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
                }
;
put_dat_key:    tPUT_DATA
                {
                    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
                    gr->gr_func = IIPUTDATA;
                    if (eq->eq_flags & EQ_FIPS)
                        er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
                                1, ERx("PUT DATA") );
                    eqtl_init(IIPUTDATA);
                }
;

/*
+* Statement:	EXEC SQL GET DBEVENT
**		    [WITH WAIT [= int_val|:int_var]  | NOWAIT];
-*
*/
get_dbevent:	get_ev_key getevt_opt_wait
		{
		    gen_call( IIEVTSTAT );
		    gr->gr_flag |= GR_GETEVT;	/* Special WHENEVER handling */
		}
;
get_ev_key:	tGET_DBEVENT
		{
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    if (eq->eq_flags & EQ_COMMON)
			er_write( E_EQ0504_OPEN_WARN, 
					EQ_WARN, 1, ERx("GET DBEVENT"));
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
					1, ERx("GET DBEVENT") );
		    esq_init();
		    arg_int_add( 0 );	/* Called from user code */
		}
;
getevt_opt_wait:/* No WITH clause */
		{
		    arg_int_add( 0 );	/* "no wait" */
		}
	|	getevt_w_eq getevt_waitval
	|	getevt_w_noeq 
;
getevt_w_eq:	tWITH tNAME tEQOP
		{
		    if (!ESQ_EQSTR($2.s, ERx("WAIT")))
		    {
			er_write(E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					ERx("GET DBEVENT"), ERx("WAIT"));
		    }
		}
;
getevt_w_noeq:	tWITH tNAME
		{
		    if (ESQ_EQSTR($2.s, ERx("WAIT")))
		    {
			arg_int_add( -1 );	/* Wait forever */
		    }
		    else 
		    {
			arg_int_add( 0 );	/* Don't wait */
		        if (!ESQ_EQSTR($2.s, ERx("NOWAIT")))
			    er_write(E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					ERx("GET DBEVENT"), ERx("NOWAIT"));
		    }
		}
;
getevt_waitval:	fm_int
;

/* 
** sql_out_tl -	a generic target list rule.
**		This rule should be moved down when we have other
**		statements (besides the GET DBEVENT) that need generic
**		target list processing.
*/
sql_out_tl:	tLPAREN sql_out_tlist tRPAREN
;
sql_out_tlist:	tl_out_elm
	|	sql_out_tlist tCOMMA tl_out_elm
;
tl_out_elm:	host_retvar sql_opt_ind tEQOP tl_attrib
		{
		    eqtl_add(gr->gr_id, (PTR)gr->gr_sym, gr->gr_nlid, (PTR)gr->gr_nlsym,
				gr->gr_type, $4.s);
		    if ( (gr->gr_type == T_STRUCT) && (eq->eq_flags & EQ_FIPS) )
			er_write( E_EQ050D_FIPS_VAR, EQ_WARN, 0 );
		}
;
tl_attrib:	fm_sconst
		{
		    $$.s = $1.s;
		}
	|	tNAME
		{
		    $$.s = $1.s;
		}
	|	tSESSION
		{
		    $$.s = $1.s;
		}
;
tl_int:		tINTCONST
		{
                       gr->gr_id = $1.s;
                       gr->gr_type = T_INT;
                       gr->gr_sym = (SYM *)0;
                       gr->gr_nlsym = (SYM *)0;
		}
        |       host_fsetvar
                {
                    if (gr->gr_sym)
                    {
                        if (gr->gr_type != T_INT)
                        {
                            er_write(E_EQ0061_grINTVAR, EQ_ERROR,1, gr->gr_id);
                        }
                    }
		    else
		    {
		       gr->gr_id = $1.s;
                       gr->gr_type = T_NONE;
                       gr->gr_sym = (SYM *)0;
                       gr->gr_nlsym = (SYM *)0;
		    }
                }
;

/*
+* Statement:	EXEC SQL IIPRINTF( string {, varying arg} )
-* Action:	Internal call to QAprintf for testing.
** Generates:	QAprintf( string, args ... );
*/

iiprintf:	iiprintf_key iiprintf_args
		{
		    gen_call( QAPRINTF );
		}
;
iiprintf_key:	tIIPRINTF
		{ 
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		}
;
iiprintf_args:	tLPAREN iiprintf_list tRPAREN
;
iiprintf_list:	iiprintf_elm
	|	iiprintf_list tCOMMA iiprintf_elm
;
iiprintf_elm:	host_fsetvar
		{
		    if (gr->gr_sym)
			arg_var_add( gr->gr_sym, gr->gr_id );
		    else
			arg_str_add( ARG_CHAR, gr->gr_id );
		}
	|	fm_iconst_arg
	|	fm_sconst_arg
;

/* 
+* Statement:	EXEC SQL INQUIRE_INGRES ( form output list )
-* Action:	Inquire about Libq information.
** Generates:	IIeqinq( vardesc, var, object ); ...
*/

inquire_ingres: inq_ingres_key sql_out_tl 
		{
			eqgen_tl(IIINQSQL);
			if (eq->eq_flags & EQ_CHRPAD)
			    esq_sqmods(IImodNOCPAD);
		}
;
inq_ingres_key: tINQ_INGRES
		{
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    gr->gr_func = IIINQSQL;
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
					1, ERx("INQUIRE_INGRES") );
		    eqtl_init(IIINQSQL);
		}
;
/* 
+* Statement:	EXEC SQL SET_INGRES ( form input list )
**	  or:	EXEC SQL SET CONNECTION connection_name
-* Action:	Set Libq information.
** Generates:	IIeqset( object, vardesc, var ); ...
*/


set_ingres:	set_ingres_key sql_in_tl 
		{
			eqgen_tl(IISETSQL);
		}
	|	set_connec_key set_con_string
		{
		    eqtl_add(gr->gr_id, (PTR)gr->gr_sym, gr->gr_nlid, 
			 (PTR)gr->gr_nlsym, gr->gr_type, ERx("connection_name"));
		    eqgen_tl(IISETSQL);
		}
	|	set_connec_key tNAME
		{
		    /*
		    ** Only NONE (unfortunately not a keyword) 
		    ** is permitted as connection identifier.
		    */
		    if ( ESQ_EQSTR( $2.s, ERx("none") ) )
		    {
			/*
			** SET CONNECTION NONE is handled 
			** as SET_SQL( SESSION = NONE ).
			*/
			char session[ 8 ];

			/* see notes in SET_SQL( SESSION ) */
			if ( eq->eq_flags & EQ_SQLSTATE )
			{
			    gen_diaginit(); 
			}

			CVna( IIsqsetNONE, session );
			eqtl_add( session, NULL, 
				  NULL, NULL, T_INT, ERx("session") );
			eqgen_tl( IISETSQL );
		    }
		    else
		    {
			er_write( E_EQ0244_yySYNWRD, EQ_ERROR, 1, $2.s );
		    }
		}
;
set_con_string:	fm_sconst
		{
			gr->gr_id = $1.s;
			gr->gr_type = T_CHAR;
			gr->gr_sym = (SYM *)0;
			gr->gr_nlsym = (SYM *)0;
		}
	|	host_setvar
;
set_ingres_key: tSET_INGRES
		{
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    gr->gr_func = IISETSQL;
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
					1, ERx("SET_INGRES") );
		    eqtl_init(IISETSQL);
		}
;
set_connec_key:	tSET_CONNECT
		{
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		    /*  ANSI syntax is SET CONNECTION connection name */
		    if (eq->eq_flags & EQ_SQLSTATE)
		    {
		        gen_diaginit();
		    }
		    gr->gr_func = IISETSQL;
		    /* SET CONNECTION is only valid in FULL ANSI SQL */
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
					1, ERx("SET CONNECTION") );
		    eqtl_init(IISETSQL);
		}
;
sql_in_tl:	tLPAREN sql_in_tlist tRPAREN
;
sql_in_tlist:	tl_in_elm 
	|	sql_in_tlist tCOMMA tl_in_elm
;
tl_in_elm:	tl_attrib tEQOP tl_in_value
		{
		  /* 
		  ** We need to "gen_diaginit" to allow setting of the SQLSTATE 
		  ** for all SQL statements.  In all but one of these 
		  ** statements, we conveniently call esq_init.  So we 
		  ** gen_diaginit in there.  However,  we don't esq_init
		  ** for a SET_INGRES (SESSION = x), so we need to 
		  ** gen_diaginit here as well.  Note that SQLSTATE is valid
		  ** outside of the context of a connection; all statements
		  ** that affect a connect need to "gen_diaginit".
		  ** We also need to handle the special case of NONE
		  ** for the session ID.
		  */
		  if (!STbcompare( ERx("session"), 0, $1.s, 0, TRUE))
		  {
		      if (eq->eq_flags & EQ_SQLSTATE)
		      {
		  	gen_diaginit();
		      }
		      if ( gr->gr_type == T_NONE  &&
		           ESQ_EQSTR( gr->gr_id, ERx("none") ) )
		      {
			  /*
			  ** Produce internal session ID for NONE.
			  */
			  static char session[ 8 ];
			  CVna( IIsqsetNONE, session );
			  gr->gr_id = session;
			  gr->gr_type = T_INT;
		      }
		  }
		  eqtl_add(gr->gr_id, (PTR)gr->gr_sym, gr->gr_nlid, 
			     (PTR)gr->gr_nlsym, gr->gr_type, $1.s);
		}
;
tl_in_value: 	fm_iconst
		{
			gr->gr_id = $1.s;
			gr->gr_type = T_INT;
			gr->gr_sym = (SYM *)0;
			gr->gr_nlsym = (SYM *)0;
		}
	|	fm_sconst
		{
			gr->gr_id = $1.s;
			gr->gr_type = T_CHAR;
			gr->gr_sym = (SYM *)0;
			gr->gr_nlsym = (SYM *)0;
		}
	|	host_setvar sql_opt_ind
	|	tNAME
		{
			gr->gr_id = $1.s;
			gr->gr_type = T_NONE;
			gr->gr_sym = (SYM *)0;
			gr->gr_nlsym = (SYM *)0;
		}
;
/* 
+* Statement: EXEC SQL WHENEVER 
**		<NOT FOUND> | SQLERROR | SQLWARNING | SQLMESSAGE | DBEVENT
**		    STOP | <<GOTO | GO TO> label> | CONTINUE | <CALL routine>
-* Action:	Generate control-flow statements after each SQL statement.
** Generates:	None
** Notes:	STOP cannot be used with the NOT FOUND condition.
**		CALL is an ESQL extension.
**		Based on the condition and the action fill the static 
**	preprocessor sqlca structure, to be used at the end of each db
**	statement.
*/

whenever:	whenever_key when_cond when_action
		{
		    if ($3.i && (esq->inc & sqcaSQL) == 0)
		    {
			er_write( E_EQ0128_sqNOSQLCA, EQ_ERROR, 0 );
			esq->inc |= sqcaSQL;
		    }
		}
			
;
whenever_key:	tWHENEVER
		{
		    esq->flag |= ESQ_NOPRT;	/* Suppress printing */
		    gr_mechanism( GR_EQSTMT, GR_sNODB, $1.s, NULL );
		}
;

/* when_cond - This rule must set $$.i, as when_action uses $0.i */
when_cond:	tNAME				/* SQLERROR, SQLWARNING */
		{
		    if (ESQ_EQSTR($1.s, ERx("sqlerror")))
		    {
			$$.i = sqcaERROR;
		    }
		    else if (ESQ_EQSTR($1.s, ERx("sqlwarning")))
		    {
			$$.i = sqcaWARNING;
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
					2, ERx("SQLWARNING"), ERx("WHENEVER") );
		    }
		    else if (ESQ_EQSTR($1.s, ERx("sqlmessage")))
		    {
			$$.i = sqcaMESSAGE;
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
					2, ERx("SQLMESSAGE"), ERx("WHENEVER") );
		    }
		    else if (ESQ_EQSTR($1.s, ERx("dbevent")))
		    {
			$$.i = sqcaEVENT;
			if (eq->eq_flags & EQ_FIPS)
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
					2, ERx("DBEVENT"), ERx("WHENEVER") );
		    }
		    else
		    {
			er_write( E_EQ0130_sqWCOND, EQ_ERROR, 1, $1.s );
			$$.i = sqcaDEFAULT;
		    }
		}
	|	tNOT tNAME			/* NOT FOUND */
		{
		    if (ESQ_EQSTR($2.s, ERx("found")))
			$$.i = sqcaNOTFOUND;
		    else
		    {
			STprintf( esq->sbuf, ERx("%s %s"), $1.s, $2.s );
			er_write( E_EQ0130_sqWCOND, EQ_ERROR, 1, esq->sbuf );
			$$.i = sqcaDEFAULT;
		    }
		}
;
/* 
** when_action returns 1 if the action was not CONTINUE.  If the value of
** the SQLCA is used then the user MUST include SQLCA.
*/
when_action:	tCONTINUE
		{
		    esqlca( $0.i, sqcaCONTINUE, (char *)0 );
		    $$.i = 0;
		}
	|	tNAME tTO host_label
		{
		    esqlca( $0.i, sqcaGOTO, $3.s );
		    $$.i = 1;
		}
	|	tGOTO host_label
		{
		    esqlca( $0.i, sqcaGOTO, $2.s );
		    $$.i = 1;
		}
	|	tCALL host_label
		{
		    esqlca( $0.i, sqcaCALL, $2.s );
		    $$.i = 1;
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				    2, ERx("CALL"), ERx("WHENEVER") );
		}
	|	tSTOP
		{
		    if ($0.i == sqcaNOTFOUND)
		    {
			er_write( E_EQ0131_sqWSTOP, EQ_ERROR, 0 );
			esqlca( $0.i, sqcaCONTINUE, (char *)0 );
			$$.i = 0;
		    }
		    else
		    {
			esqlca( $0.i, sqcaSTOP, (char *)0 );
			$$.i = 1;
		    }
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN,
				    2, ERx("STOP"), ERx("WHENEVER") );
		}
;

/*
+* ---- DYNAMIC Statements ----
*/

/*
+* Statement:	DESCRIBE statementname
**			INTO | USING DESCRIPTOR   descriptorname
**			[USING NAMES]
-* Action:
** Generates:	IIsqInit( &sqlca );
**		IIsqDescribe( lang, stmt_name, &sqlda, using_flag );
*/
describe:	describe_key sql_name_or_strvar desc_sqlda desc_using
		{
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    arg_int_add( $4.i );		/* using names? */
		    gen_call( IISQDESCRIBE );
		}
;
describe_key:	tDESCRIBE
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		    gr->gr_flag |= GR_NOSYNC;
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("DESCRIBE") );
		}
;
/* ANSI update - allow USING DESCRIPTOR */
desc_sqlda:	tINTO host_sqlda
	|	tUSING tDESCRIPTOR host_sqlda
	|	tUSING tSQL tDESCRIPTOR host_sqlda
;
/* Returns value of - no USING clause, USING NAMES, USING IIADFTYPES */
desc_using:	/* EMPTY */
		{
		    $$.i = IIsqdNULUSE;
		}
	|	tUSING tNAME
		{
		    if (ESQ_EQSTR($2.s, ERx("names")))
			$$.i = IIsqdNAMUSE;
		    else if (ESQ_EQSTR($2.s, ERx("adftypes")))
			$$.i = IIsqdADFUSE;
		    else
		    {
			$$.i = IIsqdNAMUSE;
			er_write(E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					ERx("PREPARE/DESCRIBE"), ERx("NAMES"));
		    }
		}
;

/*
+* Statement:	DESCRIBE INPUT statementname
**			USING [SQL] DESCRIPTOR   descriptorname
-* Action:
** Generates:	IIsqInit( &sqlca );
**		IIsqDescInput( lang, stmt_name, &sqlda );
**
** For parsing convenience, we allow the syntax "INTO descriptorname"
** as well as "USING DESCRIPTOR".
*/
desc_input:	desc_input_key sql_name_or_strvar desc_sqlda
		{
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IISQDESCINPUT );
		}
;
desc_input_key:	tDESC_INPUT
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		    gr->gr_flag |= GR_NOSYNC;
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		}
;

/*
+* Statement:	EXECUTE statementname [USING Using_Clause]
**		EXECUTE IMMEDIATE string | varname
**		EXECUTE IMMEDIATE select_string | select_varname
**		    INTO var_name {,var_name} | USING [DESCRIPTOR] desc_name;
**		    [EXEC SQL BEGIN;
**			program code;
**		    EXEC SQL END;]
**			
-* Action:
** Generates:
**	-- EXECUTE IMMEDIATE
**		IIsqInit( &sqlca );
**		IIsqExImmed( query_string, 0 );
**		IIsyncup();
** or
**	-- EXECUTE IMMEDIATE ... INTO ... (with non-bulk SELECT)
**		IIsqInit( &sqlca );
**		IIsqMods( IImodDYNSEL );
**		IIsqMods( IImodSINGLE );
**		IIsqExImmed( query_string, 0 );
**		IIretinit();
**		if (IInextget() != 0) {
**		  IIgetdomio( var );
**		  ...
**		}
**		IIsqFlush();
** or
**	-- EXECUTE IMMEDIATE ... USING ... (with bulk SELECT)
**		IIsqInit( &sqlca);
**		IIsqMods( IImodDYNSEL );
**		IIsqExImmed( query_string, 0 );
**		IIretinit();
**		if (IIerrtest() != 0) goto IIrtE1;
**	      IIrtB1:
**		while (IInextget() != 0) {
**		  IIcsDaGet(lang, &descriptor);
**		  if IIerrtest() != 0) goto IIrtB1;
**		    program code;
**		}
**		IIflush();
**	      IIrtE1:;
** or
**	-- EXECUTE statementname
**		IIsqInit( &sqlca );
**		IIsqExStmt( statementname, 0 );
**		IIsyncup();
** or
**	-- EXECUTE statementname USING var {, var}
**		IIsqInit( &sqlca );
**		IIsqExStmt( statementname, 1 );
**		IIsetdom( var );
**		    ...
**		IIsetdom( var );
**		IIsyncup();
** or
**	-- EXECUTE statementname USING DESCRIPTOR sqlda;
**		IIsqInit( &sqlca );
**		IIsqExStmt( statementname, 0 );
**		IIsqDaIn(lang, &sqlda);
**		IIsyncup();
*/
execute:	execute_key execu_immed
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("EXECUTE IMMEDIATE") );
		}
	|	execute_key execu_stmt host_term
		{
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("EXECUTE") );
		}
;
execute_key:	tEXECUTE
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		    if (eq->eq_flags & EQ_ENDIF)
		    {
			gr->gr_flag |= GR_ENDIF;
			eq->eq_flags &= ~EQ_ENDIF;
		    }	
		}
;
execu_immed:	tIMMED execu_imm_arg host_term
		{
		    gen_call( IISQEXIMMED );
		}
	|	tIMMED execu_imm_arg execu_sel_setup execu_sel_res
		{
		    gr->gr_flag |= GR_NOSYNC;
		    esq->flag &= ~ESQ_DESC_SEL;
		}
;
execu_imm_arg:	tSCONST
		{
		    arg_str_add( ARG_CHAR, form_sconst($1.s) );
		}
	| 	host_fsetvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_CHAR)
			    arg_var_add( gr->gr_sym, gr->gr_id );
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    arg_str_add( ARG_CHAR, gr->gr_id );
			}
		    } else	/* Error in host_fsetvar */
			arg_str_add( ARG_CHAR, gr->gr_id );
		}
;
execu_sel_setup: /* Empty */
		{
		    esq_sqmods(IImodDYNSEL);
		    esq->flag |= ESQ_REG_SELECT;
		    esl_query( ESL_START_QUERY );
		    gen_call( IISQEXIMMED );
		}
;
execu_sel_res:	execu_sel_body host_term select_block
		{
		    if ($3.i)
		    {
		      /* SELECT LOOP - gen WHILE */
			/* Close retrieve loop */
			gen_loop( G_CLOSE, L_RETBEG, L_RETFLUSH,
				    lbl_current(LBL_RET), IINEXTGET, C_0, 0 );
			gen_call( IIFLUSH );
			gen_label( G_NOLOOP, L_RETEND, lbl_current(LBL_RET) );
			gr->gr_flag &= ~GR_RETRIEVE;/* Done with SELECT loop */
		    } else
		    {
		      /* SINGLETON SELECT - gen IF */
			if (eq->eq_flags & EQ_CHREOS)
			    esq_eoscall(IImodNOCEOS);
			gen_if( G_OPEN, IINEXTGET, C_NOTEQ, 0 );
			if (eq->eq_flags & EQ_CHRPAD)
			    esq_sqmods(IImodCPAD);
			if (esq->flag & ESQ_DESC_SEL)
			    erec_desc( NULL );  /* Descriptor retrieval */
			else
			    ret_close();	    /* Variable retrieval */
			if (eq->eq_flags & EQ_CHRPAD)
			    esq_sqmods(IImodNOCPAD);
			gen_if( G_CLOSE, IINEXTGET, C_0, 0 );
			gen_call( IISQFLUSH );
		    }
		}
;
execu_sel_body:	tUSING proc_desc host_sqlda
		{
		    erec_desc( gr->gr_id );	    /* Save arg for IIcsDaGet */
		    esq->flag |= ESQ_DESC_SEL;
		}
	|	into_key into_list
		{
		    erec_setup( 0 );			/* Done with list */
		}
;
execu_stmt:	sql_name_or_strvar
		{
		    arg_int_add( 0 );			/* not using vars */
		    gen_call( IISQEXSTMT );
		}
	|	execu_using execu_namelist
	|	exec_use_desc host_sqlda
		{
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IISQDAIN );
		}
;
execu_using:	sql_name_or_strvar tUSING
		{
		    arg_int_add( 1 );			/* using vars */
		    gen_call( IISQEXSTMT );
		    gr->gr_func = tEXECUTE;
		}
;
exec_use_desc:	sql_name_or_strvar tUSING tDESCRIPTOR
		{
		    arg_int_add( 0 );			/* not using vars */
		    gen_call( IISQEXSTMT );
		}
;
execu_namelist: execu_name
	|	execu_namelist tCOMMA execu_name
;
execu_name:	host_fsetvar sql_opt_ind
		{
		    db_var( DB_REG, gr->gr_sym, gr->gr_id,
			    gr->gr_nlsym, gr->gr_nlid, (char *)0 );
		}
	|	datahdlr_cls sql_opt_ind		/* Datahandler */
		{
		    db_var( DB_HDLR, gr->gr_sym, gr->gr_id,
			    gr->gr_nlsym, gr->gr_nlid, $1.s );
		}
;

/*
+* Statement:	EXECUTE PROCEDURE procname
**		      [  ( pname = paramspec {, pname = paramspec } ) |
**			 ( pname = SESSION.global_temptab_parmname) |
**			 USING [DESCRIPTOR] descname ]
**		      [RESULT ROW hostvar:optind {, hostvar:optind}
**			 BEGIN block END]
**		      [INTO result_variable]
**		where paramspec ::= param | BYREF(hostvar:optind)
-* Action:
**	Execute a database procedure - loop collecting errors/messages,
**	then optional loop to process returned row images.
** Generates:
**	IILQpriProcInit(IIPROC_EXEC, procname);
**	[
**	  IILQprvProcValio(pname, io desc of param); ...	|
**	  IIsqDaIn(lang, descname);
**	]
**	while (IILQprsProcStatus()) {
**	    process sqlca for errors/messages
**	    [ if (IIerrtest() != 0) goto IIrtEn;
**	IIrtBn:
**	    while (IInextget() != 0) {
**		IIgetdomio( vardesc1, var1);
**		IIgetdomio( vardesc2, var2); ...
**		if (IIerrtest() != 0) goto IIrtBn;
**		... host code ...
**	    }
**	IIrtEn:; ]
**         [ In cobol another IILQprsProcStatus() call added here ]
**	}
**	IIflush();
**	[ IIeqiqio(io desc of result_variable, "iiret"); ]
*/

proc_exec:	proc_exec1 result_clause host_term execute_block
		{
		    if ($2.i)
		    {
			if ($4.i == 0)
			{
			    i4	cur_ret;
			    /* No block - "singleton" execute. Insert
			    ** IInextget after "if" followed by 
			    ** getdomio's. */	
			    gen_if( G_OPEN, IINEXTGET, C_NOTEQ, 0 );
			    ret_close();
			    gen_if( G_CLOSE, IINEXTGET, C_0, 0 );
			    gen_call( IISQFLUSH );
			    _VOID_ lbl_next( LBL_RET );
			    cur_ret = lbl_current( LBL_RET );
			    gen_goto( G_TERM, L_RETEND, lbl_current(LBL_RET));
			}
			gen_label( G_NOLOOP, L_RETEND, lbl_current(LBL_RET) );
			if (gr->gr_id && eq->eq_lang == EQ_COBOL )
			{
			   arg_int_add( gr->gr_rcnt );
			}
			gen_loop( G_CLOSE,L_RETBEG, L_RETFLUSH, 
			    lbl_current(LBL_RET), IIPROCSTAT, C_NOTEQ, 0 );
			gen_call( IIFLUSH );
			erec_setup( 0 );	/* Done with list */
		    }
		}
	|	proc_exec1 result_clause proc_into host_term execute_block
		{
		    if ($2.i)
		    {
			if ($5.i == 0)
			{
			    i4	cur_ret;
			    /* No block - "singleton" execute. Insert
			    ** IInextget after "if" followed by 
			    ** getdomio's. */	
			    gen_if( G_OPEN, IINEXTGET, C_NOTEQ, 0 );
			    ret_close();
			    gen_if( G_CLOSE, IINEXTGET, C_0, 0 );
			    gen_call( IISQFLUSH );
			    _VOID_ lbl_next( LBL_RET );
			    cur_ret = lbl_current( LBL_RET );
			    gen_goto( G_TERM, L_RETEND, lbl_current(LBL_RET));
			}
			gen_label( G_NOLOOP, L_RETEND, lbl_current(LBL_RET) );
			gen_loop( G_CLOSE,L_RETBEG, L_RETFLUSH, 
			    lbl_current(LBL_RET), IIPROCSTAT, C_NOTEQ, 0 );
			gen_call( IIFLUSH );
			erec_setup( 0 );	/* Done with list */
		    }
		    arg_int_add( 0 );

		    if (tempgr.gr_type != T_INT)
			er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1, tempgr.gr_id );

		    arg_var_add(  tempgr.gr_sym, tempgr.gr_id );
		    arg_str_add( ARG_CHAR, ERx("iiret"));
		    gen_call( IIEQINQ );
		}
;

proc_into:	tINTO host_retvar
		{
		    /* Copy (*gr) for "proc_exec" to build code. */
		    STRUCT_ASSIGN_MACRO(*gr, tempgr);
		}
;

proc_exec1:	proc_exec_key proc_exec_body
;
proc_exec_body:	proc_name proc_args
;

proc_exec_key:	tEXECUTE tPROCEDURE
		{
		    gr->gr_flag |= (GR_NOSYNC | GR_PROCEXEC );
		    STprintf( esq->sbuf, ERx("%s %s"), $1.s, $2.s );
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, esq->sbuf, NULL );
		    esq_init();
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("EXECUTE PROCEDURE") );
		    arg_int_add( IIPROC_EXEC );
		    gr->gr_rcnt = 0;
		}
;
proc_name:	sql_name_or_strvar
		{
		    gen_call( IIPROCINIT );
		}
;
proc_args:	/* empty */
	|	tLPAREN tRPAREN
	|	tLPAREN sql_name_or_strvar proc_eqop tSESSION tPERIOD
					sql_name_or_strvar tRPAREN
		{
		    gen_call( IIPROCGTTP );
		}
	|	tLPAREN proc_arg_list tRPAREN
		{
		    if (esq->flag & ESQ_PROC_BYREF)
		    {
			/* procs w/BYREF params act like singleton select */
			esq_sqmods(IImodSINGLE);
		    }
		}
	|	tUSING proc_desc host_sqlda
		{
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IISQDAIN );
		}
;
proc_desc:	/* Nothing */
	|	tDESCRIPTOR
;
proc_arg_list:
		proc_named_arg
	|	proc_arg_list tCOMMA proc_named_arg
;
proc_named_arg:	sql_name_or_strvar proc_eqop proc_arg
		{
		    gen_call( IIPROCVALIO );
		}
;
proc_eqop:	tEQOP
;
proc_arg:	byref_key proc_byref_arg
	|	no_byref_key proc_arg_var
;
byref_key:	tBYREF
		{
			arg_int_add( TRUE );
		}
;
no_byref_key:	/* empty */
		{
		    arg_int_add( FALSE );
		}
;
proc_byref_arg:	tLPAREN host_fsetvar sql_opt_ind tRPAREN
		{
		    /* Null indicator argument */
		    if (gr->gr_nlsym)
			arg_var_add( gr->gr_nlsym, gr->gr_nlid );
		    else
			arg_int_add( 0 );
		    if (gr->gr_sym)
			arg_var_add( gr->gr_sym, gr->gr_id );
		    else        /* Error in host_fsetvar */
			arg_str_add( ARG_CHAR, gr->gr_id );
		    /* add var info to ret que */
		    ret_add( gr->gr_sym, gr->gr_id,
			     gr->gr_nlsym, gr->gr_nlid, NULL, 0);
		    /* there are BYREF params */
		    esq->flag |= ESQ_PROC_BYREF;
		}
;
proc_arg_var:	fm_in_val
	|	fm_null
        |       proc_arg_boolconst
;

/*
** Database procedure boolean constant argument
**   Note:  This may also work for input form statements but there is
**          no intention to add such support at this time.
*/
proc_arg_boolconst:   tFALSE
                {
                    arg_int_add(0);            /* null indicator */
                    arg_str_add(ARG_CHAR, $1.s);
                }
        |       tTRUE
                {
                    arg_int_add(0);
                    arg_str_add(ARG_CHAR, $1.s);
                }
        |       tUNKNOWN
                {
                    arg_int_add(0);
                    arg_var_add(gr->gr_null, "unknown");
                }
;

/*
** ESQL generated block.  For example:
**	EXEC SQL EXECUTE PROCEDURE proc1 (p1 = 5, p2 = 20)
**		RESULT ROW (:a, :b, :c);
**	EXEC SQL BEGIN;
**	    user code
**	EXEC SQL END;
*/

execute_block:	/* EMPTY */
		{
		    if (esq->flag & ESQ_PROC_RESULT)
		    {	/* only if there's a result clause */

			/* Add all the INTO variables and indicators */
			if ((esq->flag & ESQ_DESC_SEL) == 0)
			    erec_use( IIRETDOM, FALSE, NULL );

			if (esq->flag & ESQ_REG_SELECT)
			{
			    esl_query( ESL_SNGL_STOP_QUERY );   /* Dump the query */
			    esq->flag &= ~ESQ_REG_SELECT;
			}
			$$.i = 0;
		    }
		}
	|	execute_block_begin block_stmts execute_block_end
		{
		    {
		      /* EXECUTE LOOP - close it off */
			gen_loop( G_CLOSE, L_RETBEG, L_RETFLUSH,
				    lbl_current(LBL_RET), IINEXTGET, C_0, 0 );
			gr->gr_flag &= ~GR_RETRIEVE;/* Done with SELECT loop */
		    } 
		    $$.i = 1;
		}
;
execute_block_begin:
		tBEGIN host_term
		{
		    i4		cur_ret;

		    if (!(esq->flag & ESQ_PROC_RESULT))
			er_write( E_EQ005B_grEXLOOP, EQ_ERROR, 0);
				/* can't have block with no RESULT ROW */
		    if (eq->eq_flags & EQ_CHREOS)
			 esq_eoscall(IImodNOCEOS);

		    /* Add all the INTO variables and indicators */
		    if ((esq->flag & ESQ_DESC_SEL) == 0)
			erec_use( IIRETDOM, FALSE, NULL );

		    if (esq->flag & ESQ_REG_SELECT)
		    {
			esl_query( ESL_BULK_STOP_QUERY );   /* Dump the query */
			esq->flag &= ~ESQ_REG_SELECT;
		    }

		    /* Here's generic block-begin code */
		    _VOID_ lbl_next( LBL_RET );
		    lbl_enter_block();
		    lbl_set_mode( LBLmEXECLOOP );
		    lbl_adset( LBL_NOLEV, gr->gr_adjective );
		    gr->gr_mode = 0;
		    gr->gr_adjective = 0;
		    gr->gr_flag &= ~(GR_SQL|GR_ESQL);

		    /* Here's SELECT-specific block-begin code */
		    cur_ret = lbl_current( LBL_RET );
		    gen_if_goto( IIERRTEST, C_NOTEQ, 0, L_RETEND, cur_ret );
		    /* Open retrieve loop */
		    gen_label( G_LOOP, L_RETBEG, cur_ret );
		    gen_loop( G_OPEN, L_RETBEG, L_RETFLUSH, cur_ret,
			IINEXTGET, C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    if (esq->flag & ESQ_DESC_SEL)
			/* Descriptor retrieval */
			erec_desc( NULL );
		    else
			ret_close();		/* Variable retrieval */
		    if (eq->eq_flags & EQ_CHRPAD)
			 esq_sqmods(IImodNOCPAD);
		    gen_if_goto( IIERRTEST, C_NOTEQ, 0, L_RETBEG, cur_ret );
		    gr->gr_flag &= ~GR_SQL;
		    gr->gr_flag |= GR_RETRIEVE; /* Prevent nesting queries */
		    if (eq->eq_flags & EQ_FIPS) 
			    er_write( E_EQ0506_FIPS_CLAUSE, EQ_WARN, 2, 
			        ERx("BEGIN"), ERx("EXECUTE") );
		}
;
execute_block_end:
		tEND host_term
		{
		    lbl_exit_block();
		}
;

/* 
** into_clause - INTO hostvar {, hostvar} 
**
** The INTO clause builds a separate name list on the side.
** Upon completion of the SELECT statement the IIret calls are generated with
** the user variables.
**
** The INTO list can also be used for the FETCH statement, which will have
** set the flag argument to interface with the cursor routines at the lower
** host_intovar rule.
**
** The host_intovar can be a structure which will cause assignment to its names.
*/

result_clause:	/* no RESULT ROW */
		{
		    arg_int_add( 0 );
		    gen_loop( G_OPEN, L_RETBEG, L_RETFLUSH, 
			    lbl_next(LBL_RET), IIPROCSTAT, C_NOTEQ, 0 );
		    gen_sqlca( sqcaSQPROC );
		    if (gr->gr_id && eq->eq_lang == EQ_COBOL )
			arg_int_add( 0 );
		    gen_loop( G_CLOSE,L_RETBEG, L_RETFLUSH, 
			    lbl_current(LBL_RET), IIPROCSTAT, C_NOTEQ, 0 );

		    /* If BYREF parms, emit that code, too. */
		    if (esq->flag & ESQ_PROC_BYREF)
		    {
			/* just like in singleton selects */
			gen_if( G_OPEN, IINEXTGET, C_NOTEQ, 0 );
			/* Generate byref variable loop */
			ret_close();
			gen_if( G_CLOSE, IINEXTGET, C_0, 0 );
			gen_call( IISQFLUSH );
		    }
		    $$.i = 0;		/* indicate no result clause */
		}
		|	result_key tLPAREN result_list tRPAREN 
		{
		    arg_int_add( gr->gr_rcnt );
		    gen_loop( G_OPEN, L_RETBEG, L_RETFLUSH, 
			    lbl_next(LBL_RET), IIPROCSTAT, C_NOTEQ, 0 );
		    gen_sqlca( sqcaSQPROC );
		    $$.i = 1;		/* indicate result clause */
		}
;
result_key:	tRESULT	tROW
		{
		    if (esq->flag & ESQ_PROC_BYREF)
			er_write( E_EQ005A_grBYREF, EQ_ERROR, 0);
				/* can't have both BYREF parm & RESULT ROW */
		    erec_setup( 1 );	/* Initialize struct indicators stuff */
		    esq->flag |= ESQ_PROC_RESULT;  /* & set flag */
		}
;
result_list:	result_elm
	|	result_list result_comma result_elm
;
result_comma:	tCOMMA
		{
		    erec_setup( 0 );	/* Done with one element */
		}
;
result_elm:	host_intovar sql_opt_ind
		{
		    gr->gr_rcnt++;
		}
;

/*
+* Statement:	PREPARE statementname
**			[INTO | USING DESCRIPTOR  descriptorname [USING NAMES]]
**			FROM string | varname
-* Action:
** Generates:	IIsqInit( &sqlca );
**		IIsqPrepare( EQ_C, stmt_name, &sqlda, using_flag, &query );
*/
prepare:	prep_head prep_from
		{
		    gen_call( IISQPREPARE );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("PREPARE") );
		}
;
/* prep_head and prep_from BOTH use gr->gr_id; that's why they're separate */
prep_head:	prepare_key sql_name_or_strvar prep_into
		{
		    if (gr->gr_id && eq->eq_lang == EQ_FORTRAN )
			arg_str_add( ARG_PSTRUCT, gr->gr_id );
		    else if (gr->gr_id)			/* sqlda */
			arg_str_add( ARG_RAW, gr->gr_id );
		    else
			arg_str_add( ARG_CHAR, (char *)0 );
		    arg_int_add( $3.i );		/* using names? */
		}
;
prepare_key:	tPREPARE
		{
		    gr_mechanism( GR_EQSTMT, GR_sLIBQ, $1.s, NULL );
		    esq_init();
		    gr->gr_flag |= GR_NOSYNC;
		    arg_int_add( eq_genlang(eq->eq_lang) );  /* host language */
		}
;
prep_into:	/* EMPTY */
		{
		    gr->gr_id = NULL;
		    $$.i = 0;
		}
	|	desc_sqlda desc_using
		{
		    $$.i = $2.i;
		}
;
prep_from:	tFROM prep_name
;
prep_name:	host_fsetvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_CHAR)
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			}
		    }
		    arg_var_add( gr->gr_sym, gr->gr_id );
		}
	|	tSCONST
		{
		    arg_str_add( ARG_CHAR, form_sconst($1.s) );
		}
;

/*
** DIRECT statements for gateways and INGRES/STAR.
**
** Statement:  DIRECT CONNECT [WITH with_clause]
**	       DIRECT DISCONNECT
**	       DIRECT EXECUTE IMMEDIATE string | varname [WITH with_clause]
** Action:
**		Send db statements to gateway.
** Generates:
**	-- DIRECT CONNECT WITH node = rabbit, database = neil;
**	   IIsqInit();
**	   IIwrite("direct connect with node = rabbit, database = neil");
**	   IIsyncup();
**
**	-- DIRECT EXECUTE IMMEDIATE 'do this'
**	   IIsqInit( &sqlca );
**	   IIwrite("direct execute immediate 'do this'");
**	   IIsyncup();
*/
direct_stmt:	dir_con_key sql_opt_with_clause
	|	dir_dis_key
	|	dir_exe_key dir_exe_str sql_opt_with_clause
;
dir_con_key:	tDIR_CONNECT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("DIRECT CONNECT") );
		}
;
dir_dis_key:	tDIR_DISCONNECT
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, NULL );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("DIRECT DISCONNECT") );
		}
;
dir_exe_key:	tDIR_EXECUTE tIMMED
		{
		    gr_mechanism( GR_EQSTMT, GR_sSQL, $1.s, $2.s );
		    if (eq->eq_flags & EQ_FIPS)
			er_write( E_EQ0505_FIPS_STATMT, EQ_WARN,
				    1, ERx("DIRECT EXECUTE IMMEDIATE") );
		}
;
dir_exe_str: 	sql_sconst
	|	host_fsetvar
		{
		    if (gr->gr_sym)
		    {
			db_var( DB_STRING, gr->gr_sym, gr->gr_id,
				(SYM *)0, (char *)0, (char *)0 );
			if (gr->gr_type != T_CHAR && gr->gr_type != T_UNDEF)
			    er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else	/* Error caught in host_setvar */
			db_sconst( gr->gr_id );
		}
;

/*
+* ---- ESQL Forms  ----
-*
**	These statements all get mapped to procedure calls
**	 in the Forms Runtime library.
*/

/* 
** frs_statement: Statements to the FRS support routines, includes both regular
**		  forms statements and table field statements.
**
** Some statements allow the host_term up at this level, so we do not need to
** write special "keyword" rules for simple statements.
*/
frs_statement:	addform host_term
	|	breakdisplay host_term
	|	clear host_term
	|	describe_form host_term
	|	describe_table host_term
	|	display
	|	enddisplay host_term
	|	endforms host_term
	|	endloop host_term
	|	formdata
	|	forminit host_term
	|	forms host_term
	|	getform host_term
	|	getoper host_term
	|	help_frs host_term
	|	helpfile host_term
	|	iimessage host_term
	|	iiprompt host_term
	|	inquire_frs host_term
	|	message host_term
	|	printscreen host_term
	|	prompt host_term
	|	putform host_term
	|	redisplay host_term
	|	resume host_term
	|	set_frs host_term
	|	sleep host_term
	|	submenu
	|	validate host_term
	/* Table field statements - subset of forms */
	|	clearrow host_term
	|	deleterow host_term
	|	getrow host_term
	|	inittable host_term
	|	insertrow host_term
	|	loadtable host_term
	|	putrow host_term
	|	scroll host_term
	|	tabledata
	|	unloadtable
	|	validrow host_term
	|	purgetable host_term
;

/*
** Equel Forms Statments - These statements all get mapped to procedure calls
**			   in the Forms Runtime library.
*/

/*
+* Statement:	Forms block.
** Example:	EXEC FRS UNLOADTABLE formname tablename (target-list);
**		EXEC FRS BEGIN;
**			User code
-*		EXEC FRS END;
**
** Notes:
**	tBEGIN is returned explicitly by scanner to avoid shift/reduce
**	conflicts on a BEGIN word following the INITIALIZE statement (with
**	an optional BEGIN block).
*/

block:		block_begin block_stmts block_end 
		{
		    lbl_exit_block();
		}
;
block_begin:	tBEGIN host_term		/* Better be EXEC FRS */
		{
		    /* This token is returned via scan_ahead - see esqgtoks.c */
		    lbl_enter_block();
		    lbl_set_mode( gr->gr_mode );
		    lbl_adset( LBL_NOLEV, gr->gr_adjective );
		    gr->gr_adjective = LBLaNONE;
		    gr->gr_mode = 0;
		    gr->gr_flag &= ~(GR_QUEL|GR_SQL|GR_EQUEL);
		}
;
block_stmts:	/* No statements */
	|	block_stmts statement
		{
		    gr_mechanism( GR_STMTFREE );
		}
;
block_end:	tEND host_term		/* Better be EXEC FRS */
;

/* 
** Statement:	## ADDFORM [ framepointer | filename ] 
** Action:	Create form from user's compiled form.
** Generates:	IIaddform( argument );
** Note:	Most expect an external (FRAME *), but a filename is allowed.
**		Binary filenames must be after EQ_ADD_FNAME is defined.
*/

addform:	addform_key addform_arg
		{
		    gen_call( IIADDFORM );
		    gr->gr_flag &= ~GR_NOINDIR;
		}
;
addform_key:	tADDFORM
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gr->gr_flag |= GR_NOINDIR;
		}
;
addform_arg:	host_fsetvar		   /* Integer pointer or string */
		{
		    if (gr->gr_sym)
		    {
			arg_var_add( gr->gr_sym, gr->gr_id );
			if (gr->gr_type == T_CHAR)
			{
# ifndef EQ_ADD_FNAME
			    er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
								    gr->gr_id );
# endif /* EQ_ADD_FNAME */
			}
			else if (gr->gr_type != T_INT && gr->gr_type != T_UNDEF)
			    er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }	
		    else		/* Error already sent if not variable */
			arg_str_add( ARG_CHAR, gr->gr_id );
		}
	|	tSCONST
		{
		    arg_str_add( ARG_CHAR, $1.s );
# ifndef EQ_ADD_FNAME
		    er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1, $1.s );
# endif /* EQ_ADD_FNAME */
		}
;

/* 
** Statement:	## BREAKDISPLAY
** Action:	Jump out of a display loop.
** Generates:	[ Required loop breakout calls, ]
**		goto IIfd_exit1;
*/

breakdisplay:	tBREAKDISPLAY
		{
		    i4  form_no;

		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    if ((form_no = lbl_gen(LBLmDISPLAY, TRUE)) != LBL_NOLEV)
			gen_goto( G_IF, L_FDEND, 
				  lbl_value(LBLmDISPLAY, form_no) );
		    else
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("DISPLAY") );
		}
;

/* 
** Statement:	## CLEAR  < SCREEN  | FIELD <ALL | name list> >
** Action:	Clear screen, all fields or specified field.
** Generates:	IIclrscr(); or IIclrflds(); or
**		IIclrfield( name ); ...
*/

clear:		tCLEAR tSCREEN
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gen_call( IICLRSCR );
		}
	|	clear_field tALL
		{
		    gen_call( IICLRFLDS );
		}
	|	clear_field fm_stringlist
;
clear_field:	tCLEAR tFIELD
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gr->gr_func = IIFLDCLEAR;
		}
;

/*
** Statements:	EXEC FRS DESCRIBE FORM form_name [mode] INTO 
**		descriptor_name
**		EXEC FRS DESCRIBE TABLE form_name table_name [mode] INTO
**		descriptor_name
**
**		where mode = ALL | QUERY | UPDATE
**		If mode is blank, empty or null, default "ALL" is assumed.
**
** Action:	Retrieves into an SQLDA-type descriptor name and type 
**		information about the fields/tablefield in a form.
**		
** Generates:	IIfrsqDescribe(lang, is_form, form_name, tablename,
**				mode, descriptor_name);
**
** Notes:	- These are ESQL-only forms statements and are based on the 
**		  SQL DESCRIBE statement.  
**		- The FRS DESCRIBE statement along with the USING version of
**		  forms I/O statements (PUTFORM, GETFORM, etc.,) allow an 
**		  application to manipulate a form whose description is not 
**		  known at compile time.
**		- The DESCRIBE statement and the USING version of I/O
**		  statements do the job of the FORMDATA statement and the 
**		  PARAM versions of I/O statements.
*/
describe_form:	desc_form desc_fm_string desc_mode tINTO host_sqlda
		{
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IIFRSQDESC );
		}
;
describe_table:	desc_table fm_string fm_string desc_mode tINTO host_sqlda
		{
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IIFRSQDESC );
		}
;
desc_form:	tDESC_FORM
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_int_add( 1 );			/* is_form = TRUE */
		}
;
desc_fm_string: fm_string
		{
		    arg_str_add( ARG_CHAR, (char* )0 );	/* No table name */
		}
;
desc_table:	tDESCRIBE tTABLE
		{
		    STprintf( esq->sbuf, ERx("%s %s"), $1.s, $2.s );
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, esq->sbuf, NULL );
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_int_add( 0 );			/* is_form = FALSE */
		}
;
desc_mode:	tUPDATE
		{
		    arg_str_add( ARG_CHAR, ERx("u") );
		}
	|	tALL
		{
		    arg_str_add( ARG_CHAR, ERx("a") );
		}
	|	desc_chk_mode	
		{
		    if (*($1.s) == EOS)		/* Empty string? */
		    {
			arg_str_add( ARG_CHAR, ERx("a") );
		    }
		    else if (STbcompare( ERx("update"), 0, $1.s, 0, TRUE) == 0)
		    {
			arg_str_add( ARG_CHAR, ERx("u") );
		    }
		    else if (STbcompare( ERx("query"), 0, $1.s, 0, TRUE) == 0)
		    {
			arg_str_add( ARG_CHAR, ERx("q") );
		    }
		    else if (STbcompare( ERx("all"), 0, $1.s, 0, TRUE) == 0)
		    {
			arg_str_add( ARG_CHAR, ERx("a") );
		    }
		    else
		    {
			frs_error( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
				   ERx("FRS DESCRIBE"), ERx("ALL"));
			arg_str_add( ARG_CHAR, ERx("a") );
		    }
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_CHAR)
			    arg_var_add( gr->gr_sym, gr->gr_id );
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    arg_str_add( ARG_CHAR, gr->gr_id );
			}
		    }
		    else
		    /* Error should already have been reported */
		    {
			arg_str_add( ARG_CHAR, ERx("a") );
		    }
		}
	|	/* Default is All */
		{
		    arg_str_add( ARG_CHAR, ERx("a") );
		}
;
desc_chk_mode:	tSCONST
		{
		    $$.s = $1.s;
		}
	|	tNAME
		{
		    $$.s = $1.s;
		}
;
/*
** Display Loop - 
**
**	The Display loop is made up of the initial DISPLAY call, INITIALIZING 
**	the form, ACTIVATE statements, and FINALIZING the form.
**
**	Example:
**
**		DISPLAY form query
**		INITIALIZE ( fld = 1 )
**		ACTIVATE MENUITEM "Help":
**		{
**		    HELPFILE "subject" "file.hlp"
**		}
**		ACTIVATE MENUITEM "End", COMMAND CONTROL_Z:
**		{
**		    BREAKDISPLAY
**		}
**		FINALIZE ( var = fld )
**
** Generates for complete Display Loop:
**
**	DISPLAY	   -	if (IIdispfrm(form, mode) == 0) goto IIfd_exit1;
**							-- or IInestmu
**			goto IImu_init1;
**		IIfd_init1:
**	INITIALIZE -	if (IIfsetio(0) == 0) goto IIfd_exit1;
**			Form Input Calls
**		IIfd_begin1:
**			while ( IIrunfrm() != 0 ) {	-- or IIrunnest()
**	ACTIVATE   -	    if (IIretval() == 1) {
**				Activate 1
**			    }
**			    else if (IIretval() == 2) {
**				Activate 2
**			    }
**			    else {
**				goto IIfd_exit1;
**			    }
**	FINALIZE   -	}
**		IIfd_final1:
**			if (IIchkfrm() == 0) goto IIf_begin1;
**			Form Output Calls.
**			goto IIfd_exit1;
**	This rule  -
**		IImu_init1:
**			Activate calls and menu building.
**			goto IIfd_init1;
**		IIfd_exit1:
**			IIendfrm();			-- or IIendnest()
*/

/*
** Final production of the DISPLAY block.
** Generates:	IImu_init1:
**			Activate calls and menu building.
**			goto IIfd_init1;
**		IIfd_exit1:
**			IIendfrm();			-- or IIendnest()
*/

display:	disp_head disp_init disp_active disp_final
		{
		    i4  cur_form = lbl_current( LBL_FORM );

		    gen_label( G_NOLOOP, L_MUINIT, cur_form );
		    act_close( cur_form );
		    gen_goto( G_TERM, L_FDINIT, cur_form );
		    gen_label( G_NOLOOP, L_FDEND, cur_form );
		    if ($1.i)				/* display submenu */
			gen_call( IIENDNEST );
		    else
			gen_call( IIENDFRM );
		    lbl_exit_block();
		}
;

/* 
** Statement: 	## DISPLAY form [ mode ] [ WITH option = value 
**              ##	[(suboption=subvalue {, suboption=subvalue})]]
**	 |
** 		## DISPLAY [ SUBMENU ] form [ mode ] 
**
** Action:	Display a form with the user's mode.
** Generates:	if (IIdispfrm(form, mode) == 0) goto IIfd_exit1;
**		goto IImu_init1;
**	IIfd_init1:
** or:		if (IInestmu() == 0) goto IIfd_exit1;
**		goto IImu_init1;
** Note:	The Formdata type arguments are decommited.
**		Used to support:    [ ( form output list ) ]
** NOTE: disp_init uses the return value from disp_head!
*/

disp_head:	display_key fm_string disp_mode disp_tl 
		    fw_opt_with_clause host_term
		{
		    i4  cur_form;

		    cur_form = lbl_next( LBL_FORM );
		    lbl_enter_block();
		  /* fake a forms BEGIN/END block */
		    gr->gr_mode = LBLmDISPLAY;
		    lbl_set_mode( gr->gr_mode );
		  /* mode is DISPLAY, and adjective is DISPLAY */
		    lbl_adset( LBL_NOLEV, LBLaDISPLAY );
		    lbl_a_reset();

		    act_open();
		    gen_if_goto( IIDISPFRM, C_EQ, 0, L_FDEND, cur_form );
		    gen_goto( G_TERM, L_MUINIT, cur_form );
		    gen_label( G_NOLOOP, L_FDINIT, cur_form );
		    $$.i = 0;
		}
	|	display_key tSUBMENU host_term
		{		/* display_key sets USEMODE *now* */
		    i4  cur_form;

		    cur_form = lbl_next( LBL_FORM );
		  /* mode is DISPLAY, but adjective is NESTMU */
		    lbl_enter_block();
		    gr->gr_mode = LBLmDISPLAY;
		    lbl_set_mode( gr->gr_mode );
		    lbl_adset( LBL_NOLEV, LBLaNESTMU );
		    lbl_a_reset();

		    act_open();
		    gen_if_goto( IINESTMU, C_EQ, 0, L_FDEND, cur_form );
		    gen_goto( G_TERM, L_MUINIT, cur_form );
		    gen_label( G_NOLOOP, L_FDINIT, cur_form );
		    $$.i = 1;
		}
;
display_key:	tDISPLAY
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gr->gr_func = IIDISPFRM;
		}
;
disp_mode:	tSCONST
		{
		    frs_mode( ERx("DISPLAY/INITTABLE"), $1.s );
		}
	|	tNAME
		{
		    frs_mode( ERx("DISPLAY/INITTABLE"), $1.s );
		}
	|	tREAD
		{
		    frs_mode( ERx("DISPLAY/INITTABLE"), $1.s );
		}
	|	tUPDATE
		{
		    arg_str_add( ARG_CHAR, ERx("u") );
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_CHAR)
			    arg_var_add( gr->gr_sym, gr->gr_id );
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    arg_str_add( ARG_CHAR, gr->gr_id );
			}
		    }
		    else	/* Error in host_setvar */
			frs_mode( ERx("DISPLAY/INTTABLE"), gr->gr_id );
		}
	|	/* Default is Fill */
		{
		    arg_str_add( ARG_CHAR, ERx("f") );
		}
;
disp_tl:	tLPAREN	 /* targetlist tRPAREN */
		{
		    sc_eat( NULL, SC_NEST|SC_SEEN, ERx(")"), '(', ')' );
		    er_write( E_EQ0051_grDISPTL, EQ_ERROR, 0 );
		}
	|
;

/* 
** Statement:	## INITIALIZE [ ( form input list ) ]
**		## {
**			User code
**		## }
** Action:	Assign data to fields before displaying form.
** Generates:	[ if (IIfsetio(0) == 0) goto IIfd_exit1;
**		  IIsetfield( field, valdesc, val ); ...
**		  User code  ]
**	IIfd_begin1:
**		while ( IIrunfrm() != 0 ) {		-- or IIrunnest()
** Note:	The initialize statement is not attached to any While loop
**		or If block, so the user block needs to be explicilty 
**		generated in block languages. The gr_mode flag is set
**		temporarily for this purpose.  This cannot be solved by moving
**		around rules because of a reduce/reduce conflict with the C
**		left brace.
** NOTE: disp_init uses the return value from disp_head!
*/

disp_init:	initialize
		{
		    i4  func = IIRUNFRM;
		    i4  cur_form = lbl_current( LBL_FORM );

		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_label( G_LOOP, L_FDBEG, cur_form );
		    if ($0.i)		/* disp_head was DISPLAY SUBMENU */
			func = IIRUNNEST;
		    gen_loop( G_OPEN, L_FDBEG, L_FDFINAL, cur_form, func, 
			      C_NOTEQ, 0 );
		}
;
initialize:	init_key form_opin_tl host_term init_block
	|	/* No initialize statement */
;
init_key:	tINITIALIZE
		{
		    if (dml->dm_exec != (DML_EXEC|DML__FRS))
			er_write( E_EQ0127_sqEXECMD, EQ_ERROR, 2, ERx("FRS"),
									$1.s );
		    arg_str_add( ARG_CHAR, (char *)0 );
		    gen_if_goto( IIFSETIO, C_EQ, 0, L_FDEND,
			lbl_current(LBL_FORM) );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		    gr->gr_func = IISETFIELD;	/* In case of I/O */
		    gr->gr_mode = LBLmDISPLAY;
		}
;
init_block:	block
	|	/* No initialize block */
;

/* 
** Statement:   ## ACTIVATE [ BEFORE | AFTER ] FIELD < name | ALL > [:]
**		## ACTIVATE MENUITEM string [:]
**		## ACTIVATE < SCROLLUP | SCROLLDOWN > table [:]
**              ## ACTIVATE [ BEFORE | AFTER ] COLUMN table < col | ALL > [:]
**		## ACTIVATE frskeyN 
**		##	    [(explanation = string, validate = <on|off>)] [:]
**		## ACTIVATE DBEVENT
**		## {
**			User Code
**		## }
**		Activate objects may be joined by commas.
**
**              Note: the following old-style syntax is no longer
**              supported and will generate a preprocessor error.
**
**              ## ACTIVATE COMMAND control_char [:]
**
** Action:	Define a block of user code to execute in the Display loop.
** Generates:	if (IIretval() == 1) {
**		    Activate block 1
**		}
**		else if (IIretval() == 2) {
**		    Activate block 2
**		}
**		else {
**		    goto IIfd_exit1;
**		}
** Note:	Alot of extra labels are passed to Gen to support labelled
**		languages and the Else clause of the If-Then-Else block.
*/

disp_active:	act_list
		{
		    i4  cur_form = lbl_current( LBL_FORM );

		    gen_else( G_OPEN, II0, C_0, 0, L_0, 0, L_0, 0 ); 
		    gen_goto( G_IF, L_FDEND, cur_form );
		    gen_else( G_CLOSE, IIRETVAL, C_0, 0, L_0, 0, 
			      L_ACTEND, cur_form );
		    gr->gr_flag |= GR_ACTIVATE;
		}
	|	/* No activate blocks */
		{
		    gr->gr_flag &= ~GR_ACTIVATE;
		}
;
act_list:	act_block 
	|	act_list act_block
;
act_block:	act_key act_stmt act_term block
		{
		    gen_else( G_ELSE, IIRETVAL, C_0, 0, L_ACTELSE, 
			lbl_current(LBL_INTR), L_ACTEND, lbl_current(LBL_FORM));
		    gr->gr_mode = LBLmDISPLAY;
		}
;
act_key:	tACTIVATE
		{
		    i4  cur_intr = lbl_next( LBL_INTR );

		    if (dml->dm_exec != (DML_EXEC|DML__FRS))
			er_write( E_EQ0127_sqEXECMD, EQ_ERROR, 2, ERx("FRS"),
									$1.s );
		    gen_else( G_OPEN, IIRETVAL, C_EQ, cur_intr, L_ACTELSE,
			cur_intr, L_ACTEND, lbl_current(LBL_FORM) );
		    gr->gr_mode = LBLmDISPLAY;
		    /* Reset activate argument list */
		    act_args( FALSE, (char *)0, (char *)0, 0, (SYM *)0 );
		}
;
act_term:	host_term
		{
		    /* Reset activate argument list */
		    act_args( FALSE, (char *)0, (char *)0, 0, (SYM *)0 );
		}
;
act_stmt:	act_elm 
	|	act_stmt tCOMMA act_elm 
;
/*
** SCROLL UP/DOWN, MENUITEM, and FRSKEY set gr->gr_adjective so that the
** following block will set its adjective, which is checked by RESUME NEXT
** (a warning).
*/
act_elm:        act_entry tFIELD act_string
		{
		    act_add( ACT_FIELD, lbl_current(LBL_INTR), $1.i, $3.ip );
		    gr->gr_adjective = LBLaFIELD;
		}
	|	tMENUITEM act_string act_args /* Later all ACT's have args */
		{
		    act_add( ACT_MENU, lbl_current(LBL_INTR), 0, $2.ip );
		    gr->gr_adjective = LBLaMITEM;
		}
	|	tSCROLLUP act_string
		{
		    act_add( ACT_SCROLL, lbl_current(LBL_INTR), sclUP, $2.ip );
		    gr->gr_adjective = LBLaSCROLL;
		}
	|	tSCROLLDOWN act_string
		{
		    act_add( ACT_SCROLL,lbl_current(LBL_INTR), sclDOWN, $2.ip );
		    gr->gr_adjective = LBLaSCROLL;
		}
	|       act_entry tCOLUMN act_string act_string
		{
		    i4  cur_intr = lbl_current( LBL_INTR );

		    act_add( ACT_COLUMN, cur_intr, $1.i, $3.ip );
		    act_add( ACT_COLUMN, cur_intr, $1.i, $4.ip );
		    gr->gr_adjective = LBLaCOLUMN;
		}
	|	tCOMMAND act_comm	
		{
		    /* Old-style syntax - no longer supported */
                    er_write( E_EQ0076_grNOWUNSUPP, EQ_ERROR, 1,
                                            ERx("ACTIVATE COMMAND") );
		}
	|	act_other	/* Non-keyword activates */
;
act_entry:      /* Empty */
		{
		    $$.i = 0;
		}
	|       tNAME
		{
		    if (STbcompare($1.s, 0, ERx("after"), 0, TRUE) == 0)
		    {
			$$.i = 0;
		    }
		    else
		    {
			if (STbcompare($1.s, 0, ERx("before"), 0, TRUE) != 0)
			    er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
					ERx("ACTIVATE"), ERx("BEFORE") );
			$$.i = 1;
		    }
		}
;
act_string:	tSCONST 
		{
		    $$.ip = act_string( form_sconst($1.s) );
		}
	|	tNAME
		{
		    $$.ip = act_string( $1.s );
		}
	|	tALL		/* Can be a Menu if not used with Field */
		{
		    $$.ip = act_string( $1.s );
		}
	|	host_setvar 
		{
		    if (gr->gr_sym)
		    {
			$$.ip = act_var( gr->gr_sym, gr->gr_id );
			if (gr->gr_type != T_CHAR && gr->gr_type != T_UNDEF)
			    er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else	/* Error in host_setvar */
			$$.ip = act_string( gr->gr_id );
		}
;
act_comm:	tNAME
		{
		    $$.s = $1.s;
		}
	|	tSCONST
		{
		    $$.s = $1.s;
		}
;
/*
** ACTIVATE TIMEOUT
** ACTIVATE FRSKEYn where n >= 1 (Note: n can be 0 if -c command flag used)
** ACTIVATE FRSKEY number
** ACTIVATE DBEVENT
**
** Note: ACTIVATE FRSKEY may take a target list; ACTIVATE TIMEOUT 
** and ACTIVATE DBEVENT may not.
*/
act_other:	tNAME act_args
		{
		    char	*s = $1.s;
		    i4		keynum = 1;

    		    if (STbcompare(s, 7, ERx("timeout"), 7, TRUE) == 0)
    		    {
    			act_add(ACT_TIMEOUT, lbl_current(LBL_INTR),0,(i4 *)0);
			/* Is this the only act_elm in this ACTIVATE? */
			if (gr->gr_adjective == LBLaNONE)
			    gr->gr_adjective = LBLaTIME;
    			if ($2.i == 1)
			{
    			    er_write( E_EQ0309_actTARGET, EQ_ERROR, 1,
    				    ERx("TIMEOUT") );
    			}
    		    }
    		    else if (STbcompare(s, 5, ERx("dbevent"), 5, TRUE) == 0)
    		    {
    			act_add(ACT_EVENT, lbl_current(LBL_INTR),0,(i4 *)0);
			/* Is this the only act_elm in this ACTIVATE? */
			if (gr->gr_adjective == LBLaNONE)
			    gr->gr_adjective = LBLaEVENT;
    			if ($2.i == 1)
			{
    			    er_write( E_EQ0309_actTARGET, EQ_ERROR, 1,
    				    ERx("DBEVENT") );
    			}
			/* Activate dbevent is not allowed in a non-display
			** submenu block.
			*/
			if ((gr->gr_mode == LBLmSUBMENU))
			    er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2,
				    ERx("ACTIVATE DBEVENT"), ERx("DISPLAY") );
    		    }
		    else if (STbcompare(s, 6, ERx("frskey"), 6, TRUE) == 0)
    		    {
    			if ((CVan(s+6, &keynum) == OK) && (keynum >= 0))
    			{
    			    act_add( ACT_FRSKEY, lbl_current(LBL_INTR),
    					keynum, (i4 *)0);
    			    gr->gr_adjective = LBLaFRSKEY;
    			}
    		        else
		        {
    			    er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, s,
				    ERx("ACTIVATE"), ERx("FRSKEY1") );
    		        }
    		    }
    		    else if (STbcompare(s, 8, ERx("control_"), 0, TRUE) == 0)
    		    {
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, s,
				     ERx("COMMAND"), ERx("ACTIVATE") );
		    }
		    else
		    {
			er_write( E_EQ0301_actBAD, EQ_ERROR, 1, s );
		    }
		}
	|	tNAME act_frsnum act_args
		{
		    char	*s = $1.s;

		    /* 
		    ** ACTIVATE FRSKEY number
		    */
		    if (STbcompare(s, 0, ERx("frskey"), 0, TRUE) == 0)
		    {
    		        act_add( ACT_FRSKEY, lbl_current(LBL_INTR),
    					$2.i, (i4 *)0);
    		        gr->gr_adjective = LBLaFRSKEY;
		    }
		    else
		    {
			er_write( E_EQ0301_actBAD, EQ_ERROR, 1, s );
		    }
		}
;
act_frsnum:	tINTCONST
		{
		    i4		keynum;

    		    if ((CVan($1.s, &keynum) == OK) && (keynum >= 0))
    		    {
			$$.i = keynum;
    		    }
		    else
		    {
    		        er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
			    ERx("ACTIVATE"), ERx("FRSKEY1") );
    		    }
		}
	|	host_setvar 
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_INT && gr->gr_type != T_UNDEF)
			    er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else
		    {
			gr->gr_type = T_INT;
		    }
		    act_num(ERx("frskey"), gr->gr_id, gr->gr_type, gr->gr_sym);
		    $$.i = 1;
		}
;
act_args:	/* No target list */
		{
		    $$.i = 0;
		}
	|	tLPAREN act_alist tRPAREN
		{
		    $$.i = 1;
		}
;
act_alist:	act_aelm
	|	act_alist tCOMMA act_aelm
;
act_aelm:	act_astr fm_is act_aval
		{
		    /* It will check for errors */
		    act_args( TRUE, $1.s, $3.s, gr->gr_type, gr->gr_sym );
		}
;
act_astr:	tNAME
		{
		    $$.s = $1.s;
		}
	|	tSCONST
		{
		    $$.s = $1.s;
		}
	|	tVALIDATE
		{
		    $$.s = $1.s;
		}
	|	tACTIVATE
		{
		    $$.s = $1.s;
		}
;
act_aval:	tSCONST
		{
		    $$.s = form_sconst($1.s);
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = NULL;
		}
	|	tINTCONST
		{
		    $$.s = $1.s;
		    gr->gr_type = T_INT;
		    gr->gr_sym = NULL;
		}
	|	host_setvar 
		{
		    $$.s = gr->gr_id;
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_CHAR && gr->gr_type != T_INT &&
			    gr->gr_type != T_UNDEF)
			    er_write( E_EQ0060_grINTSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		    else
			gr->gr_type = T_CHAR;
		}
;

/* 
** Statement:	## FINALIZE [ ( form output list ) ]
** Action:	Store final field values into program variables.
** Generates:	}  - close IIrunfrm() loop.
**		[ if (IIFRitIsTimeout() != 0) goto IIFD_exit1; ]
**	    IIfd_final1:
**		if (IIchkfrm() == 0) goto IIfd_begin1;
**		[ if (IIfsetio(0) == 0) goto IIfd_exit1;
**		  IIretfield( vardesc, var, field ); ...   ]
**		goto IIfd_exit1;
*/

disp_final:	final_gen finalize
		{
		    gen_goto( G_TERM, L_FDEND, lbl_current(LBL_FORM) );
		}
;
final_gen:	/* Close main loop */
		{
		    i4  func = IIRUNFRM;
		    i4  cur_form = lbl_current( LBL_FORM );

		    if (lbl_adget(LBL_NOLEV) == LBLaNESTMU)
			func = IIRUNNEST;
		    gen_loop( G_CLOSE, L_FDBEG, L_FDFINAL, cur_form, 
			      func, C_0, 0 );
		    if ((gr->gr_flag & GR_ACTIVATE) == 0)
			gen_if_goto( IIFRISTIME,C_NOTEQ, 0, L_FDEND, cur_form );
		    gen_label( G_LOOP, L_FDFINAL, cur_form );
		    gen_if_goto( IICHKFRM, C_EQ, 0, L_FDBEG, cur_form );
		}
;
finalize:	final_key form_opout_tl host_term
	|	/* No finalize statement */
;
final_key:	tFINALIZE 
		{
		    if (dml->dm_exec != (DML_EXEC|DML__FRS))
			er_write( E_EQ0127_sqEXECMD, EQ_ERROR, 2, ERx("FRS"),
									$1.s );
		    arg_str_add( ARG_CHAR, (char *)0 );
		    gen_if_goto( IIFSETIO, C_EQ, 0, L_FDEND,
			lbl_current(LBL_FORM) );
		    gr->gr_func = IIRETFIELD;
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		}
;

/* 
** Statement:	## ENDDATA
** Action:	Jump out of a Formdata loop.
** Generates:	[ Required loop breakout calls, ]
**		goto IIfd_exit1;	
**
+* Statement:   EXEC SQL ENDDATA
-* Action:      Break out of retrieving large objects.
** Generates:   IILQled_LoEndData();
*/

enddata:	tENDDATA
		{
		  if (dml->dm_exec & DML__FRS)
                  {
		    i4  form_no;

		    gr_mechanism( GR_EQSTMT, GR_sFORMS, ERx("frs"), $1.s );
		    gr->gr_flag &= ~GR_ESQL;
		    if ((form_no = lbl_gen(LBLmFORMDATA, TRUE)) != LBL_NOLEV)
			gen_goto( G_IF, L_FDEND, 
				  lbl_value(LBLmFORMDATA, form_no) );
		    else
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("FORMDATA") );
		  }
		  else
		  {
                    gr->gr_flag |= GR_NOSYNC;
                    gr_mechanism( GR_EQSTMT, GR_sNODB, ERx("sql"), $1.s );
                    gen_call( IIENDDATA );
                    if (eq->eq_flags & EQ_FIPS)
                            er_write( E_EQ0505_FIPS_STATMT, EQ_WARN, 1,
                                ERx("ENDDATA") );
                    $$.i = 1;
                    gr->gr_flag &= ~GR_NOSYNC; /* Bug 59881 */
		  }
		}
;

/* 
** Statement:	## ENDDISPLAY
** Action:	End Display loop with validation.
** Generates:	[ Required loop breakout calls, ]
**		goto IIfd_final1;
*/

enddisplay:	tENDDISPLAY
		{
		    i4  form_no;

		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    if ((form_no = lbl_gen(LBLmDISPLAY, TRUE)) != LBL_NOLEV)
			gen_goto( G_IF, L_FDFINAL, 
				  lbl_value(LBLmDISPLAY, form_no) );
		    else
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("DISPLAY") );
		}
;

/* 
** Statement:	## ENDFORMS
** Action:	End forms system.
** Generates:	IIendforms();
*/

endforms:	tENDFORMS
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gen_call( IIENDFORMS );
		}
;

/* 
** Statement:	## ENDLOOP
** Action:	End any Equel loop, other than a Display loop.
** Generates:	[ Required loop breakout calls, ]
**		goto label;
** Notes:	Adopted from the LIBQ statements of Equel.
*/

endloop:	tENDLOOP
		{
		    i4  stop, stop_num, stop_mode;

		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    stop = lbl_gen(LBLmFORMDATA|LBLmTBLOOP, TRUE);
		    if (stop != LBL_NOLEV)
		    {
			stop_mode = lbl_get_mode( stop );
			stop_num = lbl_value( stop_mode, stop );

			switch ( stop_mode )
			{
			  case LBLmFORMDATA:
			    gen_goto( G_IF, L_FDEND, stop_num );
			    break;

			  case LBLmTBUNLD:
			  case LBLmTBDATA:
			    gen_goto( G_IF, L_TBEND, stop_num );
			    lbl_used( LBL_TBL );
			    break;
			}
		    }
		    else
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("DISPLAY") );
		}
;

/* 
** Statement:	## FORMDATA form
**		## {
**			User Code
**		## }
** Action:	Retrieve information about current form into variables.
** Generates:	if (IIdispfrm(form, "Names") == 0) goto IIfd_exit1;
**		while ( IIfnames() != 0 ) {
**		    [ IIfdata( vardesc, var, info ); ... ]
**		    User Code
**		}
**	IIfd_exit1:
**		IIendfrm();
** Note:	The IIfdata() arguments should be phased out as they were
**		replaced by INQUIRE_FRS.
*/

formdata:	formd_init host_term block
		{
		    i4  cur_form = lbl_current( LBL_FORM );

		    gen_loop( G_CLOSE, L_FDBEG, L_FDEND, cur_form, IIFNAMES,
			C_0, 0 );
		    gen_label( G_LOOP, L_FDEND, cur_form );
		    gen_call( IIENDFRM );
		}
;
formd_init:	formdata_key fm_string
		{
		    i4  cur_form;

		    cur_form = lbl_next( LBL_FORM );
		    arg_str_add( ARG_CHAR, ERx("Names") );
		    gen_if_goto( IIDISPFRM, C_EQ, 0, L_FDEND, cur_form);
		    gen_loop( G_OPEN, L_FDBEG, L_FDEND, cur_form, IIFNAMES, 
			      C_NOTEQ, 0 );
		    gr->gr_func = IIFDATA;		/* In case of I/O */
		    gr->gr_mode = LBLmFORMDATA;		/* In case of block */
		}
;
formdata_key:	tFORMDATA
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/* 
** Statement:	## FORMINIT form {, form }
** Action:	Initialize form from database.
** Generates:	IIforminit( form ); ...
*/

forminit:	forminit_key fm_stringlist
;
forminit_key:	tFORMINIT
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gr->gr_func = IIFORMINIT;
		}
;

/* 
** Statement:	## FORMS
** Action:	Start forms system.
** Generates:	IIforms( lang );
*/

forms:		tFORMS
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( eq_genlang(eq->eq_lang) );
		    gen_call( IIFORMS );
		}
;

/*
** Statement:	## GETFORM [ form ] ( form output list )
** Action:	Get data from fields into program variables.
** Generates:	if (IIfsetio(form) != 0) {
**		    IIretfield( vardesc, var, field ); ...
**		}
** Statement:	EXEC FRS GETFORM [form] USING [DESCRIPTOR] descriptor_name
** Action:	Get data from fields into SQLDA
** Generates:	if (IIfsetio(form) != 0) {
**		    IIFRsqExecute( lang, FALSE, FALSE, descriptor_name );
**		}
** Note:	The USING version of GETFORM is used in conjunction with
**		the DESCRIBE FORM statement to get data from a form
**		whose definition is not known at compile time.
*/

getform:	getform_init form_out_tl
		{
                    if (eq->eq_flags & EQ_CHRPAD)
                        esq_sqmods(IImodNOCPAD);
		    gen_if( G_CLOSE, IIFSETIO, C_0, 0 );
		}
	|	getform_init fm_sqlda
		{
                    if (eq->eq_flags & EQ_CHRPAD)
                        esq_sqmods(IImodNOCPAD);
		    gen_if( G_CLOSE, IIFSETIO, C_0, 0 );
		}
;
getform_init:	getform_key fm_opname
		{
		    gen_if( G_OPEN, IIFSETIO, C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    gr->gr_func = IIRETFIELD;
		}
;
getform_key:	tGETFORM
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/* 
** Statement:	## GETOPER [ form ] ( intvar = field {, intvar = field} )
** Action:	Pass operator constants from fields to user int variables.
** Generates:	if (IIfsetio(form) != 0) {
**		    IIgetqry( vardesc, var, field ); ...
**		}
** Note:	This statement should be decommitted (is not documented).
*/

getoper:	tGETOPER
		{
		    er_write(E_EQ0076_grNOWUNSUPP, EQ_ERROR, 1, ERx("GETOPER"));
		    YYERROR;
		}
;

/*
** Statement:	## HELP_FRS (SUBJECT = sub, FILE = filename)
** Action:	Hooks up into internal FRS help utility.
** Generates:	IIfrshelp( type, subject, filename );
** Notes:	Currently hardcoded to use the above syntax, but may be expanded
**		in the future to use a variety of target lists.
*/

help_frs:	help_frs_key help_frs_tlist
;
help_frs_key:	tHELP_FRS
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( 0 );		/* Dummy type right now */
		}
;
help_frs_tlist: tLPAREN hf_elm tCOMMA hf_elm tRPAREN
		{
		    if (STbcompare($2.s, 0, ERx("subject"), 0, TRUE) != 0)
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					    ERx("HELP_FRS"), ERx("SUBJECT") );
		    else if (STbcompare($4.s, 0, ERx("file"), 0, TRUE) != 0)
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $4.s,
					    ERx("HELP_FRS"), ERx("FILE") );
		    gen_call( IIFRSHELP );
		}
;
hf_elm:		tNAME fm_is fm_string
		{
		    $$.s = $1.s;
		}
;

/* 
** Statement:	## HELPFILE subject [,] filename
** Action:	Display screenfuls of user file.
** Generates:	IIhelpfile( subject, filename );
*/

helpfile:	helpfile_key fm_string fm_opcomma fm_string
		{
		    gen_call( IIHELPFILE );
		}
;
helpfile_key:	tHELPFILE
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/*
** Statement:	## IIMESSAGE( string {, varying arg} )
** Action:	Internal call to QAmessage for testing.
** Generates:	QAmessage( string, args ... );
*/

iimessage:	iimessage_key iiprintf_args
		{
		    gen_call( QAMESSAGE );
		}
;
iimessage_key:	tIIMESSAGE
		{ 
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/* 
** Statement:	## INQUIRE_FRS { objects }+ ( inquire_frs-list )
** Action:	Get form information into program variables.
** Generates:	if ( IIinqset(obj, ... ) != 0 ) {
**		    IIfrsinq( vardesc, var, info ); ...
**		}
** Notes:	
**  1.	Many of the sub-rules of this statement are common to SET_FRS too.
**  2.	For backward compatible reasons it may generate either "old"
**	calls or "new" calls, decided by module eqfrs.c.  To force
**	YACC into using the "old" style a special character is backed up. 
**	See eqfrs.c for notes on use and syntax history.
**	The old style is now unsupported, but we issue our own error.
*/

inquire_frs:	inq_frs_head frs_lparen inq_targlist tRPAREN
		{
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		    frs_close();
		}
;
inq_frs_head:	inq_frs_key frs_object frs_parlist
;
frs_lparen:	tLPAREN		/* YACC must be synced up to backup tMINUS */
		{
		    frs_head();
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);

		}
;
inq_frs_key:	tINQ_FRS
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    frs_inqset( FRSinq );
		}
;
frs_object:	tSCONST
		{
		    frs_object( $1.s );
		}
	|	tNAME
		{
		    frs_object( $1.s );
		}
	|	tFIELD
		{
		    frs_object( $1.s );
		}
	|	tCOLUMN
		{
		    frs_object( $1.s );
		}
	|	tTABLE
		{
		    frs_object( $1.s );
		}
	|	tROW
		{
		    frs_object( "row" );
		}
;
frs_parlist:	/* No parent-names */
	|	frs_parlist frs_parname
;
frs_parname:	tSCONST
		{
		    frs_parentname( $1.s, T_CHAR, (PTR)0 );
		}
	|	tNAME
		{
		    frs_parentname( $1.s, T_CHAR, (PTR)0 );
		}
	|	tINTCONST
		{
		    frs_parentname( $1.s, T_INT, (PTR)0 );
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_CHAR && gr->gr_type != T_INT)
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    frs_parentname( gr->gr_id, T_CHAR, (PTR)0 );
			}
			else
			    frs_parentname( gr->gr_id, gr->gr_type, (PTR)(gr->gr_sym) );
		    }
		    else	/* Error in host_setvar */
			frs_parentname( gr->gr_id, T_CHAR, (PTR)0 );
		}
;
/* 
** INQUIRE_FRS target list:
**		var = frs_const[(frs_name)], ...
*/
inq_targlist:	inq_tlist
	|	tMINUS /* inq_oldtlist */	/* See eqfrs.c for tMINUS */
		{
		    er_write( E_EQ0077_grISUNSUPP, EQ_ERROR, 1,
							ERx("INQUIRE_FRS") );
		    YYERROR;
		}
;
inq_tlist:	inq_elm
	|	inq_tlist tCOMMA inq_elm
;
inq_elm:	inq_var_is frs_constant
;
inq_var_is:	host_retvar sql_opt_ind fm_is
		{
		    frs_iqvar( gr->gr_id, gr->gr_type, gr->gr_sym,
			gr->gr_nlid, gr->gr_nlsym );
		}
;
frs_constant:	frs_constname
		{
		    frs_constant( $1.s, (char *)0, T_NONE, (SYM *)0 );
		}
	|	frs_constname tLPAREN tRPAREN
		{
		    er_write( E_EQ0054_grNOPARENS, EQ_ERROR, 0 );
		    frs_constant( $1.s, (char *)0, T_NONE, (SYM *)0 );
		}
	|	frs_constname tLPAREN frs_constobj tRPAREN
		{
		    /* Should be an error */
		    frs_constant( $1.s, $3.s, gr->gr_type, gr->gr_sym );
		}
;
/* Host languages should look at the table in eqfrs.c (ie: PASCAL uses tTYPE) */
frs_constname:	tNAME
		{
		    $$.s = $1.s;
		}
	|	tSCONST
		{
		    $$.s = $1.s;
		}
	|	tVALIDATE
		{
		    $$.s = $1.s;
		}
	|	tACTIVATE
		{
		    $$.s = $1.s;
		}
	|	tFIELD
		{
		    $$.s = $1.s;
		}
	|	tCOLUMN
		{
		    $$.s = $1.s;
		}
	|	tCOMMAND
		{
		    $$.s = $1.s;
		}
	|	tTABLE
		{
		    $$.s = $1.s;
		}
	|	tROWS
		{
		    $$.s = $1.s;
		}
	|	tEXISTS
		{
		    $$.s = $1.s;
		}
;
frs_constobj:	tSCONST
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tNAME
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tINTCONST
		{
		    $$.s = $1.s;
		    gr->gr_type = T_INT;
		    gr->gr_sym = (SYM *)0;
		}
	|	tSCROLLUP
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tSCROLLDOWN
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tCLEAR
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tMENUITEM
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tPRINTSCREEN
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tCOLUMN
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	tFIELD
		{
		    $$.s = $1.s;
		    gr->gr_type = T_CHAR;
		    gr->gr_sym = (SYM *)0;
		}
	|	host_setvar
		{
		    $$.s = gr->gr_id;
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_CHAR && gr->gr_type != T_INT)
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    gr->gr_type = T_CHAR;
			    gr->gr_sym = (SYM *)0;
			}
		    }
		    else	/* Error in host_setvar */
			gr->gr_type = T_CHAR;
		}
;

/*
** Statement:	## IIPROMPT( string {, varying arg} )
** Action:	Internal call to QAprompt for testing.
** Generates:	QAprompt( string, args ... );
*/

iiprompt:	iiprompt_key iiprintf_args
		{
		    gen_call( QAPROMPT );
		}
;
iiprompt_key:	tIIPROMPT
		{ 
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/* 
** Statement: ## MESSAGE text [WITH option = value 
**            ##	[(suboption=subvalue {, suboption=subvalue})]]
**
** Action:	Print message in area of a form indicated by with clause
** Generates:	
**		IIFRgpcontrol( FSP_OPEN );
**		IIFRgpset(id(p1),...);
**		IIFRgpcontrol( FSP_CLOSE );
** 		IImessage( text );
*/

message:    	message_key fm_qstring fw_opt_with_clause 
        	{
		    gen_call( IIMESSAGE ); 
    		}
;
message_key:	tMESSAGE
    		{
            	    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
    	    	    gr->gr_func = IIMESSAGE;
		}
;

/*
** Syntax: 
**     WITH option = value [(suboption=subvalue {, suboption=subvalue})]
**	  [ {, option = value [(suboption=subvalue {, suboption=subvalue})]}]
**
**	where 	option 	= style
**	      	value 	= popup | fullscreen
**
**		suboption = startrow | startcolumn | rows | columns 
**		subvalue  = sconst | iconst | ivar 
**
** Note:  gr->gr_func must have been set to the function
**        owning the with clause
*/
fw_opt_with_clause: fw_with_clause
		| 	/* No forms with clause */	
;
fw_with_clause: fw_with fw_option_list
		{
		    EQFW3glgen();	
		}
;
fw_with:	tWITH
		{
		    EQFWopen(gr->gr_func);
		}
;
fw_option_list: fw_option_clause 
	    |   fw_option_list tCOMMA fw_option_clause
;
fw_option_clause:
		fw_option fw_opt_suboption_list
;

/*
**  STYLE = POPUP
**  STYLE = FULLSCREEN
*/
fw_option: 	fw_option_lhs tEQOP fw_option_rhs
		{
		    EQFWwcoption($1.s, $3.s);
		}
;
fw_option_lhs:	tNAME
		{
		    $$.s = $1.s;
		}		
 	    |   tSCONST
		{
		    $$.s = $1.s;
		}		
;
fw_option_rhs:	tNAME
		{
		    $$.s = $1.s;
		}
 	    |   tSCONST
		{
		    $$.s = $1.s;
		}		
;
fw_opt_suboption_list: tLPAREN fw_suboption_list tRPAREN 
	|     	
;
fw_suboption_list:
	    	fw_suboption
	    |	fw_suboption_list tCOMMA fw_suboption	
;
/*
** fw_suboption:
**		fw_suboption_lhs = fw_suboption_rhs
**
**	where fw_suboption_lhs is:
**		startrow | startcol | rows | columns 
**
**	where fw_suboption_rhs is:
**		default | floating | decimal | iconst | ivar | none  
**
** NOTE: Validation of lhs-rhs-statement combinations is performed in the
**	 EQFW routines and is based on tables found in that unit. 
*/
fw_suboption:	fw_suboption_lhs tEQOP fw_suboption_rhs
	{
		EQFWsuboption($1.s, gr->gr_type, gr->gr_id, (PTR)gr->gr_sym);
	}
;
fw_suboption_lhs:	tNAME
		{
	    	    $$.s = $1.s;
	        }
 	    |   tSCONST
		{
		    $$.s = $1.s;
		}		
 	    |   tROWS
		{
		    $$.s = $1.s;
		}		
;
fw_suboption_rhs:  
	     	fm_iconst
	    	{
	    	    gr->gr_sym = (SYM *)0;
	    	    gr->gr_type = T_INT;
	    	    gr->gr_id = $1.s;
	    	}
	|	fm_sconst
	    	{
	    	    gr->gr_sym = (SYM *)0;
	    	    gr->gr_type = T_CHAR;
	    	    gr->gr_id = $1.s;
	    	}
	|	fm_fconst
	    	{
	    	    gr->gr_sym = (SYM *)0;
	    	    gr->gr_type = T_FLOAT;
	    	    gr->gr_id = $1.s;
	    	}
	|	fm_dconst
	    	{
	    	    gr->gr_sym = (SYM *)0;
	    	    gr->gr_type = T_PACKASCHAR;
	    	    gr->gr_id = $1.s;
	    	}
        |    	host_setvar
	    	{
		    if (!gr->gr_sym)
		    {
			gr->gr_type = T_CHAR;
		    }	
		}
	|	tNAME
	    	{
	    	    gr->gr_sym = (SYM *)0;
	    	    gr->gr_type = T_CHAR;
	    	    gr->gr_id = $1.s;
	    	}
	|       tCURRENT
		{
		    gr->gr_sym = (SYM *)0;
		    gr->gr_type = T_CHAR;
		    gr->gr_id = $1.s;
		}
	|	tDEFAULT
		{
		    gr->gr_sym = (SYM *)0;
		    gr->gr_type = T_CHAR;
		    gr->gr_id = $1.s;
		}
;

/* 
** Statement:	## PRINTSCREEN [ ( file = file-name ) ]
** Action:	Dump screen to a file.
** Generates:	IIprnscr( file-name );
*/

printscreen:	printscr_key prnscr_tlist
		{
		    gen_call( IIPRNSCR );
		}
;
printscr_key:	tPRINTSCREEN
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;
prnscr_tlist:	tLPAREN prnscr_nm fm_is fm_string tRPAREN
		{
		    /* Should check that $2.s is "file" */
		    if (STbcompare($2.s, 0, ERx("file"), 0, TRUE) != 0)
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $2.s,
					    ERx("PRINTSCREEN"), ERx("FILE") );
		}
	|	/* No file specified */
		{
		    arg_str_add( ARG_CHAR, (char *)0 );
		}
;
prnscr_nm:	tNAME
		{
		    $$.s = $1.s;
		}
;

/* 
** Statement:	## PROMPT [NOECHO] ( message, buffer )
**          	##     [WITH option = value 
**		##     [(suboption=subvalue {, suboption=subvalue})]]
** Action:	Display message, store user response in buffer.
** Generates:	
**		IIFRgpcontrol(FSP_OPEN);
**		IIFRgpset(id(p1),);
**		IIFRgpcontrol(FSP_CLOSE);
** 		IIdoprompt( message, buffer ); | IIneprompt( message, buffer );
** Note:	Can use the STprintf() style format for C - allow parenthesis.
**		These parenthesis were also allowed for Fortran.
*/
prompt:	     	prompt_key pr_noecho tLPAREN fm_qstring tCOMMA pr_buffer tRPAREN
		fw_opt_with_clause
		{
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    gen_call( IINPROMPT );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);

		}
;
prompt_key:	tPROMPT
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gr->gr_func = IINPROMPT;
		}
;
pr_noecho:	tNAME
		{
		    if (STbcompare($1.s, 0, ERx("noecho"), 0, TRUE) != 0)
			er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
						ERx("PROMPT"), ERx("NOECHO") );
		    arg_int_add( 1 );
		}
	|	/* Regular prompt */
		{
		    arg_int_add( 0 );
		}
;
pr_buffer:	host_retvar sql_opt_ind
		{
		    /* Null indicator argument */
		    if (gr->gr_nlsym)
			arg_var_add( gr->gr_nlsym, gr->gr_nlid );
		    else
			arg_int_add( 0 );

		    /* Prompt buffer argument */
		    if (gr->gr_sym)
		    {
			if ((gr->gr_type == T_CHAR) || (gr->gr_type == T_DBV))
			{
			    arg_var_add( gr->gr_sym, gr->gr_id );
			} else
			{
			    arg_str_add( ARG_CHAR, gr->gr_id );
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								gr->gr_id );
			}
		    } else
		    {
			arg_str_add( ARG_CHAR, gr->gr_id );
			if (gr->gr_type != T_UNDEF)
			    er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		}
;



/*
** Statement:	## PUTFORM [ form ] ( form input list )
** Action:	Pass data from program variables to fields.
** Generates:	if (IIfsetio(form) != 0) {
**		    IIsetfield( field, valdesc, val ); ...
**		}
** Statement:	EXEC FRS PUTFORM [form] USING [DESCRIPTOR] descriptor_name
** Action:	Pass data from SQLDA into fields.
** Generates:	if (IIfsetio(form) != 0) {
**		    IIFRsqExecute( lang, TRUE, FALSE, descriptor_name );
**		}
** Note:	The USING version of PUTFORM is used in conjunction with
**		the DESCRIBE FORM statement to put data into a form
**		whose definition is not known at compile time.
*/

putform:	putform_init form_in_tl
		{
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IIFSETIO, C_0, 0 );
		}
	|	putform_init fm_sqlda
		{
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IIFSETIO, C_0, 0 );
		}
;
putform_init:	putform_key fm_opname
		{
		    gen_if( G_OPEN, IIFSETIO, C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		    gr->gr_func = IISETFIELD;
		}
;
putform_key:	tPUTFORM
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/* 
** Statement:	## REDISPLAY
** Action:	Display data in form before returning control to IIrunfrm.
** Generates:	IIredisp();
*/

redisplay:	tREDISPLAY
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gen_call( IIREDISP );
		}
;

/* 
** Statement:   ## RESUME [ FIELD name | COLUMN table col | NEXT | MENU |
**                          ENTRY | NEXTFIELD | PREVIOUSFIELD ]
** Action:	Exit Activate block and transfer control to specified object.
** Generates:	[ Required loop breakout calls, ]
**		IIresnext();	-- disallowed in ACTIVATE SCROLL UP/DOWN
**	or:	IIresfld( field );
**	or:	IIrescol( table, column );
**	or:	IIresmu();
**      or:     IIFRreResEntry();
**	or:	IIFRgotofld(direction);
**		goto IIfd_begin1;
*/

resume:		resume_key resume_args
		{
		    i4  form_no;

		    if ((form_no = lbl_gen(LBLmDISPLAY, TRUE)) != LBL_NOLEV)
		    {
    			if ($2.s &&
		            lbl_adget(form_no) == LBLaEVENT)
			{
			    /* Only a "plain" RESUME is allowed in an
			    ** ACTIVATE DBEVENT block
			    */
			    er_write( E_EQ0310_actBADRES, EQ_ERROR, 2, $2.s,
					ERx("DBEVENT") );
			}
			else
			{
			    gen_goto( G_IF, L_FDBEG, 
				  lbl_value(LBLmDISPLAY, form_no) );
			}
		    }	
		    else
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("DISPLAY") );
		}
;
resume_key:	tRESUME
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;
resume_args:	/* Resume to display loop */
		{
		    $$.s = (char *)0;	
		}
	|	tNEXT
		{
		    i4		form_no;

		    $$.s = $1.s;	
		    /* No RESUME NEXT unless we're in a DISPLAY loop */
		    if ((form_no = lbl_gen(LBLmDISPLAY, FALSE)) != LBL_NOLEV)
		    {
			switch (lbl_adget(form_no))
			{

			  /* RESUME should not be allowed on activate SCROLL,
			  ** FRSKEY or MENUITEM; however we don't give an
			  ** error on LBLaSCROLL, LBLaFRSKEY and LBLaMITEM
			  ** for backward compatibility reasons.
			  */
			  case LBLaTIME:
			    er_write( E_EQ0307_actRESNEXT, EQ_WARN, 1,
						ERx("TIMEOUT") );
			    break;
			  default:
			    break;
			}
			gen_call( IIRESNEXT );
		    }
		}
	|	tFIELD fm_string
		{
		    $$.s = $1.s;	
		    gen_call( IIRESFLD );
		}
	|	tCOLUMN fm_string fm_string
		{
		    $$.s = $1.s;	
		    gen_call( IIRESCOL );
		}
	|       resume_name
		{
		    i4		stop;	

		    $$.s = $1.s;	
		    /* find the nearest DISPLAY or SUBMENU block, if any */
		    stop = lbl_gen( LBLmDISPLAY|LBLmSUBMENU, FALSE );

		    if (STbcompare($1.s, 0, ERx("entry"), 0, TRUE) == 0)
		    {
			/* Warning if nearest block is not a DISPLAY block */
			if ((stop != LBL_NOLEV)
				&& (lbl_get_mode(stop) == LBLmSUBMENU))
			    er_write( E_EQ0058_grINLOOP, EQ_WARN, 2,
					ERx("RESUME ENTRY"), ERx("DISPLAY") );
			else
			    gen_call( IIFRRERESENTRY );
		    }	
		    else if (STbcompare($1.s, 0, ERx("nextfield"), 0,
			TRUE) == 0)
		    {
			/* Warning if nearest block is not a DISPLAY block */
			if ((stop != LBL_NOLEV)
				&& (lbl_get_mode(stop) == LBLmSUBMENU))
			{
			    er_write( E_EQ0058_grINLOOP, EQ_WARN, 2,
					ERx("RESUME NEXTFIELD"),
					ERx("DISPLAY") );
			}
			else
			{
			    arg_int_add( IIFRresNEXT );
			    gen_call( IIFRNXTPRVFLD );
			}
		    }
		    else if (STbcompare($1.s, 0, ERx("previousfield"), 0,
			TRUE) == 0)
		    {
			/* Warning if nearest block is not a DISPLAY block */
			if ((stop != LBL_NOLEV)
				&& (lbl_get_mode(stop) == LBLmSUBMENU))
			{
			    er_write( E_EQ0058_grINLOOP, EQ_WARN, 2,
					ERx("RESUME PREVIOUSFIELD"),
					ERx("DISPLAY") );
			}
			else
			{
			    arg_int_add( IIFRresPREV );
			    gen_call( IIFRNXTPRVFLD );
			}
		    }
		    else
		    {
		        if (STbcompare($1.s, 0, ERx("menu"), 0, TRUE) != 0)
			    er_write( E_EQ0069_grBADWORD, EQ_ERROR, 3, $1.s,
						ERx("RESUME"), ERx("MENU") );
			/* error if nearest one is not a DISPLAY block */
		    	if ((stop != LBL_NOLEV)
			        && (lbl_get_mode(stop) == LBLmSUBMENU))
			    er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2,
					ERx("RESUME MENU"), ERx("DISPLAY") );
		    	else
			    gen_call( IIRESMU );
		    }			
		}
;
resume_name:    tNAME   /* extra rule to allow PL1 keyword ENTRY */
		{
		    $$.s = $1.s;
		}
;

/* 
** Statement:	## SET_FRS { objects }+ ( set_frs-list )
** Action:	Set form information from program values.
** Generates:	if ( IIinqset(obj, ... ) != 0 ) {
**		    IIfrsset( vardesc, var, info ); ...
**		}
** Notes:	See Notes for INQUIRE_FRS for special cases.
*/

set_frs:	set_frs_head frs_lparen setf_targlist tRPAREN
		{
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    frs_close();
		}
;
set_frs_head:	set_frs_key frs_object frs_parlist
;
set_frs_key:	tSET_FRS
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    frs_inqset( FRSset );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		}
;
/* 
** SET_FRS target list:
**		frs_const[(frs_name)] = value, ...
*/
setf_targlist:	setf_tlist
;
setf_tlist:	setf_elm
	|	setf_tlist tCOMMA setf_elm
;
setf_elm:	frs_constant fm_is setf_val
;
setf_val:	tSCONST
		{
		    frs_setval( form_sconst($1.s), T_CHAR, (SYM *)0,
			(char *)0, (SYM *)0 );
		}
	|	tINTCONST
		{
		    frs_setval( $1.s, T_INT, (SYM *)0, (char *)0, (SYM *)0 );
		}
	|	tFLTCONST
		{
		    er_write( E_EQ0059_grINT, EQ_ERROR, 1, $1.s );
		    frs_setval(ERx("0"), T_INT, (SYM *)0, (char *)0, (SYM *)0);
		}
	|	tDECCONST
		{
		    er_write( E_EQ0059_grINT, EQ_ERROR, 1, $1.s );
		    frs_setval(ERx("0"), T_INT, (SYM *)0, (char *)0, (SYM *)0);
		}
	|	tUPDATE
		{
		    frs_setval( $1.s, T_CHAR, (SYM *)0, (char *)0, (SYM *)0 );
		}
	|	tREAD
		{
		    frs_setval( $1.s, T_CHAR, (SYM *)0, (char *)0, (SYM *)0 );
		}
	|	tNAME
		{
		    if (ESQ_EQSTR($1.s, ERx("off")))
		        frs_setval( ERx("0"), T_INT, (SYM *)0, (char *)0,
					(SYM *)0 );
		    else if (ESQ_EQSTR($1.s, ERx("bell")))
		        frs_setval( ERx("2"), T_INT, (SYM *)0, (char *)0,
					(SYM *)0 );
		    else
		        frs_setval( $1.s, T_CHAR, (SYM *)0, (char *)0,
					(SYM *)0 );
		}
	|	host_setvar sql_opt_ind
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type != T_CHAR && gr->gr_type != T_INT)
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    frs_setval( gr->gr_id, T_CHAR, (SYM *)0,
					(char *)0, (SYM *)0 );
			}
			else
			    frs_setval( gr->gr_id, gr->gr_type, gr->gr_sym,
					gr->gr_nlid, gr->gr_nlsym );

		    }
		    else	/* Error in host_fsetvar */
			frs_setval( gr->gr_id, T_CHAR, (SYM *)0, (char *)0,
                                    (SYM *)0 );
		}
	|	tON
		{
		    frs_setval( ERx("1"), T_INT, (SYM *)0, (char *)0,
				(SYM *)0 );
		}
;

/* 
** Statement:	## SLEEP sec
** Action:	Sleeps for sec seconds
** Generates:	IIsleep( sec );
*/

sleep:		sleep_key fm_int
		{
		    gen_call( IISLEEP );
		}
;
sleep_key:	tSLEEP
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/*
** Statement:	## SUBMENU
**		## ACTIVATE MENUITEM menu [:]
**		   ...
** Action:	Display nested menus, and menus without a form.
**		These are plain submenus; nested menus are now truly
**		recursive displays, and are part of the DISPLAY rules.
** Generates:	goto IImu_init1;
**	    IIfd_begin1:
**		IIrunmu( 0 );
**		if (IIretval() == 1) {
**		    Activate 1
**		}
**		else if (IIretval() == 2) {
**		    Activate 2
**		}
**		else {
**		    goto IIfd_exit1;
**		}
**		goto IIfd_exit1;
**	    IImu_init1:
**		IImuonly();
**		Activate menuitem calls.
**		goto IIfd_begin1;
**	    IIfd_exit:
*/

submenu:	submenu_head submenu_active
		{
		    i4  cur_form = lbl_current( LBL_FORM );

		    gen_else( G_OPEN, II0, C_0, 0, L_0, 0, L_0, 0 ); 
		    gen_goto( G_IF, L_FDEND, cur_form );
		    gen_else( G_CLOSE, IIRETVAL, C_0, 0, L_0, 0, 
			      L_ACTEND, cur_form );
		    gen_goto( G_TERM, L_FDEND, cur_form );
		    gen_label( G_NOLOOP, L_MUINIT, cur_form );
		    gen_call( IIMUONLY );
		    act_close( cur_form );
		    gen_goto( G_TERM, L_FDBEG, cur_form );
		    gen_label( G_NOLOOP, L_FDEND, cur_form );
		}	
;
submenu_head:	submenu_key host_term
;
submenu_key:	tSUBMENU
		{
		    i4  cur_form = lbl_next( LBL_FORM );

		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    gen_goto( G_TERM, L_MUINIT, cur_form );
		    gen_label( G_NOLOOP, L_FDBEG, cur_form );
		    arg_int_add( 0 );
		    gen_call( IIRUNMU );
		    lbl_a_reset();
		    act_open();
		}
;
submenu_active: submu_actstmt
	|	submenu_active submu_actstmt
;
submu_actstmt:	submu_actkey submu_clause act_term block 
		{
		    gen_else( G_ELSE, IIRETVAL, C_0, 0, L_ACTELSE, 
			lbl_current(LBL_INTR), L_ACTEND, 
			lbl_current(LBL_FORM) );
		    gr->gr_mode = LBLmSUBMENU;
		}
;
/* Set mode to SUBMENU here so we can detect ACTIVATE DBEVENT error later on */
submu_actkey:	act_key
		{
		    gr->gr_mode = LBLmSUBMENU;	/* Not LBLmDISPLAY */
		}
;
submu_clause:	submu_elm 
		{
		    gr->gr_mode = LBLmSUBMENU;	/* Not LBLmDISPLAY */
		}
	|	submu_clause tCOMMA submu_elm 
		{
		    gr->gr_mode = LBLmSUBMENU;	/* Not LBLmDISPLAY */
		}
;
submu_elm:	tMENUITEM act_string act_args
		{
		    act_add( ACT_MENU, lbl_current(LBL_INTR), 0, $2.ip );
		    gr->gr_adjective = LBLaMITEM;
		}
	|	act_other	/* Non-keyword activates */
;

/* 
** Statement:	## VALIDATE [ FIELD name ]
** Action:	Validate data on form or field.
** Generates:	if (IIvalfld(field) == 0) {
**	or:	if( IIchkfrm() == 0 ) {
**		    [ Break out of Equel loops ]
**		    goto IIfd_begin1;
**		}
** Note:	May also generate breakout code of active Equel loops.
*/

validate:	validate_key validate_args
		{
		    i4  form_no;

		    gen_if( G_OPEN, gr->gr_func, C_EQ, 0 );
		    if ((form_no = lbl_gen(LBLmDISPLAY, TRUE)) != LBL_NOLEV)
			gen_goto( G_NOTERM, L_FDBEG, 
				  lbl_value(LBLmDISPLAY, form_no) );
		    else
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("DISPLAY") );
		    gen_if( G_CLOSE, gr->gr_func, C_EQ, 0 );
		}
;
validate_key:	tVALIDATE
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;
validate_args:	/* Validate the form */
		{
		    gr->gr_func = IICHKFRM;
		}
	|	tFIELD fm_string
		{
		    gr->gr_func = IIVALFLD;
		}
;

/*
** Equel Table Field Statements - These statements get mapped to calls
**				  in the Forms Runtime or Tbacc libraries.
*/

/*
** Statement:	## CLEARROW form table [row] [ ( column list ) ]
** Action:	Clears columns of table field row. Clear row if no columns.
** Generates:	if (IItbsetio(cmCLEAR, form, table, row) != 0) {
**		    IItclrrow();
**	or:	    IItclrcol( col ); ...
**                      ...
**                  IITBceColEnd();
**		}
*/

clearrow:	clearrow_init clearrow_tlist
		{
		    gen_call( IITBCECOLEND );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;
clearrow_init:	clearrow_key fm_string fm_string fm_row
		{
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
		    gr->gr_func = IITCLRCOL;
		}
;
clearrow_key:	tCLEARROW
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmCLEARR );
		}
;
clearrow_tlist: tLPAREN fm_stringlist tRPAREN
	|	tLPAREN tRPAREN
		{
		    er_write( E_EQ0054_grNOPARENS, EQ_ERROR, 0 );
		    gen_call( IITCLRROW );
		}
	|	/* No target list */
		{
		    gen_call( IITCLRROW );
		}
;

/* 
** Statement:	## DELETEROW form table [row]
**			  [ OUT ( form output list ) ]
**			  [ IN	( form	input list ) ]
** Action:	Delete row specified by user.  IN / OUT target lists can 
**		specify where data is coming from / going to. 
** Generates:	if (IItbsetio(cmDELR, form, table, row) != 0) {
**	OUT:	    [ IItcolret( vardesc, var, col ); ... ]
**		    if (IItdelrow(INflag) != 0) {
**	 IN:		[ IItcolset( col, vardesc, var ); ... ]
**		    }
**		}
** Note:	Code generated may vary based on the target lists.
*/

deleterow:	delrow_init delr_out delr_in
		{
		    /* Close inner and deleterow if blocks */
		    gen_if( G_CLOSE, IITDELROW, C_0, 0 );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;
delrow_init:	deleterow_key fm_string fm_string fm_row
		{
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
                    if (eq->eq_flags & EQ_CHRPAD)
                        esq_sqmods(IImodCPAD);
                    if (eq->eq_flags & EQ_CHREOS)
                        esq_sqmods(IImodCEOS);
		    gr->gr_func = IITCOLRET;	/* May be an Out list */
		}
;
deleterow_key:	tDELETEROW
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmDELETER );
		}
;
delr_out:	/* No Out list */
	|	tOUT form_out_tl
		{
		    if (eq->eq_flags & EQ_VERSWARN)
			er_write( E_EQ0078_grSTYUNSUPP, EQ_WARN, 1,
							ERx("DELETEROW OUT") );
		}
;
delr_in:	/* No In list */
		{
		    arg_int_add( FALSE );
		    gen_if( G_OPEN, IITDELROW, C_NOTEQ, 0 );
		}
	|	del_in_key form_in_tl
		{
		    if (eq->eq_flags & EQ_VERSWARN)
			er_write( E_EQ0078_grSTYUNSUPP, EQ_WARN, 1,
							ERx("DELETEROW IN") );
		}
;
del_in_key:	tIN 
		{
		    arg_int_add( TRUE );	/* In list */
		    gen_if( G_OPEN, IITDELROW, C_NOTEQ, 0 );
		    gr->gr_func = IITCOLSET;
		}
;

/* 
** Statement:	## GETROW form table [row] ( form output list )
** Action:	Fill user variables with table field data.
** Generates:	if (IItbsetio(cmGETR, form, table, row) != 0) {
**		    IItcolret( vardesc, var, col ); ...
**                      ...
**                  IITBceColEnd();
**		}
** Statement    EXEC FRS GETROW form table [row] USING [DESCRIPTOR] desc_name
** Action:	Fill sqlda with table field data.
** Generates:	if (IItbsetio(cmGETR, form, table, row) != 0) {
**		    IIFRsqExecute( lang, FALSE, FALSE, desc_name );
**                  IITBceColEnd();
**		}
** Note:	The USING version of GETROW is used in conjunction with
**		the DESCRIBE TABLE statement to get data from a table
**		whose definition is not known at compile time.
*/

getrow:		getr_init form_out_tl
		{
                    if (eq->eq_flags & EQ_CHRPAD)
                        esq_sqmods(IImodNOCPAD);
		    gen_call( IITBCECOLEND );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
	|	getr_init fm_sqlda
		{
                    if (eq->eq_flags & EQ_CHRPAD)
                        esq_sqmods(IImodNOCPAD);
		    gen_call( IITBCECOLEND );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;
getr_init:	getrow_key fm_string fm_string fm_row
		{
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
                    if (eq->eq_flags & EQ_CHRPAD)
                        esq_sqmods(IImodCPAD);
		    gr->gr_func = IITCOLRET;
		}
;
getrow_key:	tGETROW
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmGETR );
		}
;

/* 
** Statement:	## INITTABLE form table [ mode ] [ (col = type {, col = type}) ]
** Action:	Initialize table field [with hidden columns] and table modes.
** Generates:	if (IItbinit(form, table, mode) != 0) {
**		    [ IIthidecol( col, ingtype ); ... ]
**		    IItfill();
**		}
** Note:	If the target list is in a string variable then generate:
**		    IIhidecol( strvar, null );
*/

inittable:	inittab_init inittab_tlist
		{
		    gen_call( IITFILL );
		    gen_if( G_CLOSE, IITBINIT, C_0, 0 );
		}
;
inittab_init:	inittable_key fm_string fm_string disp_mode
		{
		    gen_if( G_OPEN, IITBINIT, C_NOTEQ, 0 );
		}
;
inittable_key:	tINITTABLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;
inittab_tlist:	tLPAREN tRPAREN
	|	tLPAREN inittab_tlist1 tRPAREN
	|	/* EMPTY */
;
inittab_tlist1: fm_strvar
		{
		    arg_str_add( ARG_CHAR, (char *)0 );
		    gen_call( IITHIDECOL );
		}
	|	inittab_hide
;
inittab_hide:	inithide_elm
	|	inittab_hide tCOMMA inithide_elm
;
/*
** BUG 3576 - Check that a mixture of variables and constants were not used
** (ncg)      only within the format specification.  This is allowed:
**			colvar = char(10)
**	      but this is not:
**			col    = typevar(10)
**	      Clear gr_sym before parsing format rules.
*/
inithide_elm:	fm_string fm_is { gr->gr_sym = (SYM *)0; }
			inithide_type inittype_mods inithide_null
		{
		    arg_str_add( ARG_CHAR,  id_getname() );
		    id_free();
		    gen_call( IITHIDECOL );

		  /* Can't use literals and a variable too. */
		    if (gr->gr_sym && ($5.i || $6.i))
			er_write( E_EQ0074_grMISVAR, EQ_ERROR, 2, gr->gr_id,
							    ERx("INITTABLE") );
		}
;
/* Some host grammars add to this rule. */
inithide_type:	init_string
;
init_string:	tSCONST
		{
		    id_add( form_sconst($1.s) );
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_CHAR)
			    arg_var_add( gr->gr_sym, gr->gr_id );
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0134_sqNAME, EQ_ERROR, 1,
								    gr->gr_id );
			    id_add( gr->gr_id );
			}
		    }
		    else
			id_add( gr->gr_id );
		}
	|	tNAME
		{
		    id_add( $1.s );
		}
;
inittype_mods:	/* EMPTY */
		{
		    $$.i = 0;		/* Paren not stuff present */
		}
	|	tLPAREN tINTCONST tRPAREN
		{
		    id_add( $1.s );
		    id_add( $2.s );
		    id_add( $3.s );
		    $$.i = 1;		/* Paren stuff present */
		}
	|	tLPAREN tINTCONST tCOMMA tINTCONST tRPAREN  /* Decimal(p,s) */
		{
		    id_add( $1.s );
		    id_add( $2.s );
		    id_add( $3.s );
		    id_add( $4.s );
		    id_add( $5.s );
		    $$.i = 1;		/* Paren stuff present */
		}
;
/*
** End of an inittable hidden column tlist item:
**	[ WITH NULL | NOT NULL [WITH DEFAULT] ]
*/
inithide_null:	/* EMPTY */
		{
		    $$.i = 0;		/* No NULL clause */
		}
	|	tWITH tNULL
		{
		    id_add( ERx(" with null") );
		    $$.i = 1;		/* With NULL clause */
		}
	|	init_notnull init_withdef
		{
		    if ($2.i == 0)
			id_add( ERx(" not null") );
		    else
			id_add( ERx(" not null with default") );
		    $$.i = 1;		/* With NULL clause */
		}
;
init_notnull:	tNOT tNULL
;
/* consi01 bug 81399 changed tNAME to tDEFAULT and */
/* removed hard coded test for "default"           */
init_withdef:	tWITH tDEFAULT
		{
		    $$.i = 1;
		}
	|	/* EMPTY */
		{
		    $$.i = 0;
		}
;

/*
** Statement:	## PURGETABLE form table
**
** Action:	Moves deleted rows to the free list.
**
** Generates:	if (IItbsetio(cmPURGTBL, form, table, 0) != 0) {
**		}
*/

purgetable:	purgetbl_key fm_string fm_string
		{
		    /*
		    **  Add dummy argument for IItbsetio statement
		    **  which is not used by purgetable.
		    */
		    arg_int_add( 0 );
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;

purgetbl_key:	tPURGETBL
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmPURGE );
		}
;

/* 
** Statement:	## INSERTROW form table [row] [ ( form input list ) ]
**			[with (ATTR(col) = ATTR_VAL {, ... }]
** Action:	Insert user data after row.
** Generates:	if (IItbsetio(cmINSRTR, form, table, row) != 0) {
**		    if (IItinsert() != 0) {
**			IItcolset( col, valdesc, val ); ...
**                      ...
**                      [ IIFRsaSetAttrio
**                      ( att, col, &ind, byref, type, len, var|val ); ... ]
**                      IITBceColEnd();
**		    }
**		}
** Statement:   EXEC FRS INSERTROW form table [row] USING [DESCRIPTOR]
**		descriptor_name
**                      [with (ATTR(col) = ATTR_VAL {, ... }]
** Action:	Insert user data from sqlda data row.
** Generates:	if (IItbsetio(cmINSRTR, form, table, row) != 0) {
**		    if (IItinsert() != 0) {
**			IIFRsqExecute( lang, FALSE, TRUE, desc_name );
**                      [ IIFRsaSetAttrio
**                      ( att, col, &ind, byref, type, len, var|val ); ... ]
**                      IITBceColEnd();
**		    }
**		}
** Note:	1) The USING version of INSERTROW is used in conjunction with
**		the DESCRIBE TABLE statement to get data from a table
**		whose definition is not known at compile time.
**              2) The with clause supports setting cell atributes on the
**              basis of the value being loaded into the table.
*/

insertrow:	insr_init form_opin_tl ld_with_clause
		{
		    /* Close inner and insertrow if blocks */
		    gen_call( IITBCECOLEND );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IITINSERT, C_0, 0 );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
	|	insr_init fm_sqlda ld_with_clause
		{
		    /* Close inner and insertrow if blocks */
		    gen_call( IITBCECOLEND );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IITINSERT, C_0, 0 );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;
insr_init:	insertrow_key fm_string fm_string fm_row
		{
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
		    gen_if( G_OPEN, IITINSERT, C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		    gr->gr_func = IITCOLSET;
		}
;
insertrow_key:	tINSERTROW
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmINSERTR );
		}
;

/* 
** Statement:	## LOADTABLE form table ( form input list )
**                      [with (ATTR(col) = ATTR_VAL {, ... })]
** Action:	Load new data onto the end of table field data set.
** Generates:	if (IItbact(form, table, (loading)1) != 0) {
**		    IItcolset( col, valdesc, val ); ...
**                      ...
**                  [ IIFRsaSetAttrio
**                      ( att, col, &ind, byref, type, len, var|val );
**			   ... ]
**                  IITBceColEnd();
**		}
** Statement:	EXEC FRS LOADTABLE form table USING [DESCRIPTOR] desc_name
**                      [with (ATTR(col) = ATTR_VAL {, ... })]
** Action:	Load new data from sqlda onto the end of table field data set.
** Generates:	if (IItbact(form, table, (loading)1) != 0) {
**		    IIFRsqExecute( lang, FALSE, TRUE, desc_name );
**                  [ IIFRsaSetAttrio
**                      ( att, col, &ind, byref, type, len, var|val ); ... ]
**                  IITBceColEnd();
**		}
** Note:	1) The USING version of LOADTABLE is used in conjunction with
**		the DESCRIBE TABLE statement to put data into a table
**		whose definition is not known at compile time.
**              2) The with clause supports setting cell atributes on the
**              basis of the value being loaded into the table.
*/
		
loadtable:	load_init form_in_tl ld_with_clause
		{
		    gen_call( IITBCECOLEND );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IITBACT, C_0, 0 );
		}
	|	load_init fm_sqlda ld_with_clause
		{
		    gen_call( IITBCECOLEND );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IITBACT, C_0, 0 );
		}
;
load_init:	loadtable_key fm_string fm_string
		{
		    arg_int_add( TRUE );		/* Loading */
		    gen_if( G_OPEN, IITBACT, C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		    gr->gr_func = IITCOLSET;
		}
;
loadtable_key:	tLOADTABLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;
ld_with_clause: /* Empty */
	|	ld_with tLPAREN setf_targlist tRPAREN
;
ld_with:	tWITH
		{
		    frs_inqset(FRSload);
		    frs_object(ERx("row"));
		}
;

/* 
** Statement:	## PUTROW form table [row]  ( form input list )
** Action:	Fill columns with user data.
** Generates:	if (IItbsetio(cmPUTR, form, table, row) != 0) {
**		    IItcolset( col, valdesc, val ); ...
**                      ...
**                  IITBceColEnd();
**		}
** Statement:   EXEC FRS PUTROW form table [row] USING [DESCRIPTOR] desc_name
** Action:	Fill columns with user data from sqlda.
** Generates:	if (IItbsetio(cmPUTR, form, table, row) != 0) {
**		    IIFRsqExecute( lang, FALSE, TRUE, desc_name );
**                  IITBceColEnd();
**		}
** Note:	The USING version of PUTROW is used in conjunction with
**		the DESCRIBE TABLE statement to put data into a table
**		whose definition is not known at compile time.
*/

putrow:		putr_init form_in_tl
		{
		    gen_call( IITBCECOLEND );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
	|	putr_init fm_sqlda
		{
		    gen_call( IITBCECOLEND );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;
putr_init:	putrow_key fm_string fm_string fm_row 
		{
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		    gr->gr_func = IITCOLSET;
		}
;
putrow_key:	tPUTROW
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmPUTR );
		}
;

/* 
** Statement:	## SCROLL form table TO record
**		## SCROLL form table < UP | DOWN >
**		##		     [ OUT ( form output list ) ]
**		##		     [ IN  ( form  input list ) ]
** Action:	Scroll to a specified record, or
**		scroll table up or down using in / out target lists to
**		specify where data is coming from / going to. 
** Generates:	if (IItbsetio(cmSCROLL, form, table, rowNONE) != 0) {
**		    IItbsmode( mode );
**	OUT:	    [ IItcolret( vardesc, var, col ); ... ]
**	 IN:	    if (IItscroll(INflag, recnum) != 0) {
**			[ IItcolset(col, cvar); ... ]
**		    }
**		}
** Note:	Code generated may vary from the above, based on the mode of
**		scrolling and the target lists used.
*/

scroll:		scroll_init scroll_tlist
		{
		    /* Close inner and scroll if blocks */
		    gen_if( G_CLOSE, IITSCROLL, C_0, 0 );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;
scroll_init:	scroll_key fm_string fm_string
		{
		    arg_int_add( rowNONE );
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
		}
;
scroll_key:	tSCROLL
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmSCROLL );
		}
;
scroll_tlist:	scroll_to scrollto_arg
		{
		    gen_if( G_OPEN, IITSCROLL, C_NOTEQ, 0 );
		}
	|	scroll_updown scroll_out scroll_in 
		{
		    if (($2.i || $3.i) && (eq->eq_flags & EQ_VERSWARN))
			er_write( E_EQ0078_grSTYUNSUPP, EQ_WARN, 1,
							ERx("SCROLL IN/OUT") );
		}
;
scroll_to:	tTO 
		{
		    arg_str_add( ARG_CHAR, $1.s );
		    gen_call( IITBSMODE );
		    arg_int_add( FALSE );	/* Ignore In flag */
		}
;
scrollto_arg:	fm_int
	|	tEND 
		{
		    arg_int_add( rowEND );
		}
;
scroll_updown:	tUP 
		{
		    arg_str_add( ARG_CHAR, $1.s );
		    gen_call( IITBSMODE );
		}
	|	tDOWN 
		{
		    arg_str_add( ARG_CHAR, $1.s );
		    gen_call( IITBSMODE );
		}
;
scroll_out:	/* No out list */
	|	sc_out_key form_out_tl
;
sc_out_key:	tOUT
		{
		    gr->gr_func = IITCOLRET;
		}
;
scroll_in:	/* No in list */
		{
		    arg_int_add( FALSE );
		    arg_int_add( rowNONE );
		    gen_if( G_OPEN, IITSCROLL, C_NOTEQ, 0 );
		}
	|	sc_in_key form_in_tl
;
sc_in_key:	tIN 
		{
		    arg_int_add( TRUE );	/* In list */
		    arg_int_add( rowNONE );
		    gen_if( G_OPEN, IITSCROLL, C_NOTEQ, 0 );
		    gr->gr_func = IITCOLSET;
		}
;

/* 
** Statement:	## TABLEDATA 
**		## {
**			User code
**		## }
** Action:	Inside formdata - get Vifred info about current table field.
** Generates:	while (IItdata() != 0) {
**			User code (Inquire calls)
**		}
**	IItb_end1:
**		IItdatend();
*/	

tabledata:	tabdata_init host_term block
		{
		    i4  cur_table = lbl_current( LBL_TBL );

		    /* Close tabledata loop */
		    gen_loop( G_CLOSE, L_TBBEG, L_TBEND, cur_table, IITDATA,
			      C_0, 0 );
		    if (lbl_is_used(LBL_TBL))
			gen_label( G_LOOP, L_TBEND, cur_table );
		    gen_call( IITDATEND );
		}
tabdata_init:	tTABLEDATA
		{
		    i4  cur_table = lbl_next( LBL_TBL );

		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    if (lbl_gen(LBLmFORMDATA, FALSE) == LBL_NOLEV)
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("FORMDATA") );
		    gr->gr_mode = LBLmTBDATA;
		    gen_loop( G_OPEN, L_TBBEG, L_TBEND, cur_table, IITDATA, 
			      C_NOTEQ, 0 );
		}
;

/* 
** Statement:	## UNLOADTABLE form table [ ( form output list ) ]
**		## {
**			User code
**		## }
** Action:	Unload data set, allowing user intervention with each row.
** Generates:	if (IItbact( form, table, (unload)0) == 0) goto IItb_end1; 
**		while ( IItunload() != 0 ) {
**			IItcolret( vardesc, var, col ); ...
**                      IITBceColEnd();
**			User code ...
**		}
**	IItb_end1:
**		IItunend();
** Statement:	EXEC FRS UNLOADTABLE form table USING [DESCRIPTOR] desc_name
**		EXEC FRS BEGIN
**			User code
**		EXEC FRS END
** Action:	Unload data set into sqlda, allowing intervention with each row.
** Generates:	if (IItbact( form, table, (unload)0) == 0) goto IItb_end1; 
**		while ( IItunload() != 0 ) {
**			IIFRsqExecute( lang, FALSE, FALSE, desc_name );
**                      IITBceColEnd();
**			User code ...
**		}
**	IItb_end1:
**		IItunend();
** Note:	The USING version of UNLOADTABLE is used in conjunction with
**		the DESCRIBE TABLE statement to get data from a table
**		whose definition is not known at compile time.
*/	

unloadtable:    unload_stmt block
		{
		    i4  cur_table = lbl_current( LBL_TBL );

		    /* Close unloadtable loop */
		    gen_loop( G_CLOSE, L_TBBEG, L_TBEND, cur_table, IITUNLOAD,
			      C_0, 0 );
		    gen_label( G_LOOP, L_TBEND, cur_table );
		    gen_call( IITUNEND );
		}
;
unload_stmt:    unload_init form_opout_tl host_term
		{
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		    gen_call( IITBCECOLEND );
		}
	|       unload_init fm_sqlda host_term
		{
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		    gen_call( IITBCECOLEND );	
		}
;
unload_init:	unloadtab_key fm_string fm_string
		{
		    i4  cur_table = lbl_next( LBL_TBL );

		  /* Nested unloadtable? */
		    if (lbl_gen(LBLmTBUNLD,FALSE) != LBL_NOLEV)
			er_write( E_EQ0068_grUNLOADTB, EQ_ERROR, 0 );
		    gr->gr_mode = LBLmTBUNLD;
		    arg_int_add( FALSE );		/* Unload flag */
		    gen_if_goto( IITBACT, C_EQ, 0, L_TBEND, cur_table );
		    gen_loop( G_OPEN, L_TBBEG, L_TBEND, cur_table, IITUNLOAD, 
			      C_NOTEQ, 0 );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    gr->gr_func = IITCOLRET;
		}
;
unloadtab_key:	tUNLOADTABLE
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		}
;

/*
** Statement:	## VALIDROW form table [row] [ ( column list ) ]
** Action:	Validates columns of table row. Validate row if no columns.
** Generates:	if (IItbsetio(cmVALIDR, form, table, row) != 0) {
**     For row:	    IItvalrow();
**     For columns: IItcolval( col1 );
**		    IItcolval( col2 ); ...
**
**		    if (IItvalval(0) == 0) {
**			[ Break out of Equel loops ]
**			goto IIfd_begin1;
**		    }
**		}
*/

validrow:	validrow_init validrow_tlist
		{
		    i4  stop_level;

		    arg_int_add( 0 );
		    gen_if( G_OPEN, IITVALVAL, C_EQ, 0 );
		    if ((stop_level = lbl_gen(LBLmDISPLAY, TRUE)) == LBL_NOLEV)
			er_write( E_EQ0058_grINLOOP, EQ_ERROR, 2, $1.s,
							    ERx("DISPLAY") );
		    else
			gen_goto( G_NOTERM, L_FDBEG, 
				  lbl_value(LBL_FORM, stop_level) );
		    /* Close inner and validrow if blocks */
		    gen_if( G_CLOSE, IITVALVAL, C_0, 0 );
		    gen_if( G_CLOSE, IITBSETIO, C_0, 0 );
		}
;
validrow_init:	validrow_key fm_string fm_string fm_row
		{	
		    gen_if( G_OPEN, IITBSETIO, C_NOTEQ, 0 );
		    gr->gr_func = IITCOLVAL;
		    $$.s = $1.s;
		}
;
validrow_key:	tVALIDROW
		{
		    gr_mechanism( GR_EQSTMT, GR_sFORMS, $1.s, NULL );
		    arg_int_add( cmVALIDR );
		}
;
validrow_tlist: tLPAREN fm_stringlist tRPAREN
	|	tLPAREN tRPAREN
		{
		    er_write( E_EQ0054_grNOPARENS, EQ_ERROR, 0 );
		    gen_call( IITVALROW );
		}
	|	/* Default is whole row */
		{
		    gen_call( IITVALROW );
		}
;

/* 
** Form utility rules - all rules must begin with 'fm_' 
*/

/* Form string variable - either to receive data (PROMPT) or other use */
fm_strvar:	host_setvar
		{
		    if (gr->gr_sym && gr->gr_type == T_CHAR)
			arg_var_add( gr->gr_sym, gr->gr_id );
		    else
		    {
			arg_str_add( ARG_CHAR, gr->gr_id );
			if (gr->gr_type != T_UNDEF)
			    er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
		    }
		}
;

/* 
** Form string list - string { , string }
** Note:	gr->gr_func must be set to whatever to call on each element.
*/

fm_stringlist:	fm_string
		{
		    gen_call( gr->gr_func );
		}
	|	fm_stringlist tCOMMA fm_string 
		{
		    gen_call( gr->gr_func );
		}
;
/*
** General format of a Form in target list (ie: in PUTFORM ) is:
**	( object = val { , object = val } )
**
**	object: < name | PUTOPER( name ) >
**
** Generates:	IIinfunc( object, valdesc, val ); ...
** Note:	gr->gr_func must be set to the corresponding output function.
*/

form_opin_tl:	form_in_tl
	|	tLPAREN tRPAREN 
		{
		    er_write( E_EQ0054_grNOPARENS, EQ_ERROR, 0 );
		}
	|	/* No input list */
;
form_in_tl:	tLPAREN fm_in_tlist tRPAREN
;
fm_in_tlist:	in_elm
	|	fm_in_tlist tCOMMA in_elm
;
in_elm:		fm_string fm_is fm_in_val
		{
		    gen_call( gr->gr_func );
		}
	|	tPUTOPER tLPAREN fm_string tRPAREN fm_is fm_in_val
		{
		    switch ( gr->gr_func )
		    {
		      case IISETFIELD:
		      case IITCOLSET:
			arg_push();
			arg_int_add( TRUE );
			gen_call( IIPUTOPER );
			switch (gr->gr_type)
			{
			  case T_INT:
			  case T_DBV:
			  case T_UNDEF:
			    break;
			  default:
			    er_write( E_EQ0053_grFMINTFUNC, EQ_ERROR, 1, $1.s );
			    break;
			}
			break;

		      default:
			er_write( E_EQ0052_grFMFUNC, EQ_ERROR, 1, $1.s );
			break;
		    }
		    gen_call( gr->gr_func );
		}
	|	fm_string fm_is fm_null
		{
		    gen_call( gr->gr_func );
		}
;
/*
** This rule is used in input forms statements where target list is:
**	( col = null, ... )
** We store away two arguments: a null pointer for indicator (just a
** zero) and a null pointer for data (a special SYM).  The code generator
** expects this convention for I/O arguments.
**	note, this is also used as a parameter to database procedures.
*/
fm_null:	tNULL
		{	
		    arg_int_add( 0 );
		    arg_var_add( gr->gr_null, ERx("null") ); 
		}
;

/*
** General format of a Form output target list (ie: in GETFORM ) is:
**	( var = object {, var = object} )
**
**	object: < name | GETOPER( name ) >
**
** Generates:	IIoutfunc( vardesc, var, object ); ...
** Note:	gr->gr_func must be set to the corresponding input function.
*/
 
form_opout_tl:	form_out_tl
	|	tLPAREN tRPAREN 
		{
		    er_write( E_EQ0054_grNOPARENS, EQ_ERROR, 0 );
		}
	|	/* No output target list */
;
form_out_tl:	tLPAREN fm_out_tlist tRPAREN
;
fm_out_tlist:	out_elm
	|	fm_out_tlist tCOMMA out_elm
;
out_elm:	fm_out_var fm_is fm_string
		{
		    gen_call( gr->gr_func );
		}
	|	fm_out_var fm_is tGETOPER tLPAREN fm_string tRPAREN
		{
		    switch ( gr->gr_func )
		    {
		      case IIRETFIELD:
		      case IITCOLRET:
			arg_push();
			arg_int_add( TRUE );
			gen_call( IIGETOPER );
			if ($1.i != T_INT && $1.i != T_DBV && $1.i != T_UNDEF)
			    er_write( E_EQ0053_grFMINTFUNC, EQ_ERROR, 1, $2.s );
			break;

		      default:
			er_write( E_EQ0052_grFMFUNC, EQ_ERROR, 1, $2.s );
			break;
		    }
		    gen_call( gr->gr_func );
		}
;
fm_out_var:	host_retvar sql_opt_ind
		{
		    if (gr->gr_nlsym)
			arg_var_add( gr->gr_nlsym, gr->gr_nlid );
		    else
			arg_int_add( 0 );
		    arg_var_add( gr->gr_sym, gr->gr_id );
		    $$.i = gr->gr_type;
		}
;

/* Optional table field row number:  [ rownum ] */
fm_row:		fm_int
	|	/* No row specified - use current row */
		{
		    arg_int_add( rowCURR );
		}
;

/* Optional form name on some I/O statements - $0 is always the keyword */
fm_opname:	fm_string
	|	/* No form name - use null in Display loop */
		{
		    arg_str_add( ARG_CHAR, (char *)0 );
		    if (lbl_gen(LBLmDISPLAY, FALSE) == LBL_NOLEV)
			er_write( E_EQ0056_grFORMNAME, EQ_ERROR, 1, $0.s );
		}
;

/* Assignment operator */
fm_is:		tIS
		{
		    er_write( E_EQ0071_grASSGNOP, EQ_ERROR, 1, $1.s );
		}
	|	tEQOP
;


/* Optional comma */
fm_opcomma:	tCOMMA
	|
;


/* 
+* ---- ESQL Forms Utility Rules  ----
-*
** Form utility rules - all rules must begin with 'fm_' 
*/

/* Form string constant */
fm_sconst:	tSCONST
		{
		    $$.s = form_sconst($1.s);
		}
;
/* Form string constant added to arg list */
fm_sconst_arg:	fm_sconst
		{
		    arg_str_add( ARG_CHAR, $1.s );
		}
;
/* string constant for forms i/o statements */
fm_iosconst:	fm_sconst
		{
		    arg_int_add( 0 );		/* null indicator */
		    arg_str_add( ARG_CHAR, $1.s );
		}
;

/*
** fm_string - Form string constants (quotes are not required) or string
**	       variable.
** fm_qstring - Quoted string or string variable. (07/22/88 - marge)
*/
fm_string:	fm_qstring
	|	tNAME
		{
		    arg_str_add( ARG_CHAR, $1.s );
		}
	|	tDELIMID
		{
		    i4  dummy;
		    char *delim_arg;

		    /*
		    ** Put the quotes back for delimited ids and escape
		    ** them (\") so they will be generated correctly
		    ** later on.
		    */
		    /* Place the delimited ids (with quotes and escape 
	            ** characters) in buffers of the string table work space
		    ** to avoid being overwritten when there is another
		    ** call to gen_sqmakesconst within the same SQL 
		    ** statement.          		b57771tt       
		    */
		    delim_arg = str_add( STRNULL, 
                                gen_sqmakesconst(G_DELSTRING, $1.s, &dummy) );

		    arg_str_add( ARG_CHAR, delim_arg );
		}
;
fm_qstring:	fm_sconst_arg
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_CHAR)
			    arg_var_add( gr->gr_sym, gr->gr_id );
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0067_grSTRVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    arg_str_add( ARG_CHAR, gr->gr_id );
			}
		    }
		    else	/* Error already in host_setvar */
			arg_str_add( ARG_CHAR, gr->gr_id );
		}
;

/* Form integer constant */

fm_iconst: 	tINTCONST
		{
		    $$.s = $1.s;
		}
	|	tMINUS tINTCONST	%prec tUNARYOP
		{
		    char	ibuf[50];

		    ibuf[0] = '-';
		    ibuf[1] = '\0';
		    $$.s = str_add( STRNULL, STcat(ibuf, $2.s) );
		}
	|	tPLUS tINTCONST		%prec tUNARYOP
		{
		    $$.s = $2.s;
		}
;

/* Form integer constant added to arg list */
fm_iconst_arg:	fm_iconst
		{
		    arg_str_add( ARG_INT, $1.s );
		}
;
/* integer const for forms i/o statements */
fm_ioiconst:	fm_iconst
		{
		    arg_int_add( 0 );		/* null indicator */
		    arg_str_add( ARG_INT, $1.s );
		}
;

/* Form floating constant */
fm_fconst:	tFLTCONST
		{
		    $$.s = $1.s;
		}
	|	tMINUS tFLTCONST	%prec tUNARYOP
		{
		    char	fbuf[50];

		    fbuf[0] = '-';
		    fbuf[1] = '\0';
		    $$.s = str_add( STRNULL, STcat(fbuf, $2.s) );
		}
	|	tPLUS tFLTCONST		%prec tUNARYOP
		{
		    $$.s = $2.s;
		}
;

/*
** Form floating constant added to arg list.
** Only the I/O form is currently used
fm_fconst_arg:	fm_fconst
		{
		    arg_str_add( ARG_FLOAT, $1.s );
		}
;
*/
/* floating-point const for forms i/o statements */
fm_iofconst:	fm_fconst
		{
		    arg_int_add( 0 );		/* null indicator */
		    arg_str_add( ARG_FLOAT, $1.s );
		}
;

/* Form decimal constant */
fm_dconst:	tDECCONST
		{
		    $$.s = $1.s;
		}
	|	tMINUS tDECCONST	%prec tUNARYOP
		{
		    char	dbuf[50];

		    dbuf[0] = '-';
		    dbuf[1] = '\0';
		    $$.s = str_add( STRNULL, STcat(dbuf, $2.s) );
		}
	|	tPLUS tDECCONST		%prec tUNARYOP
		{
		    $$.s = $2.s;
		}
;
/* decimal const for forms i/o statements */
fm_iodconst:	fm_dconst
		{
		    arg_int_add( 0 );		/* null indicator */
		    arg_str_add( ARG_PACK, $1.s );
		}
;

/* Form integer constant or variable */

fm_int:		fm_iconst_arg
	|	tFLTCONST		/* Common error */
		{
		    er_write( E_EQ0059_grINT, EQ_ERROR, 1, $1.s );
		    arg_int_add( 0 );
		}
	|	tDECCONST		/* Common error */
		{
		    er_write( E_EQ0059_grINT, EQ_ERROR, 1, $1.s );
		    arg_int_add( 0 );
		}
	|	host_fsetvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_INT)
			    arg_var_add( gr->gr_sym, gr->gr_id );
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    arg_int_add( 0 );
			}
		    }
		    else	/* Error in host_setvar */
			arg_int_add( 0 );
		}
;

/* 
** Input values and constants for the forms system 
**
**	note, these are also used for parameters to database procedures.
*/

fm_in_val:	host_fsetvar sql_opt_ind
		{
		    /* Null indicator argument */
		    if (gr->gr_nlsym)
			arg_var_add( gr->gr_nlsym, gr->gr_nlid );
		    else
			arg_int_add( 0 );

		    if (gr->gr_sym)
			arg_var_add( gr->gr_sym, gr->gr_id );
		    else	/* Error in host_fsetvar */
			arg_str_add( ARG_CHAR, gr->gr_id );
		}
	|	fm_ioiconst
		{
		    gr->gr_type = T_INT;
		}
	|	fm_iofconst
		{
		    gr->gr_type = T_FLOAT;
		}
	|	fm_iodconst
		{
		    gr->gr_type = T_PACKASCHAR;
		}
	|	fm_iosconst
		{
		    gr->gr_type = T_CHAR;
		}
;

/* The USING clause allowed on dynamic versions of forms I/O statements */
fm_sqlda:	tUSING fm_desc host_sqlda
		{
		    i4	form_table, input_output;

		    switch (gr->gr_func) {
		      case IISETFIELD:
			form_table = 1;
			input_output= 1;
			break;
		      case IIRETFIELD:
			form_table = 1;
			input_output= 0;
			break;
		      case IITCOLSET:
			form_table = 0;
			input_output= 1;
			break;
		      case IITCOLRET:
			form_table = 0;
			input_output= 0;
			break;
		    }
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_int_add( form_table );		/* is form? */
		    arg_int_add( input_output );	/* is input? */
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IIFRSQEXEC );
		}
;
fm_desc:	/* Nothing */
	|	tDESCRIPTOR
;


/*
+* --- EXEC 4GL Rules ---
-*
** These rules support accessing ABF/4GL and Windows4GL data from
** 3GL procedures.  The function calls they generate are resolved in
** the abfrt directory for ABF/4GL and the w4glrt directory for Windows4GL.
*/
exec4gl_statement: callframe_or_proc
	|	clear_array
	|	describe4gl
	|	get_attribute
	|	get_global
	|	getrow4gl
	|	inquire_4gl
	|	insertrow4gl
	|	removerow
	|	senduevent
	|	set_4gl
	|	set_attribute
	|	set_global
	|	setrow
	|	setrow_deleted
;

/*
** Statement:	EXEC 4GL CALLFRAME frame 
**			({ [parameter =] [BYREF(] :var [:ind] [)] {, ...} } )
**			[INTO :var [:ind] ]
** Action:	Clears (empties) a 4GL array.
** Generates:	if (IIG4icInitCall(name, frame_or_proc) == 0)
**		{
**		    IIG4vpValParam(name, ind, isval, type, length, data);
**		    IIG4bpByrefParam(ind, isval, type, length, data, name);
**		    ...
**		    {IIG4rvRetVal(ind, isval, type, length, data);}
**		    IIG4ccCallComp();
**		}
**
**		IIG4vpValParam is generated for non-BYREF parameters,
**		IIG4bpByrefParam for BYREF parameters.  The 'name' argument
**		of both will be an empty string if no parameter name
**		ws specified.
**		If there is no INTO clause, no call to IIG4rvRetVal will 
**		be generated.	
*/

callframe_or_proc: call_init call_param_part opt_retval
		{
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		    gen_call(IIG4CALLCOMP);
		    gen_if( G_CLOSE, IIG4INITCALL, C_EQ, 0);
		}
;

call_init:	call_key fm_string
		{
		    char *statement_name = ($1.i == G4CT_FRAME) ?
					       ERx("callframe") :
					       ERx("callproc");

		    gr_mechanism( GR_EQSTMT, GR_s4GL, statement_name, NULL );
		    arg_int_add($1.i);
		    gen_if( G_OPEN, IIG4INITCALL, C_EQ, 0);
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		}
;

call_key:	tCALLPROC
		{
		    $$.i = G4CT_PROC;
		}
	|	tCALLFRAME
		{
		    $$.i = G4CT_FRAME;
		}

;

call_param_part: tLPAREN tRPAREN
	|	tLPAREN call_param_list tRPAREN
;

call_param_list: call_param_item
		{
		    if ($1.i == 0)
		    {
			/* Not byref */
			args_toend(1, 2);
		        gen_call(IIG4VALPARAM);
		    }
		    else
		    {
			/* Byref */
			gen_call(IIG4BYREFPARAM);
		    }
		}
	|	call_param_list tCOMMA call_param_item
		{
		    if ($3.i == 0)
		    {
			/* Not byref */
			args_toend(1, 2);
		        gen_call(IIG4VALPARAM);
		    }
		    else
		    {
			/* Byref */
			gen_call(IIG4BYREFPARAM);
		    }
		}
;

call_param_item: tNAME tEQOP call_arg
		{
		    arg_str_add(ARG_CHAR, $1.s);
		    $$.i = $3.i;
		}
	|	tSCONST tEQOP call_arg
		{
		    arg_str_add(ARG_CHAR, $1.s);
		    $$.i = $3.i;
		}
	|	param_in_var tEQOP call_arg
		{
		    /* 
		    ** The parameter name was pushed too early.
		    ** Now place it correctly.
		    */
		    args_toend(1, 1);
		    $$.i = $3.i;
		}
	|	call_arg
		{
		    arg_str_add(ARG_CHAR, ERx(""));
		    $$.i = $1.i;
		}
;

param_in_var:	host_setvar
		{
		    if (gr->gr_type != T_NONE && 
			gr->gr_type != T_CHAR)
		    {
			er_write(E_EQ0067_grSTRVAR, EQ_ERROR, 
				 1, gr->gr_id);
		    }
		    arg_var_add(gr->gr_sym, gr->gr_id);
		}
;

call_arg:	tBYREF tLPAREN fm_out_var tRPAREN
		{
		    $$.i = 1;
		}
	|	g4_in_ioval
		{
		    $$.i = 0;
		}
;
	
opt_retval:	
	|	tINTO fm_out_var
		{
		    gen_call(IIG4RETVAL);
		}
;

/*
** Statement:	EXEC 4GL CLEAR ARRAY array;
** Action:	Clears (empties) a 4GL array.
** Generates:	IIG4acArrayClear(array);
*/
clear_array:	clear_array_key g4_objval_arg
		{
		    gen_call( IIG4CLRARR );
		}
;

clear_array_key: tCLEAR_ARRAY
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

/*
** Statement:	EXEC 4GL DESCRIBE object INTO sqlda
** Action:	Puts attribute descriptions into the SQLDA
** Generates:	IIG4fdFillDscr(object, langauge, sqlda)
*/
describe4gl:	describe4gl_key g4_objval_arg tINTO host_sqlda
		{
		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		    gen_call( IIG4DESCRIBE );
		}
;

describe4gl_key: tDESCRIBE_4GL
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

/*
** Statement:	EXEC 4GL GET ATTRIBUTE object [index] (:var:ind = name {, ...})
** Action:	Gets attributes from a 4GL object or array row
** Generates:	if (IIG4chkobj(object, access, index) == 0)
**		{
**			IIG4gaGetAttr(ind, isvar, type, len, data, name);
**			...
**		}
**	or
**		if (IIG4chkobj(object, access, index) == 0)
**		{
**			IIG4udUseDscr(language, direction, sqlda);
**		}
*/
get_attribute:	get_attribute_init get_attribute_params
		{
			if (eq->eq_flags & EQ_CHRPAD)
			    esq_sqmods(IImodNOCPAD);
			gen_if( G_CLOSE, IIG4CHKOBJ, C_EQ, 0);
		}
;

get_attribute_init:	get_attribute_key g4_objval_arg g4_opt_index
		{
		    if ($3.s == NULL)
		    {
			/* index is 0; access is to whole object */
			arg_int_add(G4OA_OBJECT);
			arg_int_add(0);
		    }
		    else
		    {
			/* access is to row */
			arg_int_add(G4OA_ROW);
			arg_str_add(ARG_INT, $3.s);
		    }

		    /* Caller is Get attribute */
		    arg_int_add(G4GATTR_ID);

		    gen_if( G_OPEN, IIG4CHKOBJ, C_EQ, 0);
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    gr->gr_func = IIG4GETATTR;
		}
;

get_attribute_key:	tGET_ATTR
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

get_attribute_params:	g4_sqlda
		{
		    gen_call(IIG4USEDESCR);
		}
	|	tLPAREN g4_out_attr_list tRPAREN
;

g4_out_attr_list: g4_out_elm
		{
		    gen_call(IIG4GETATTR);
		}
	|	g4_out_attr_list tCOMMA g4_out_elm
		{
		    gen_call(IIG4GETATTR);
		}
;

/*
** Statement:	EXEC 4GL GET GLOBAL CONSTANT|VARIABLE (:var:ind = name)
** Action:	Gets a global 4GL variable or constant
** Generates:	IIG4ggGetGlobal(ind, isvar, type, len, data, name, const_or_var)
*/
get_global:	get_global_key tNAME tLPAREN g4_out_elm tRPAREN
		{
		    i4  gtype = 0;

		    if (STbcompare($2.s, 0, ERx("constant"), 0, TRUE) == 0)
		    {
			gtype = G4GT_CONST;
		    }
		    else if (STbcompare($2.s, 0, ERx("variable"), 0, TRUE) == 0)
		    {
			gtype = G4GT_VAR;
		    }
		    else
		    {
			er_write( E_EQ0081_TL_ATTR_UNKNOWN, EQ_ERROR, 1, $2.s);
		    }
		    if(eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    arg_int_add(gtype);
		    gen_call( IIG4GETGLOB );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);

		}
;

get_global_key: tGET_GLOBAL
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

/*
** Statement:	EXEC 4GL GETROW array index (ROW = row)
** Action:	Gets a row from an array
** Generates:	IIG4grGetRow(rowind, rowisvar, rowtype, rowlen, row,
**			     array, index);
*/
getrow4gl:	getrow4gl_key g4_objval getrow4gl_index getrow4gl_params
		{
		    arg_str_add( ARG_INT, $2.s);
		    arg_str_add( ARG_INT, $3.s);
		    gen_call( IIG4GETROW );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		}
;

getrow4gl_key:	tGETROW_4GL
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		}
;

getrow4gl_index:	g4_in_val 
		{
		    if (gr->gr_type != T_UNDEF) /* Don't cascade errs */
		    {
			if (gr->gr_type != T_INT)
			    er_write( E_EQ0059_grINT, EQ_ERROR, 1, gr->gr_id );
		    }
		    $$.s = gr->gr_id;
		}
;

getrow4gl_params:	tLPAREN g4_objvar_arg fm_is tROW tRPAREN
;

/*
** Statement:	EXEC 4GL INQUIRE_4GL ({:variable = 4GLconst, } 
**				      {:variable = 4GLconst(object), })
** Action:	Inquire about a 4GL object or 4GL state.
** Generates:	IIG4i4Inq4GL(ind, isvar, type, length, data, object, inqtype);
*/
inquire_4gl:	inquire_4gl_key tLPAREN inquire_4gl_list tRPAREN
		{
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodNOCPAD);
		}
;
inquire_4gl_key: tINQ_4GL
		{
                    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		    if (eq->eq_flags & EQ_CHRPAD)
			esq_sqmods(IImodCPAD);
		    gr->gr_func = IIINQ4GL;
		}
;

inquire_4gl_list: inquire_4gl_item
	|	inquire_4gl_list tCOMMA inquire_4gl_item
;

inquire_4gl_item: fm_out_var fm_is g4_inqset_attrib 
		{
		    gen_call(IIINQ4GL);
		}
;

/*
** Statement:	EXEC 4GL INSERTROW array (ROWNUMBER = rownumber)
** Action:	Inserts a row into an array
** Generates:	IIG4irInsRow(array, index, which, row, state);
*/
insertrow4gl:	insertrow4gl_key g4_objval_arg tLPAREN insertrow4gl_arglist tRPAREN
		{
		    i4  which = 0;
		    INSROW4GL_PARMS *prmptr = (INSROW4GL_PARMS *)($4.ip);
		
		    /* 
		    ** Generate the parameters.  Unspecified optional 
		    ** parameters become 0. 
		    */
		    if (*prmptr->rownumber == EOS)
		    {
			    er_write( E_EQ051A_NOROWNUM, EQ_ERROR, 0);
		    }
		    arg_str_add( ARG_INT, prmptr->rownumber );
		    if (*prmptr->row == EOS)
		    {
			arg_int_add(0);
		    }
		    else
		    {
			arg_str_add( ARG_INT, prmptr->row);
			which |= G4IR_ROW;
		    }
		    if (*prmptr->row_state == EOS)
		    {
			arg_int_add(0);
		    }
		    else
		    {
			arg_str_add( ARG_INT, prmptr->row_state);
			which |= G4IR_STATE;
		    }
		    arg_int_add(which);
			
		    gen_call( IIG4INSROW );
		    MEfree((PTR)prmptr);
		}
;

insertrow4gl_key:	tINSERTROW_4GL
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

insertrow4gl_arglist: insertrow4gl_arg
		{
		    INSROW4GL_PARMS *prmptr;

		    prmptr = (INSROW4GL_PARMS *)
				MEreqmem(0, sizeof(INSROW4GL_PARMS), 
					 FALSE, NULL);
		    prmptr->rownumber = prmptr->row_state = prmptr->row = 
			ERx("");
		    $$.ip = (i4 *)prmptr;
		    set_insrow_param($1.s, gr->gr_id, gr->gr_type, 
				     gr->gr_sym, prmptr);
		}
	|	insertrow4gl_arglist tCOMMA insertrow4gl_arg
		{
		    INSROW4GL_PARMS *prmptr = (INSROW4GL_PARMS *)($1.ip);

		    set_insrow_param($3.s, gr->gr_id, gr->gr_type, 
				     gr->gr_sym, prmptr);
		    $$.ip = $1.ip;
		}
;

insertrow4gl_arg:	tNAME fm_is g4_in_val
		{
		    $$.s = $1.s;
		}
;

			
/*
** Statement:	EXEC 4GL REMOVEROW array (ROWNUMBER = rownumber)
** Action:	Removes a row from an array
** Generates:	IIG4rrRemRow(array, index);
*/
removerow:	removerow_key g4_objval_arg g4_rownumber
		{
		    gen_call( IIG4REMROW );
		}
;

removerow_key:	tREMOVEROW
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

/*
** Statement:   EXEC 4GL SEND USEREVENT frame (eventname = string
**				     {, messageobject = object }
**				     {, messageinteger = integer }
**				     {, messagefloat = float }
**				     {, messagevarchar = string }
**				     {, focusbehavior = string }
**				     {, messageobject = object }
**				     {, delay = float } )
** Action:	Queues a userevent to a frame
** Generates:	if (IIG4seSendEvent(frame) == 0)
**		{
**		    IIG4vpValParam(name, ind, isval, type, length, data);
**		    ...
**		    IIG4ccCallComp();
**		}
*/
senduevent:	senduevent_init senduevent_args
		{
		    gen_call( IIG4CALLCOMP );
		    gen_if( G_CLOSE, IISENDUSEREVENT, C_EQ, 0);
		}
;

senduevent_init: tSEND_USEREVENT g4_objval_arg
		{
                    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		    gen_if( G_OPEN, IISENDUSEREVENT, C_EQ, 0);
		}
;

senduevent_args:	tLPAREN senduevent_arglist tRPAREN
;

senduevent_arglist: senduevent_argspec
	|	senduevent_arglist tCOMMA senduevent_argspec
;

senduevent_argspec: g4_inqset_attrib_val fm_is g4_in_ioval
		{
		    arg_str_add(ARG_CHAR, $1.s);
		    args_toend(1, 2);
		    gen_call(IIG4VALPARAM);
		}
;

/*
** Statement:	EXEC 4GL SET_4GL ({4GLconst = :variable, } 
**				      {4GLconst(object) = :variable, })
** Action:	Set status of a 4GL object or general 4GL state
** Generates:	IIG4s4Set4GL(inqtype, object, ind, isvar, type, length, data)
*/
set_4gl:	set_4gl_key tLPAREN set_4gl_list tRPAREN
		{
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		}
;

set_4gl_key: tSET_4GL
		{
                    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		    gr->gr_func = IISET4GL;
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		}
;

set_4gl_list: set_4gl_item
	|	set_4gl_list tCOMMA set_4gl_item
;

set_4gl_item: g4_inqset_attrib fm_is g4_in_ioval
		{
		    gen_call(IISET4GL);
		}
;

/*
** Statement:	EXEC 4GL SET ATTRIBUTE object [index] (:var:ind = name {, ...})
** Action:	Sets attributes from a 4GL object or array row
** Generates:	if (IIG4chkobj(object, access, index) == 0)
**		{
**			IIG4saSetAttr(name, ind, isvar, type, len, data);
**			...
**		}
**	or
**		if (IIG4chkobj(object, access, index) == 0)
**		{
**			IIG4udUseDscr(language, direction, sqlda);
**		}
*/
set_attribute:	set_attribute_init set_attribute_params
		{
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
			gen_if( G_CLOSE, IIG4CHKOBJ, C_EQ, 0);
		}
;

set_attribute_init:	set_attribute_key g4_objval_arg g4_opt_index
		{
		    if ($3.s == NULL)
		    {
			/* index is 0; access is to whole object */
			arg_int_add(G4OA_OBJECT);
			arg_int_add(0);
		    }
		    else
		    {
			/* access is to row */
			arg_int_add(G4OA_ROW);
			arg_str_add(ARG_INT, $3.s);
		    }

		    /* Caller is Set attribute */
		    arg_int_add(G4SATTR_ID);

		    gen_if( G_OPEN, IIG4CHKOBJ, C_EQ, 0);
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		    gr->gr_func = IIG4SETATTR;
		}
;


set_attribute_key:	tSET_ATTR
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;
set_attribute_params:	g4_sqlda
		{
		    gen_call(IIG4USEDESCR);
		}
	|	tLPAREN g4_in_attr_list tRPAREN
;

g4_in_attr_list: g4_in_elm
		{
		    gen_call(IIG4SETATTR);
		}
	|	g4_in_attr_list tCOMMA g4_in_elm
		{
		    gen_call(IIG4SETATTR);
		}
;

/*
** Statement:	EXEC 4GL SET GLOBAL VARIABLE (:var:ind = name)
** Action:	Sets a 4GL global variable
** Generates:	IIG4sgSetGlobal(name, ind, isvar, type, len, data)
*/
set_global:	set_global_key tNAME tLPAREN g4_in_elm tRPAREN
		{

		    if (STbcompare($2.s, 0, ERx("variable"), 0, TRUE) != 0)
		    {
			er_write( E_EQ0081_TL_ATTR_UNKNOWN, EQ_ERROR, 1, $2.s);
		    }
		    gen_call( IIG4SETGLOB );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodNOCEOS);
		}
;

set_global_key:	tSET_GLOBAL
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		    if (eq->eq_flags & EQ_CHREOS)
			esq_sqmods(IImodCEOS);
		}
;

/*
** Statement:	EXEC 4GL SETROW array index (ROW = row)
** Action:	Sets a row in an array to point to a particular object
** Generates:	IIG4srSetRow(array, index, row);
*/
setrow:		setrow_key g4_objval_arg g4_in_row setrow_params
		{
		    gen_call( IIG4SETROW );
		}
;

setrow_key:	tSETROW
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

setrow_params:	tLPAREN tNAME fm_is g4_objval_arg tRPAREN
		{
		    if (STbcompare(ERx("row"), 0, $2.s, 0, TRUE) != 0)
		    {
			    er_write( E_EQ0081_TL_ATTR_UNKNOWN, EQ_ERROR, 1,
								$2.s);
		    }
		}
;

/*
** Statement:	EXEC 4GL SETROW DELETED array (ROWNUMBER = rownumber)
** Action:	Sets a row in an array to be deleted
** Generates:	IIG4drDelRow(array, index);
*/
setrow_deleted:	setrowdel_key g4_objval_arg g4_rownumber
		{
		    gen_call( IIG4DELROW );
		}
;

setrowdel_key:	tSETROW_DEL
		{
		    gr_mechanism( GR_EQSTMT, GR_s4GL, $1.s, NULL );
		}
;

/*
+* --- EXEC 4GL Utility Rules ---
-*
** Where possible, the FRS (fm_) rules are used.  Since EXEC 4GL requires
** colons before all host variables to avoid problems with CALLPROC and
** CALLFRAME, the host_fsetvar production is not allowed, and must always be
** replaced by host_setvar.
*/

/* Rownumber argument */
g4_rownumber:	tLPAREN tNAME fm_is g4_in_row tRPAREN
		{
		    if (STbcompare(ERx("rownumber"), 0, $2.s, 0, TRUE) != 0)
		    {
			    er_write( E_EQ0081_TL_ATTR_UNKNOWN, EQ_ERROR, 1,
								$2.s);
		    }
		}
;

/* Input object value.  Push argument. */
g4_objval_arg:	g4_objval
		{
		    arg_str_add( ARG_INT, $1.s);
		}
;

/* Input object value.  Defer pushing argument. */
g4_objval:	g4_objvar
		{
		    $$.s = $1.s;
		}
	|	fm_iconst
		{
		    $$.s = $1.s;
		}
;

/* Output object variable.  Push argument. */
g4_objvar_arg:	g4_objvar
		{
		    arg_int_add(0);	/* Null indicator */
		    arg_var_add( gr->gr_sym, gr->gr_id );
		}
;

/* Output object variable.  Defer pushing argument. */
g4_objvar:	host_retvar
		{
		    /* Check that it's a valid object */
		    if (gr->gr_type != T_UNDEF) /* Don't cascade errs */
		    {
			if (gr->gr_type != T_INT
				|| sym_g_dsize(gr->gr_sym) != 4)
			    er_write( E_EQ0518_grOBJVAR, EQ_ERROR, 1,
								gr->gr_id );
		    }
		    $$.s = gr->gr_id;
		}
;

/* Optional argument for inquire_4gl or set_4gl */
g4_opt_object:	tLPAREN g4_objval_arg tRPAREN
		{
		    $$.i = 1;
		}
		|
		{
		    arg_int_add(0);
		    $$.i = 0;
		}
;
		    
/* Input row numbers */
g4_in_row:	g4_int
;

/* Optional array index */
g4_opt_index:	
		{
		    $$.s = NULL;
		}
	|	g4_in_val
		{
		    if (gr->gr_type != T_UNDEF) /* Don't cascade errs */
		    {
			if (gr->gr_type != T_INT)
			    er_write( E_EQ0059_grINT, EQ_ERROR, 1, gr->gr_id );
		    }
		    $$.s = gr->gr_id;
		}
;

/* Input values */
g4_in_val:	host_setvar
		{
		}
	|	fm_iconst
		{
		    gr->gr_type = T_INT;
		    gr->gr_id = $1.s;
		    gr->gr_sym = NULL;
		}
	|	fm_fconst
		{
		    gr->gr_type = T_FLOAT;
		    gr->gr_id = $1.s;
		    gr->gr_sym = NULL;
		}
	|	fm_dconst
		{
		    gr->gr_type = T_PACKASCHAR;
		    gr->gr_id = $1.s;
		    gr->gr_sym = NULL;
		}
	|	fm_sconst
		{
		    gr->gr_type = T_CHAR;
		    gr->gr_id = $1.s;
		    gr->gr_sym = NULL;
		}
;

/* SQLDA */
g4_sqlda:	tUSING fm_desc host_sqlda
		{
		    i4  input_output;

		    if (gr->gr_func == IIG4GETATTR)
			input_output = G4SD_GET;
		    else
			input_output = G4SD_SET;

		    arg_int_add( eq_genlang(eq->eq_lang) );/* host language */
		    arg_int_add( input_output );	/* is input? */
		    arg_str_add( ARG_RAW, gr->gr_id );	/* sqlda */
		}
;

/* Element of output list */
g4_out_elm:	fm_out_var fm_is fm_string
;

/* Element of input list */
g4_in_elm:	fm_string fm_is g4_in_ioval
;

/* 4GL integer constant or variable */

g4_int:		fm_iconst_arg
	|	tFLTCONST		/* Common error */
		{
		    er_write( E_EQ0059_grINT, EQ_ERROR, 1, $1.s );
		    arg_int_add( 0 );
		}
	|	tDECCONST		/* Common error */
		{
		    er_write( E_EQ0059_grINT, EQ_ERROR, 1, $1.s );
		    arg_int_add( 0 );
		}
	|	host_setvar
		{
		    if (gr->gr_sym)
		    {
			if (gr->gr_type == T_INT)
			    arg_var_add( gr->gr_sym, gr->gr_id );
			else
			{
			    if (gr->gr_type != T_UNDEF)
				er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1,
								    gr->gr_id );
			    arg_int_add( 0 );
			}
		    }
		    else	/* Error in host_setvar */
			arg_int_add( 0 );
		}
;

/* Input value pushed as an io descriptor. */
g4_in_ioval:	host_setvar sql_opt_ind
		{
		    /* Null indicator argument */
		    if (gr->gr_nlsym)
			arg_var_add( gr->gr_nlsym, gr->gr_nlid );
		    else
			arg_int_add( 0 );

		    if (gr->gr_sym)
			arg_var_add( gr->gr_sym, gr->gr_id );
		    else	/* Error in host_fsetvar */
			arg_str_add( ARG_CHAR, gr->gr_id );
		}
	|	fm_ioiconst
		{
		    gr->gr_type = T_INT;
		}
	|	fm_iofconst
		{
		    gr->gr_type = T_FLOAT;
		}
	|	fm_iodconst
		{
		    gr->gr_type = T_PACKASCHAR;
		}
	|	fm_iosconst
		{
		    gr->gr_type = T_CHAR;
		}
;

/* Attribute for inquire or set */
g4_inqset_attrib: g4_inqset_attrib_val g4_opt_object
		{
		    i4  code;

		    code = g4_check(gr->gr_func, $1.s, (bool)$2.i);
		    arg_int_add(code);
		}
;

g4_inqset_attrib_val: tNAME
		{
		    $$.s = $1.s;
		}
	|	tSCONST
		{
		    $$.s = $1.s;
		}
;


/*
+* ---- Fake Rules ----
-*
** FAKE RULES THAT ARE DEFINED IN L BUT ARE HERE TO ALLOW YACC TO COMPLETE
**
** The L grammar must define the following rules:
**  1. host_code			- Host program code;
**  2. host_term and host_incterm	- Host terminator (for include too);
**  3. host_label			- Host lable;
**  4. host_declare			- Host declarations;
**  5. host_setvar, host_retvar, host_insvar
**     host_intovar, host_fsetvar	- Host variables and names;
**     These variable must set gr_id, gr_sym and gr_type of the name or
**     variable parsed;
**  6. any other rules that need to be added for the language.
**	(ie: PASCAL will add frs_constant: tTYPE).
*/

/* %L fake begin */

/* Block opening and closing */
block_open:	tL_BLK_BEGIN
;
block_close:	tL_BLK_END
;

host_declare:	tH_DECLARE	/* Declare section */
;
host_code:	tHOSTCODE
;
host_insvar:	tCOLON tNAME
;
host_intovar:	tCOLON tNAME
;
host_fsetvar:	tCOLON tNAME
;
host_setvar:	tCOLON tNAME
;
host_retvar:	tCOLON tNAME
;
host_indvar:	tCOLON tNAME
;
host_term:	tH_TERM
;
host_incterm:	tH_TERM
;
host_label:	tNAME
	|	tCOLON tNAME
;
/* %L fake end */

/* %L rules */
%%

/* %L mechanism */
/*{
** Name:	set_insrow_param -- Set a parameter for INSERTROW
**
** Description:
**	EXEC 4GL INSERTROW takes a fixed set of parameters.  Here,
**	we chech a parameter for validity, and save it away if it's correct.	
**
** Inputs:
**	name	char *		Name string for parameter.
**	value	char *		Value string for parameter.
**	type	i4		Data type for parameter.
**	symbol	SYM *		Symbol for parameter
**
** Outputs:
**	param	INSROW4GL_PARAMS *	Parameter structure.
**
** History:
**	11/92 (Mike S) Initial version
*/
static VOID
set_insrow_param(char *name, char *value, i4  type, SYM *symbol,
INSROW4GL_PARMS *param)
{
    /* Fill in our structure, if we can */
    if (STbcompare(name, 0, ERx("rownumber"), 0, TRUE) == 0)
    {
	if (type != T_UNDEF) /* Don't cascade errs */
	{
	    if (type != T_INT)
		er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1, value );
	}
	param->rownumber = value;
    }
    else if (STbcompare(name, 0, ERx("row"), 0, TRUE) == 0)
    {
	if (type != T_UNDEF) /* Don't cascade errs */
	{
	    if (type != T_INT || (symbol != NULL && sym_g_dsize(symbol) != 4))
		er_write( E_EQ0518_grOBJVAR, EQ_ERROR, 1, value );
	}
	param->row = value;
    }
    else if (STbcompare(name, 0, ERx("row_state"), 0, TRUE)== 0)
    {
	if (type != T_UNDEF) /* Don't cascade errs */
	{
	    if (type != T_INT)
		er_write( E_EQ0061_grINTVAR, EQ_ERROR, 1, value );
	}
	param->row_state = value;
    }
    else
    {
	er_write( E_EQ0081_TL_ATTR_UNKNOWN, EQ_ERROR, 1, name);
    }
}
