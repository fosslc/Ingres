/*
** Copyright (c) 2004 Ingres Corporation
*/

#include	<compat.h>
#include	<er.h>
#include	<si.h>
#include	<gl.h>
#include	<sl.h>
#include	<iicommon.h>
#include	<equel.h>
#include	<eqsym.h>
#include	<eqgen.h>
#include	<eqrun.h>
#include	<eqtgt.h>
#include	<ereq.h>

/* {
** Name: eqtlgen.c - Generate the calls for a statement with a target list.
**
** Description:
**	This module is called from the ESQL parser to generate code
**	for a statement that contains a target list, e.g. INQUIRE_/SET_SQL.
**
**	Calls generated by this routine:
**	    SET_SQL
**		IILQssSetSqlio()
**		IILQshSetHandler()
**	    INQUIRE_SQL
**		IILQisInqSqlio()
**		IILQihInqHandler()
**	    GET DATA
**		IILQlgd_LoGetData()
**	    PUT DATA
**		IILQlpd_LoPutDatat()
**
** Defines:
**	eqgen_tl()	- Generate calls based on saved target list info.
**	
** History:
**	13-nov-1989	(barbara)
**	    Written for Phoenix/Alerters
**	22-feb-1991	(kathryn)
**	    Added Support for SET/INQUIRE_SQL statements.
**	24-mar-1991	(barbara)
**	    Added a case for COPYHANDLER in the SET_SQL processing.
**	22-apr-1991	(teresal)
**	    Removed code for GET EVENT.
**	01-nov-1992	(kathryn)
**	    Added support for new GET DATA and PUT DATA statements.
**	    Added function eqtl_setelem().
**	10-dec-1992 (kathryn)
**	    Removed function eqtl_setelem() no longer needed.
**      12-Dec-95 (fanra01)
**          Added definitions for referencing data in DLLs on windows NT from
**          code built for static libraries.
**	14-mar-1996 (thoda04)
**	    Added function prototype for eqgen_tlarg().
**	    Upgraded eqgen_tlarg() function definition to ANSI C
**	    since the bool can't be mixed with old and new C styles.
**
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
*/

static VOID eqgen_tlarg(TL_ELEM *elem_ptr, bool indvar);

/* {
** Name: eqgen_tl - Generate run-time calls for processing a target list
**
** Description:
**	This routine is called from the ESQL parser when a statement containing
**	a target list has been parsed.  The target list elements have been
**	saved away by routines in the eqtarget.c module.  This routine
**	uses the saved information to generate code.
**	For INQUIRE/SET SQL statements one call is generated for each 
**	element in the target list.
**	For GET/PUT DATA statements, one call containing a parameter for each
**	of the attributes in the attribute table is generated.  If the 
**	attribute was not contained in the target list of the statement 
**	then a NULL argument is generated.
**
** Inputs:
**	stmt_id		Internal id of statement to be generated.
** Outputs:
**	None.
**	Returns:
**	    VOID.
**	Errors:
**	    E_EQ0080_TL_STMTID - Illegal or unexpected internal statement id.
** History:
**	13-nov-1989	(barbara)
**	    Written for Phoenix/Alerters.
**	17-jan-1990	(barbara)
**	    Updated to generate "input" target lists.
**	01-mar-1991	(kathryn)
**	    Added support for SET/INQUIRE_SQL statments, including handlers.
**	24-mar-1991	(barbara)
**	    Added a case for COPYHANDLER in the SET_SQL processing.
**	22-apr-1991	(teresal)
**	    Removed code for GET EVENT.
**	29-jul-1991	(teresal)
**	    Modify siEVTHDLR to siDBEVHDLR as part of the
**	    EVENT to DBEVENT change.
**	01-nov-1992	(kathryn)
**	    Added support for GET DATA (IIGETDATA) and PUT DATA (IIPUTDATA)
**	    statements.
**	10-feb-1993 	(kathryn)
**	    Do not special case the gdMAXLENG attribute of for the GET DATA
**	    statement. The code generators will ensure that the parameter 
**	    is not passed by reference.
**	17-sep-1993 (kathryn)
**	    Remove references to INQUIRE_SQL for error,message and dbevent
**	    handlers.  This has/will not be supported.
**	01-oct-1993 (kathryn)
**	    Generate new "dataflags" parameter for GET/PUT DATA statments.
**	    II_DATLEN defined in eqrun.h set when segmentlength has been 
**	    specifed on PUT DATA stmt or maxlength has been specified on 
**	    the GET DATA stmt.
**	9-nov-93 (robf)
**          Add dbprompthandler support
**	
*/


VOID
eqgen_tl(stmt_id)
i4	stmt_id;
{
    i4		i;
    i4		attr_id;
    i4		dataflags = 0;
    TL_DESC 	*tl_desc;
    TL_DESC	*eqtl_get();
    TL_ELEM	*elem_ptr;
    TL_ELEM	tl_nul = {(char *)0, (PTR)0, (char *)0, (PTR)0, 0, 0};

# if defined(NT_GENERIC) && defined(__USE_LIB__)
    GLOBALDLLREF	i4 max_attribs;
# else              /* NT_GENERIC && __USE_LIB__ */
    GLOBALREF	i4 max_attribs;
# endif             /* NT_GENERIC && __USE_LIB__ */

    tl_desc = eqtl_get();

    /* If error with whole target list, don't generate code */
    if (tl_desc->tld_error == TRUE)
	return;

    /* Check for illegal statement id */
    if (tl_desc->tld_stmtid != stmt_id)
    {
	er_write( E_EQ0080_TL_STMTID, EQ_ERROR, 0 );
	return;
    }

    switch (stmt_id)
    {

    	/* For each element in the target list: 
	**     Add appropriate arguments to the arg array.
	**     Generate one IILQssSetSqlio call. 
	*/ 

	case IISETSQL:
	    for (i = 0; i < tl_desc->tld_nelems; i++)
	    {
		elem_ptr = &tl_desc->tld_elem[i];
		arg_int_add( elem_ptr->tle_attr );
		switch (elem_ptr->tle_attr)
		{
		    case siERHDLR:
		    case siDBEVHDLR:
		    case siMSGHDLR:
		    case siCPYHDLR:
		    case siDBPRMPTHDLR:
			eqgen_tlarg(elem_ptr,0);
			gen_call(IISETHDL);
			break;
		    default:
			eqgen_tlarg(elem_ptr,1);
			gen_call(stmt_id);
			break;
		}
 	    }
	    break;


        /* For each element in the target list:
        **     Add appropriate arguments to the arg array.
        **     Generate one IILQisInqSqlio call.
        */

	case IIINQSQL:
            for (i = 0; i < tl_desc->tld_nelems; i++)
	    {
		elem_ptr = &tl_desc->tld_elem[i];	
		eqgen_tlarg(elem_ptr,1);
		arg_int_add( elem_ptr->tle_attr );
		gen_call(stmt_id);
	    }
	    break;

	/* Generate one statement which contains arguments for each of the
	** elements in the attribute table.  Arguments for all attributes 
	** in the TL_ATTRS table (getdat_attribs/putdat_attribs) must
	** be generated.  If the attribute was not specified in the
	** target list of the statement then generate the appropriate
	** NULL value.
	*/
 	case IIGETDATA:
	case IIPUTDATA:
	    for (i = 0; i < max_attribs; i++)
	    {
		attr_id = tl_desc->tld_attrtbl[i].tla_id;
		elem_ptr = eqtl_elem(attr_id);

		/* Generate appropriate null argument */
		if (elem_ptr == (TL_ELEM *)0)
		    elem_ptr = &tl_nul;
		else if (attr_id == gdSEGMENT)
			dataflags |= II_DATSEG;
		else if (((attr_id == gdSEGLENG) && (stmt_id == IIPUTDATA))
		        || (attr_id == gdMAXLENG))
		    dataflags |= II_DATLEN;
	  	eqgen_tlarg(elem_ptr,0);
	    }
	    arg_int_add(dataflags);
            gen_call(stmt_id);
            break;

	default:
	    break;
    }
}
/* {
** Name: eqgen_tlarg - Save arguments for the arg manager.
**
** Description:
**	Add arguments to the argument array for generation of IILQ calls.
**
** Inputs:
**	elem_ptr:	- Attribute element.
**	indvar:		- Null indicator arg should be generated.
**
** Outputs:
**	Returns:
**	    VOID.
**	Errors:
**	    none.
**
** History:
**	01-mar-1991 	(kathryn) Written.
**
*/
static VOID
eqgen_tlarg(TL_ELEM *elem_ptr, bool indvar)
{
	if (indvar)
	{
	    if (elem_ptr->tle_indvar != (PTR)0)
	        arg_var_add( elem_ptr->tle_indvar, elem_ptr->tle_indname );
	    else 
	        arg_int_add( 0 );
	}
	if (elem_ptr->tle_var != (PTR)0)
	{
	    /* Generic null should be handled through here */
	    arg_var_add( elem_ptr->tle_var, elem_ptr->tle_val );
	}
	else
	{
	    switch (elem_ptr->tle_type)
	    {
	      case T_INT:
		arg_str_add( ARG_INT, elem_ptr->tle_val );
		break;
	      case T_FLOAT:
		arg_str_add( ARG_FLOAT, elem_ptr->tle_val );
		break;
	      case T_CHAR:
		arg_str_add( ARG_CHAR, elem_ptr->tle_val );
		break;
	      default:
		arg_str_add( ARG_RAW, elem_ptr->tle_val );
	    }
	}
}
