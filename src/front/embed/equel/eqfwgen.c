
/*
** Copyright (c) 2004 Ingres Corporation
*/

# include <compat.h>
# include <er.h>
# include <si.h>
# include <st.h>
# include	<gl.h>
# include	<sl.h>
# include	<iicommon.h>
# include <equel.h>
# include <fsicnsts.h>
# include <eqsym.h>		/* Needed by eqgen.h */
# include <eqgen.h>		/* Needed for IIMESSAGE, IIDISPFRM, etc */
# include <eqfw.h> 


/*{
**  Filename:	eqfwgen.c
**
**  Purpose:   	Generate the IIFR calls for a forms with clause
**
**  Defines:	
**	EQFW3glgen()	- Generate runtime code for forms with clause
**
**  Notes:
**	1.  Does not generate any code if error indicator has been set in
**	IIFWGI_GLOBAL_INFO error member 
**      2.  If the default values used in the IIFR unit change
**  	from 0 to some number, changes will have to be made, as currently
**	any options which have been set to 0 do not generate an IIFR call.
**
**  History:
**	22-apr-1988	Written.	(marge)
**	13-may-1988	Changed fw_isdefault local function to call
**			global macro EQFW_ISDEFAULT.  (marge)
**	18-may-1988	Fixed bug: was using subopid instead of rtsubopid
**			for IIFRgpsetio call.  (marge)
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
*/
/*{
**  Name:	EQFW3glgen
**
**  Description:
**	Generate the runtime calls for a forms with clause
**	based on values stored in the option value list.
**
**  Inputs:
**	None
**  Returns:
**	nothing
**  History:
**	22-apr-1988	Written.	(marge)
*/

VOID
EQFW3glgen()
{
    IIFWGI_GLOBAL_INFO		*gip;
    IIFWOV_OPTION_VALUE		*ovp;
    i4				type;

    gip = EQFWgiget();		/* Get global info pointer */
    if (gip->gi_err == TRUE)
	return;

    /*  Generate IIFWgpcontrol(FSPS_OPEN, 0); */
    arg_push();			/* Push any args on arg stack */
    arg_int_add(FSPS_OPEN);	
    arg_int_add(0);		/* Argument slot for future flags */
    gen_call(IIFRGPCONTROL);

    /*  For each entry in the option-value list, generate an IIFRgpsetio call */
    for (ovp = gip->gi_ovp; ovp->ov_pval != NULL; ovp++)
    {
	/* args for IIFRgpsetio:
	** (i4 pid, i2 *nullind, bool isvar, i4  type,  i4  len, PTR val)
	** Where last 4 args are automatically generated by gen_io call
	*/
	/*
	**  NOTE:  If the default values used in the IIFR unit change
	**  	   from 0 to some number, this call will have to change
	**	   and perhaps we'll have to send all settings to IIFR
	*/
	if (!EQFW_ISDEFAULT(ovp))	/* gen call if value != def */
	{ 
            arg_push();				/* Push any args on arg stack */
	    arg_int_add(ovp->ov_odptr->od_rtsubopid);	/* push pid */
	    arg_int_add(0);			/* Arg slot for null ind */
	    if (ovp->ov_varinfo != NULL)	/* symbol? */
	    {
		    arg_var_add(ovp->ov_varinfo, ovp->ov_pval);
	    }
	    else
	    {	/* map grammar's types to arg manager's types */

		switch (ovp->ov_odptr->od_type)
		{
		    case T_CHAR:
			 type = ARG_CHAR;
			 break;
		    case T_INT:
			 type = ARG_INT;
			 break;
		    case T_FLOAT:
			 type = ARG_FLOAT;
			 break;
		    default:
			 type = ARG_INT;	/* TEST ALL CASES ?? */
			 break;
		}
		arg_str_add(type, ovp->ov_pval);
	    }
	    gen_call(IIFRGPSETIO);
	}
    }
    arg_push();			/* Push any args on arg stack */
    arg_int_add(FSPS_CLOSE);	
    arg_int_add(0);		/* Argument slot for future flags */
    gen_call(IIFRGPCONTROL);
}

	
