/* Copyright (c) 1986, 2005 Ingres Corporation
**
**
*/

%{
#include    <compat.h>
#include    <gl.h>
#include    <cs.h>
#include    <ci.h>
#include    <cv.h>
#include    <mh.h>
#include    <qu.h>
#include    <st.h>
#include    <tr.h>
#include    <tm.h>
#include    <tmtz.h>
#include    <cm.h>
#include    <er.h>
#include    <me.h>
#include    <bt.h>
#include    <pc.h>
#include    <iicommon.h>
#include    <dbdbms.h>
#include    <gca.h>
#include    <ddb.h>
#include    <dmf.h>
#include    <dmacb.h>
#include    <dmccb.h>
#include    <dmtcb.h>
#include    <dmrcb.h>
#include    <dmucb.h>
#include    <adf.h>
#include    <ade.h>
#include    <adfops.h>
#include    <ulf.h>
#include    <ulm.h>
#include    <qsf.h>
#include    <qefrcb.h>
#include    <rdf.h>
#include    <sxf.h>
#include    <copy.h>
#include    <qefmain.h>
#include    <qefqeu.h>
#include    <qeuqcb.h>
#include    <qefcopy.h>
#include    <qefcb.h>
#include    <opfcb.h>
#include    <scf.h>
#include    <ex.h>
#include    <cui.h>
#include    <psfparse.h>
#include    <psfindep.h>
#include    <pshparse.h>
#include    "pslgram.h"
#include    "pslscan.h"
#include    <yacc.h>
#include    <usererror.h>
#include    <dudbms.h>
#include    <psftrmwh.h>
#include    <psldef.h>
#include    <psqcvtdw.h>
#include    <psqmonth.h>
#include    <psttprpnd.h>
#include    <pstwindup.h>
#include    <psyaudit.h>
#include    <uld.h>

/* 
** NO_OPTIM=dgi_us5 int_lnx int_rpl ibm_lnx i64_aix
*/

/* look in yyvars.h in local directory for local variables.*/
#define YYDEBUG 1
#define YACC_VARS 1
#define MAX_CREATE_CHARS 3
#define MAX_INDEX_CHARS 12
%}

/**
**
**  Name: PSLGRAM.YI - The grammar for QUEL.
**
**  Description:
**      This file contains the grammar for QUEL in the server. 
[@comment_line@]...
**
**          psl_parse - Parses a QUEL statement, checks for syntax errors
**			and some limited semantic errors, and generates data
**			structures for the next phase in query processing.
**
**
**  History:
**      22-jan-86 (jeff)    
**          Transcribed from old grammar.y without actions.
**      03-sep-86 (seputis)
**          Fixed SCU_INFORMATION calls to pass correct parameters
**	19-sep-86 (daved)
**	    set the updmap for cursors with the column number. this is
**	    the number checked in the addresdom code. don't use the
**	    resdom number.
**	19-jan-87 (rogerk)
**	    Added parsing of COPY command.
**	1-apr-87 (daved)
**	    ISOP is for '=' in QUEL
**	27-apr-87 (puree)
**	    Added COPY WITH NULL productions.
**	09-jun-87 (rogerk)
**	    Made sure parser gave an ADF function instance for VARCHAR row
**	    types (even if tuple type is varchar).
**	26-aug-87 (puree)
**	    use cp_cvlen for ADF result length, cp_length for user specified
**	    length.
**	22-feb-88 (puree)
**	    fix copy bug 1984.  set ADE_LEN_UNKNOWN in variable length dummy
**	    field.
**	20-may-88 (thurston)
**	    Added code to the grammar for SET DATE_FORMAT so that the new
**	    "german" date format is understood.
**	26-may-88 (thurston)
**	    Added code to the SET DATE_FORMAT production to allow "german" as
**	    a legal format.
**	03-jun-88 (jrb)
**	    Added code for all PST_OP_NODEs to set pst_isescape to
**	    PST_DOESNT_APPLY (this field is used only for the LIKE predicate
**	    in SQL when an ESCAPE character is indicated).
**	26-jul-88 (andre)
**	    Modified restrictions on when a DB object may be created/deleted,
**	    i.e. an object can't be created/deleted if 1) it is a core catalog
**	    or 2) it is a catalog and the user has no update privilege or
**	    3) it is not a catalog (i.e. it is a table), and the user doesn't
**	    own it.    
**	20-sep-88 (stec)
**	    Fix error text output from crname production (shared by retrieve 
**	    into and create).
**	21-sep-88 (stec)
**	    When calling psl0_rngent to identify DESTROY object,
**	     do not request info on columns.
**	21-sep-88 (stec)
**	    Set money_format statement.
**	12-oct-88 (stec)
**	    5.0->6.0 gateway requires parser to accept repeat queries with =,is.
**	13-oct-88 (stec)
**	    Fix `set money precision' to accept <0..2>.
**	13-oct-88 (stec)
**	    Disallow SET[NO]JOURNALING on catalogs (LRC decision).
**	19-oct-88 (stec)
**	    DESTROY will now get info from RDF, invalidate the entry and get
**	    a fresh one from DMF (see comment in the destrname: rule).
**	24-oct-88 (puree)
**	    Fix copy bug 2684.  For a dummy copy column in copy into, if the 
**	    cp_length is ADE_LEN_UNKNOWN, set cp_cvlen to 0 so that iicopy
**	    computes the correct row length.
**	24-oct-88 (stec)
**	    Disallow REPLACE on BTREE secondary indices.
**	    Fix DEFINE CURSOR statement.
**	    Change pst_dups initialization for retrieve.
**	    Implement code changes allowing DBA to grant privileges on
**	    extended catalogs.
**	04-nov-88 (stec)
**	    Remove references to psc_status_mask, psc_storage_type.
**	    Replaced MEcopy with STRUCT_ASSIGN_MACRO (cursor action).
**	    Initialize $Ynonupdt.
**	08-nov-88 (stec)
**	    Catalog update priv is sufficient to define permits on catalogs.
**	    Fix update btree index check.
**	10-nov-88 (stec)
**	    Fix cursor problem - should not be readonly if FOR UPDATE
**	    not specified.
**	    Fix SET DATE FORMAT bug.
**	11-nov-88 (stec)
**	    Change timezone defn from i2 to nat.
**	14-nov-88 (stec)
**	    Initialize properly ADF_CB on the stack.
**	16-nov-88 (stec)
**	    Change cursor code to open without READONLY clause
**	    specified when non-deleteable.
**	17-nov-88 (stec)
**	    Take out support for PRINT stmt.
**	21-nov-88 (stec)
**	    Fix initialization of default structure characteristic in
**	    the index statement.
**	28-nov-88 (stec)
**	    Add support for nonconforming user names in DEFINE PERMIT.
**	    Allow DESTROY PERMIT on catalogs by non-dba users if catalog update 
**	    privilege has been specified.
**	10-jan-89 (puree)
**	    Fix copy bug 4367 and 4370, handling of null-substitution values.
**	    Also need changes in the front end part IICOPY.
**	24-jan-89 (stec)
**	    Straightened out comments related to when indices and non-
**	    extended catalogs can be modified (catalog update privilege
**	    is required).
**	13-feb-89 (stec)
**	    Removed rname rule.
**	    Changed code for the UPDATE clause in the OPEN CURSOR statement,
**	    column list is optional and semantics of the clause are different
**	    from SQL. For more info see quel ref.man.
**	25-mar-89 (jrb)
**	    Change adc_lenchk calls to reflect interface change.
**	24-may-89 (ralph)
**	    GRANT Enhancements, Phase 2c:
**	    Check CREATE_TABLE and LOCKMODE privileges
**	18-sep-89 (jrb)
**	    Major changes for DECIMAL datatype.  Fields for precision were set
**	    properly, new code for DECIMAL conversion function, literals,
**	    column specifications, and COPY support.
**	18-sep-89 (ralph)
**	    GRANT Enhancements, Phase 2e:
**	    Added support for SET [NO]MAX{QUERY,IO,ROW,CPU,PAGE,COST}
**      20-sep-89 (jennifer)
**          Added DAC audit calls.
**	02-oct-89 (neil)
**	    Trap trace point to SET [NO]RULES, discontinue old query modes
**	    reused for alerters.
**	08-oct-89 (ralph)
**	    GRANT Enhancements, Phase 2e:
**	    Added support for SET [NO]MAX{QUERY,IO,ROW,CPU,PAGE,COST}
**	25-oct-89 (ralph)
**	    Fixed auditing of DESTROY VIEW
**	06-nov-89 (fred)
**	    Added support for unsortable and unkeyable datatypes.  In modify,
**	    index, and retrieve into processing, check keys for keyability.
**	    Also changed the final parameter to pst_{var,exp}sort() to be
**	    the entire psq_cb -- needed for ADF error propogation.
**	16-dec-89 (neil)
**	    Trap SET [NO]RULES trace points in 2 places.
**	19-Jan-90 (anton)
**	    Integrate NS&E porting changes from ingresug 90020
**	03-may-90 (linda)
**	    Always initialize dmu_gw_id field to 0 for QUEL when creating
**	    tables or indexes.
**	08-aug-90 (ralph)
**	    Initialize new psy_cb fields.
**	23-aug-90 (ralph)
**	    Call psy_cpyperm to check permission to issue COPY INTO/FROM
**      12-sep-90 (teresa)
**          Several booleans have become bitflags in either pss_flag or
**          pss_ses_flag: PSS_AGINTREE, PSS_TXTEMIT, PSS_WARNINGS,
**          PSS_JOURNALING, PSS_FIPS_MODE, PSS_CATUPD; also pss_project becomes
**	    a bitflag in psq_flag instead of being a boolean
**	25-oct-90 (andre)
**	    for PST_AGHEAD and PST_ROOT, in pst_node() pst_qlang will be set to
**	    cb->pss_lang and pst_project to FALSE. (fix for bug 33371)
**	6-nov-90 (andre)
**	    replace pss_flag with pss_stmt_flags and pss_dbp_flags.
**	26-dec-90 (andre)
**	    support SET [NO]OPTIMIZEONLY: act as if user entered
**	    "SET TRACE POINT op160"
**	22-jan-91 (andre)
**	    disallow SET LOCKMODE ON TABLE WHERE TIMEOUT=0 on SCONCUR catalogs,
**	    iihistogram and iistatistics if
**	    (Psf_srvblk->psf_flags & PSF_NO_ZERO_TIMEOUT)
**	04-feb-91 (andre)
**	    The following changes were made as a part of the project to support
**	    shareable QUEL repeat queries:
**	     - append:, delete:, replace:, and dmlstmt: productions will now
**	       return a pointer to a query tree header;
**	     - defined a new function, psl_quel_shareable(), which is used to
**	       determine if an apparently shareable query meets the
**	       QUEL-specific shareability tests;
**	     - modified query: production to allocate and populate
**	       DB_SHR_RPTQRY_INFO structure for an apparently shareable query;
**	       final detrmination will be made by psl_repeat_qry_id();
**	     - modified query_key: production to open text chain used for
**	       storing "normalized" text of a repeat query;
**	     - defined new function, psl_rptqry_tblids(), which will be use to
**	       build an ORDERED list of IDs of tables which were used in an
**	       apparently shareable QUEL repeat query;
**	     - added support for a new tracepoint, ps132, which will report
**	       whether the query was shareable, and if not, provide a reason.
**      07-feb-1991 (jennifer)
**          Fix bug 31865 by checking minpages and maxpages for a maximum
**          value of 8388607.
**      07-feb-1991 (jennifer)
**          Fix bug 34079 by checking if update,delete or insert directly to 
**          a secondary index.  This was never supposed to be supported
**          for 6.0.
**	20-feb-91 (andre)
**	    group and role permits must be disregarded when parsing definitions
**	    of views - OR PSS_DISREGARD_GROUP_ROLE_PERMS into cb->pss_stmt_flags
**	    upon parsing DEFINE VIEW
**	    (this was done as a part of fix for bug #32457)
**
**	    When parsing DEFINE PERMIT, (in permwho:) set psy_cb->psy_gtype to
**	    DBGR_USER if grantee is a user or to DBGR_PUBLIC if grantee is
**	    specified as ALL. Until now, this field was not set here, and in
**	    psy_dperm() it was set to DBGR_USER regardless of grantee type.
**	19-mar-91 (andre)
**	    moved semantic actions used to parse MODIFY into PSLMDFY.C
**	    moved semantic actions responsible for parsing SET LOCKMODE into
**	    PSLLKMD.C
**	09-apr-91 (andre)
**	    fix bug 36828: in retwithcls: production, upon encountering WITH
**	    issue an error message and avoid further processing if the query
**	    being processed is not RETRIEVE INTO (actually, INTO is optional).
**	    In case of WITH NULL, I can't really do it upon parsing WITH since
**	    the grammar sees WITHNULL, but fortunately this does not cause any
**	    problems, and the error message gets issued upon seeing WITHNULL.
**	22-apr-91 (andre)
**	    modify copyoption: production to disregard WITH-clause of form
**	    "copyhandler = <string>"
**	29-apr-1991 (Derek)
**	    Added support for COPY,INDEX,MODIFY,CREATE with clause options.
**	24-may-91 (andre)
**	    Add support for SET USER AUTHORIZATION, SET [NO]ROLE, and SET
**	    [NO]GROUP.
**	24-jun-91 (andre)
**	    Make changes required to facilitate splitting of permit tuples
**	    built for DEFINE PERMIT statement so that each tuple represents
**	    exactly one privilege.
**	13-nov-91 (andre)
**	    merge 4-feb-91 (rogerk) change:
**		Moved support for SET [NO]LOGGING and SET LOG_TRACE from SQL
**		grammar to QUEL grammar.
**		Added SET LOG_TRACE statement.  Causes PSQ_DMFTRACE statement.
**		Added SET [NO]LOGGING statement.  Causes PSQ_SLOGGING statement
**		to enable/disable logging.
**	13-nov-1991 (andre)
**	    merge 25-feb-91 (rogerk) change:
**		Added SET SESSION statement.  Returns PSQ_SON_ERROR query mode.
**		Changed ERUSF error numbers added for Set Nologging to be
**		ERPSF errors to follow error number conventions.
**	19-nov-1991 (andre)
**	    merge 03-jun-91 (stevet) change:
**		fix bug 37777.  Preserve NULLability when datatype is being
**		mapped to DB_CHA_TYPE because of the AD_NOEXPORT
**		or AD_CONDEXPORT condition.
**	19-nov-1991 (andre)
**	    merge 25-jul-91 (andre) change:
**		set psy_cb->psy_grant to PSY_TDROP when destroying permits;
**		otherwise psy_kperm() gets terribly confused and results are
**		unpredictable.  This fixes bug 38843
**	    merge 05-aug-91 (markg) change:
**		fix bug 38897. In a MODIFY statement allow the key-sortorder to
**		be "a" or "d" as well as "ascending" or "descending".
**	    merge 10-sep-91 (andre) change:
**		If the WITH-clause of COPY statement encounters WITH LOG = ~V,
**		call qdata_cvt() to ensure that we are dealing with a
**		DB_TEXT_STRING before trying to copy it.
**	14-jan-92 (barbara)
**	    Included ddb.h for Star.
**	26-feb-92 (andre)
**	    if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in
**	    sess_cb->pss_ses_flags, allow REPLACE/DELETE/APPEND on indexes
**	    marked as non-extended catalogs 
**	30-mar-1992 (bryanp)
**	    Set pss_sess_table to false for all QUEL objects.
**      20-may-92 (schang)
**          GW merge. mainly change args in procedure so that code can be
**          shared bwteen Ingres and RMS gateway servers.
**	15-jun-92 (barbara)
**	    Sybil merge.  Although the distributed thread is not supported
**	    in QUEL, the changes to the SQL grammar affect the QUEL
**	    grammar: extract copy semantic actions into separate
**	    module, change interface to pst_header() pst_rglook(), 
**	    psl_shareable() and psl0_rngent.
**	20-jul-92 (andre)
**	    added a new keyword - EXCLUDING
**
**	    added support for EXCLUDING (<column list>) clause in DEFINE PERMIT
**	    statement
**	31-aug-92 (barbara)
**	    On DESTROY, no need to clear whole cache to get rid of potentially
**	    stale RDF cache entries that could be on cache after a rollback
**	    of a dropped table.  Instead, DROP now sets RDF's refresh
**	    bit (see pstshowtab.c) to tell RDF to renew its cached entry.
**	16-sep-92 (andre)
**	    privilege map gets populated using bitwise operators - care should
**	    be excersized when accessing it using BTnext(), BTset(), BTclear(),
**	    and the like.  In particular, one should not count on BTnext()
**	    returning DB_RETP even if you know for a fact that the map contains
**	    DB_RETRIEVE
**	25-sep-1992 (pholman)
**	    For C2, replace obsolete qeu_audit calls with their SXF successor,
**	    adding <sxf.h>.
**  	25-sep-92 (stevet)
**  	    Implemented the new timezone adjustment method by
**  	    replacing TMzone() with TMtz_search() routine.
**	11-oct-92 (rblumer)
**	    changed new SQL option NOT NULL <no default> to behave like
**	    NOT DEFAULT; added new PSS_TYPEs in the null_default production;
**	    added parameter to psl_ct1_create_table call; 
**	    added parameter to psl_ct9_new_loc_name call.
**	27-nov-92 (robf)
**	    re-added GWF tracing test (lost in last integration)
**	01-dec-92 (andre)
**	    removed support for SET USER AUTHORIZATION, SET [NO]ROLE, and SET
**	    [NO]GROUP.
**	04-dec-1992 (pholman)
**	    change sxf_calls to be use new psy_secaudit wrapper
**	20-nov-92 (rblumer)
**	    added PST_QNODE parameter to psl_ct14_type_desc call; 
**          have view definition define a generic default ID for each column.
**	21-dec-92 (andre)
**	    replaced most of defview: semantic action with a call to
**	    psl_cv1_create_view().  In a related development, instead of
**	    building a PSY_CB to represent DEFINE VIEW statement, we will be
**	    building a PST_CREATE_VIEW statement.
**	30-dec-92 (andre)
**	    when processing a view definition, remember whether it involved
**	    aggregate(s) outside of qualification
**      13-jan-1993 (stevet)
**          Add check to make sure second argument of string
**          functions: ascii(), text(), char(), varchar(), is a
**          constant integer.
**	25-jan-93 (rblumer)
**	    added DB_TEXT_STRING parameter to psl_ct14_typedesc call; 
**          change append to handle user-defined defaults (psl_check_defaults).
**	25-feb-93 (rblumer)
**	    Change RETRIEVE INTO code to record default ID info in the resdom
**	    so OPC can use it to set up attribute descriptors for the table;
**	    change parameter to psf_adf_error to be psq_error, not psq_cb.
**	10-mar-93 (andre)
**	    now it is possible for a user to define a cursor FOR UPDATE of
**	    column(s) for some of which the current user lacks UPDATE/REPLACE
**	    privilege (this was done for SQL cursors to make them
**	    SQL92-compliant, but it will also spill into QUEL.)  This it is
**	    possible that a column name will be found in the list of "for
**	    update" columns, but the corresponding bit in psc_updmap may not be
**	    set.  If that is the case, we need to tell the user that he lacks
**	    UPDATE privilege on that attribute
**	01-apr-93 (andre)
**	    (fix for bugs 50823, 50825, and 50899)
**	    when processing REPLACE CURSOR, obtain description of the table or
**	    view over which the cursor was defined and make cb->pss_resrng point
**	    at it - this will make it possible for us to apply psy_view() and
**	    psy_protect() (if necessary) and ensure that psy_rules() will not be
**	    dereferencing through a NULL pointer;
**
**	    get rid of delcurs non-terminal and the associated semantic action
**	    since DELETE CURSOR processing will always go through psq_dlcsrrow()
**	02-apr-93 (andre)
**	    (fix for bug 42691)
**	    while the bug was reported against SQL cursor update, it applies
**	    equally to QUEL.  In attribfcn: NAME production, rather than trying
**	    to look up column among columns in the FOR UPDATE list, we should
**	    search the list of all columns of the table/view on which the
**	    cursor was defined.  It requires that we obtain description of the
**	    table on which the cursor is defined in replcursorstmnt: production
**	    and make cb->pss_resrng point at it, and in attribfcn: NAME
**	    production, instead of calling psq_ccol(), we will use
**	    pst_coldesc().  After calling psy_qrymod(), we will invoke
**	    psl_curval() to convert PST_VAR nodes in the subtrees hanging off
**	    PST_RESDOMs into PST_CURVAL nodes as expected by the optimizer
**	06-apr-93 (rblumer)
**	    added with_clauses parameter to psl_md3_modstorage
**	10-mar-93 (barbara)
**	    For Star delimited id support, grammar flags were moved to the
**	    session cb.  The interface to several CREATE TABLE functions
**	    changed as a result.
**	20-apr-93 (rblumer)
**	    in RETRIEVE INTO, changed default values for calculated columns to
**	    be based on the 'default' QUEL default, instead of UNKNOWN.
**	    Removed unused variables & added externs to quiet compiler warnings.
**	31-mar-93 (ralph)
**	    DELIM_IDENT:
**	    Introduce "nonkeyword" production to translate non-keyword
**	    uses of NAME to lower case in upper-cased regular identifier
**	    environments.
**	    Use appropriate case for "tid".
**	06-apr-93 (swm)
**	    Comment out character string following #endifs.
**      06-may-93 (anitap)
**          Added support for "SET UPDATE_ROWCOUNT" statement.
**	26-may-93 (andre)
**	    if a language variable is used to supply a value where a string
**	    constant is expected, verify that its type is indeed one of C, CHAR,
**	    TEXT, VARCHAR, or LONGTEXT
**	    When calling qdata_cvt(), ensure that the output datatype agrees
**	    with input datatype as regards nullability
**	17-jun-93 (andre)
**	    changed interface of psy_secaudit() to accept PSS_SESBLK
**	18-jun-93 (robf)
**	    Secure 2.0:
**	       Pass security label to psy_secaudit
**	06-jul-93 (anitap)
**	    Removed CHANGED as a keyword for SET UPDATE_ROWCOUNT statement.
**	    Changed from SET UPDATE_ROWCOUNT TO CHANGED/QUALIFIED to 
**	    SET UPDATE_ROWCOUNT CHANGED/QUALIFIED.
**	07-Jul-1993 (daveb)
**	    Removed FUNC_EXTERN of EXsetup.  It is (and should be) in <ex.h>.
**	    Removed FUNC_EXTERN of scf_call.  It is (and should be) in <scf.h>.
**      12-Jul-1993 (fred)
**          Changed lots of places so that users cannot directly muck
**          with extension tables.  These are now treated basically
**          the same as core system catalogs for permission purposes.
**	14-jul-93 (ed)
**	    replacing <dbms.h> by <gl.h> <sl.h> <iicommon.h> <dbdbms.h>.
**	26-jul-1993 (rmuth)
**	    Support more WITH options for the COPY command. Add the
**	    "with_clauses" parameter to psl_cp1_copytable, psl_cp2_copstmnt 
**	    and  psl_cp11_nm_eq_no.
**	27-jul-93 (ralph)
**	    DELIM_IDENT:
**	    Lower case nonkeywords specified in the cr_lst_elem production.
**	10-aug-93 (andre)
**	    fix causes of compiler warnings
**	12-aug-93 (andre)
**	    replace TABLES_TO_CHECK() with PSS_USRTBL|PSS_DBATBL|PSS_INGTBL.
**	    TABLES_TO_CHECK() was being used because long time ago we made an
**	    assumption that 3-tier name space will not be used when processing 
**	    SQL queries while running in FIPS mode.  That assumption proved to 
**	    be incorrect and there is no longer a need to use this macro
**	17-aug-93 (andre)
**	    PSS_OBJ_NAME.pss_qualified and PSS_OBJ_NAME.pss_sess_table have been
**	    replaced with PSS_OBJSPEC_EXPL_SCHEMA and PSS_OBJSPEC_SESS_SCHEMA
**	    defined over PSS_OBJ_NAME.pss_objspec_flags so instead of setting 
**	    pss_qualified and pss_sess_table to FALSE, we will initialize
**	    pss_objspec_flags to 0
**
**	    got rid of name_or_sconst
**	    introduced a new non-terminal - nonkey_or_sconst.  Unlike 
** 	    name_or_sconst, it will always lowercase unquoted strings.  
** 	    It will be used in coent: and cpdelim: productions where we do not 
**	    want to have delimiter string being uppercased
**	17-aug-93 (stephenb)
**	    Fixed audit message in call to psy_secaudit() on drop index, was
**	    incorrectly auditing I_SX2025_TABLE_DROP.
**	18-aug-93 (andre)
**	    added support for QUEL version of delimited identifiers.  It is my
**	    intent that they be allowed only inside <column list> in 
**	    DEFINE PERMIT statement.  We must allow delimited identifiers there
**          because QEF may need to generate a column list for a QUEL permit 
**	    affected by revocation of column-specific privilege, and some of 
**	    those column names may need to be expressed as delimited identifiers
**	    (as a matter of fact, for now they will all be expressed as 
** 	    delimited identifiers - there is hope, however, that at some point 
**	    we will get our hands on IIUGdlm_ChkdlmBEobjct (I cannot and will 
**	    not claim credit for this one) which will enable us to avoid 
**	    delimiting column names unless absolutely necessary)
**
**	    defined generic_ident non-terminal which will be used on the RHS 
**	    of permtelm production
**      23-aug-1993 (rmuth)
**          READONLY table : Disallow a user dropping this object.
**	15-sep-93 (swm)
**	    Moved cs.h include above other header files which need its
**	    definition of CS_SID.
**	13-sep-1993 (dianeh)
**	    Removed NO_OPTIM setting for obsolete Sun3 port (sun_u42).
**	20-sep-93 (robf)
**          Use same semantics for QUEL/SQL updates of row security label.
**	30-sep-93 (stephenb)
**	    DEFINE/DESTROY INTEGRITY is an auditable event, added calls to
**	    psy_secaudit() to audit failed attempt to do so.
**	18-oct-1993 (rmuth)
**	    Correct a call to psf_error.
**	20-oct-93 (robf)
**          Add support  for COPY_INTO/FROM permits
**	25-oct-93 (vijay)
**	    cast rhs of assignment to dmc_id to ptr. 
**	    Also, qef_dmf_id and qef_sess_id are now CS_SID.
**	18-nov-93 (stephenb)
**	    Include psyaudit.h for prototyping. And then eliminate prototyping
**	    errors.
**	09-oct-93 (swm)
**	    Bug #56437
**	    Put pss_sessid into new dmc_session_id rather than dmc_id.
**	11-oct-93 (swm)
**	    Bug #56448
**	    Made psf_display() portable. The old psf_display() took a variable
**	    number of variable-sized arguments. It could not be re-written as
**	    a varargs function as this practice is outlawed in main line code.
**	    The problem was solved by invoking a varargs function, TRformat,
**	    directly.
**	    The psf_display() function has now been deleted, but for flexibilty
**	    psf_display has been #defined to TRformat to accomodate future
**	    change.
**	    All calls to psf_display() changed to pass additional arguments
**	    required by TRformat:
**	        psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1, ...)
**	    this emulates the behaviour of the old psf_display() except that
**	    the trbuf must be supplied.
**	28-feb-94 (robf)
**          Initialize pst_dmuflags.
**	17-mar-1994 (pearl)
**	    Bug 58955.  'set trace [terminal | output | input]' does not notify
**	    user if it cannot open the file or tty specified by the user.
**	    To correct this situation, check the return from TRset_file() if
**	    a tty or file is being opened.  If an error is encountered,
**	    write error E_US1764_5988 to the session, but don't log it in
**	    the errlog.
**	23-may-94 (robf)
**          Add checks for security catalogs when determining updatability,
**	    this catches early direct attempts to change security catalogs
**	    which may only be updated by security sessions.
**      19-dec-94 (sarjo01) from 15-Sep-94 (johna)
**          initialize dmt_mustlock (added by markm while fixing bug (58681)
**      06-jan-95 (rudtr01) 
**          bug fix for 47329 added from SQL grammar.
**	05-jun-95 (harpa06)
**	    Print an error message if user specified an invalid permit
**	    operation. 
**	04-Mar-96 (mckba01)
**	    #74286, qdata_cvt function was not initialising the db_datatype
**	    field of the resultant value passed to adi_0calclen. Failure
**	    to specifiy the result type when the source type is Nullable
**          leads to the returned length being 1 less than it should.
**	8-mar-96 (inkdo01)
**	    Repair Quel handling of "set session with on_error ..." to be 
**	    same as SQL.
**	09-Jan-96 (allmi01)
**	    Added NO_OPTIM for dgi_us5 (DG/UX on Intel) to fix SQL92 releated problems
**	    like creation of iidbdb fails when case parms in config.dat are anything but
**	    lower lower lower.
**	19-mar-96 (pchang)
**	    Fixed bug 70204.  Incorrect test on the next symbol location for
**	    byte alignment in qdata_cvt() prevented a new symbol block to be
**	    allocated when there are exactly 2 bytes left on the current symbol
**	    table, and subsequent alignment operation on the next symbol
**	    pointer caused it to advance beyond the current symbol block and
**	    thus, corrupting adjacent object when the next symbol was assigned.
**	    SEGVIO followed when the trashed object was later referenced.
**	05-Feb-1996 (allmi01)
**	    Added NO_OPTIM for dgi_us5 to correct SQL92 related problems.
**      06-nov-1996 (canor01)
**          Enable cr_nm_eq_no for quel to allow page_size parameter to
**          CREATE TABLE.
**	27-Feb-1997 (jenjo02)
**	    Extended <set session> statement to support <session access mode>
**	    (READ ONLY | READ WRITE).
**	25-Mar-1997 (jenjo02)
**	    Table priority project:
**	    Use psl_nm_eq_no in production of MODIFY table TO priority = <table_priority>
**	21-jul-97 (inkdo01)
**	    Added SET [NO]FLATTEN to permit control of subselect flattening
**	    without needing trace point privileges (as for op132).
**      14-oct-97 (stial01)
**          Changes to set session access mode.
**	19-Jan-1999 (shero03)
**	    Add SET RANDOM_SEED
**      21-jan-1999 (hanch04)
**          replace nat and longnat with i4
**	26-jan-99 (toumi01)
**	    Added NO_OPTIM for lnx_us5 to correct SQL-92 related problems.
**      02-feb-1999 (hanch04)
**          replace longnat with i4
**	20-Apr-1999 (shero03)
**	    Support multivariate functions (3 & 4 operands)
**	26-apr-1999 (hanch04)
**	    Added casts to quite compiler warnings
**      28-apr-1999 (hanch04)
**          Replaced STlcopy with STncpy
**	24-Jun-1999 (shero03)
**	    Added ISO4 date format.
**      03-Dec-1998 (hanal04)
**          Added support for 'set transaction' statement to QUEL. b94351.
**	24-aug-1999 (gygro01)
**	    Backed change for b94351 / pb ingsrv 816, becaused it caused
**	    bug 98507 / pb ingsrv 995, found during QA testing.
**	01-Jul-1999 (shero03)
**	    Support II_MONEY_FORMAT=NONE for sir 92541
**	06-oct-1999 (toumi01)
**	    Change Linux config string from lnx_us5 to int_lnx.
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	08-Aug-2000 (horda03)
**	    RETRIEVE INTO statement does not inherit session SET JOURNALING
**	    status unless the WITH clause is specified. Bug 102193.
**	22-aug-2000 (somsa01)
**	    Added NO_OPTIM for ibm_lnx to correct SQL-92 related problems.
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	10-Jan-2001 (jenjo02)
**	    Deleted qef_dmf_id, use dmf_sess_id instead.
**	    Added *PSS_SELBLK parm to psf_mopen(), psf_mlock(), psf_munlock(),
**	    psf_malloc(), psf_mclose(), psf_mroot(), psf_mchtyp(),
**	    psl_rptqry_tblids(), psq_tout(), psq_1rptqry_out().
**	17-Jan-2001 (jenjo02)
**	    Short-circuit calls to psy_secaudit() if not C2SECURE.
**	26-Feb-2001 (jenjo02)
**	    Set session_id in all QEF_RCB's;
**      23-Mar-2001 (toumi01)
**	    Add support for 'set transaction' statement to [E]QUEL. b94351.
**	    This will allow db utilities written in quel to issue e.g.
**	    SET TRANSACTION READ WRITE to override an installation level
**	    isolation level setting of READ UNCOMMITTED.
**	03-May-2001 (toumi01)
**	    Add support for 'set session isolation level' to [E]QUEL. b94351.
**	16-aug-2001 (toumi01)
**	    speculative i64_aix NO_OPTIM change for beta xlc_r - FIXME !!!
**	30-oct-01 (inkdo01)
**	    Enable "session." qualifier in range statements (permits declaration
**	    of global temp tables in SQL, then reference to them in Quel).
**	30-apr-02 (inkdo01)
**	    Enable "session." qualifier in append, delete and replace, for
**	    symmetry.
**	10-jun-2003 (devjo01)
**	    Prevent careless/malicious user from clobbering useful
**	    files with SET TRACE OUTPUT. b110302.
**      02-jan-2004 (stial01)
**          Changes to expand number of WITH CLAUSE options
**	28-Jan-2004 (schka24)
**	    Track changes made for partition definition.  (Not supported
**	    in QUEL though.)
**	12-feb-04 (inkdo01)
**	    Delete/replace request 8-byte TIDs (as part of partitioned 
**	    table support).
**	23-Feb-2004 (schka24)
**	    More tracking of partitioning changes, in modify this time.
**	16-apr-2004 (somsa01)
**	    initialize dmu_cb for relocate.
**	26-Apr-2004 (schka24)
**	    Call change for COPY.
**	22-Jul-2004 (schka24)
**	    Delete old normalization calls, been ifdef'ed out for years.
**	23-nov-04 (inkdo01)
**	    Added "set [no]hash", "set [no]ojflatten", "set [no]parallel"
**	    having forgotten to add them from SQL some time ago.
**	13-dec-04 (inkdo01)
**	    Added "collID" parm to psl_ct14_typedesc() calls.
**	3-Feb-2005 (schka24)
**	    Trick out tids in retrieve list to be i4 if the appropriate
**	    parser-compatability flag is on.
**	28-Nov-2005 (kschendel)
**	    Use struct name lookup utility.
**	24-May-2006 (kschendel)
**	    Rip out the SET J_FREESZn statements, long obsolete.
**	06-Jul-06 (kiria01) b116230
**	    psl_print becomes PSL_RS_PRINT bit in new field psl_rsflags
**	    to allow for extra flags in PST_RSDM_NODE
**       6-Nov-2006 (hanal04) SIR 117044
**          Add int.rpl for Intel Rpath Linux build.
**	04-Jan-2007 (kibro01) b117310
**	    Add joinop greedy/nogreedy/newenum/nonewenum commands which
**	    are already allowed in SQL (in pslsgram.yi).
**	18-Oct-2007 (kibro01) b119318
**	    Use a common function in adu to determine valid date formats
**	28-nov-2007 (dougi)
**	    Add parm to psl_crsopen() for cached dynamic in SQL.
**	25-Jun-2008 (kiria01) SIR120473
**	    Extend LIKE support to include LIKE modifiers
**	    Move pst_isescape into new u_i2 pst_pat_flags.
**	    Widened pst_escape.
**	15-Oct-2008 (kiria01) SIR121012
**	    Extended precision/scale handling for DECIMAL to work with
**	    constant folding.
**	05-Feb-2009 (kiria01) b121607
**	    Changed function calls for psl_cp2_copstmnt() and getfacil()
**	    to reflect the change from i4 to PSQ_MODE used in the call.
**	28-May-2009 (kschendel) b122118
**	    Minor cleanup: use bools for true/false stuff.
**	26-Aug-2009 (kschendel) 121804
**	    Need uld.h to satisfy gcc 4.3.
**	23-Sep-2009 (kiria01) b122578
**	    Initialise the ADF_FN_BLK .adf_fi_desc and adf_dv_n members.
**	17-Nov-2009 (kschendel) SIR 122890
**	    Reflect DB journaling status in pst-resjour request.
**	07-Dec-2009 (troal01)
**	    Consolidated DMU_ATTR_ENTRY, DMT_ATTR_ENTRY, and DM2T_ATTR_ENTRY
**	    to DMF_ATTR_ENTRY. This change affects this file.
**	06-Feb-2010 (kiria01) b123438
**	    Fix compiler warnings.
**	12-Feb-2010 (toumi01) SIR 122403
**	    For encryption project add arg to psl_ct14_typedesc calls.
**      01-apr-2010 (stial01)
**          Changes for Long IDs
**	19-Jun-2010 (kiria01) b123951
**	    Add extra parameter to psl0_rngent & psl_rngent for WITH
**	    support to pass active join_id in case a WITH list element
**	    needs expanding and joinids need duplicating. 
**	16-Jul-2010 (kschendel) B123104
**	    Convert constant-folded bools in a "qual" back to operators,
**	    so that opf can deal with them in a consistent manner.
**	20-Jul-2010 (kschendel) SIR 124104
**	    Pass with-clauses to create table.
**	28-Jul-2010 (kschendel) SIR 124104
**	    Fix up code that thinks pst_compress is a boolean.  It hasn't
**	    been boolean for a while.  It has worked by accident since
**	    the relevant flag happens to be 1, just like TRUE.
**      01-oct-2010 (stial01) (SIR 121123 Long Ids)
**          Store blank trimmed names in DMT_ATT_ENTRY
*/

%{
/*[@forward_type_references@]*/

/*
**  Forward and/or External function references.
*/

/*[@function_reference@]...*/

/*
**  Defines of other constants.
*/

/*[@group_of_defined_constants@]...*/
/*[@type_definitions@]*/
/*[@global_variable_definitions@]*/
/*[@static_variable_or_function_definitions@]*/
%}

/*
** YACC starting symbol.
*/

%start          stmnt

/*
** Union of types for tokens and non-terminal symbols.
*/

%union
{
    i4              psl_tytype;         /* Operator types, etc. */
    PST_QNODE       *psl_trtype;        /* Query tree node pointer */
    PSS_RNGTAB	    *psl_rngtype;	/* Range table entry */
    i4	    psl_inttype;	/* General-purpose number */
    i2		    *psl_i2type;
    i4		    *psl_i4type;
    u_char	    *psl_dectype;
    f4		    *psl_f4type;
    f8		    *psl_f8type;
    char	    *psl_strtype;
    DB_TEXT_STRING  *psl_textype;	/* A text string, with 2-byte count */
    PST_QTREE	    *psl_qttype;	/* Query tree type */
    DB_CURSOR_ID    *psl_cursid;	/* A cursor id */
    PSC_CURBLK	    *psl_crblk;		/* A cursor control block */
    DB_DATA_VALUE   *psl_dbval;		/* A db data value */
    PST_RESKEY	    *psl_reskey;	/* key struct ptr */
}

/*
** Definitions of all tokens in the grammar, and their datatypes.
*/

%token              ABORT

/*
** An aggregate operator: sum, sumu, count, countu, any, avg, avgu.
*/
%token              AGOP

%token		    ALL APPEND AS AT

/*
** A binary arithmetic operator: *, /.
*/
%token              BAOP

/*
** A high precedence binary arithmetic operator: **.
*/
%token              BAOPH

/*
** A binary comparison operator: <, <=, >, >=.
*/
%token              BDOP

/*
** "begin transaction" taken a a single token.
*/
%token              BGNXACT

%token              BY

/*
** The "close cursor" token,
*/
%token		    CLSCURSOR

/*
** A column number as stored in the IIqrytext relation.
*/
%token		    COLNO

/*
** A colon character: :
*/
%token              COLON

/*
** A comma character: ,
*/
%token		    COMMA

%token		    COMMITTED COPY CREATE

/*
** A decimal constant (literal)
*/
%token		    DECCONST

/*
** The "define cursor" token.
*/
%token		    DEFCURSOR

/*
** The "for deferred" token.
*/
%token		    DEFERUPD

/*
** "define integrity" taken as a single token.
*/
%token		    DEFINTEG

/*
** "define location" taken as a single token.
*/
%token		    DEFLOC

/*
** "define permit" taken as a single token.
*/
%token		    DEFPERM

/*
** "define query" taken as a single token.
*/
%token		    DEFQRY
/*
** "define reference" taken as a single token.
*/
%token              DEFREF

/*
** "define view" taken as a single token.
*/
%token		    DEFVIEW

/*
** delimitd identifier - QUEL style
*/
%token		    DELIM_IDENT

%token              DELETE DESTROY

/*
** "destroy integrity" taken as a single token.
*/
%token		    DESTINTEG

/*
** "destroy permit" taken as a single token.
*/
%token		    DESTPERM

/*
** "destroy reference" taken as a single token.
*/
%token              DESTREF

/*
** The "for direct" token.
*/
%token		    DIRECTUPD

%token		    DISTRIBUTE

/*
** A dollar sign: $.
*/
%token              DOLLAR

/*
** "end transaction" taken as a single token.
*/
%token              ENDXACT

/*
** An equality operator: !=.
*/
%token              EOP

%token              EXECUTE EXCLUDING

/*
** Four and eight byte floating-point constants.
*/
%token              F4CONST F8CONST

/* FOR */
%token		    FOR

/*
** The "for readonly" symbol.
*/
%token		    FORREADONLY

/*
** The "for update" symbol.
*/
%token		    FORUPDATE

%token              FROM

%token              HELP

/*
** hex constants x'....'
*/
%token		    HEXCONST
/*
** Two and four byte integer constants.
*/
%token              I2CONST I4CONST

%token              IN

%token              INDEX INTO INTEGRITY

/*
** The word "is" 
*/
%token              IS

%token		    ISOLATION

/* The equals sign (=).*/
%token		    ISOP

/* "is null" taken as a token */
%token		    ISNULL

%token              JOURNALING

/*
** Logical binary operator: and, or.
*/
%token              LBOP

%token              LEVEL LOGGING

/*
** A left parenthesis: (.
*/
%token              LPAREN

%token              MODIFY MOVE

/*
** A sequence of characters that begins with a letter or underscore, and
** contains letters, digits, and underscores.  PUT SOMETHING HERE ABOUT
** ESCAPED NAMES.
*/
%token              NAME

%token              NOT

/* "not null", from is not null, taken as a token */
%token		    NOTNULL

%token              OF ON ONLY

/*
** "Only where" taken as a single token.
*/
%token		    ONLYWHERE

/*
** "Open cursor" taken as a single token.
*/
%token		    OPENCURSOR

/*
** "order by" taken as a single token
*/
%token		    ORDERBY

/*
** A period character: .
*/
%token              PERIOD

%token              PERMIT PRINT

%token		    QDATA
%token		    QUERYID

%token              RANGE READ RELOCATE

%token		    REPEATABLE REPLACE

/*
** The "replace cursor" symbol.
*/
%token		    REPCURSOR

%token		    REPLICATE

/*
** The "retrieve cursor" symbol.
*/
%token		    RETCURSOR

%token		    RETRIEVE

/*
** A right parenthesis: )
*/
%token		    RPAREN

%token              SAVE SAVEPOINT

/*
** A string constant of the TEXT type, consisting of a two-byte count followed
** by an array of characters.
*/
%token              SCONST

%token		    SERIALIZABLE

%token		    SET

/*
** "set autocommit" taken as a single token.
*/
%token		    SETAUTOCOMMIT

/*
** "set aggregate" taken as a single token.
*/
%token		    SETAGGR

/*
** "set cpufactor" taken as a single token.
*/
%token		    SETCPUFACT

/*
** "set create_compression" taken as a single token.
*/
%token		    SETCREATECOMPRESSION

/*
** "set date_format" taken as a single token.
*/
%token		    SETDATEFMT

/*
** "set decimal" taken as a single token.
*/
%token		    SETDECIMAL

/*
** "set [no]flatten" taken as a single token.
*/
%token		    SETFLATTEN

/*
** "set [no]hash" taken as a single token.
*/
%token		    SETHASH

/*
/*
** "set io_trace/noiotrace" taken as a single token.
*/
%token		    SETIOTRACE

/*
** "set [no]joinop" taken as a single token.
*/
%token		    SETJOINOP

/*
** "set [no]journaling" taken as a single token.
*/
%token		    SETJOURNAL

/*
** "set lockmode" taken as a single token.
*/
%token		    SETLOCKMODE

/*
** "set lock_trace" as a single token.
*/
%token		    SETLTRACE

/*
** "set logging" taken as a single token.
*/
%token		    SETLOGGING

/*
** "set logtrace" taken as a single token.
*/
%token		    SETLOGTRACE

/*
** "set money_format" taken as a single token.
*/
%token		    SETMNYFMT

/*
** "set [no]maxio" taken as a single token 
*/
%token		    SETMXIO

/*
** "set [no]maxrow" taken as a single token 
*/
%token		    SETMXROW

/*
** "set [no]maxcpu" taken as a single token 
*/
%token		    SETMXCPU

/*
** "set [no]maxpage" taken as a single token 
*/
%token		    SETMXPAGE

/*
** "set [no]maxcost" taken as a single token 
*/
%token		    SETMXCOST

/*
** "set money_prec" taken as a single token.
*/
%token		    SETMNYPREC

/*
** "set [no]ojflatten" taken as a single token.
*/
%token		    SETOJFLATTEN

/*
** "set [no]optimizeonly" as a single token
*/
%token		    SETOPTIMIZEONLY

/*
** "set parallel" taken as a single token.
*/
%token		    SETPARALLEL

/*
** "set printqry" taken as a single token.
*/
%token		    SETPRINTQRY

/*
** "set [no]qep" taken as a single token.
*/
%token		    SETQEP

/*
** "set random_seed" taken as a single token.
*/
%token		    SETRANDOMSEED

/*
** "set ret_into" taken as a single token.
*/
%token		    SETRETINTO

/*
** "set result_structure" as a single token.
*/
%token SETRSTRUCT

/*
** "set session" taken as a single token.
*/
%token              SETSESSION

/*
** "set [no]sql" taken as a single token.
*/
%token		    SETSQL

/*
** "set statistics" taken as a single token.
*/
%token		    SETSTATS

/*
** "set [no]trace" taken as a single token.
*/
%token		    SETTRACE

/*
** "set transaction" taken as a single token */
%token              SETTRANSACTION

/* "set update_rowcount" taken as a single token. */
%token              SETUPDROWCNT

%token              SORT

/*
** A table id as stored in the iiqrytext system relation.
*/
%token		    TABID

%token              TO

/*
** A unary arithmetic operator: +, -.
*/
%token		    UAOP

%token              UNCOMMITTED UNIQUE UNTIL

/*
** "update of"
*/
%token		    UPDATE

/*
** A range variable number, as stored in the iiqrytext relation.
*/
%token		    VAR

%token		    VIEW

%token		    WHERE WITH

/* "with null" as token */

%token		    WITHNULL

%token		    WRITE

/*[@yacc_token_definition@]*//*...*/

/*
** Datatypes of tokens and non-terminal symbols.
*/

%type	<psl_strtype> AGOP
%type   <psl_tytype>  BAOP BAOPH BDOP EOP IS UAOP ISOP
%type   <psl_f4type>  F4CONST
%type	<psl_f8type>  F8CONST
%type	<psl_dectype> DECCONST
%type	<psl_i2type>  I2CONST
%type	<psl_i4type>  I4CONST
%type	<psl_tytype>  LBOP NOT
%type	<psl_strtype> NAME DELIM_IDENT
%type	<psl_textype> SCONST HEXCONST
%type	<psl_tytype>  SETCREATECOMPRESSION SETJOINOP SETJOURNAL SETSQL SETTRACE 
%type   <psl_tytype>  SETQEP SETSTATS SETPRINTQRY SETRSTRUCT
%type   <psl_tytype>  SETLTRACE SETIOTRACE SETOPTIMIZEONLY SETOJFLATTEN
%type	<psl_tytype>  SETLOGGING SETLOGTRACE SETFLATTEN SETHASH SETPARALLEL
%type	<psl_tytype>  SETMXIO SETMXROW SETMXCPU SETMXPAGE SETMXCOST
%type	<psl_i4type>  VAR
%type	<psl_cursid> DEFCURSOR CLSCURSOR OPENCURSOR 
%type	<psl_cursid> REPCURSOR RETCURSOR QUERYID
%type	<psl_dbval>  QDATA
%type	<psl_inttype> COLNO

%type	<psl_inttype> intsetparam st_auto changed_or_qualified
%type	<psl_tytype>  settracestmnt setjtimeout setrstruct setltrace
%type	<psl_tytype>  setiotrace setlockkey index_unique
%type	<psl_tytype>  setmxio_kwd setmxrow_kwd setmxcpu_kwd
%type	<psl_tytype>  setmxpage_kwd setmxcost_kwd 
%type	<psl_strtype> strsetparam sp_name tname nonkeyword generic_ident
%type	<psl_inttype> intconst null_default int2_int4 parconst setjint
%type	<psl_strtype> indexcolname strconst crname cp_delim nonkey_or_sconst
%type	<psl_rngtype> var sortrng delvar repvar intvar permvar sname
%type	<psl_trtype>  attrib qualclause sortclause tlclause tlelm tlist
%type	<psl_trtype>  sortvar qual clause afcn aggrfcn
%type	<psl_trtype>  domseq targdom attribfcn param aggtarg updlist updname
%type	<psl_tytype>  func uop relop sign_op
%type	<psl_qttype>  append delete replace retrieve dmlstmt
%type	<psl_crblk>   defcursorstmnt defrptcursstmnt
%type	<psl_tytype>  updclause readclause updword m_asc_desc
%type	<psl_strtype> destrname entname
%type	<psl_inttype> timeofday month
%type	<psl_inttype> aggfcnwhere uniqueclause
%type	<psl_textype> sconst
%type	<psl_reskey>  rt_lst rt_lst_elem
%type	<psl_inttype> isolation_level access_mode


/*
** Declarations of precedences for rules.
*/

%left               LBOP
%left		    NOT
%left		    UAOP
%left		    BAOP
%left		    BAOPH
%nonassoc           unaryop

%%

/*
** Rules Section.
*/

stmnt:              abort
	  |	    append
          |	    btransact
          |	    closecurs
	  |	    copy
          |	    create
          |	    defloc
	  |	    defcursor
	  |	    defref
	  |	    defrptcurs
	  |	    delete
          |	    destinteg
	  |	    destperm
	  |	    destref
	  |	    destroy
          |	    etransact
	  |	    execute
	  |	    index
          |	    defintegrity
          |	    modify
          |	    defpermit
          |	    query
          |	    range
          |	    relocate
          |	    replace
	  |	    replcursor
	  |	    retcursor
          |	    retrieve
          |	    save
          |	    savepoint
          |	    setautocommit
	  |	    setaggr
	  |	    setcpufact
	  |	    setcrecomp
          |	    setdatefmt
	  |	    setdecimal
	  |	    setflatten
	  |	    sethash
          |	    setiotrace
	  |	    setjoinop
          |	    setjournal
          |	    setjtimeout
	  |	    setlockmode
	  |	    setlogging
	  |	    setlogtrace
	  |	    setltrace
	  |	    setrstruct
	  |	    setmnyfmt
	  |	    setmnyprec
	  |	    setmxio
	  |	    setmxrow
	  |	    setmxcpu
	  |	    setmxpage
	  |	    setmxcost
	  |	    setojflatten
	  |         setoptimizeonly
	  |	    setparallel
	  |	    setprintqry
	  |	    setqep
	  |	    setrandomseed
	  |	    setretinto
          |         setsession
	  |	    setsql
	  |	    setstats
	  |	    settrace
	  |	    settransaction
	  |	    setupdrowcnt
	  |	    defview
          |	    error
    {
	YYABORT;
    }
;

abort:             abstmnt abortto NAME
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;

	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	STmove($3, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;
    }
          |	    abstmnt abortto intconst
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;
	DB_SP_NAME	       *spname;
	char		       numbuf[25];

	psq_cb->psq_mode = PSQ_ABSAVE;

	/* Allocate memory for savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(DB_SP_NAME), 
	    (PTR *) &spname, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Give QEF pointer to name */
	CVla((i4) $3, (PTR) numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) spname);
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = spname;
    }
          |	    abstmnt
    {
	QEF_RCB                *qef_rcb;

	psq_cb->psq_mode = PSQ_ABORT;
	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_spoint = (DB_SP_NAME *) NULL;
    }
;

abstmnt:	    ABORT
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	/* Create the QEF control block for abort */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    }
;

abortto:           TO
          |
;

append:            apstmt apto apprname tlclause qualclause
    {
	PST_QNODE		*node, *rsdmnode;
	DB_STATUS		status;
	PST_RT_NODE		root;
	PST_QTREE		*tree;
	i4			err_code;
	PST_PROCEDURE		*pnode;
	i4			mask;
	i4			mask2;
	i4			qrymod_resp_mask;

	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;

	status = pst_node(cb, &cb->pss_ostream, $4, $5, PST_ROOT, (PTR) &root,
	    sizeof(root), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &node,
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Now check the target list to see if there are any
	** resdoms with pst_ttargtype of PST_USER, if so
	** convert them to PST_ATTNO.
	*/
	for (rsdmnode = node->pst_left;
	 rsdmnode != (PST_QNODE *) NULL && 
	 rsdmnode->pst_sym.pst_type == PST_RESDOM;
	 rsdmnode = rsdmnode->pst_left)
	{
	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		== PST_USER)
	    {
		rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		    = PST_ATTNO;
	    }
	}

	if (cb->pss_defqry == PSQ_DEFQRY)
	{
	    /*
	    ** now call psl_shareable() to determine if the query satisfies SQL
	    ** definition of shareability (i.e. all tables used in the query are
	    ** catalogs or are owned by the DBA; QUEL user cannot explicitly
	    ** qualify them with an owner name)
	    */
	    status = psl_shareable(psq_cb, cb, &$Yqp_shareable, &$Yshr_qryinfo);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	/* Apply qrymod (views, permits, & integrities) */
	status = psy_qrymod(node, cb, psq_cb, &$Yjoin_id, &qrymod_resp_mask);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** if this is a repeat query and it is shareable according to SQL
	** definition of shareability, apply QUEL-specific checking
	*/
	if (cb->pss_defqry == PSQ_DEFQRY && $Yqp_shareable)
	{
	    psl_quel_shareable(cb, $Yqry_mask, &$Yqp_shareable);
	}

	/* make sure all mandatory columns have been specified,
	** and build default CONST nodes for any columns
	** that haven't been specified
	*/
	status = psl_check_defaults(cb, cb->pss_resrng, node,
				    FALSE, (DB_TAB_NAME *) NULL, 
				    &psq_cb->psq_error);
	if DB_FAILURE_MACRO(status)
	    return(status);
    
	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/* Make sure base table is updateable;
	** In case of an index or a non-extended catalog,
	** catalog update privilege must be on.
	** In case of security catalog session must have
	** security privilege active.
	** Bug 34079, since 6.0 you were never supposed to be 
        ** able to update a secondary index.  Fixed it so 
        ** the same error is returned whether you have update 
        ** syscat or not (jennifer)
	** 
	** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
	** allow APPEND to indexes which are non-extended catalogs
	*/
	if (mask & DMT_IDX)
	{
	    if (!(   mask & DMT_CATALOG && ~mask & DMT_EXTENDED_CAT
	          && cb->pss_ses_flag & PSS_CATUPD
		  && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
		 )
	       )
	    {
		_VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return(E_DB_ERROR);
	    }
	}
	else if ( ( (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
		 && ~mask & DMT_EXTENDED_CAT
		 && !(cb->pss_ses_flag & PSS_CATUPD))
	       ||
	        ((mask & DMT_SECURE) &&
	          !(cb->pss_ustat & DU_USECURITY)))
	{
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_INSERT, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_APPEND, &e_error);
		if (local_status > status)
		    status = local_status;
	    _VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Create the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    node, &tree, &pnode, PST_0FULL_HEADER, (PSS_Q_XLATE *) NULL);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;

	/* Fix the root in QSF */
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = tree;
    }
;

apstmt:            APPEND
    {
	DB_STATUS              status;

	psq_cb->psq_mode = PSQ_APPEND;
	if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);	    /* non-zero return means error */
	}
    }
;

apto:              TO
          |
;

apprname:	    NAME
    {
	DB_STATUS              status;
	PSS_RNGTAB	       *resrange;
	DB_TAB_NAME	       tabname;
	i4		       err_code;
	i4		       rngvar_info;

	STmove($1, ' ', sizeof(tabname), tabname.db_tab_name);
	status = psl0_rngent(&cb->pss_usrrange, -1, "", &tabname, cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    PSS_USRTBL | PSS_DBATBL | PSS_INGTBL, &rngvar_info, 0, NULL);
	if (status != E_DB_OK)
	{
	    return (status);
	}
	if (!resrange)
	{
	    (VOID) psf_error(2108L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		(i4) STlength($1), $1);
	    return (E_DB_ERROR);
	}

	cb->pss_resrng = resrange;
    }
	|	nonkeyword PERIOD NAME
    {
	DB_STATUS              status;
	PSS_RNGTAB	       *resrange;
	DB_TAB_NAME	       tabname;
	i4		       err_code;
	i4		       rngvar_info;

	if (STcasecmp($1, "session"))
	{
	    (VOID) psf_error(5153, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) $1), $1);
	    return (E_DB_ERROR);
	}
	STmove($3, ' ', sizeof(tabname), tabname.db_tab_name);
	status = psl0_rngent(&cb->pss_usrrange, -1, "", &tabname, cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    PSS_SESTBL, &rngvar_info, 0, NULL);
	if (status != E_DB_OK)
	{
	    return (status);
	}
	if (!resrange)
	{
	    (VOID) psf_error(2108L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		(i4) STlength($3), $3);
	    return (E_DB_ERROR);
	}

	cb->pss_resrng = resrange;
    }
;

btransact:         BGNXACT
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_BGNTRANS;

	/* Allocate QEF control block for begin transaction */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_modifier = QEF_MSTRAN;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_db_id = cb->pss_dbid;
	qef_rcb->qef_flag = 0;
    }
;

closecurs:         CLSCURSOR QUERYID
    {
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_CLSCURS;

	/* Allocate a QEF control block for doing the close */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(*($2), psq_cb->psq_cursid);

	/* Look up the cursor */
	status = psq_crfind(cb, $2, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, DB_CURSOR_MAXNAME, $2->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Get rid of the cursor control block */
	status = psq_crclose(cursor, &cb->pss_curstab, &cb->pss_memleft,
	    &psq_cb->psq_error);
 	if (status != E_DB_OK)
	    return (status);
    }
;

copy:              copstmnt copytable LPAREN coparam RPAREN keywd
		   copyfile copywith
    {
	DB_STATUS		status;

	status = psl_cp1_copy(cb, psq_cb, &$Yxlated_qry,
		(PTR) NULL, &$Ywith_clauses, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

copstmnt:          COPY
    {
	DB_STATUS		status;

	status = psl_cp2_copstmnt( cb, &psq_cb->psq_mode, &$Ywith_clauses,
				   &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

copytable:	    NAME
    {
	DB_STATUS		status;
	DB_TAB_NAME		tabname;
	PSS_RNGTAB		*resrange;
	i4		       rngvar_info;

	/* Look up table id and timestamp */
	STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info, NULL);
	if (status != E_DB_OK)
	    return (status);

	status = psl_cp3_copytable(cb, resrange, &tabname,
		(PSS_Q_XLATE *) NULL, (DD_LDB_DESC *) NULL,
		&psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

coparam:           cospecs
          |
    {
	DB_STATUS	status;

	status = psl_cp4_coparam(cb, (PSS_Q_XLATE *) NULL, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

cospecs:	    entname is fmtspec
    {
	DB_STATUS		status;

	status = psl_cp5_cospecs(cb, (PSS_Q_XLATE *) NULL, $1,
		(PTR) NULL, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
	    |	    cospecs COMMA entname is fmtspec
    {
	DB_STATUS		status;

	status = psl_cp5_cospecs(cb, (PSS_Q_XLATE *) NULL, $3,
		(PTR) NULL, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

entname:	    NAME
    {
	DB_STATUS	status;

	status = psl_cp6_entname(cb, $1, &psq_cb->psq_error, (PTR *) NULL);

	if (DB_FAILURE_MACRO(status))
	    return (status);

	cb->pss_stmt_flags &= ~PSS_CP_DUMMY_COL;
	$$ = $1;
    }
;

fmtspec:	    coent
	    |	    coent WITHNULL
    {
	DB_STATUS		status;

	status = psl_cp7_fmtspec(cb, &psq_cb->psq_error, FALSE);

	if (DB_FAILURE_MACRO(status))
	    return (status);

    }
	    |	    coent WITHNULL LPAREN covalue RPAREN
    {
	DB_STATUS		status;

	status = psl_cp7_fmtspec(cb, &psq_cb->psq_error, TRUE);

	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

nonkey_or_sconst:   NAME
    {
	char	    *letter;
	/*
	** Translate nonkeywords to lower case if regular ids are not always 
	** lowercased
	*/
	if (~*cb->pss_dbxlate & CUI_ID_REG_L)
	{
	    for (letter =  $1; *letter != EOS; CMnext(letter))
	        CMtolower(letter, letter);
        }

	$Yid_type = PSS_ID_NONKEY;
	$$ = $1;
    }
	    |       SCONST
    {
	$Yid_type = PSS_ID_SCONST;
	$$ = sconvert($1);
    }
;

cp_delim:
    {
	/* no delimiter */
	$$ = (char *) NULL;
    }
	|	    nonkey_or_sconst
    {
	$$ = $1;
    }
;

coent:             nonkey_or_sconst
    {
	DB_STATUS		status;

	/*
	** This is a possibly quoted column type, possibly with a delimiter.
	**     - i4
	**     - c0tab
	**     - date
	**     - "d0null"
	*/

	status = psl_cp8_coent(cb, psq_cb, (bool) TRUE, $1, 0, (i4 *) NULL,
	    (char *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	    NAME LPAREN intconst RPAREN cp_delim
    {
	DB_STATUS		status;
	i4			len = (i4) $3;

	/*
	** This is a column type, length and possibly a (possibly quoted)
	** delimiter.
	**     - text(40)[["]nl["]]
	*/

	status = psl_cp8_coent(cb, psq_cb, (bool) FALSE, $1, 1, &len, $5);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	NAME LPAREN intconst COMMA intconst RPAREN cp_delim
     {
	DB_STATUS		status;
	i4			len[2];

	/*
	** This is a column type, length and possibly a (possibly quoted)
	** delimiter.
	**     - decimal(15,2)[["]nl["]]
	*/

	len[0] = $3;
	len[1] = $5;
	status = psl_cp8_coent(cb, psq_cb, (bool) FALSE, $1, 2, len, $7);

	if (DB_FAILURE_MACRO(status))
	    return(status);
     }
;

covalue:	    sign_op I2CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	if ($1 == ADI_MINUS_OP)
	    *$2 = -(*$2);
	cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	cpdom_desc->cp_nulldbv.db_prec = 0;
	cpdom_desc->cp_nulldbv.db_length = sizeof(i2);
	cpdom_desc->cp_nulldbv.db_data = (PTR) $2;
    }
	    |	    sign_op I4CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	if ($1 == ADI_MINUS_OP)
	    *$2 = -(*$2);
	cpdom_desc->cp_nulldbv.db_datatype = DB_INT_TYPE;
	cpdom_desc->cp_nulldbv.db_prec = 0;
	cpdom_desc->cp_nulldbv.db_length = sizeof(i4);
	cpdom_desc->cp_nulldbv.db_data = (PTR) $2;

    }
	    |	    sign_op DECCONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;
	i2		prec_scale;
	i4		prec;
	i4		scale;
	u_char		tmp[DB_MAX_DECLEN];
	PTR		d;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	I2ASSIGN_MACRO(*$2, prec_scale);
	prec  = DB_P_DECODE_MACRO(prec_scale);
	scale = DB_S_DECODE_MACRO(prec_scale);
	d     = (PTR) ((char *) $2 + sizeof(i2));

	if ($1 == ADI_MINUS_OP)
	{
	    MEcopy(d, DB_PREC_TO_LEN_MACRO(prec), (PTR)tmp);
	    MHpkneg((PTR)tmp, prec, scale, d);
	}
	
	cpdom_desc->cp_nulldbv.db_datatype = DB_DEC_TYPE;
	cpdom_desc->cp_nulldbv.db_prec = prec_scale;
	cpdom_desc->cp_nulldbv.db_length = DB_PREC_TO_LEN_MACRO(prec);
	cpdom_desc->cp_nulldbv.db_data = d;
    }
	    |	    sign_op F4CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	if ($1 == ADI_MINUS_OP)
	    *$2 = -(*$2);
	cpdom_desc->cp_nulldbv.db_datatype = DB_FLT_TYPE;
	cpdom_desc->cp_nulldbv.db_prec = 0;
	cpdom_desc->cp_nulldbv.db_length = sizeof(f4);
	cpdom_desc->cp_nulldbv.db_data = (PTR) $2;

    }
	    |	    sign_op F8CONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	if ($1 == ADI_MINUS_OP)
	    *$2 = -(*$2);
	cpdom_desc->cp_nulldbv.db_datatype = DB_FLT_TYPE;
	cpdom_desc->cp_nulldbv.db_prec = 0;
	cpdom_desc->cp_nulldbv.db_length = sizeof(f8);
	cpdom_desc->cp_nulldbv.db_data = (PTR) $2;

    }
	    |	    HEXCONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	cpdom_desc->cp_nulldbv.db_datatype = DB_VCH_TYPE;
	cpdom_desc->cp_nulldbv.db_prec = 0;
	cpdom_desc->cp_nulldbv.db_length = (i4)$1->db_t_count + DB_CNTSIZE;
	cpdom_desc->cp_nulldbv.db_data = (PTR) $1;
    }
	    |	    SCONST
    {
	QEF_RCB		*qef_rcb;
	QEU_CPDOMD	*cpdom_desc;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	cpdom_desc = qef_rcb->qeu_copy->qeu_fdesc->cp_cur_fdd;

	cpdom_desc->cp_nulldbv.db_datatype = DB_VCH_TYPE;
	cpdom_desc->cp_nulldbv.db_prec = 0;
	cpdom_desc->cp_nulldbv.db_length = (i4)$1->db_t_count + DB_CNTSIZE;
	cpdom_desc->cp_nulldbv.db_data = (PTR) $1;
    }
;

sign_op:	UAOP
    {
	if ($1 == ADI_SUB_OP)
	    $$ = ADI_MINUS_OP;
	else
	    $$ = ADI_PLUS_OP;
    }
	|
    {
	$$ = ADI_PLUS_OP;
    }
;

keywd:             INTO
    {
	QEF_RCB			*qef_rcb;
	DB_STATUS	status;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_direction = CPY_INTO;
	}
	else
	{
	    status = psq_x_add(cb, "", &cb->pss_ostream,
				$Yxlated_qry.pss_buf_size,
				&$Yxlated_qry.pss_q_list,
				(i4) -1,	
				(char *)NULL, (char *)NULL, "into ", 
				&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    }
          |         FROM
    {
	QEF_RCB			*qef_rcb;
	DB_STATUS	status;

	if (~cb->pss_distrib & DB_3_DDB_SESS)
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qef_rcb->qeu_copy->qeu_direction = CPY_FROM;
	}
	else
	{
	    status = psq_x_add(cb, "", &cb->pss_ostream,
				$Yxlated_qry.pss_buf_size,
				&$Yxlated_qry.pss_q_list,
				(i4) -1,	
				(char *)NULL, (char *)NULL, "from ", 
				&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	}
    }
;

copyfile:	    strconst
    {
	QEF_RCB		*qef_rcb;
	QEU_COPY	*qe_copy;
	DB_STATUS	status;

	if (cb->pss_distrib & DB_3_DDB_SESS)
	{
	    status = psq_x_add(cb, $1, &cb->pss_ostream,
				$Yxlated_qry.pss_buf_size,
				&$Yxlated_qry.pss_q_list,
				(i4)STlength((char *)$1),	
				"\'", "\'", (char *) NULL, &psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);
	    $Yscanbuf_ptr = (PTR) cb->pss_nxtchar;
	}
	else
	{
	    qef_rcb = (QEF_RCB *) cb->pss_object;
	    qe_copy = qef_rcb->qeu_copy;

	    /*
	    ** Copy the filename to the control block.
	    */
	    status = psf_malloc(cb, &cb->pss_ostream, STlength((char *) $1) + 1,
		(PTR *) &qe_copy->qeu_fdesc->cp_filename, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    STcopy((char *) $1, qe_copy->qeu_fdesc->cp_filename);
	} 
    }
	  | 	    NAME
    {
	QEF_RCB		*qef_rcb;
	i4		err_code;

	qef_rcb = (QEF_RCB *) cb->pss_object;

	if (STcompare($1, "program") != 0)
	{
	    (VOID) psf_error(5851L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, STlength($1), $1);
	    return (E_DB_ERROR);
	}

	qef_rcb->qeu_copy->qeu_stat |= CPY_PROGRAM;
    }
;

copywith:	    WITH copyclause
	  |
;

copyclause:	    copyoption
	  |	    copyclause COMMA copyoption
;

copyoption:	    nonkeyword is nonkeyword
    {
	DB_STATUS		status;

	status = psl_cp9_nm_eq_nm(cb, $1, $3, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);

    }
	  |	    nonkeyword is sconst
    {
	DB_STATUS		status;

	status = psl_cp10_nm_eq_str(cb, $1, sconvert($3), &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	    nonkeyword is int2_int4
    {
	DB_STATUS		status;

	status = psl_cp11_nm_eq_no( cb, $1, $3, &$Ywith_clauses,
				    &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	    nonkeyword is QDATA
    {
	DB_STATUS		status;

	status = psl_cp12_nm_eq_qdata(cb, psq_cb, $1, $3, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
        |
                nonkeyword
    {
	DB_STATUS		status;

	status = psl_cp13_nm_single(cb, $1, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

create:      crestmnt crlocationname LPAREN specs RPAREN crwith
    {
	DB_STATUS		    status;

	status = psl_ct1_create_table(cb, psq_cb, &$Ywith_clauses, (PSS_CONS *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

crestmnt:          CREATE
    {
	DB_STATUS 		    status;

	psq_cb->psq_mode = PSQ_CREATE;
	status = psl_ct10_crt_tbl_kwd(cb, psq_cb, &$Ywith_clauses, FALSE);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

crlocationname:      NAME COLON crname
    {
	DB_STATUS		status;

	status = psl_ct9_new_loc_name(cb, psq_cb, $1, $3, &$Ywith_clauses,
				      (PSS_Q_XLATE *) NULL);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
          |	    crname
    {
	DB_STATUS		status;

	status = psl_ct9_new_loc_name(cb, psq_cb, (char *) NULL, $1,
				      &$Ywith_clauses, (PSS_Q_XLATE *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

crname:   NAME
    {
	DB_STATUS               status;

	/*
	** store the table name into format understood by psl_ct12_crname()
	** which is also used by the SQL crname
	*/

        STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &$Yobj_spec.pss_obj_name);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &$Yobj_spec.pss_owner);
	$Yobj_spec.pss_objspec_flags = 0;
	$Yobj_spec.pss_orig_obj_name = $1;

	status = psl_ct12_crname(cb, psq_cb, &$Yobj_spec);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = $1;
    }
;

specs:             newcolname is typedesc
          |         specs COMMA newcolname is typedesc
;

newcolname:	    NAME
    {
        DB_STATUS               status;

        /* schang : change the last arg so that code */
        /*          can be shared by RMS GW */
	status = psl_ct13_newcolname(cb, $1, psq_cb, (PSS_Q_XLATE *)0, 
					(PTR *)0);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

typedesc:          tname null_default
    {
	DB_STATUS		status;

	status = psl_ct14_typedesc(cb, $1, 0, (i4 *) NULL, $2,
				  (PST_QNODE *) NULL, (DB_TEXT_STRING *) NULL,
				   	(DB_IISEQUENCE *) NULL, psq_cb, -1, 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	|          NAME LPAREN intconst RPAREN null_default
    {
	DB_STATUS               status;
	i4			len = $3;

	status = psl_ct14_typedesc(cb, $1, 1, &len, $5,
				   (PST_QNODE *) NULL, (DB_TEXT_STRING *) NULL,
				   (DB_IISEQUENCE *) NULL, psq_cb, -1, 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	|         NAME LPAREN intconst COMMA intconst RPAREN null_default
    {
	i4			parms[2];
	DB_STATUS               status;

	parms[0] = $3;
	parms[1] = $5;
	status = psl_ct14_typedesc(cb, $1, 2, parms, $7, 
				   (PST_QNODE *) NULL, (DB_TEXT_STRING *) NULL,
				   (DB_IISEQUENCE *) NULL, psq_cb, -1, 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

tname:		NAME
    {
	$$ = $1;
    }
	|	NAME NAME
    {
	DB_STATUS		status;
	char			*value;

	status = psl_ct11_tname_name_name(cb, psq_cb, $1, $2, 
						(char *)NULL, &value);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	$$ = value;
    }
;

null_default:
    {
	/*
	** nothing specified implies ->
	**	not null with default
	*/
	$$ = PSS_TYPE_NOT_NULL | PSS_TYPE_DEFAULT;
    }
	  |	    WITHNULL
    {
	/*
	** WITH NULL implies -->
	**	with null with default
	*/
	$$ = PSS_TYPE_NULL;      /* don't want PSS_TYPE_DEFAULT here
				 ** because WITH NULL implies a default of NULL
				 ** and the new PSS_TYPE_DEFAULT implies a 
				 ** default of 0 or blank depending on 
				 ** the datatype   (rjb  10/11/92)
				 */
    }
	  |	    NOTNULL
    {
	/*
	** NOT NULL implies -->
	**	not null with default
	*/
	$$ = PSS_TYPE_NOT_NULL | PSS_TYPE_DEFAULT;
    }
	  |	    NOTNULL WITH nonkeyword
    {
	i4	    err_code;

	if (STcompare($3, "default") != 0)
	{
	    /* create table syntax error message */
	    (VOID) psf_error(2607L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength($3), $3);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else
	{
	    /*
	    ** NOT NULL WITH DEFAULT implies just that
	    */
	    $$ = PSS_TYPE_NOT_NULL | PSS_TYPE_DEFAULT;
	}
    }
	  |	    NOTNULL NOT nonkeyword
    {
	i4	    err_code;

	if ((STcompare($3, "default") != 0))
	{
	    /* create table syntax error message */
	    (VOID) psf_error(2607L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength($3), $3);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else
	{
	    /*
	    ** NOT NULL NOT DEFAULT implies just that
	    */
	    $$ = PSS_TYPE_NOT_NULL | PSS_TYPE_NDEFAULT;
	}
    }
	  |	    NOT nonkeyword
    {
	i4	    err_code;

	if ((STcompare($2, "default") != 0))
	{
	    /* create table syntax error message */
	    (VOID) psf_error(2607L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else
	{
	    /*
	    ** NOT DEFAULT imples -->
	    **	    not null not default
	    */
	    $$ = PSS_TYPE_NOT_NULL | PSS_TYPE_NDEFAULT;
	}
    }
;

crwith:	    WITH crwithlist
    {
	DB_STATUS		status;

	status = psl_ct3_crwith(cb, psq_cb->psq_mode, &$Ywith_clauses,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	  |	crwithnull
    {
	DB_STATUS		status;

	status = psl_ct3_crwith(cb, psq_cb->psq_mode, &$Ywith_clauses,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

crwithnull:	    WITHNULL
		|
;

crwithlist:	    crwithelem
		|   crwithlist COMMA crwithelem
;

crwithelem:	    cr_single_kwd
	|	    cr_nm_eq_no
	|	    cr_lst_cl
;

cr_single_kwd:	    nonkeyword
    {
	DB_STATUS		status;

	status = psl_ct6_cr_single_kwd(cb, $1, &$Ywith_clauses,
	    psq_cb->psq_mode, &psq_cb->psq_error, (PSS_Q_XLATE *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

cr_nm_eq_no:      nonkeyword ISOP intconst
    {
        DB_STATUS               status;

        status = psl_nm_eq_no(cb, $1, $3, &$Ywith_clauses, psq_cb->psq_mode,
            &psq_cb->psq_error, (PSS_Q_XLATE *) NULL);

        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;


cr_lst_cl:	cr_lst_cl_prefix LPAREN cr_lst RPAREN
;

cr_lst_cl_prefix:	    nonkeyword ISOP
    {
	DB_STATUS		status;

	status = psl_lst_prefix(cb, psq_cb, $1, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

cr_lst:		cr_lst_elem
	|	cr_lst COMMA cr_lst_elem
;

cr_lst_elem:	    NAME
    {
	DB_STATUS		status;
	char			*letter;

	if ($Ylist_clause != PSS_KEY_CLAUSE)
	{
	    /*
	    ** Translate nonkeywords to lower case
	    */
	    for (letter =  $1; *letter != EOS; CMnext(letter))
		CMtolower(letter, letter);
	}

	$Yid_type = PSS_ID_REG;
	status = psl_ct8_cr_lst_elem(cb, psq_cb, yyvarsp, $1,
	    (PST_RESKEY **) NULL, (PSS_Q_XLATE *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return (status);
		    
    }	    	    
;

defcursor:         defcursorstmnt retrieve updclause readclause
    {
	DB_STATUS	status;

	/* Initialize the type of updating in the query tree header */
	$2->pst_updtmode = $3;

	status = psl_crsopen(cb, psq_cb, $1, $2, $4,
	    $Yupdcollst, $Ynonupdt, $Yjoin_id, FALSE);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
    }
;

defcursorstmnt:    OPENCURSOR QUERYID
    {
	DB_STATUS              status;
	PSC_CURBLK	       *curblk;
	i4		       err_code;

	/* Indicate that this isn't a repeat cursor */
	psq_cb->psq_mode = PSQ_DEFCURS;
	cb->pss_defqry = 0;

	/* look for cursor by its FE id. It should not exist */
	status = psq_crffind(cb, $2, &curblk, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	if (curblk != (PSC_CURBLK *) NULL)
	{
	    (VOID) psf_error(2201L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, DB_CURSOR_MAXNAME, $2->db_cur_name);
	    return (E_DB_ERROR);
	}
	/* Create cursor control block */
	status = psq_crcreate(cb, $2, psq_cb->psq_mode, &curblk,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(curblk->psc_blkid, psq_cb->psq_cursid);

	$$ = curblk;
    }
;

updclause:	updword uplist
    {
	if ($Yupdcollst != (PST_QNODE *) NULL)
	{
	    /* FOR UPDATE clause must have been specified.
	    ** We need to validate column names. We will also
	    ** generate VAR nodes and connect them to resdom nodes.
	    ** This mini target-list will be connected to the main one
	    ** so that qrymod executed from within cursor_open tells us
	    ** what attribute numbers in the underlying base relation(s)
	    ** these update columns map to; we need these att. nos.
	    ** for proper initialization of psc_iupdmap and consequently
	    ** pst_updmap in the tree header passed to OPF.
	    */
	    DB_STATUS		status;
	    DMT_ATT_ENTRY	*coldesc;
	    PST_QNODE		*rsdm, *newnode;
	    char		*name;
	    DB_DATA_VALUE	*dv;
	    PST_VAR_NODE	varnode;
	    i4		err_code;

	    /* deferred is the default update mode */
	    if ($1 == PST_UNSPECIFIED)
	    {
		$1 = PST_DEFER;
	    }

	    for (rsdm = $Yupdcollst;
		 rsdm && rsdm->pst_sym.pst_type == PST_RESDOM;
		 rsdm = rsdm->pst_left
		)
	    {
		name = rsdm->pst_sym.pst_value.pst_s_rsdm.pst_rsname;

		/* Get the column description */
		coldesc = pst_coldesc(cb->pss_resrng, name, DB_ATT_MAXNAME);

		if (coldesc == (DMT_ATT_ENTRY *) NULL)
		{
		    (VOID) psf_error(2102L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2,
			(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
			(i4) psf_trmwhite(DB_ATT_MAXNAME, name), name);
		    return (E_DB_ERROR);
		}

		dv = &rsdm->pst_sym.pst_dataval;

		dv->db_data =   (PTR) NULL;
		dv->db_length = coldesc->att_width;
		dv->db_datatype = coldesc->att_type;
		dv->db_prec = coldesc->att_prec;

		/* Set up var node. */
		varnode.pst_vno = cb->pss_resrng->pss_rgno;
		varnode.pst_atno.db_att_id = coldesc->att_number;

		/* Create the node */
		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    sizeof(varnode), (DB_DT_ID) coldesc->att_type,
		    (i2) coldesc->att_prec, (i4) coldesc->att_width,
		    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
		if (DB_FAILURE_MACRO(status))
		    return (status);

		rsdm->pst_right = newnode;
	    }
	}
	else
	{
	    /* If no column list, FOR and UPDATE are the only
	    ** legal words in the update clause.
	    */
	    if ($1 != PST_UNSPECIFIED)
	    {
		i4 err_code;

		(VOID) psf_error(2200L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		    &cb->pss_lineno, psf_trmwhite(DB_CURSOR_MAXNAME,
		    cb->pss_crsr->psc_curid.db_cur_name),
		    cb->pss_crsr->psc_curid.db_cur_name);
		return (E_DB_ERROR);
	    }
	    else
	    {
		register i4  i;

		/* Find the possible result table. If there is more than one,
		** and the query is not 'readonly', we will catch the error 
		** later.
		*/
		for (i = 0; i < PST_NUMVARS; i++)
		{
		    if (cb->pss_usrrange.pss_rngtab[i].pss_rdrinfo
			!= (RDR_INFO *) NULL)
		    {
			cb->pss_resrng = &cb->pss_usrrange.pss_rngtab[i];
			break;
		    }
		}

		/* No explicit updates */
		$1 = PST_READONLY;
	    }
	}

	$$ = $1;
    }
	|
    {
	i4   i;

	/* Find the possible result table. If there is more 
	** than one, and the query is not 'readonly', we
	** will catch the error later.
	*/
	for (i = 0; i < PST_NUMVARS; i++)
	{
	    if (cb->pss_usrrange.pss_rngtab[i].pss_rdrinfo 
		    != (RDR_INFO *) NULL)
	    {
		cb->pss_resrng = &cb->pss_usrrange.pss_rngtab[i];
		break;
	    }
	}

	/* Update privilege has not been requested */
	$$ = PST_READONLY;
    }
;

updword:	    DEFERUPD nonkeyword
    {
	i4	    err_code;

	if (STcompare($2, "update"))
	{
	    (VOID) psf_error(2615L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength($2), $2);
	    return (E_DB_ERROR);
	}

	$$ = PST_DEFER;
    }
	  |	    DIRECTUPD nonkeyword
    {
	i4	    err_code;

	if (STcompare($2, "update"))
	{
	    (VOID) psf_error(2615L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength($2), $2);
	    return (E_DB_ERROR);
	}

	$$ = PST_DIRECT;
    }
	    |	    FORUPDATE
    {
	$$ = PST_UNSPECIFIED;
    }
;

uplist:    uplist_of LPAREN updlist RPAREN
    {
	/* updcollst points to the root of RESDOM tree with
	** names of columns named in the FOR UPDATE clause.
	*/
	$Yupdcollst = $3;
    }
	|
    {
	/* No update column list.
	** $Yupdcollst is NULL.
	*/
    }
;

uplist_of:	    OF
    {
	i4   i;

	/* Find the possible result table. If there is more
	** than one, and the query is not 'readonly', we 
	** will catch the error later.
	*/
	for (i = 0; i < PST_NUMVARS; i++)
	{
	    if (cb->pss_usrrange.pss_rngtab[i].pss_rdrinfo 
		    != (RDR_INFO *) NULL)
	    {
		cb->pss_resrng = &cb->pss_usrrange.pss_rngtab[i];
		break;
	    }
	}
    }
;

updlist:	    updname
    {
	$$= $1;
    }
	  |	    updlist COMMA updname
    {
	$$ = pst_tlprpnd($1, $3);
    }
;

updname:	    NAME
    {
	DB_STATUS	    status;
	PST_QNODE	    *resdomnode;
	PST_RSDM_NODE	    resdom;

	/* Normalize the attribute name */
	STmove($1, ' ', sizeof(resdom.pst_rsname),
	    (char *) resdom.pst_rsname);

	resdom.pst_rsno = (i4) 1;
	resdom.pst_ntargno = (i4) 0;
	resdom.pst_ttargtype = (i4) PST_USER;
	resdom.pst_rsupdt = (i4) FALSE;
	resdom.pst_rsflags = PST_RS_PRINT;
	resdom.pst_dmuflags = 0;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_RESDOM, (char *) &resdom,
	    sizeof(PST_RSDM_NODE), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &resdomnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	$$ = resdomnode;
    }
;

readclause:	    FORREADONLY
    {
	$$ = TRUE;
    }
	  |	    /* NULL */
    {
	$$ = FALSE;
    }
;

defref:	    defrefstmnt NAME WITH defrefclauses
;

defrefstmnt:	    DEFREF
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_DEFREF;

	/* "define reference" is allowed only in distributed */
	if (cb->pss_distrib == DB_DSTNO)
	{
	    (VOID) psf_error(5205L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

defrefclauses:	    defrefclause
	  |	    defrefclauses COMMA defrefclause
;

defrefclause:	    nonkeyword ISOP NAME COLON COLON NAME COLON NAME
    {
	i4                err_code;

	/* The only valid parameter of this form is "pathname" */
	if (STcasecmp($1, "pathname" ))
	{
	    (VOID) psf_error(5152L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($1), $1);
	    return (E_DB_ERROR);    /* Non-zero return means error */
	}
    }
	  |	    nonkeyword
    {
	i4                err_code;

	/*
	** The recognized parameters of this form are "permanent and
	** "temporary
	*/
	if (!STcasecmp($1, "permanent"))
	{
	}
	else if (!STcasecmp($1, "temporary"))
	{
	}
	else
	{
	    (VOID) psf_error(5152L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STlength($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

defrptcurs:	    defrptcursstmnt retrieve updclause readclause
    {
	DB_STATUS	status;

	/* Initialize the type of updating in the query tree header */
	$2->pst_updtmode = $3;

	status = psl_crsopen(cb, psq_cb, $1, $2, $4,
	    $Yupdcollst, $Ynonupdt, $Yjoin_id, FALSE);

	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}
    }
;

defrptcursstmnt:   DEFCURSOR QUERYID
    {
	DB_STATUS              status;
	PSC_CURBLK	       *curblk;
	i4		       err_code;

	psq_cb->psq_mode = PSQ_DEFCURS;
	cb->pss_defqry = PSQ_DEFCURS;

	/* Look for FE version of cursor control block.
	** If it doesn't exist, error. The cursor may be opened.
	** The user should try the exec statement first.
	*/
	status = psq_crffind(cb, $2, &curblk, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	if (curblk != (PSC_CURBLK *) NULL)
	{
	    (VOID) psf_error(2210L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, DB_CURSOR_MAXNAME, $2->db_cur_name);
	    return (E_DB_ERROR);
	}
	status = psq_crcreate(cb, $2, psq_cb->psq_mode, &curblk,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(curblk->psc_blkid, psq_cb->psq_cursid);

	$$ = curblk;
    }
;

/* define location location_name with type= location_type,
**  area=area_name.
*/
defloc:		defloc_stmt NAME WITH nonkeyword ISOP nonkeyword COMMA 
		nonkeyword ISOP strconst
    {
	DB_STATUS		status;
	i4			err_code;
	DMC_CB			*dmc_cb;
	DMC_LOC_ENTRY		*loc_entry;
	char			*syn_error;

	if (STcompare($4, "type"))
	{
	    syn_error = $4;
	}
	else if (STcompare($8, "area"))
	{
	    syn_error = $8;
	}
	else
	{
	    syn_error = (char *) NULL;
	}

	if (syn_error)
	{
	    (VOID) psf_error(2683L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength(syn_error), syn_error);
	    return (E_DB_ERROR);
	}
	/* check for legal location types
	** DATA is the only legal value
	*/
	if (STcompare($6, "data"))
	{
	    (VOID) psf_error(2718L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength($6), $6);
	    return (E_DB_ERROR);
	}		

	/* check for legal location name.
	** Just check length.
	*/
	if (STlength($10) > sizeof (loc_entry->loc_extent))
	{
	    (VOID) psf_error(2719L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, 
		sizeof cb->pss_lineno, &cb->pss_lineno,
		(i4) STlength($10), $10);
	    return (E_DB_ERROR);
	}

	/* Create control block for DMC_ALTER call for define location */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CB), (PTR *) &dmc_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_LOC_ENTRY), 
	    (PTR *) &loc_entry, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) dmc_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	cb->pss_object	    = (PTR) dmc_cb;
	dmc_cb->type	    = DMC_CONTROL_CB;
	dmc_cb->length	    = sizeof (DMC_CB);
	dmc_cb->dmc_op_type = DMC_DATABASE_OP;
	dmc_cb->dmc_session_id	= (PTR)cb->pss_sessid;
	dmc_cb->dmc_flags_mask = DMC_ALOCATION;
	dmc_cb->dmc_db_id   = cb->pss_dbid;
	dmc_cb->dmc_db_access_mode = 0;
	dmc_cb->dmc_lock_mode	= 0;
	dmc_cb->dmc_db_location.data_address = (char*) loc_entry;
	dmc_cb->dmc_db_location.data_in_size = sizeof (*loc_entry);
	loc_entry->loc_flags = LOC_DATA;
	STmove($2, ' ', sizeof(DB_LOC_NAME), (char *) &loc_entry->loc_name);
	loc_entry->loc_l_extent = STlength($10);
	MEcopy((PTR) $10, loc_entry->loc_l_extent, 
	    (PTR) loc_entry->loc_extent);
    }
;

defloc_stmt:	    DEFLOC
    {
	psq_cb->psq_mode = PSQ_DEFLOC;
    }
;	

delete:            delstmnt delvar qualclause
    {
	PST_QNODE              *tidnode;
	PST_VAR_NODE	       tidvar;
	PST_QNODE	       *rsdmnode;
	PST_RSDM_NODE	       resdom;
	PST_QNODE	       *rootnode;
	PST_RT_NODE	       root;
	PST_QTREE	       *tree;
	DB_STATUS	       status;
	i4		       err_code;
	i4		       mask;
	i4		       mask2;
	i4		       qrymod_resp_mask;
	PST_PROCEDURE	       *pnode;

	/* Set up a var. node representing the tid */
	tidvar.pst_vno = $2->pss_rgno;
	tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar, sizeof(tidvar),
	    DB_TID_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL,
	    &tidnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	    /* non-zero return means error */
	}

	/* Set up a resdom result domain representing a tid. */
	resdom.pst_rsno = cb->pss_rsdmno++; /* Count resdoms */
	resdom.pst_ntargno = resdom.pst_rsno;
	resdom.pst_ttargtype = PST_ATTNO;
	resdom.pst_rsupdt = FALSE;
	resdom.pst_rsflags = 0; /* no PST_RS_PRINT */

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, 
	    tidnode, PST_RESDOM, (PTR) &resdom, sizeof(resdom), DB_TID_TYPE,
	    (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL, &rsdmnode,
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Make the root node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;

	status = pst_node(cb, &cb->pss_ostream, rsdmnode, $3, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Remember the result variable */
	cb->pss_resrng = $2;

	if (cb->pss_defqry == PSQ_DEFQRY)
	{
	    /*
	    ** now call psl_shareable() to determine if the query satisfies SQL
	    ** definition of shareability (i.e. all tables used in the query are
	    ** catalogs or are owned by the DBA; QUEL user cannot explicitly
	    ** qualify them with an owner name)
	    */
	    status = psl_shareable(psq_cb, cb, &$Yqp_shareable, &$Yshr_qryinfo);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	/* Apply qrymod algorithm (views, permits, integrities) */
	status = psy_qrymod(rootnode, cb, psq_cb, &$Yjoin_id,
	    &qrymod_resp_mask);
	if (status != E_DB_OK)
	    return (status);

	/*
	** if this is a repeat query and it is shareable according to SQL
	** definition of shareability, apply QUEL-specific checking
	*/
	if (cb->pss_defqry == PSQ_DEFQRY && $Yqp_shareable)
	{
	    psl_quel_shareable(cb, $Yqry_mask, &$Yqp_shareable);
	}

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/* Make sure base table is updateable;
	** In case of an index or a non-extended catalog,
	** catalog update privilege must be on.
	** In case of security catalog session must have
	** security privilege active.
	** Bug 34079, since 6.0 you were never supposed to be 
        ** able to update a secondary index.  Fixed it so 
        ** the same error is returned whether you have update 
        ** syscat or not (jennifer)
	**
	** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
	** allow DELETE on indexes which are non-extended catalogs
	*/
	if (mask & DMT_IDX)
	{
	    if (!(   mask & DMT_CATALOG && ~mask & DMT_EXTENDED_CAT
	          && cb->pss_ses_flag & PSS_CATUPD
		  && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
		 )
	       )
	    {
		_VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return(E_DB_ERROR);
	    }
	}
	else if ( ( (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
		 && ~mask & DMT_EXTENDED_CAT
		 && !(cb->pss_ses_flag & PSS_CATUPD))
	      ||
	     	((mask & DMT_SECURE) &&
	       !(cb->pss_ustat & DU_USECURITY)))
	{
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_DELETE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_DELETE, &e_error);
		if (local_status > status)
		    status = local_status;
	    _VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Make the header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, PST_0FULL_HEADER, (PSS_Q_XLATE *) NULL);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;

	/* Fix the root in QSF */
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = tree;
    }
;

delstmnt:          DELETE
    {
	DB_STATUS              status;

	/* Set query mode */
	psq_cb->psq_mode = PSQ_DELETE;

	/* Open memory stream for allocating query tree */
	if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);    /* non-zero return means error */
	}
    }
;

delvar:		    var
    {
	$$ = $1;
    }
	|           nonkeyword PERIOD NAME
    {
	i4		    rngvar_info;
	i4		    err_code;
	DB_STATUS           status;
	PSS_RNGTAB	    *rngtab;
	DB_TAB_NAME	    tabname;
	DB_OWN_NAME	    sessname;

	if (STcasecmp($1, "session"))
	{
	    (VOID) psf_error(5153, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) $1), $1);
	    return (E_DB_ERROR);
	}
	STmove($3, ' ', sizeof(tabname), (char *) &tabname);
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, sessname);
	status = psl_orngent(&cb->pss_usrrange, -1, $1, &sessname, &tabname, 
	    cb, FALSE, &rngtab, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = rngtab;
    }
;

destinteg:	    destintegstmnt NAME destqymlist
    {
	PSY_CB                 *psy_cb;
	DB_STATUS	       status;
	DB_TAB_NAME	       tabname;
	PSS_RNGTAB	       *resrange;
	DB_TAB_NAME	       *nameplace;
	DB_TAB_ID	       *idplace;
	i4			err_code;
	i4			mask;
	i4			mask2;
	i4			err_num = 0L;
	i4			rngvar_info;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* -1 means "all" has been specified, so change to 0 */
	if (psy_cb->psy_numnms == -1)
	    psy_cb->psy_numnms = 0;

	/* Figure out where table name and id go */
	idplace = &psy_cb->psy_tables[psy_cb->psy_numtabs];
	nameplace = &psy_cb->psy_tabname[psy_cb->psy_numtabs++];

	/* Find table id for this table name */
	STmove($2, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info, NULL);
	if (status != E_DB_OK)
	    return (status);

	mask = resrange->pss_tabdesc->tbl_status_mask;
	mask2 = resrange->pss_tabdesc->tbl_2_status_mask;

	if (mask & (DMT_CATALOG | DMT_EXTENDED_CAT)
	    || mask2 & DMT_TEXTENSION)
	{
	    /* If not an extended catalog and no catalog update
	    ** permission - error.
	    */
	    if (~mask & DMT_EXTENDED_CAT
		&& !(cb->pss_ses_flag & PSS_CATUPD))
	    {
		err_num = 5201L;
	    }
	}
	else if (MEcmp((PTR) &resrange->pss_ownname, 
		(PTR) &cb->pss_user, sizeof(DB_OWN_NAME)))
	{
	    err_num = 5202L;
	}

	if (err_num != 0L)
	{
	    /* Must audit DESTROY INTEGRITY here. */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS		local_status;
		DB_ERROR		e_error;

		local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabdesc->tbl_name,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2036_INTEGRITY_DROP, SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
	    }

	    (VOID) psf_error(err_num, 0L, PSF_USERERR,&err_code, 
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Put it in the control block, along with the table name */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid, *idplace);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabname, *nameplace);
    }
;

destintegstmnt:    DESTINTEG
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_DSTINTEG;

	/* Allocate a PSY_CB for destroy integrity */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    }
;

destqymlist:	    destint
          |	    destqymlist COMMA destint
          |	    ALL
    {
	PSY_CB                 *psy_cb;

	/*
	** If "all" is specified, set the number of numbers to -1.  It will
	** be set to 0 later.  This way, if the user specifies some numbers
	** along with "all", they will all be destroyed, instead of just
	** the ones after the "all".
	*/
	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_numnms = -1;
    }
;

destint:	       intconst
    {
	PSY_CB		       *psy_cb;
	i4		       err_code;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* -1 means "all" has been specified */
	if (psy_cb->psy_numnms != -1)
	{
	    if (++psy_cb->psy_numnms > PSY_MAXTABS)
	    {
		(VOID) psf_error(2113L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	    psy_cb->psy_numbs[psy_cb->psy_numnms - 1] = $1;
	}
    }
;

destperm:             destpermstmnt NAME destqymlist
    {
	PSY_CB              *psy_cb;
	DB_STATUS	    status;
	DB_TAB_NAME	    tabname;
	PSS_RNGTAB	    *resrange;
	DB_TAB_NAME	    *nameplace;
	DB_TAB_ID	    *idplace;
	i4		    err_code;
	i4		    mask;
	i4		    mask2;
	i4		    err_num = 0L;
	i4		    rngvar_info;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* destroying permit on a table */
	psy_cb->psy_grant = PSY_TDROP;

	/* -1 means "all" has been specified, so change to 0 */
	if (psy_cb->psy_numnms == -1)
	    psy_cb->psy_numnms = 0;

	/* Figure out where table name and id go */
	idplace = &psy_cb->psy_tables[psy_cb->psy_numtabs];
	nameplace = &psy_cb->psy_tabname[psy_cb->psy_numtabs++];

	/* Find table id for this table name */
	STmove($2, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info, NULL);
	if (status != E_DB_OK)
	    return (status);

	mask = resrange->pss_tabdesc->tbl_status_mask;
	mask2 = resrange->pss_tabdesc->tbl_2_status_mask;
	
	/* Catalog update privilege alone is enough to manipulate
	** catalogs.
	*/
	if (!(mask & (DMT_CATALOG | DMT_EXTENDED_CAT) && 
	     (cb->pss_ses_flag & PSS_CATUPD)))
	{
	    /* Only the dba is allowed to revoke a permit */
	    if (MEcmp((PTR) &cb->pss_user, (PTR) &cb->pss_dba, 
		sizeof(DB_OWN_NAME)))
	    {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS	    local_status;
		    DB_ERROR	    e_error;

		    /* Must audit DESTROY PERMIT here. */

		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabdesc->tbl_name,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2018_PROT_TAB_DROP, SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
		}

		(VOID) psf_error(5210L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }
	}

	if (mask & (DMT_CATALOG | DMT_EXTENDED_CAT)
	    || mask2 & DMT_TEXTENSION)
	{
	    /* If not an extended catalog and no catalog update
	    ** permission - error.
	    */
	    if (~mask & DMT_EXTENDED_CAT && !(cb->pss_ses_flag & PSS_CATUPD))
	    {
		err_num = 5201L;
	    }
	}
	else if (MEcmp((PTR) &resrange->pss_ownname, 
		(PTR) &cb->pss_user, sizeof(DB_OWN_NAME)))
	{
	    err_num = 5202L;
	}

	if (err_num != 0L)
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	    local_status;
		DB_ERROR	    e_error;

		/* Must audit DESTROY PERMIT here. */

		local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabdesc->tbl_name,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2018_PROT_TAB_DROP, SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
	    }

	    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Put it in the control block, along with the table name */
	STRUCT_ASSIGN_MACRO(resrange->pss_tabid, *idplace);
	STRUCT_ASSIGN_MACRO(resrange->pss_tabname, *nameplace);
    }
;

destpermstmnt:	    DESTPERM
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_DSTPERM;

	/* Allocate a PSY_CB for destroy permit */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    }
;

destref:	    DESTREF NAME
    {
	psq_cb->psq_mode = PSQ_DSTREF;
    }
;

destroy:           destmnt relationlist
    {
	PSY_CB		*psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	if (psy_cb->psy_numtabs == 0)
	    return (E_DB_ERROR);
    }	
;

destmnt:           DESTROY
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_DESTROY;

	/* Create a PSY_CB to do the destruction of tables and views */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);
    }
;

relationlist:	    destrname
          |	    relationlist COMMA destrname
;

destrname:	    NAME
    {
	PSY_CB                 *psy_cb;
	i4		       err_code;
	DB_STATUS	       status;
	DB_TAB_NAME	       tabname;
	PSS_RNGTAB	       *resrange;
	DB_TAB_NAME	       *nameplace;
	DB_TAB_ID	       *idplace;
	i4			rngvar_info;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Figure out where table name and id go */
	idplace = &psy_cb->psy_tables[psy_cb->psy_numtabs];
	nameplace = &psy_cb->psy_tabname[psy_cb->psy_numtabs];

	STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);

	status = psl0_rngent(&cb->pss_auxrng, -1, "", &tabname, cb,
	    TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    PSS_USRTBL | PSS_DBATBL | PSS_INGTBL, &rngvar_info, 0, NULL);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	if (!resrange)
	{
	    (VOID) psf_error(5202L, 0L, PSF_USERERR,&err_code,
		&psq_cb->psq_error, 1, STlength($1), $1);
	}
	/*
	** DESTROY synonym_name will be disallowed
	*/
	else if (rngvar_info & PSS_BY_SYNONYM)
	{
	    (VOID) psf_error(E_PS0452_CANT_DROP_SYN, 0L,
		PSF_USERERR, &err_code, &psq_cb->psq_error, 1, 
		STlength($1), $1);
	}
	else if (resrange->pss_tabdesc->tbl_2_status_mask & DMT_READONLY)
	{
	    (VOID) psf_error( E_US14E8_5352_DROP_READONLY, 0L, PSF_USERERR,
			      &err_code, &psq_cb->psq_error, 2,
			      sizeof( "DESTROY" ), "DESTROY",
			      psf_trmwhite(sizeof(DB_TAB_NAME),
			      tabname.db_tab_name),
			      tabname);
	}
	else
	{
	    i4	err_num = 0L;

	    /* Make sure base table isn't a system table */
	    if (resrange->pss_tabdesc->tbl_status_mask & DMT_CATALOG
		|| resrange->pss_tabdesc->tbl_2_status_mask & DMT_TEXTENSION)
	    {
	        /*							    
		** if object is a core catalog or user can't update	
		** catalogs
		*/
		if (  (!(cb->pss_ses_flag & PSS_CATUPD)) ||
    	              (resrange->pss_tabdesc->tbl_status_mask &
		       DMT_CONCURRENCY)
		   ) 
		{
		    err_num = 5201L;
		}
	    }
	    /*								    
	    ** Object is not a catalog (i.e. it is a table) and is
	    ** not owned by the user
	    */
	    else if (MEcmp((PTR) &resrange->pss_ownname, 
		    (PTR) &cb->pss_user, sizeof(DB_OWN_NAME)))
	    {
		err_num = 5202L;
	    }

	    if (err_num != 0L)
	    {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS		local_status;
		    DB_ERROR		e_error;
		    i4			msg_id;
		    i4		        accessmask = SXF_A_FAIL;
		    i4			auditevent;
		    
		    /* Must audit DROP Failure. */

		    if (resrange->pss_tabdesc->tbl_status_mask & DMT_VIEW)
		    {
			accessmask |= SXF_A_DROP;
			auditevent = SXF_E_VIEW;
			msg_id     = I_SX2015_VIEW_DROP;
		    }
		    else if (resrange->pss_tabdesc->tbl_status_mask & DMT_IDX)
		    {
			accessmask |= SXF_A_INDEX;
			auditevent = SXF_E_TABLE;
			msg_id = I_SX2010_INDEX_DROP;
		    }
		    else
		    {
			accessmask |= SXF_A_DROP;
			auditevent = SXF_E_TABLE;
			msg_id     = I_SX2025_TABLE_DROP;
		    }

		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&resrange->pss_tabdesc->tbl_name,
			    &resrange->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), auditevent,
			    msg_id, accessmask, 
			    &e_error);
		}

		(VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME), 
			(char *) &resrange->pss_tabname),
		    &resrange->pss_tabname);
	    }
	    /*
	    ** found no errors; will add table to the list of tables to be
	    ** dropped
	    */
	    else		
	    {
		/* if dropping a view, set a flag for psy_kview() */
		psy_cb->psy_obj_mask[psy_cb->psy_numtabs++] =
		    (resrange->pss_tabdesc->tbl_status_mask & DMT_VIEW)
								? PSY_IS_VIEW
								: 0;
		cb->pss_resrng = resrange;

		/* Check for too many tables to fit into control block */
		if (psy_cb->psy_numtabs > PSY_MAXTABS)
		{
		    (VOID) psf_error(2113L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}

		/* Put it in the control block, along with the table name */
		STRUCT_ASSIGN_MACRO(resrange->pss_tabid, *idplace);
		STRUCT_ASSIGN_MACRO(resrange->pss_tabname, *nameplace);
	    }
	}
    }
;

etransact:         ENDXACT
    {
	QEF_RCB                *qef_rcb;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_ENDTRANS;

	/* Allocate the QEF control block for commit */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    }
;

execute:	    execstmt LPAREN paramclause RPAREN
          |	    execstmt
;

execstmt:          EXECUTE NAME
    {

	DB_STATUS	       status;

	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_EXECQRY;

	/* Hand the query name back to the caller */
	psq_cb->psq_cursid.db_cursor_id[0] = cb->pss_psessid;
	psq_cb->psq_cursid.db_cursor_id[1] = 0;
	STmove($2, ' ', DB_CURSOR_MAXNAME, psq_cb->psq_cursid.db_cur_name);

	/* Allocate the QEF control block for execute cursor */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_modifier = 0;

	/* set the query id in the qef_rcb */
	qef_rcb->qef_qp.db_cursor_id[0] = cb->pss_psessid;
	qef_rcb->qef_qp.db_cursor_id[1] = 0;
	STmove($2, ' ', DB_CURSOR_MAXNAME, qef_rcb->qef_qp.db_cur_name);

	/* Allocate the input data area */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_PARAM),
	    (PTR *) &qef_rcb->qef_param, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qef_rcb->qef_param->dt_next = (QEF_PARAM *) NULL;
	/* start numbering parameters at 1 */
	qef_rcb->qef_pcount = 0;
	qef_rcb->qef_param->dt_size = 1;
	/* room for 255 parameters */
	status = psf_malloc(cb, &cb->pss_ostream, 256 * sizeof (PTR),
	    (PTR *) &qef_rcb->qef_param->dt_data, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** To make things easier, we will cheat, and use one of the
	** fields in qef_rcb to keep track of the number of bytes allocated
	** for the parameter buffer.
	*/
	qef_rcb->qef_rowcount = 256;
    }
;

paramclause:	    eparam
          |	    paramclause COMMA eparam
;

eparam:            QDATA
    {
	QEF_RCB                *qef_rcb;
	char		       *bufptr;
	DB_STATUS	       status;
	DB_DATA_VALUE	       *dbval;

	qef_rcb = (QEF_RCB *) cb->pss_object;
	dbval	= $1;
	/*
	** If there's not enough room in the current buffer, allocate one
	** that's twice as big.
	*/
	if (qef_rcb->qef_param->dt_size >= qef_rcb->qef_rowcount)
	{
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) qef_rcb->qef_rowcount,
		(PTR *) &bufptr, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    MEcopy((char *) qef_rcb->qef_param->dt_data, 
		qef_rcb->qef_rowcount, bufptr);
	    qef_rcb->qef_param->dt_data = (PTR*) bufptr;
	    qef_rcb->qef_rowcount *= 2;
	}

	qef_rcb->qef_param->dt_data[qef_rcb->qef_param->dt_size++] 
						    = (PTR) dbval->db_data;
	/* increment number of parameters */
	qef_rcb->qef_pcount++;
    }
;

index:             instmnt LPAREN indexcols RPAREN index_with
    {
	DB_STATUS		status;

	status = psl_ci1_create_index(cb, &$Ywith_clauses, $Yunique,
					&psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

instmnt:           indexq ON NAME index_is indexlocname
    {
	DB_STATUS		status;

	/*
	** store the table name into format understood by psl_ci3_indexrel()
	** which is also used by the SQL indexrel:
	*/

        STmove($3, ' ', sizeof(DB_TAB_NAME), (char *) &$Yobj_spec.pss_obj_name);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &$Yobj_spec.pss_owner);
	$Yobj_spec.pss_objspec_flags = 0;
	$Yobj_spec.pss_orig_obj_name = $3;

	status = psl_ci3_indexrel(cb, &$Yobj_spec, &psq_cb->psq_error,
	    psq_cb->psq_mode);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

indexq:            INDEX index_unique 
    {
	DB_STATUS		status;

        /*
	** schang : need to set psq_cb->psq_mode to PSQ_INDEX to share code with
	** RMSGW
	*/ 
        psq_cb->psq_mode = PSQ_INDEX;
	cb->pss_object = (PTR) 0;
	cb->pss_save_qeucb = (PTR) 0;

	status = psl_ci2_index_prefix(cb, psq_cb, &$Ywith_clauses, $2);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

index_unique:	    UNIQUE
    {
	$$ = TRUE;
	$Yunique = TRUE;
    }
	    |
    {
	$$ = FALSE;
	$Yunique = FALSE;
    }
;

index_is:	IS
    |		ISOP
;

indexlocname:	    NAME COLON NAME
    {
	DB_STATUS		status;

	/*
	** store the index name into format understood by psl_ci5_indexlocname()
	** which is also used by the SQL indexlocname:
	*/

        STmove($3, ' ', sizeof(DB_TAB_NAME), (char *) &$Yobj_spec.pss_obj_name);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &$Yobj_spec.pss_owner);
	$Yobj_spec.pss_objspec_flags = 0;
	$Yobj_spec.pss_orig_obj_name = $3;

        /* schang : last arg is psq_cb so that RMS GW can use the same code */
	status = psl_ci5_indexlocname(cb, $1, &$Yobj_spec, &$Ywith_clauses,
	    psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	NAME
    {
	DB_STATUS		status;

	/*
	** store the index name into format understood by psl_ci5_indexlocname()
	** which is also used by the SQL indexlocname:
	*/

        STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &$Yobj_spec.pss_obj_name);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &$Yobj_spec.pss_owner);
	$Yobj_spec.pss_objspec_flags = 0;
	$Yobj_spec.pss_orig_obj_name = $1;

        /* schang : last arg is psq_cb so that RMS GW can use the same code */
	status = psl_ci5_indexlocname(cb, (char *) NULL, &$Yobj_spec,
	    &$Ywith_clauses, psq_cb);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

indexcols:	    indexcolname
	  |	    indexcols COMMA indexcolname
;

indexcolname:	    NAME
    {
	DB_STATUS		status;

	status = psl_ci4_indexcol(cb, $1, &psq_cb->psq_error, FALSE);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

index_with:	    WITH index_withopts
	    |	    WITHNULL
	    |
;

index_withopts:	    index_withopt
	    |	    index_withopts COMMA index_withopt
;

index_withopt:	    index_woname
	    |	    index_wonum
	    |	    index_wolst
	    |	    index_woword
;

index_woname:	    nonkeyword ISOP nonkeyword
    {
	DB_STATUS		status;

	status = psl_nm_eq_nm(cb, $1, $3, &$Ywith_clauses, psq_cb->psq_mode,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

index_wonum:	    nonkeyword ISOP intconst
    {
	DB_STATUS		status;

	status = psl_nm_eq_no(cb, $1, $3, &$Ywith_clauses, psq_cb->psq_mode,
	    &psq_cb->psq_error, (PSS_Q_XLATE *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

index_wolst:	    index_lst_prefix LPAREN index_lst RPAREN
    {
	$Ylist_clause = 0;	/* done with this clause */
    }
;

index_lst_prefix:    nonkeyword ISOP
    {
	DB_STATUS		status;

	status = psl_lst_prefix(cb, psq_cb, $1, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

index_lst:	    index_lst_elem
	    |	    index_lst COMMA index_lst_elem
;

index_lst_elem:	    NAME
    {
	DB_STATUS		status;

	$Yid_type = PSS_ID_REG;
	status = psl_lst_elem(cb, yyvarsp, $1, PSQ_INDEX,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

index_woword:	    nonkeyword
    {
	DB_STATUS		status;

	status = psl_ci7_index_woword(cb, $1, &$Ywith_clauses,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

defintegrity:      integstmnt integnoise intvar integis qual
    {
	DB_STATUS              status;
	PST_RT_NODE	       root;
	PST_QNODE	       *rootnode;
	PST_QTREE	       *tree;
	PSY_CB		       *psy_cb;
	i4		       err_code;
	PST_PROCEDURE	       *pnode;

	cb->pss_qualdepth--;

	/* Make the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, $5,
	    PST_ROOT, (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	    return (status);

	/* make sure no tids in the integrity */
	if (psy_qscan(rootnode, cb->pss_resrng->pss_rgno, DB_IMTID))
	{
	    (VOID) psf_error(3496L, 0L, PSF_USERERR, &err_code, 
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}
	/* Make the query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, PST_0FULL_HEADER, (PSS_Q_XLATE *) NULL);
	if (status != E_DB_OK)
	    return (status);

	/*
	** pst_numjoins was set to PST_NOJOIN in pst_header(), so we don't need
	** to do it here.
	*/

	/* Make sure there are no aggregates in qualification */
	if (tree->pst_agintree)
	{
	    (VOID) psf_error(3490L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof(DB_TAB_NAME),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Make sure the integrity has only one range variable */
	if (cb->pss_usrrange.pss_maxrng >= 1)
	{
	    (VOID) psf_error(3491L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof(DB_TAB_NAME),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Set the root in QSF */
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);


	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	/* Copy the query tree stream so we can re-use it */
	STRUCT_ASSIGN_MACRO(cb->pss_ostream, cb->pss_cbstream);

	/* Create the PSY_CB for the integrity definition */
	status = psy_qminit(cb, psq_cb, &cb->pss_ostream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Fill in QSF object ids for query tree and modified query text */
	STRUCT_ASSIGN_MACRO(cb->pss_cbstream.psf_mstream, psy_cb->psy_intree);

	/* Fill in table id and table name */
	STRUCT_ASSIGN_MACRO($3->pss_tabid, psy_cb->psy_tables[0]);
	STRUCT_ASSIGN_MACRO($3->pss_tabname, psy_cb->psy_tabname[0]);

	/* Put the query text in a contiguous block in QSF */
	status = psq_tout(cb, &cb->pss_usrrange, cb->pss_tchain, &cb->pss_tstream,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
    }
;

integstmnt:        DEFINTEG
    {
	DB_STATUS	       status;
	PTR		       piece;

	psq_cb->psq_mode = PSQ_INTEG;

	/* Open the memory stream for allocating the query tree */
	status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/*
	** The "define integrity" statement requires query text to be stored in
	** the iiqrytext relation.  Open a text chain and put the initial
	** words "define integrity " in it.  The text chain will be coalesced
	** into a contiguous block later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT;	    /* Indicate to emit text */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psq_tadd(cb->pss_tchain, (u_char *) "define integrity ",
	    sizeof("define integrity ") - 1, &piece, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
    }
;

integnoise:        ON
          |
;

integis:           IS
    {
	cb->pss_qualdepth++;
    }
          |	    ISOP	/* for compatibility */
    {
	cb->pss_qualdepth++;
    }
	  |
    {
	cb->pss_qualdepth++;
    }
;
    
intvar:	    var
    {
	i4     err_code;
	i4	    mask;
	i4	    mask2;

	/*
	** On an integrity definition, remember what the result range variable
	** is.  This can't be stored in the result range variable slot in
	** the user range table, because that is not for "real" range variables,
	** only for result tables (as in an append).
	*/
	cb->pss_resrng = $1;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/*
	** Check for integrities on views.
	*/
	if (mask & DMT_VIEW)
	{
	    (VOID) psf_error(3493L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, 
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	if (mask & (DMT_CATALOG | DMT_EXTENDED_CAT)
	    || mask2 & DMT_TEXTENSION)
	{
	    /* If not an extended catalog and no catalog update
	    ** permission - error.
	    */
	    if (~mask & DMT_EXTENDED_CAT
		&& !(cb->pss_ses_flag & PSS_CATUPD))
	    {
		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    DB_STATUS	local_status;
		    DB_ERROR	e_error;
		    /*
		    ** Audit failure to define integrity
		    */
		    local_status = psy_secaudit( FALSE, cb, 
			    cb->pss_resrng->pss_tabname.db_tab_name,
			    &cb->pss_resrng->pss_ownname,
			    sizeof(cb->pss_resrng->pss_tabname),
			    SXF_E_TABLE, I_SX203D_INTEGRITY_CREATE,
			    SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
		}

		(VOID) psf_error(3498L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2, 
		    sizeof(cb->pss_lineno), &cb->pss_lineno,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return (E_DB_ERROR);
	    }
	}
	/* Check for integrity on table owned by someone else. */
	else if (MEcmp((PTR) &cb->pss_user, 
	    (PTR) &cb->pss_resrng->pss_tabdesc->tbl_owner, sizeof(DB_OWN_NAME)))
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	local_status;
		DB_ERROR	e_error;
		/*
		** Audit failure to define integrity
		*/
		local_status = psy_secaudit( FALSE, cb, 
		    cb->pss_resrng->pss_tabname.db_tab_name,
		    &cb->pss_resrng->pss_ownname,
		    sizeof(cb->pss_resrng->pss_tabname),
		    SXF_E_TABLE, I_SX203D_INTEGRITY_CREATE,
		    SXF_A_FAIL | SXF_A_CONTROL,
		    &e_error);
	    }

	    (VOID) psf_error(3494L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME),
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	$$ = $1;
    }
;

modify:            modstmnt modtable modnoise modstorage modkeys modwith
    {
	DB_STATUS		    status;

	status = psl_md1_modify(cb, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modstmnt:          MODIFY
    {
	DB_STATUS		status;

	status = psl_md2_modstmnt(cb, psq_cb, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modtable:	    NAME
    {
	DB_STATUS		status;

	/*
	** store the index name into format understood by psl_md8_modtable()
	** which is also used by the SQL modtable:
	*/

        STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &$Yobj_spec.pss_obj_name);
	MEfill(sizeof(DB_OWN_NAME), ' ', (PTR) &$Yobj_spec.pss_owner);
	$Yobj_spec.pss_objspec_flags = 0;
	$Yobj_spec.pss_orig_obj_name = $1;

	status = psl_md8_modtable(cb, &$Yobj_spec, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

modnoise:	    TO
    |
;

modstorage:	    modstorname
          |	    modstorname UNIQUE
    {
	DB_STATUS		status;

	status = psl_md3_modstorage(cb, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modstorname:	    modopt_num_cl
          |         nonkeyword
    {
	DB_STATUS		status;

	status = psl_md4_modstorname(cb, $1, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
	|	RELOCATE
    {
	DB_STATUS		status;

	status = psl_md4_modstorname(cb, "relocate", yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modkeys:           ON modrptkey
	  |
    {
	DB_STATUS		status;

	status = psl_md5_modkeys(cb, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modrptkey:	    modbasekey
          |	    modrptkey COMMA modbasekey
;

m_asc_desc:	    COLON nonkeyword
    {
	/* Decode sortorder.  Error if unknown. */
	if (!STcompare($2, "a") || !STcompare($2, "ascending"))
	{
	    $$ = PSS_ASCENDING;
	}
	else if (!STcompare($2, "d") || !STcompare($2, "descending"))
	{
	    $$ = PSS_DESCENDING;
	}
	else
	{
	    psl_yerror(3, cb, psq_cb);
	    return (E_DB_ERROR);
	}
    }
;

modbasekey:	    modkeyname
          |	    modkeyname m_asc_desc
    {
	DB_STATUS		    status;

	status = psl_md6_modbasekey(cb, (i4) ($2 == PSS_ASCENDING),
	    $Yis_heapsort, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modkeyname:	    NAME
    {
	DB_STATUS		status;

	status = psl_md7_modkeyname(cb, $1, yyvarsp, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modwith:	    modwith_kwd modopts
	    |	    WITHNULL
	    |
;

modwith_kwd:	    WHERE
	    |	    WITH
;

modopts:	    modopt
	    |	    modopts COMMA modopt
;

modopt:		    modopt_num_cl
	    |	    modopt_lst_cl
	    |	    modopt_word
;

modopt_num_cl:	    nonkeyword ISOP intconst
    {
	DB_STATUS		status;

	status = psl_nm_eq_no(cb, $1, $3, &$Ywith_clauses, PSQ_MODIFY,
	    &psq_cb->psq_error, (PSS_Q_XLATE *) NULL);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modopt_lst_cl:	    modopt_lst_prefix LPAREN modopt_lst RPAREN
    {
	$Ylist_clause = 0;	/* done with this clause */
    }
;

modopt_lst_prefix:	nonkeyword ISOP
    {
	DB_STATUS		status;

	status = psl_lst_prefix(cb, psq_cb, $1, yyvarsp);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modopt_lst:	modopt_lst_elem
	|	modopt_lst COMMA modopt_lst_elem
;

modopt_lst_elem:    nonkeyword
    {
	DB_STATUS		status;

	$Yid_type = PSS_ID_REG;
	status = psl_lst_elem(cb, yyvarsp, $1, PSQ_MODIFY,
	    &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

modopt_word:    nonkeyword
    {
	DB_STATUS		status;

	status = psl_md9_modopt_word(cb, $1, &$Ywith_clauses,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;	
	
defpermit:         permit_prefix permtd qualclause
    {
	DB_STATUS              status;
	PSF_MSTREAM	       tempstream;
	PST_QNODE	       *rootnode;
	PST_RT_NODE	       root;
	PSY_CB		       *psy_cb;
	PST_QTREE	       *tree;
	PST_PROCEDURE	       *pnode;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* mark if we have a qualification */
	if (($3)->pst_sym.pst_type != PST_QLEND)
	{
	    psy_cb->psy_istree = TRUE;

	    /* Make the ROOT node */
	    root.pst_rtuser = TRUE;
	    root.pst_union.pst_next  = 0;
	    root.pst_dups   = PST_ALLDUPS;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, $3, 
		PST_ROOT, (PTR) &root, sizeof(PST_RT_NODE), DB_NODT, (i2) 0,
		(i4) 0, (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error,
		(i4) 0);
	    if (status != E_DB_OK)
		return (status);

	    /* Make the query tree header */
	    status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
		rootnode, &tree, &pnode, PST_0FULL_HEADER,
		(PSS_Q_XLATE *) NULL);
	    if (status != E_DB_OK)
		return (status);

	    /* pst_numjoins was set to PST_NOJOIN in pst_header. */

	    /* Set the root in QSF */
	    status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, 
		&psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    /*
	    ** Copy the object ids for the query tree and query text to the
	    ** control block.
	    */
	   STRUCT_ASSIGN_MACRO(cb->pss_ostream.psf_mstream, psy_cb->psy_intree);
	}
	else
	{
	    /* There is no QTREE, so close QTREE stream */
	    status = psf_mclose(cb, &cb->pss_ostream, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);
	    cb->pss_ostream.psf_mstream.qso_handle = (PTR) NULL;
	}


	/*
	** We want to give the control block back to the caller.  However,
	** the control block has been allocated using the control block
	** stream, and it's the output stream that gets handed back to the
	** caller.  Therefore, we must swap the control block and output
	** streams.
	*/
	if (psy_cb->psy_istree)
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_ostream, tempstream);
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    STRUCT_ASSIGN_MACRO(tempstream, cb->pss_cbstream);
	}
	else
	{
	    STRUCT_ASSIGN_MACRO(cb->pss_cbstream, cb->pss_ostream);
	    cb->pss_cbstream.psf_mstream.qso_handle = (PTR) NULL;
	}

	/* Put the query text in a contiguous block in QSF */
	status = psq_tout(cb, &cb->pss_usrrange, cb->pss_tchain, &cb->pss_tstream,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(cb->pss_tstream.psf_mstream, psy_cb->psy_qrytext);
    }
;

permit_prefix:	permstmnt permlist
    {
	PTR		piece;
	DB_STATUS	status;
	char		*str;
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;
	i4		err_code;

	/*
	** The "define permit" statement requires query text to be stored in
	** the iiqrytext relation.  Open a text chain and put the initial
	** string in it.  If a permit represents more than one privilege,
	** the initial string will contain a placeholder big enough to
	** accomodate any of privilege names (i.e. RETRIEVE, REPLACE, APPEND or
	** DELETE); otherwise, the actual privilege name will be inserted.
	** Initial string will also contain word ON since it was already seen by
	** the scanner.  The text chain will be coalesced into a contiguous
	** block later.
	*/
	cb->pss_stmt_flags |= PSS_TXTEMIT; 	    /* Indicate to emit text */

	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (BTcount((char *) &psy_cb->psy_opmap, BITS_IN(psy_cb->psy_opmap))
	        > 1)
	{
	    str = "define permit ???????? on";
	}
	else if (psy_cb->psy_opmap == DB_RETRIEVE)
	{
	    str = "define permit retrieve on";
	}
	else if (psy_cb->psy_opmap == DB_REPLACE)
	{
	    str = "define permit replace on";
	}
	else if (psy_cb->psy_opmap == DB_DELETE)
	{
	    str = "define permit delete on";
	}
	else if (psy_cb->psy_opmap == DB_APPEND)
	{
	    str = "define permit append on";
	}
	else
	{
            _VOID_ psf_error(9346L, 0L, PSF_USERERR, &err_code,
            &psq_cb->psq_error, 0);
            return (E_DB_ERROR);
        }

	status = psq_tadd(cb->pss_tchain, (u_char *) str, STlength(str), &piece,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
		permword permvar permtarg permwho permplace
;

permstmnt:         DEFPERM
    {
	DB_STATUS	       status;
	PSY_CB		       *psy_cb;

	psq_cb->psq_mode = PSQ_PROT;

	/* Open the memory stream for allocating the query tree */
	status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Allocate the PSY_CB for the define permit statement */
	status = psy_qminit(cb, psq_cb, &cb->pss_cbstream);
	if (status != E_DB_OK)
	    return (status);

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Set control block fields to defaults and initial values */
	psy_cb->psy_grant   = PSY_CPERM;    /* this is not GRANT */

	/* Default terminal name is "" */
	MEfill(sizeof(psy_cb->psy_terminal), ' ', (PTR) &psy_cb->psy_terminal);

	/* default user name is " " */
	MEfill(sizeof(psy_cb->psy_user), ' ', (PTR) &psy_cb->psy_user);
	
	/*
	** Default time is all day, starting at 00:00 and ending at 24:00,
	** given as minutes after 00:00.
	*/
	psy_cb->psy_timbgn = 0;
	psy_cb->psy_timend = 1440;

	/*
	** Default days are all week, starting with Sunday and ending with
	** Saturday.  Sunday = 0, Saturday = 6.
	*/
	psy_cb->psy_daybgn = 0;
	psy_cb->psy_dayend = 6;
    }
;

permlist:	    permxlist
          |	    permlist COMMA permxlist
;

permxlist:         ALL
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap = psy_cb->psy_opctl =
	    DB_RETRIEVE | DB_APPEND | DB_REPLACE | DB_DELETE;
    }
          |	    RETRIEVE
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= DB_RETRIEVE;
	psy_cb->psy_opctl |= DB_RETRIEVE;
    }
          |	    DELETE
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= DB_DELETE;
	psy_cb->psy_opctl |= DB_DELETE;
    }
          |	    APPEND
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= DB_APPEND;
	psy_cb->psy_opctl |= DB_APPEND;
    }
          |	    REPLACE
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_opmap |= DB_REPLACE;
	psy_cb->psy_opctl |= DB_REPLACE;
    }
          |	   nonkeyword
    {
	PSY_CB		*psy_cb = (PSY_CB *) cb->pss_object;

	if(!STcasecmp($1, "COPY_INTO")==0)
	{
		psy_cb->psy_opmap |= DB_COPY_INTO;
		psy_cb->psy_opctl |= DB_COPY_INTO;
	}
	else if(!STcasecmp($1, "COPY_FROM")==0)
	{
		psy_cb->psy_opmap |= DB_COPY_FROM;
		psy_cb->psy_opctl |= DB_COPY_FROM;
	}
	else
	{
		return E_DB_ERROR;
	}
    }
;

permword:	ON
          |	OF
          |	TO
;

permvar:	    var
    {
	PSY_CB		    *psy_cb;
	i4		    err_code;
	i4		    mask;
	PSY_TBL		    *psy_tbl;
	DB_STATUS	    status;

	cb->pss_resrng = $1;

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;

	/*
	** unless the object is a catalog and the user has CATUPD, the following
	** must be true:
	**   - current user must be the DBA and
	**   - object must be owned by the current user (the DBA) or must be an
	**     extended catalog
	*/

	if (!psy_permit_ok(mask, cb, &cb->pss_resrng->pss_ownname))
	{
	    i4	    err_num;

	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		DB_STATUS	    local_status;
		DB_ERROR	    e_error;

		/* Must audit CREATE PERMIT failure. */
		local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabdesc->tbl_name,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX2016_PROT_TAB_CREATE, SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
	    }

	    err_num = (MEcmp((PTR) &cb->pss_user, (PTR) &cb->pss_dba,
			     sizeof(DB_OWN_NAME))) ? 3595L : 3592L;

	    _VOID_ psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Don't allow permits on views */
	if (mask & DMT_VIEW)
	{
	    _VOID_ psf_error(3593L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Copy table id and table name to control block */
	psy_cb = (PSY_CB *) cb->pss_object;

	/* Allocate memory for a table entry */
	status = psf_malloc(cb, &cb->pss_cbstream, (i4) sizeof(PSY_TBL),
	    (PTR *) &psy_tbl, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** Copy table id, table name, and owner name in table entry.
	*/
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabid, psy_tbl->psy_tabid);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_tabname, psy_tbl->psy_tabnm);
	STRUCT_ASSIGN_MACRO(cb->pss_resrng->pss_ownname, psy_tbl->psy_owner);
	
	/* remember the object type */
	psy_tbl->psy_mask = (mask & DMT_IDX) ? PSY_OBJ_IS_INDEX
					     : PSY_OBJ_IS_TABLE;

	/*
	** Attach element to the list.
	*/
	QUinsert((QUEUE *) psy_tbl, (QUEUE *) &psy_cb->psy_tblq);

	$$ = $1;
    }
;

permtarg:          LPAREN permtlist RPAREN
	  |	   EXCLUDING LPAREN permtlist RPAREN
    {
	PSY_CB                 *psy_cb = (PSY_CB *) cb->pss_object;

	psy_cb->psy_flags |= PSY_EXCLUDE_COLUMNS;
    }
          |
;

permtlist:	    permtelm
          |	    permtlist COMMA permtelm
;

permtelm:          generic_ident
    {
	DMT_ATT_ENTRY	       *attribute;
	DB_ATT_NAME	       attname;
	i4		       err_code;
	PSY_CB		       *psy_cb;

	/* Look up the attribute number */
	STmove($1, ' ', sizeof(DB_ATT_NAME), (char *) &attname);
	attribute = pst_coldesc(cb->pss_resrng, attname.db_att_name, 
			DB_ATT_MAXNAME);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    (VOID) psf_error(2100L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 4, cb->pss_lineno, &cb->pss_lineno,
		sizeof(DB_TAB_NAME), &cb->pss_resrng->pss_tabname,
		sizeof(DB_OWN_NAME), &cb->pss_resrng->pss_ownname,
		STlength($1), $1);
	    return (E_DB_ERROR);
	}

	/* Copy the attribute number to the control block */
	psy_cb = (PSY_CB *) cb->pss_object;
	if (psy_cb->psy_numcols >= DB_MAX_COLS)
	{
	    (VOID) psf_error(2113L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_cols[psy_cb->psy_numcols++].db_att_id =
	    (i2) attribute->att_number;
    }
;

permwho:           TO NAME
    {
	PSY_CB                 *psy_cb;

	/* {@fix_me@} */	/* Check validity of user name? */
	psy_cb = (PSY_CB *) cb->pss_object;
	STmove($2, ' ', sizeof(DB_OWN_NAME), (char *) &psy_cb->psy_user);

	/* granted to a user */
	psy_cb->psy_gtype = DBGR_USER;
    }
	  |	   TO SCONST
    {
	PSY_CB          *psy_cb;
	char		*str;

	str = sconvert($2);

	/* {@fix_me@} */	/* Check validity of user name? */
	psy_cb = (PSY_CB *) cb->pss_object;
	STmove(str, ' ', sizeof(DB_OWN_NAME), (char *) &psy_cb->psy_user);

	/* granted to a user */
	psy_cb->psy_gtype = DBGR_USER;
    }
          |	    TO ALL
    {
	PSY_CB          *psy_cb = (PSY_CB *) cb->pss_object;

	/* granted to public */
	psy_cb->psy_gtype = DBGR_PUBLIC;

	/* psy_cb->psy_user has already been filled with blanks */
    }
;

permplace:         AT NAME
    {
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

#ifdef NOT_NEEDED
	/* Check validity of terminal name */
	if (!TEvalid($2))
	{
	    i4		       err_code;

	    (VOID) psf_error(3590L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STlength($2), $2);
	    return (E_DB_ERROR);
	}
#endif
	/* Copy terminal name to control block */
	STmove($2, ' ', sizeof(DB_TERM_NAME), (char *) &psy_cb->psy_terminal);
    }
          |	    AT ALL  /* Default already filled in */
          |
;

permtd:		    permtime permday
          |	    permday
          |	    permtime
          |
;

permtime:	    FROM timeofday TO timeofday
    {
	PSY_CB                 *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;
	psy_cb->psy_timbgn = $2;
	psy_cb->psy_timend = $4;
    }
;

timeofday:	    intconst COLON intconst
    {
	i4                err_code;

	/* Check validity of hours */
	if ($1 > 24 || $1 < 0)
	{
	    (VOID) psf_error(2136L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof($1), &($1));
	    return (E_DB_ERROR);
	}

	/* Check validity of minutes */
	if ($3 > 59 || $3 < 0)
	{
	    (VOID) psf_error(2137L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof($3), &($3));
	    return (E_DB_ERROR);
	}

	/* If hours are 24, make sure minutes are 0 (e.g. 24:10 illegal) */
	if ($1 == 24 && $3 != 0)
	{
	    (VOID) psf_error(2138L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof (cb->pss_lineno), &cb->pss_lineno,
		sizeof($3), &($3));
	    return (E_DB_ERROR);
	}

	$$ = ($1 * 60) + $3;
    }
;

permday:           ON NAME TO NAME
    {
	PSY_CB                 *psy_cb;
	i4		       err_code;
	i4		       daynum;

	psy_cb = (PSY_CB *) cb->pss_object;

	/* Convert beginning day of week string to number */
	daynum = psq_cvtdow($2);
	if (daynum < 0)
	{
	    (VOID) psf_error(3594L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(DB_TAB_NAME),
		&cb->pss_resrng->pss_tabname, STlength($2), $2);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_daybgn = daynum;

	/* Convert ending day of week string to number */
	daynum = psq_cvtdow($4);
	if (daynum < 0)
	{
	    (VOID) psf_error(3594L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(DB_TAB_NAME),
		&cb->pss_resrng->pss_tabname, STlength($4), $4);
	    return (E_DB_ERROR);
	}
	psy_cb->psy_dayend = daynum;
    }
;

query:             query_key dmlstmt
    {
	i4	    save_qry_mode = psq_cb->psq_mode;

	psq_cb->psq_mode = PSQ_DEFQRY;

	/*
	** Added code to support shareable QUEL repeat queries.
	** NOTE: 5.0-style repeat queries will not be shared
	*/
	if (cb->pss_defqry == PSQ_DEFQRY && $Yqp_shareable)
	{
	    DB_STATUS		    status;
	    DB_SHR_RPTQRY_INFO	    *qry_info;

	    /* allocate memory for DB_SHR_RPTQRY_INFO structure */
	    status = psf_malloc(cb, &cb->pss_ostream,
		(i4) sizeof(DB_SHR_RPTQRY_INFO), (PTR *) &qry_info,
		&psq_cb->psq_error);
	    if (DB_FAILURE_MACRO(status))
		return (status);

	    /*
	    ** first collect information for this repeat query which would
	    ** enable us to effectively determine if an existing query plan can
	    ** indeed be shared.
	    */

	    /*
	    ** put text the repeat query acumulated so far into a contiguous
	    ** block of memory
	    */
	    status = psq_1rptqry_out(cb, cb->pss_tchain, &cb->pss_ostream,
		&qry_info->db_qry_len, &qry_info->db_qry, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }

	    /* build a list of table ids of tables used in the query */

	    status = psl_rptqry_tblids(cb, &cb->pss_usrrange, &cb->pss_ostream,
		save_qry_mode, &qry_info->db_num_tblids,
		&qry_info->db_tblids, &psq_cb->psq_error);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }    

	    /*
	    ** Note that psl_repeat_qry_id() may change psq_cb->psq_mode to
	    ** PSQ_QRYDEFED if the QEP is already in memory
	    */
	    status = psl_repeat_qry_id(psq_cb, cb, &$Yfe_cursor_id, $2,
		qry_info);

	    if (DB_FAILURE_MACRO(status))
	    {
		return(status);
	    }
	}

	cb->pss_defqry = PSQ_DEFQRY;
    }
;

dmlstmt:	    append
    {
	$$ = $1;
    }
          |	    delete
    {
	$$ = $1;
    }
          |	    replace
    {
	$$ = $1;
    }
          |
    {
	$Ycheck_for_vlups = TRUE;
    }
		    retrieve
    {
	$$ = $2;
    }
;

/*
** When we move to sharing queries, we need to check for duplicate query
** names. Right now, we will redefine the query each time through here.
*/

query_key:         DEFQRY NAME is
    {
	i4         val1 = 0, val2 = 0;
        char		trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

	psq_cb->psq_mode = PSQ_DEFQRY;
	cb->pss_defqry = PSQ_50DEFQRY;
	/* return the query name. The session id and name uniquely
	** identify the query.
	*/
	psq_cb->psq_cursid.db_cursor_id[0] = cb->pss_psessid;
	psq_cb->psq_cursid.db_cursor_id[1] = 0;
	STmove($2, ' ', DB_CURSOR_MAXNAME, psq_cb->psq_cursid.db_cur_name);

	if (ult_check_macro(&cb->pss_trace, 4, &val1, &val2))
	{
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"\n5.0-style QUEL repeat query cannot be shared.\n");
	}
    }
	    |	    DEFQRY QUERYID IS
    {
	DB_STATUS	status;

	psq_cb->psq_mode = PSQ_DEFQRY;
	cb->pss_defqry = PSQ_DEFQRY;

	/* For shared QEP's save the original FE id. */
	STRUCT_ASSIGN_MACRO(*($2), $Yfe_cursor_id);

	/* 
	** Hand cursor id back to caller. PSF fills in a part of cursor id.
	** The part consists of two i4's. The only requirement here is that
	** they be unique. So we use pss_sessid which is always unique and
	** a counter (pss_crsid) within each session. We used TMnow before
	** but it turns out that the granularity of the system clock is not
	** good enough to make the timestamp unique.
	*/
	STRUCT_ASSIGN_MACRO(*($2), psq_cb->psq_cursid);
	psq_cb->psq_cursid.db_cursor_id[0] = (i4) cb->pss_psessid;
	psq_cb->psq_cursid.db_cursor_id[1] = (i4) ++cb->pss_crsid;

	/*
	** Determining if a quel repeat query is shareable requires that its
	** text be stored along with the range table
	*/
	cb->pss_stmt_flags |= PSS_QUEL_RPTQRY_TEXT;

	/* open the text chain */
	status = psq_topen(&cb->pss_tchain, &cb->pss_memleft,
	    &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

range:		    rngstmt OF rngclause
          |	    rngstmt rngclause
;

rngclause:	    rngclause COMMA rngelm
          |	    rngelm
;

rngelm:            NAME is NAME
    {
	i4		    rngvar_info;
	DB_STATUS           status;
	PSS_RNGTAB	    *resrange;
	DB_TAB_NAME	    tabname;

	STmove($3, ' ', sizeof(tabname), (char *) &tabname);
	status = psl_rngent(&cb->pss_usrrange, -1, $1, &tabname, cb,
	    TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info, NULL);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
	|	    NAME ISNULL
    {
	DB_STATUS           status;
	i4		    rngvar_info;
	PSS_RNGTAB	    *resrange;
	DB_TAB_NAME	    tabname;

	/* takes care of a case where table name happens to be "null" */
	STmove("null", ' ', sizeof(tabname), (char *) &tabname);
	status = psl_rngent(&cb->pss_usrrange, -1, $1, &tabname, cb,
	    TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info, NULL);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
	|           NAME is nonkeyword PERIOD NAME
    {
	i4		    rngvar_info;
	i4		    err_code;
	DB_STATUS           status;
	PSS_RNGTAB	    *resrange;
	DB_TAB_NAME	    tabname;
	DB_OWN_NAME	    sessname;

	if (STcasecmp($3, "session"))
	{
	    (VOID) psf_error(5153, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) $3), $3);
	    return (E_DB_ERROR);
	}
	STmove($5, ' ', sizeof(tabname), (char *) &tabname);
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, sessname);
	status = psl_orngent(&cb->pss_usrrange, -1, $1, &sessname, &tabname, 
	    cb, TRUE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info);
	if (status != E_DB_OK)
	{
	    return (status);
	}
    }
;

rngstmt:           RANGE
    {
	psq_cb->psq_mode = PSQ_RANGE;
    }
;

relocate:          RELOCATE NAME TO NAME
    {
	i4             err_code;
	i4		    err_num = 0L;
	bool		    must_audit = FALSE;
	DB_STATUS	    status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMU_CB		    *dmu_cb;
	DB_TAB_NAME	    tabname;
	PSS_RNGTAB	    *resrange;
	bool		    leave_loop = TRUE;

	psq_cb->psq_mode = PSQ_RELOCATE;

	/* Allocate QEU_CB for RELOCATE and initialize its header */
	status = psl_qeucb(cb, DMU_RELOCATE_TABLE, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMU control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMU_CB),
	    (PTR *) &dmu_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	MEfill(sizeof(DMU_CB), '\0', dmu_cb);
	qeu_cb->qeu_d_cb = (PTR) dmu_cb;

	/* Fill in the DMU control block header */
	dmu_cb->type = DMU_UTILITY_CB;
	dmu_cb->length = sizeof(DMU_CB);
	dmu_cb->dmu_flags_mask = 0;
	dmu_cb->dmu_db_id = (char*) cb->pss_dbid;

	/* Look up the table to be relocated */
	STmove($2, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb,
	    FALSE, &resrange, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info, NULL);
	if (status != E_DB_OK)
	    return (status);

	dmu_cb->dmu_nphys_parts = resrange->pss_tabdesc->tbl_nparts;

	do	    /* something to break out of */
	{
	    /*
	    ** If table resides in multiple locations MODIFY RELOCATE
	    ** must be used.
	    */
	    if (resrange->pss_tabdesc->tbl_status_mask & DMT_MULTIPLE_LOC)
	    {
		err_num = 6207L;
		break;
	    }

	    cb->pss_resrng = resrange;

	    /* Put it in the control block */
	    STRUCT_ASSIGN_MACRO(resrange->pss_tabid, dmu_cb->dmu_tbl_id);

	    /*
	    ** Allocate 1 location entry (`RELOCATE' is not supposed to handle
	    ** multiple locations - this is done by `MODIFY'.
	    */
	    status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_LOC_NAME),
		(PTR *) &dmu_cb->dmu_location.data_address, &psq_cb->psq_error);
	    if (status != E_DB_OK)
		return (status);

	    /* Store the new location name in the control block */
	    STmove($4, ' ', sizeof(DB_LOC_NAME),
		(char *) dmu_cb->dmu_location.data_address);
	    dmu_cb->dmu_location.data_in_size = sizeof(DB_LOC_NAME);

	    /* Indicate no old locations. */
	    dmu_cb->dmu_olocation.data_in_size = 0;

	    /* Don't allow relocation of someone else's table */
	    if (MEcmp((char *) &resrange->pss_ownname,
		(char *) &cb->pss_user, sizeof(DB_OWN_NAME)))
	    {
		must_audit = TRUE;
		err_num    = 6204L;
	    }

	    /* Don't allow relocation of views */
	    else if (resrange->pss_tabdesc->tbl_status_mask & DMT_VIEW)
	    {
		err_num = 6205L;
	    }
	    
	    /* leave_loop has already been set to TRUE */
	} while (!leave_loop);

	if (err_num != 0L)
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE && must_audit )
	    {
		/* Must audit RELOCATE failure. */
		DB_STATUS   local_status;
		DB_ERROR    e_error;
		
	    	local_status = psy_secaudit(FALSE, cb,
	    		(char *)&resrange->pss_tabdesc->tbl_name,
			&resrange->pss_tabdesc->tbl_owner,
	    		sizeof(DB_TAB_NAME), SXF_E_TABLE,
	      		I_SX2026_TABLE_ACCESS, SXF_A_FAIL | SXF_A_RELOCATE,
	      		&e_error);
	    }

	    (VOID) psf_error(err_num, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &resrange->pss_tabname),
		&resrange->pss_tabname);
	    return (E_DB_ERROR);
	}
    }
;

replace:           repstmnt repvar tlclause qualclause
    {
	PST_QNODE              *tidnode;
	PST_VAR_NODE	       tidvar;
	PST_QNODE	       *rsdmnode;
	PST_RSDM_NODE	       resdom;
	PST_QNODE	       *rootnode;
	PST_RT_NODE	       root;
	PST_QTREE	       *tree;
	DB_STATUS	       status;
	i4		       err_code;
	i4		       mask;
	i4		       mask2;
	i4		       qrymod_resp_mask;
	PST_PROCEDURE	       *pnode;
	i4                mask3;

	/* Set up a var. node representing the tid */
	tidvar.pst_vno = $2->pss_rgno;
	tidvar.pst_atno.db_att_id = 0;	    /* tid is always column 0 */
	STmove(((*cb->pss_dbxlate & CUI_ID_REG_U) ? "TID" : "tid"),
	       ' ', DB_ATT_MAXNAME, tidvar.pst_atname.db_att_name);

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &tidvar, sizeof(tidvar),
	    DB_TID_TYPE, (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL,
	    &tidnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	    /* non-zero return means error */
	}

	/* Set up a resdom result domain representing a tid. */
	resdom.pst_rsno = cb->pss_rsdmno++; /* Count resdoms */
	resdom.pst_ntargno = resdom.pst_rsno;
	resdom.pst_ttargtype = PST_ATTNO;
	resdom.pst_rsupdt = FALSE;
	resdom.pst_rsflags = 0; /* no PST_RS_PRINT */

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    tidnode, PST_RESDOM, (PTR) &resdom, sizeof(resdom), DB_TID_TYPE,
	    (i2) 0, (i4) DB_TID8_LENGTH, (DB_ANYTYPE *) NULL, &rsdmnode,
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* prepend the tid node to the target list */
	(VOID) pst_tlprpnd(rsdmnode, $3);

	/* Make the root node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;

	status = pst_node(cb, &cb->pss_ostream, $3, $4, PST_ROOT,
	    (PTR) &root, sizeof(PST_RT_NODE), DB_INT_TYPE, (i2) 0, (i4) 4,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);	/* non-zero return means error */
	}

	/* Now check the target list to see if there are any
	** resdoms with pst_ttargtype of PST_USER, if so
	** convert them to PST_ATTNO.
	*/
	for (rsdmnode = rootnode->pst_left;
	 rsdmnode != (PST_QNODE *) NULL && 
	 rsdmnode->pst_sym.pst_type == PST_RESDOM;
	 rsdmnode = rsdmnode->pst_left)
	{
	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		== PST_USER)
	    {
		rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		    = PST_ATTNO;
	    }
	}

	if (cb->pss_defqry == PSQ_DEFQRY)
	{
	    /*
	    ** now call psl_shareable() to determine if the query satisfies SQL
	    ** definition of shareability (i.e. all tables used in the query are
	    ** catalogs or are owned by the DBA; QUEL user cannot explicitly
	    ** qualify them with an owner name)
	    */
	    status = psl_shareable(psq_cb, cb, &$Yqp_shareable, &$Yshr_qryinfo);
	    if (DB_FAILURE_MACRO(status))
		return(status);
	}

	/* Apply the qrymod algorithm (views, permits, integrities) */
	status = psy_qrymod(rootnode, cb, psq_cb, &$Yjoin_id,
	    &qrymod_resp_mask);
	if (status != E_DB_OK)
	    return (status);

	/*
	** if this is a repeat query and it is shareable according to SQL
	** definition of shareability, apply QUEL-specific checking
	*/
	if (cb->pss_defqry == PSQ_DEFQRY && $Yqp_shareable)
	{
	    psl_quel_shareable(cb, $Yqry_mask, &$Yqp_shareable);
	}

	mask = cb->pss_resrng->pss_tabdesc->tbl_status_mask;
	mask2 = cb->pss_resrng->pss_tabdesc->tbl_2_status_mask;

	/* Make sure base table is updateable;
	** In case of an index or a non-extended catalog,
	** catalog update privilege must be on.
	** In case of security catalog session must have security 
	** privilege active.
	** Bug 34079, since 6.0 you were never supposed to be 
        ** able to update a secondary index.  Fixed it so 
        ** the same error is returned whether you have update 
        ** syscat or not (jennifer)
	**
	** if PSS_REPAIR_SYSCAT and PSS_CATUPD are set in cb->pss_ses_flag,
	** allow REPLACE on indexes which are non-extended catalogs
	*/
	if (mask & DMT_IDX)
	{
	    if (!(   mask & DMT_CATALOG && ~mask & DMT_EXTENDED_CAT
	          && cb->pss_ses_flag & PSS_CATUPD
		  && cb->pss_ses_flag & PSS_REPAIR_SYSCAT
		 )
	       )
	    {
		_VOID_ psf_error(2106L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1,
		    psf_trmwhite(sizeof(DB_TAB_NAME),
			(char *) &cb->pss_resrng->pss_tabname),
		    &cb->pss_resrng->pss_tabname);
		return(E_DB_ERROR);
	    }
	}
	else if ( ( (mask & DMT_CATALOG || mask2 & DMT_TEXTENSION)
		 && ~mask & DMT_EXTENDED_CAT
		 && !(cb->pss_ses_flag & PSS_CATUPD))
	     ||
	        ((mask & DMT_SECURE) &&
	         !(cb->pss_ustat & DU_USECURITY)))
	{
		i4 local_status;
		DB_ERROR	    e_error;

		if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
		{
		    local_status = psy_secaudit(FALSE, cb,
			    (char *)&cb->pss_resrng->pss_tabname,
			    &cb->pss_resrng->pss_tabdesc->tbl_owner,
			    sizeof(DB_TAB_NAME), 
			    SXF_E_TABLE,
			    I_SX2020_PROT_REJECT, 
			    SXF_A_FAIL|SXF_A_UPDATE, 
			    &e_error);

		    if (local_status > status)
			status = local_status;
		}

		/* process security_alarms */
		local_status = psy_do_alarm_fail(cb, 
				cb->pss_resrng, PSQ_REPLACE, &e_error);
		if (local_status > status)
		    status = local_status;
	    _VOID_ psf_error(2107L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &cb->pss_resrng->pss_tabname),
		&cb->pss_resrng->pss_tabname);
	    return (E_DB_ERROR);
	}

	mask3=PST_0FULL_HEADER,

	/* Make the header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, mask3, (PSS_Q_XLATE *) NULL);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;

	/* Fix the root in QSF */
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = tree;
    }
;

repstmnt:          REPLACE
    {
	DB_STATUS              status;

	psq_cb->psq_mode = PSQ_REPLACE;

	/* Open memory stream for allocating query tree */
	if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);    /* non-zero return means error */
	}
    }
;

repvar:	    var
    {
	i4	err_code;

	/* Updates on secondary index tables that are btrees
	** are not allowed.
	*/
	if ($1->pss_tabdesc->tbl_status_mask & DMT_IDX
	    &&
	    $1->pss_tabdesc->tbl_storage_type == DMT_BTREE_TYPE
	   )
	{
	    (VOID) psf_error(2124L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2,
		sizeof(cb->pss_lineno), &cb->pss_lineno,
		psf_trmwhite(sizeof(DB_TAB_NAME), (char *) &$1->pss_tabname),
		&$1->pss_tabname);
	    return(E_DB_ERROR);	    
	}

	/*
	** On a replace, remember what the result range variable is.
	** This can't be stored in the result range variable slot in
	** the user range table, because that is not for "real" range
	** variables, only for result tables (as in an append).
	*/
	cb->pss_resrng = $1;
	$$ = $1;
    }
	|           nonkeyword PERIOD NAME
    {
	i4		    rngvar_info;
	i4		    err_code;
	DB_STATUS           status;
	PSS_RNGTAB	    *rngtab;
	DB_TAB_NAME	    tabname;
	DB_OWN_NAME	    sessname;

	if (STcasecmp($1, "session"))
	{
	    (VOID) psf_error(5153, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_OWN_NAME), 
		    (char *) $1), $1);
	    return (E_DB_ERROR);
	}
	STmove($3, ' ', sizeof(tabname), (char *) &tabname);
	STRUCT_ASSIGN_MACRO(cb->pss_sess_owner, sessname);
	status = psl_orngent(&cb->pss_usrrange, -1, $1, &sessname, &tabname, 
	    cb, FALSE, &rngtab, psq_cb->psq_mode, &psq_cb->psq_error,
	    &rngvar_info);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** On a replace, remember what the result range variable is.
	** This can't be stored in the result range variable slot in
	** the user range table, because that is not for "real" range
	** variables, only for result tables (as in an append).
	*/
	cb->pss_resrng = rngtab;
	$$ = rngtab;
    }
;

replcursor:	    replcursorstmnt tlclause
    {
	DB_STATUS              status;
	PST_RT_NODE	       root;
	PST_QNODE	       *rootnode, *rsdmnode;
	PST_QTREE	       *tree;
	i4		       err_code;
	i4		       qrymod_resp_mask;
	PST_PROCEDURE	       *pnode;

	/* make sure that no range vars were used in the target list */
	if (cb->pss_usrrange.pss_maxrng != -1)
	{
	    (VOID) psf_error(2212L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);
	}
	/* Allocate root node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;

	status = pst_node(cb, &cb->pss_ostream, $2, (PST_QNODE *) NULL,
	    PST_ROOT, (PTR) &root, sizeof(root), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &rootnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* Now check the target list to see if there are any
	** resdoms with pst_ttargtype of PST_USER, if so
	** convert them to PST_ATTNO.
	*/
	for (rsdmnode = rootnode->pst_left;
	 rsdmnode != (PST_QNODE *) NULL && 
	 rsdmnode->pst_sym.pst_type == PST_RESDOM;
	 rsdmnode = rsdmnode->pst_left)
	{
	    if (rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		== PST_USER)
	    {
		rsdmnode->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		    = PST_ATTNO;
	    }
	}

	status = psy_qrymod(rootnode, cb, psq_cb, &$Yjoin_id,
	    &qrymod_resp_mask);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** if processing REPLACE CURSOR, we delayed replacing PST_VAR with
	** PST_CURVAL until now to make life easier for psy_view()
	*/
	for (rsdmnode = rootnode->pst_left;
	     rsdmnode != (PST_QNODE *) NULL &&
		rsdmnode->pst_sym.pst_type == PST_RESDOM;
	     rsdmnode = rsdmnode->pst_left)
	{
	    status = psl_curval(cb, psq_cb, cb->pss_crsr, &rsdmnode->pst_right);
	    if (DB_FAILURE_MACRO(status))
	    {
		return (status);
	    }
	}

	/* Generate query tree header */
	status = pst_header(cb, psq_cb, PST_UNSPECIFIED, (PST_QNODE *) NULL,
	    rootnode, &tree, &pnode, PST_0FULL_HEADER, (PSS_Q_XLATE *) NULL);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;

	/* Fix the root in QSF */
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

replcursorstmnt:   REPCURSOR QUERYID
    {
	PSC_CURBLK          *cursor;
	DB_STATUS	    status;
	i4		    err_code;
	i4		    rngvar_info;

	psq_cb->psq_mode = PSQ_REPCURS;

	/* Look up the cursor */
	status = psq_crfind(cb, $2, &cursor, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, DB_CURSOR_MAXNAME, $2->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Check if cursor updateable */
	if (cursor->psc_forupd == FALSE)
	{
	    (VOID) psf_error(2217L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		psf_trmwhite(DB_CURSOR_MAXNAME, cursor->psc_blkid.db_cur_name),
		cursor->psc_blkid.db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Open memory stream in QSF for query tree */
	status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/*
	** obtain description of the table over which the cursor was defined and
	** make cb->pss_resrng point at it - will come in real handy when  we
	** encounter column references on the RHS of assignment + in
	** psy_view(), psy_protect(), and psy_rules() 
	*/
	status = psl_orngent(&cb->pss_auxrng, -1, "!",
	    &cursor->psc_ownnm, &cursor->psc_tabnm,
	    cb, FALSE, &cb->pss_resrng, psq_cb->psq_mode,
	    &psq_cb->psq_error, &rngvar_info);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Hand cursor id back to caller */
	STRUCT_ASSIGN_MACRO(*($2), psq_cb->psq_cursid);
    }
;

retcursor:	    RETCURSOR QUERYID
    {
	PSC_CURBLK             *cursor;
	DB_STATUS	       status;
	i4		       err_code;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_RETCURS;

	/* Look up the cursor */
	status = psq_crfind(cb, $2, &cursor, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Complain if not found */
	if (cursor == (PSC_CURBLK *) NULL || cursor->psc_open == FALSE)
	{
	    (VOID) psf_error(2205L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, DB_CURSOR_MAXNAME, $2->db_cur_name);
	    return (E_DB_ERROR);
	}

	/* Hand the cursor id back to the caller */
	STRUCT_ASSIGN_MACRO(*($2), psq_cb->psq_cursid);

	/* Allocate the QEF control block for fetch cursor */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
    }
;

retrieve:   retstmnt intoclause uniqueclause tlclause
	    qualclause sortclause retwithcls
    {
	DB_STATUS       status, local_status;
	DB_ERROR	e_error;
	PST_QNODE	*rootnode;
	PST_QNODE	*ssnode;
	PST_RESKEY	*reskey;
	PST_RT_NODE	root;
	PST_QTREE	*tree;
	i2		dup_val;
	i4		err_code;
	i4		error = 0;
	char		*withentry;
	PST_PROCEDURE   *pnode;
	PST_QNODE	*resdom;
	bool		 found;
	char		obj_name[sizeof(DB_TAB_NAME)];
 
	/* Verify CREATE_TABLE privileges for RETRIEVE INTO*/
	
	if ((psq_cb->psq_mode == PSQ_RETINTO) &&
	    ((status = psy_ckdbpr(psq_cb, (u_i4)DBPR_TAB_CREATE))
		    != E_DB_OK)
	   )
	{
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		STmove(yacc_cb->yypvt[-0].psl_strtype, 
		       ' ', sizeof(DB_TAB_NAME), 
		       obj_name);
		
		local_status = psy_secaudit(FALSE, cb,
			    obj_name,
			    &cb->pss_user,
			    sizeof(DB_TAB_NAME), SXF_E_TABLE,
			    I_SX201E_TABLE_CREATE, SXF_A_FAIL | SXF_A_CONTROL,
			    &e_error);
	    }

	    (VOID) psf_error(6245L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (status);
	}

	/* Make sure there is a location in case of a RETRIEVE INTO. */
	if ((psq_cb->psq_mode == PSQ_RETINTO) &&
	    !cb->pss_restab.pst_resloc.data_in_size
	   )
	{
	    /* Default location */
	    STmove("$default", ' ', sizeof(DB_LOC_NAME),
		(char *) cb->pss_restab.pst_resloc.data_address);
	    cb->pss_restab.pst_resloc.data_in_size = sizeof(DB_LOC_NAME);
	}

	/* Make the root node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;

	/* with_dups is set in retwithcls to establish duplicate characteristics
	** for retrieve into statements (this initial value may be altered
	** below.
	*/
	root.pst_dups   = $Ywith_dups;

	status = pst_node(cb, &cb->pss_ostream, $4, $5, PST_ROOT, (PTR) &root,
	    sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &rootnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	if (psq_cb->psq_mode == PSQ_RETINTO)
	{
	    PST_QNODE	    *res2;
	    PSS_RNGTAB	    *rngtabp;
	    DMT_ATT_ENTRY   *attribute;
	    char	    *name;

	    for (resdom = rootnode->pst_left;
	     resdom != (PST_QNODE *) NULL && 
	     resdom->pst_sym.pst_type == PST_RESDOM;
	     resdom = resdom->pst_left)
	    {
		/* Now check the target list to see if there are any
		** resdoms with pst_ttargtype of PST_USER, if so
		** convert them to PST_ATTNO.
		*/
		if (resdom->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
		    == PST_USER)
		{
		    resdom->pst_sym.pst_value.pst_s_rsdm.pst_ttargtype
			= PST_ATTNO;
		}

		/* check for duplicate names */
		for (res2 = resdom->pst_left; res2 != (PST_QNODE*) NULL && 
		    res2->pst_sym.pst_type == PST_RESDOM; res2 = res2->pst_left)
		{
		    if (!MEcmp(resdom->pst_sym.pst_value.pst_s_rsdm.pst_rsname, 
			res2->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
			DB_ATT_MAXNAME))
		    {
			(VOID) psf_error(5105L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2, 
			    sizeof(cb->pss_restab.pst_resname),
			    (char*)&cb->pss_restab.pst_resname,
		    sizeof(resdom->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
		    (char*)resdom->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
			    return (E_DB_ERROR);
			
		    }
		}

		/* To avoid creation of columns of LONG TEXT type in case of
		** retrieve into tab (col = NULL) following check is performed.
		*/
		if ((resdom->pst_right->pst_sym.pst_type == PST_CONST) &&
		    (abs(resdom->pst_right->pst_sym.pst_dataval.db_datatype)
							    == DB_LTXT_TYPE))
		{
		    (VOID) psf_error(2142L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}

		/*
		** Set up defaultability.
		**
		** If the resdom is based directly on a column
		** (i.e. is a PST_VAR), we copy that column's default value;
		** otherwise the resdom must be based on a calculated column or
		** expression, so set up the 'default' QUEL default.
		*/
		if (resdom->pst_right->pst_sym.pst_type != PST_VAR)
		{
		    /* resdom based on expression--use the 'default'
		    ** QUEL default:
		    **     unspecified (null)  for nullable columns
		    **     WITH DEFAULT        for non-nullable columns
		    */ 
		    DB_DATA_VALUE  *dbdata;
		    DMF_ATTR_ENTRY attr;

		    dbdata = &resdom->pst_right->pst_sym.pst_dataval;
		    
		    if (dbdata->db_datatype < 0)
		    {
			/* datatype is nullable;
			** use unspecified default (which is null)
			*/
			SET_CANON_DEF_ID(
				resdom->pst_sym.pst_value.pst_s_rsdm.pst_defid, 
				DB_DEF_NOT_SPECIFIED);
		    }
		    else
		    {
			/* datatype is non-nullable;
			** set up attribute descriptor and get ingres default
			** id for this tuple
			*/
			MEfill(sizeof(attr), 0, (PTR) &attr);
	
			attr.attr_type      = dbdata->db_datatype;
			attr.attr_size      = dbdata->db_length;
			attr.attr_precision = dbdata->db_prec;
			
			status = psl_2col_ingres_default(cb, &attr, 
							 &psq_cb->psq_error);
			if (DB_FAILURE_MACRO(status))
			    return(status);
			
			COPY_DEFAULT_ID(attr.attr_defaultID,
			       resdom->pst_sym.pst_value.pst_s_rsdm.pst_defid);
		    }  /* end else non-nullable datatype */
		}  
		else	/* resdom is based on a column of underlying table */
		{
		    name = resdom->pst_sym.pst_value.pst_s_rsdm.pst_rsname;

		    /* find range table entry 
		     */
		    status = pst_rgfind(
					&cb->pss_usrrange, &rngtabp,
					resdom->pst_right->pst_sym
						.pst_value.pst_s_var.pst_vno,
					&psq_cb->psq_error);
		    if (status != E_DB_OK)
		    {
			(VOID) psf_error(E_PS0909_NO_RANGE_ENTRY, 
					 0L, PSF_INTERR,
					 &err_code, &psq_cb->psq_error, 1,
					 psf_trmwhite(DB_ATT_MAXNAME, name), name);
			return (E_DB_ERROR);
		    }

		    /* Look up the attribute 
		     */
		    attribute = pst_coldesc(rngtabp,
			resdom->pst_right->pst_sym.pst_value.pst_s_var.pst_atname.db_att_name,
			DB_ATT_MAXNAME);

		    /* Check for attribute not found 
		     */
		    if (attribute == (DMT_ATT_ENTRY *) NULL)
		    {
			(VOID) psf_error(E_PS090A_NO_ATTR_ENTRY, 0L, PSF_INTERR,
					 &err_code, &psq_cb->psq_error, 1,
					 psf_trmwhite(DB_ATT_MAXNAME, name), name);
			return (E_DB_ERROR);
		    }
		    COPY_DEFAULT_ID(attribute->att_defaultID,
				resdom->pst_sym.pst_value.pst_s_rsdm.pst_defid);
	    
		} /* end else resdom is based on a column of underlying table */

	    }  /* end for resdom->pst_sym.pst_type == PST_RESDOM */

	    /* min or max pages requires hashed relation
	    ** data fillfactor can't use heap.
	    ** leaffill and index fill require btree.
	    */
	    if ((cb->pss_restab.pst_minpgs > 0) &&
		(cb->pss_restab.pst_struct != DB_HASH_STORE))
	    {
		error++;
		withentry = "MINPAGES";
	    }
	    else if ((cb->pss_restab.pst_maxpgs > 0) &&
		(cb->pss_restab.pst_struct != DB_HASH_STORE))
	    {
		error++;
		withentry = "MAXPAGES";
	    }
	    else if ((cb->pss_restab.pst_fillfac > 0) && 
		 (cb->pss_restab.pst_struct == DB_HEAP_STORE))
	    {
		error++;
		withentry = "FILLFACTOR";
	    }
	    else if ((cb->pss_restab.pst_leaff > 0) &&
		(cb->pss_restab.pst_struct != DB_BTRE_STORE))
	    {
		error++;
		withentry = "LEAFFILL or INDEXFILL";
	    }
	    else if ((cb->pss_restab.pst_nonleaff > 0) &&
		(cb->pss_restab.pst_struct != DB_BTRE_STORE))
	    {
		error++;
		withentry = "NONLEAFFILL";
	    }
	    else if ((cb->pss_restab.pst_reskey != NULL) &&
		(cb->pss_restab.pst_struct == DB_HEAP_STORE))
	    {
		error++;
		withentry = "KEY";
	    }

	    if (error)
	    {
		(VOID) psf_error(2152L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1,
		    (i4) STlength(withentry), withentry);
		return (E_DB_ERROR);
	    }
	}
	else if ($Ycheck_for_vlups)
	{
	    /* we need to check for VLUPs in the target list of RETRIEVE */
	    for (resdom = rootnode->pst_left;
	         resdom != (PST_QNODE *) NULL && 
		 resdom->pst_sym.pst_type == PST_RESDOM;
		 resdom = resdom->pst_left)
	    {
		if (resdom->pst_sym.pst_dataval.db_length == ADE_LEN_UNKNOWN)
		{
		    /* We have found a VLUP that will cause an AV.
		    ** Flag it for now.
		    */
		    (VOID) psf_error(2218L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}
	    }
	}

	/*
	** Check whether KEY clause has been specified, if so validate it.
	*/
	if (cb->pss_restab.pst_reskey != (PST_RESKEY *) NULL)
	{
	    for (reskey = cb->pss_restab.pst_reskey, found = FALSE;
		 reskey;
		 reskey = reskey->pst_nxtkey)
	    {
                for (ssnode = rootnode->pst_left;
                     ssnode->pst_sym.pst_type != PST_TREE;
                     ssnode = ssnode->pst_left
                    )
                {
                    /* compare domain names */
                    if (MEcmp((PTR) &reskey->pst_attname,
                        (PTR) ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname,
                         sizeof (reskey->pst_attname)) == 0)
                    {
                        found++;
                        break;
                    }
                }
                if (found == FALSE)
                {   /* bogus column name */
                    (VOID) psf_error(4611L, 0L, PSF_USERERR, &err_code,
                        &psq_cb->psq_error, 0);
                    return (E_DB_ERROR);
                }
		status = psl_check_key(cb, &psq_cb->psq_error,
			    (DB_DT_ID) ssnode->pst_sym.pst_dataval.db_datatype);
		if (status)
		{
		    (VOID) psf_error(2179L, 0L, PSF_USERERR, &err_code,
			&psq_cb->psq_error, 2,
			sizeof(cb->pss_lineno), &cb->pss_lineno,
			psf_trmwhite(sizeof(DB_ATT_NAME),
			    (char*) &reskey->pst_attname),
			(char *) &reskey->pst_attname);
			return (E_DB_ERROR);
		}
	    }
	}
	else if (cb->pss_restab.pst_struct &&
		    (cb->pss_restab.pst_struct != DB_HEAP_STORE))
	{
	    /* Must check that implicit key is keyable */

	    /* First, find it */
	    
	    for (ssnode = rootnode->pst_left;
		 ssnode->pst_sym.pst_type != PST_TREE;
		 ssnode = ssnode->pst_left
		)
	    {
		if (	(ssnode->pst_sym.pst_type == PST_RESDOM)
		    &&	(ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsno == 1))
		{
		    status = psl_check_key(cb, &psq_cb->psq_error,
				(DB_DT_ID) ssnode->pst_sym.pst_dataval.db_datatype);
		    if (status)
		    {
			(VOID) psf_error(2179L, 0L, PSF_USERERR, &err_code,
			    &psq_cb->psq_error, 2,
			    sizeof(cb->pss_lineno), &cb->pss_lineno,
			    psf_trmwhite(sizeof(DB_ATT_NAME),
				(char*) &ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname),
			    (char *) &ssnode->pst_sym.pst_value.pst_s_rsdm.pst_rsname);
			    return (E_DB_ERROR);
		    }
		    break;
		}
	    }
	}

	/* No result range variable on a retrieve */
	cb->pss_resrng = (PSS_RNGTAB *) NULL;

	/*
	** Apply the qrymod algorithm (views, permits, and integrities).
	** If the query mode isn't PSQ_RETRIEVE, this must be a cursor
	** statement, in which case we want to defer qrymod until we know
	** which columns are for update.
	*/
	if (psq_cb->psq_mode == PSQ_RETRIEVE ||
	    psq_cb->psq_mode == PSQ_RETINTO)
	{
	    i4		qrymod_resp_mask;

	    if (cb->pss_defqry == PSQ_DEFQRY)
	    {
		/*
		** now call psl_shareable() to determine if the query satisfies
		** SQL definition of shareability (i.e. all tables used in the
		** query are catalogs or are owned by the DBA; QUEL user cannot
		** explicitly qualify them with an owner name)
		*/
		status = psl_shareable(psq_cb, cb, &$Yqp_shareable,
		    &$Yshr_qryinfo);
		if (DB_FAILURE_MACRO(status))
		    return(status);
	    }

	    status = psy_qrymod(rootnode, cb, psq_cb, &$Yjoin_id,
		&qrymod_resp_mask);
	    if (status != E_DB_OK)
		return (status);

	    /*
	    ** if this is a repeat query and it is shareable according to SQL
	    ** definition of shareability, apply QUEL-specific checking
	    */
	    if (cb->pss_defqry == PSQ_DEFQRY && $Yqp_shareable)
	    {
		psl_quel_shareable(cb, $Yqry_mask, &$Yqp_shareable);
	    }
	}

        /* Make and fill in the query tree header */
        status = pst_header(cb, psq_cb, PST_UNSPECIFIED, $6, rootnode,
	    &tree, &pnode, PST_0FULL_HEADER, (PSS_Q_XLATE *) NULL);
    	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Make sure the procedure gets updated later if cursor. */
	if (psq_cb->psq_mode == PSQ_RETRIEVE ||
	    psq_cb->psq_mode == PSQ_RETINTO)
	{
	    psq_cb->psq_pnode = (PTR)NULL;
	}
	else 
	    psq_cb->psq_pnode = (PTR)pnode;

	/* Tell whether retrieve unique */
	if ($3 == TRUE || $Ysort_by)
	    dup_val = PST_NODUPS;
	else if ($Ywith_dups == PST_DNTCAREDUPS)
	    dup_val = PST_ALLDUPS;
	else
	    dup_val = $Ywith_dups;
	
	for (;rootnode; rootnode = rootnode->
	     pst_sym.pst_value.pst_s_root.pst_union.pst_next
	    )
	{
	    rootnode->pst_sym.pst_value.pst_s_root.pst_dups = dup_val;
	}
	    
        $$ = tree;

	/* set pst_numjoins.  $Yjoin_id contains the highest join id */
	tree->pst_numjoins = $Yjoin_id;

	/* Fix the root in QSF */
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) pnode, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
	    return (status);
    }
;

retstmnt:          RETRIEVE
    {
	DB_STATUS              status;

	/* A "define cursor" statement shouldn't be changed to a retrieve */
	if (psq_cb->psq_mode != PSQ_DEFCURS)
	    psq_cb->psq_mode = PSQ_RETRIEVE;

	/* Open memory stream for allocating query tree */
	if ((status = psf_mopen(cb, QSO_QTREE_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error)) != E_DB_OK)
	{
	    return (status);    /* non-zero return means error */
	}
    }
;

intoclause:	    retkwd locationname
    {
	/* "Retrieve into" not allowed for cursors */
	if (psq_cb->psq_mode == PSQ_DEFCURS)
	{
	    i4	err_code;

	    (VOID) psf_error(2209L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		DB_CURSOR_MAXNAME, psq_cb->psq_cursid.db_cur_name);
	    return (E_DB_ERROR);
	}
	else
	{
	    $Ywith_dups = PST_DNTCAREDUPS;
	}
    }
	  |
    {
	$Ywith_dups = PST_ALLDUPS;
    }
;

uniqueclause:      UNIQUE
    {
	$$ = TRUE;
    }
	  |
    {
	$$ = FALSE; 
    }
;

retkwd:		retkwd_1
    {
	DB_STATUS	       status;

	/*
	** Allocate the location entries.  Assume DM_LOC_MAX, although it's
	** probably fewer.  This is because we don't know how many locations
	** we have at this point, and it would be a big pain to allocate
	** less and then run into problems.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, DM_LOC_MAX * sizeof(DB_LOC_NAME),
	    (PTR *) &cb->pss_restab.pst_resloc.data_address,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	cb->pss_restab.pst_resloc.data_in_size = 0; /* Start with 0 locations */

	/* processing RETRIEVE INTO */
	psq_cb->psq_mode = PSQ_RETINTO;
    }
;

retkwd_1:            INTO
          |          TO
          |
;

retwithcls:	    WITH
    {
	i4     err_code;

	/* User specified WITH clause only allowed on a RETRIEVE INTO */
	if (psq_cb->psq_mode != PSQ_RETINTO)
	{
	    (VOID) psf_error(2141L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
		    retwiths
    {
	i4	    err_code;
	i4	    minp;
	i4	    maxp;

	minp = cb->pss_restab.pst_minpgs;
	maxp = cb->pss_restab.pst_maxpgs;

	if (minp > 0 && maxp > 0 && minp > maxp)
	{
	    (VOID) psf_error(2143L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(minp), &minp);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}

	/* If user has not specified [NO]JOURNALING clause
	** session default should be used.
	*/
	if (!$Ywith_journaling && (cb->pss_ses_flag & PSS_JOURNALING))
	{
	    if (cb->pss_ses_flag & PSS_JOURNALED_DB)
		cb->pss_restab.pst_resjour = PST_RESJOUR_ON;
	    else
		cb->pss_restab.pst_resjour = PST_RESJOUR_LATER;
	}

	/* If user has NOT specified [NO]DUPLICATES clause,
	** language default should be used.
	*/
	if ($Ywith_dups == PST_DNTCAREDUPS)
	    cb->pss_restab.pst_resdup = FALSE;

    }
	  |	WITHNULL
    {
	/* User specified WITH clause only allowed on a RETRIEVE INTO */
	if (psq_cb->psq_mode != PSQ_RETINTO)
	{
	    i4     err_code;

	    (VOID) psf_error(2141L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	if (cb->pss_ses_flag & PSS_JOURNALING)
	{
	    if (cb->pss_ses_flag & PSS_JOURNALED_DB)
		cb->pss_restab.pst_resjour = PST_RESJOUR_ON;
	    else
		cb->pss_restab.pst_resjour = PST_RESJOUR_LATER;
	}

	/* If user has NOT specified [NO]DUPLICATES clause
	** language default should be used.
	*/
	cb->pss_restab.pst_resdup = FALSE;
    }
	  |
    {
	if (cb->pss_ses_flag & PSS_JOURNALING)
	{
	    if (cb->pss_ses_flag & PSS_JOURNALED_DB)
		cb->pss_restab.pst_resjour = PST_RESJOUR_ON;
	    else
		cb->pss_restab.pst_resjour = PST_RESJOUR_LATER;
	}

	/* If user has NOT specified [NO]DUPLICATES clause
	** language default should be used.
	*/
	cb->pss_restab.pst_resdup = FALSE;
    }
;

retwiths:	    retwith
	  |	    retwiths COMMA retwith
;

retwith:	    rt_nm_eq_nm
	    |	    rt_nm_eq_no
	    |	    rt_single_kwd
	    |	    rt_lst_cl
;

rt_nm_eq_nm:	    nonkeyword ISOP nonkeyword
    {
	i4	    err_code;
	i4	    storestruct;
	i4	    compressed = FALSE;

	if (STcompare($1, "structure") == 0)
	{
	    char    *ssname = $3;

	    /* Decode storage structure */
	    if (*ssname == 'c')
	    {
		compressed = TRUE;
		ssname++;
	    }

	    storestruct = uld_struct_xlate(ssname);
	    if (storestruct == 0 || storestruct == DB_RTRE_STORE
	      || storestruct == DB_SORT_STORE)
	    {
		(VOID) psf_error(2144L, 0L, PSF_USERERR, &err_code,
			  &psq_cb->psq_error, 1, (i4) STtrmwhite($3), $3);
		return (E_DB_ERROR);    /* non-zero return means error */
	    }

	    cb->pss_restab.pst_struct   = storestruct;
	    cb->pss_restab.pst_compress = compressed ? PST_DATA_COMP : 0;
	}
	else
	{
	    (VOID) psf_error(2139L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

rt_nm_eq_no:	    nonkeyword ISOP intconst
    {
	i4		    err_code;

	if (!STcasecmp($1, "fillfactor"))
	{
	    /* Fillfactor must be between 1% and 100% */
	    if ($3 < 1 || $3 > 100)
	    {
		(VOID) psf_error(2145L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof($3), &$3);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    cb->pss_restab.pst_fillfac = $3;
	}
	else if (!STcasecmp($1, "minpages"))
	{
	    /* minpages must be greater than zero */
            if (($3 <= 0) || ($3 > DB_MAX_PAGENO))
	    {
		(VOID) psf_error(2146L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof($3), &$3);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    cb->pss_restab.pst_minpgs = $3;
	}
	else if (!STcasecmp($1, "maxpages"))
	{
	    /* maxpages must be greater than zero */
            if (($3 <= 0) || ($3 > DB_MAX_PAGENO))
	    {
		(VOID) psf_error(2147L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof($3), &$3);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    cb->pss_restab.pst_maxpgs = $3;
	}
	else if (!STcasecmp($1, "nonleaffill"))
	{
	    /* Nonleaffill must be between 1% and 100% */
	    if ($3 < 1 || $3 > 100)
	    {
		(VOID) psf_error(2148L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof($3), &$3);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    cb->pss_restab.pst_nonleaff = $3;
	}
	else if (!STcasecmp($1, "leaffill") ||
		 !STcasecmp($1, "indexfill")   )
	{
	    /* Leaffill/indexfill must be between 1% and 100% */
	    if ($3 < 1 || $3 > 100)
	    {
		(VOID) psf_error(2149L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) sizeof($3), &$3);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    cb->pss_restab.pst_leaff = $3;
	}
	else if (!STcasecmp($1, "maxindexfill"))
	{
	    /* ignore */
	}
        else if (!STcasecmp($1, "allocation"))
        {
            /* Nonleaffill must be between 4 and 8388607 */
            if ($3 < 4 || $3 > 8388607)
            {
                (VOID) psf_error(5555L, 0L, PSF_USERERR, &err_code,
                    &psq_cb->psq_error, 1, (i4) sizeof($3), &$3);
                return (E_DB_ERROR);    /* non-zero return means error */
            }
            cb->pss_restab.pst_alloc = $3;
        }
        else if (!STcasecmp($1, "extend"))
        {
            /* Nonleaffill must be between 1 and 8388607 */
            if ($3 < 1 || $3 > 8388607)
            {
                (VOID) psf_error(5556L, 0L, PSF_USERERR, &err_code,
                    &psq_cb->psq_error, 1, (i4) sizeof($3), &$3);
                return (E_DB_ERROR);    /* non-zero return means error */
            }
            cb->pss_restab.pst_extend = $3;
        }
	else	/* Unknown parameter */
	{
	    (VOID) psf_error(2140L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite($1), $1);
	    return (E_DB_ERROR);
	}
    }
;

rt_single_kwd:	nonkeyword
    {
	i4			err_code;

	if (STcompare((char*) $1, "journaling") == 0 ||
	    STcompare((char*) $1, "logging") == 0)
    	{
	    $Ywith_journaling = 1;
	    if (cb->pss_ses_flag & PSS_JOURNALED_DB)
		cb->pss_restab.pst_resjour = PST_RESJOUR_ON;
	    else
		cb->pss_restab.pst_resjour = PST_RESJOUR_LATER;
	}
	else if (STcompare((char*) $1, "nojournaling") == 0 ||
	    STcompare((char*) $1, "nologging") == 0)
	{
	    $Ywith_journaling = 1;
	    cb->pss_restab.pst_resjour = PST_RESJOUR_OFF;
	}
	else if (STcompare((char*) $1, "duplicates") == 0)
	{
	    $Ywith_dups = PST_ALLDUPS;
	    cb->pss_restab.pst_resdup = TRUE;
	}
	else if (STcompare((char*) $1, "noduplicates") == 0)
	{
	    $Ywith_dups = PST_NODUPS;
	    cb->pss_restab.pst_resdup = FALSE;
	}
	else
	{
	    (VOID) psf_error(2154L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno, STtrmwhite($1), $1);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
    }
;

rt_lst_cl:	    rt_lst_cl_prefix LPAREN rt_lst RPAREN
    {
	if ($Ylist_clause == PSS_KEY_CLAUSE)
	    cb->pss_restab.pst_reskey = $3;

	$Ylist_clause = 0;	/* done with this clause */
    }
;

rt_lst_cl_prefix:	    nonkeyword ISOP
    {
	i4                err_code;

	if (STcompare((char*) $1, "key") == 0)
	    $Ylist_clause = PSS_KEY_CLAUSE;
	else if (STcompare($1, "location") == 0)
	{
	    $Ylist_clause = PSS_NLOC_CLAUSE;
	    /* check if user specified a locationname */
	    if ($Ywith_location)
	    {
		(VOID) psf_error(2114L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }
	    $Ywith_location = 1;
	}
	else
	{
	    (VOID) psf_error(2150L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

rt_lst:	rt_lst_elem
    {
	$$ = $1;
    }
	|	rt_lst COMMA rt_lst_elem
    {
	if ($Ylist_clause == PSS_KEY_CLAUSE)
	{
	    PST_RESKEY	*reskey;
	    i4		err_code;

	    /*
	    ** Check for duplicate names.
	    */
	    reskey = $1;	
	    do {
		if (!MEcmp((char *) &($3)->pst_attname,
		    (char *) &reskey->pst_attname,
		    sizeof(reskey->pst_attname))
		   )
		{
		    (VOID) psf_error(2151L, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 1,
				     STlength($3->pst_attname.db_att_name), 
				     $3->pst_attname.db_att_name); 
		    return (E_DB_ERROR);
		}
		reskey = reskey->pst_nxtkey;
	    } while (reskey != (PST_RESKEY *) NULL);
     
	    /*
	    ** Find the last key in the list.
	    */
	    for (reskey = $1; reskey->pst_nxtkey; reskey = reskey->pst_nxtkey)
	    ;

	    reskey->pst_nxtkey = $3;

	    $$ = $1;
	}
    }
;

rt_lst_elem:		NAME
    {
	if ($Ylist_clause == PSS_KEY_CLAUSE)
	{
	    DB_STATUS	status;
	    PST_RESKEY	*reskey;

	    /* Allocate memory for a key entry */
	    status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(PST_RESKEY),
		(PTR *) &reskey, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /*
	    ** Copy column name to column entry.
	    */
	    STmove($1, ' ', sizeof(reskey->pst_attname),
		(char *) &reskey->pst_attname);
	    reskey->pst_nxtkey = (PST_RESKEY *) NULL;

	    $$ = reskey;
	}
	else
	{
	    register DB_LOC_NAME *loc, *lim;
	    i4	err_code;

	    /* See if there is space for 1 more */
	    if (cb->pss_restab.pst_resloc.data_in_size/sizeof(DB_LOC_NAME) >=
		DM_LOC_MAX)
	    {
		/* Too many locations */
		(VOID) psf_error(2115L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, sizeof(cb->pss_lineno),
		    &cb->pss_lineno);
		return (E_DB_ERROR);
	    }

	    lim = (DB_LOC_NAME *) (cb->pss_restab.pst_resloc.data_address +
		    cb->pss_restab.pst_resloc.data_in_size);

	    /* Store normalized location name */
	    STmove($1, ' ', (u_i4) DB_LOC_MAXNAME, (char *) lim);
	    cb->pss_restab.pst_resloc.data_in_size += sizeof(DB_LOC_NAME);

	    /* See if not a duplicate */
	    for (loc = (DB_LOC_NAME *) cb->pss_restab.pst_resloc.data_address;
		 loc < lim;
		 loc++
		)
	    {
		if (!MEcmp((char *) loc, (char *) lim, sizeof(DB_LOC_NAME)))
		{
		    /* A duplicate was found */
		    (VOID) psf_error(2116L, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 2,
			sizeof(cb->pss_lineno), &cb->pss_lineno,
			psf_trmwhite(DB_LOC_MAXNAME, $1), $1);
		    return (E_DB_ERROR);
		}
	    }
	}
    }
;

sortclause:        sortkwd sortlist
    {
	$$ = $Ysort_list;
    }
          |
    {
	/* No sort clause generates empty sort list */
	$$ = (PST_QNODE *) NULL;
    }
;

sortkwd:	    SORT
    {
	  $Ysort_by = 1;
    }
	    |	    SORT BY
    {
	  $Ysort_by = 1;
    }
	    |	    ORDERBY
    {
	  $Ysort_by = 0;
    }
;

sortlist:	    sortkey
          |	    sortlist COMMA sortkey
;

sortkey:	    sortvar
          |	    sortvar COLON nonkeyword
    {
	/*
	** if the same attribute appears more than once in the sort list, we
	** will disregard all but the first occurrence (since those occurrences
	** have no effect on the result of the query); as a result, pst_adsort()
	** may return NULL, in which case we should not worry about the
	** direction of the sort
	*/
	if ($1 != (PST_QNODE *) NULL)
	{
	    DB_STATUS   status;

	    /* Indicate "ascending" or "descending" in sort node */
	    status = pst_sdir($1, $3, &psq_cb->psq_error);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}
    }
;

sortvar:           sortrng PERIOD NAME
    {
	PST_QNODE              *sortnode;
	DB_STATUS	       status;

	/* Allocate a sort node by range variable */
	status = pst_varsort(cb, &cb->pss_ostream, cb->pss_tlist, &$Ysort_list,
	    $1, $3, &sortnode, psq_cb);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = sortnode;
    }
          |	    NAME
    {
	PST_QNODE              *sortnode;
	DB_STATUS	       status;

	/* Allocate a sort node by expression name */
	status = pst_expsort(cb, &cb->pss_ostream, cb->pss_tlist, &$Ysort_list,
	    $1, &sortnode, psq_cb);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = sortnode;
    }
;

sortrng:           NAME
    {
	PSS_RNGTAB             *rngvar;
	DB_STATUS	       status;
	i4		       err_code;

	status = pst_rglook(cb, &cb->pss_usrrange, -1, $1, FALSE, 
	    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	if (rngvar == (PSS_RNGTAB *) NULL)
	{
	    (VOID) psf_error(2109L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2, sizeof(cb->pss_lineno), &cb->pss_lineno,
		(i4) STlength($1), $1);
	    return (E_DB_ERROR);
	}

	$$ = rngvar;
    }
;

save:              savstmnt sname UNTIL date
    {
	QEU_CB	*qeu_cb;
	DMT_CB	*dmt_cb;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmt_cb = (DMT_CB *) qeu_cb->qeu_d_cb;
	STRUCT_ASSIGN_MACRO($2->pss_tabid, dmt_cb->dmt_id);
    }
	|	    savstmnt sname
    {
	QEU_CB	*qeu_cb;
	DMT_CB	*dmt_cb;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmt_cb = (DMT_CB *) qeu_cb->qeu_d_cb;
	STRUCT_ASSIGN_MACRO($2->pss_tabid, dmt_cb->dmt_id);
    }
;

sname:		    NAME
    {
	i4		    err_code, err_num = 0L;
	DB_STATUS           status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMT_CB		    *dmt_cb;
	PSS_RNGTAB	    *rngtab;
	DB_TAB_NAME	    tabname;

	qeu_cb = (QEU_CB *) cb->pss_object;
	dmt_cb = (DMT_CB *) qeu_cb->qeu_d_cb;

	STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);

	status = psl0_rngent(&cb->pss_auxrng, -1, "", &tabname, cb,
	    FALSE, &rngtab, psq_cb->psq_mode, &psq_cb->psq_error,
	    PSS_USRTBL | PSS_DBATBL | PSS_INGTBL, &rngvar_info, 0, NULL);
	if (status != E_DB_OK)
	    return (status);

	if (rngtab == (PSS_RNGTAB *) NULL)
	{
	    (VOID) psf_error(5604L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		STlength($1), $1);
	    return (E_DB_ERROR);
	}

	/* See if system catalog */
	if (rngtab->pss_tabdesc->tbl_status_mask &
	    	    	    	(DMT_CATALOG | DMT_EXTENDED_CAT)
	    || rngtab->pss_tabdesc->tbl_2_status_mask & DMT_TEXTENSION)
	{
	    err_num = 5600L;
	}
	else if (MEcmp((PTR) &rngtab->pss_ownname, (PTR) &cb->pss_user,
		       sizeof(DB_OWN_NAME)))
	{
	    err_num = 5604L;
	}

	if (err_num != 0L)
	{
	    (VOID) psf_error(err_num, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &rngtab->pss_tabname),
		&rngtab->pss_tabname);
	    return (E_DB_ERROR);
	}

	$$ = rngtab;
    }
;

savstmnt:          SAVE
    {
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DB_STATUS	       status;
	DMT_CHAR_ENTRY	       *chr;

	psq_cb->psq_mode = PSQ_SAVE;

	/* Allocate QEU_CB for SAVE and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = (PTR) dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the save date */

	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id	= DMT_C_SAVEDATE;
	chr->char_value = 0;
    }
;

date:              month intconst intconst
    {
	i4		       err_code;
	register i4	       i;
	register i4       date;
	i4		       value;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	QEU_CB		       *qeu_cb;
	DMT_CB		       *dmt_cb;
	DMT_CHAR_ENTRY	       *chr;

	/* Check out the year */
	if ($3 < 1970 || $3 > 2035)
	{
	    (VOID) psf_error(5603L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof($3), &($3));
	    return (E_DB_ERROR);
	}

	/* Check out the day */
	if ($2 < 1 || psq_monsize((i4) $1, (i4) $3) < $2)
	{
	    (VOID) psf_error(5602L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof($2), &($2));
	    return (E_DB_ERROR);
	}

	/* Convert date */

	/* "date" will be number of days from 1970 for a while */
	date = 0;

	/* Do year conversion */
	date += ($3 - 1970) * 365;
	if ($3 > 1970)
	    date += ($3 - 1973) / 4 + 1;    /* Add one day for each leap year */

	/* Do month conversion */
	for (i = 1; i < $1; i++)
	    date += psq_monsize((i4)i, (i4)$3);

	/* Do date conversion */
	date += $2 - 1;

	/* Convert the date to be the number of hours since 1970 */
	date *= 24;

	/* NOTE: NO DAYLIGHT SAVINGS TIME COMPUTATIONS */

	/* Convert to minutes */
	date *= 60;

	/* Convert to seconds */
	date *= 60;

	/* Adjust to GMT */

    	if( date > MAXI4)
    	    value = MAXI4;
    	else
    	    value = date;
    
    	date -=	TMtz_search(adf_scb->adf_tzcb, TM_TIMETYPE_LOCAL,
    	    	    	    value);



	/* Store number of seconds in control block */
	qeu_cb = (QEU_CB *) cb->pss_object;
	dmt_cb = (DMT_CB *) qeu_cb->qeu_d_cb;
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_value = date;
    }
;

month:             nonkeyword
    {
	DB_STATUS              status;
	i4		       monthno;
	
	/* Translate month name to month number */
	status = psq_month($1, &monthno, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	$$ = monthno;
    }
          |	    intconst
    {
	i4		       err_code;
	char		       err[100];

	if ($1 <= 0 || $1 > 12)
	{
	    CVla($1, err);
	    (VOID) psf_error(5601L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STlength(err), err);
	    return (E_DB_ERROR);
	}

	$$ = $1;
    }
;

savepoint:         spoint sp_name
    {
	/* done */
    }
;

spoint:	    SAVEPOINT
    {
	DB_STATUS              status;
	QEF_RCB		       *qef_rcb;

	psq_cb->psq_mode = PSQ_SVEPOINT;

	/* Allocate QEF control block for savepoint */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;
	qef_rcb->qef_length = sizeof(QEF_RCB);
	qef_rcb->qef_type = QEFRCB_CB;
	qef_rcb->qef_owner = (PTR)DB_PSF_ID;
	qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_modifier = QEF_MSTRAN;
	qef_rcb->qef_flag   = DB_QUEL;
	qef_rcb->qef_sess_id = cb->pss_sessid;
	qef_rcb->qef_db_id  = cb->pss_dbid;

	/* Allocate the savepoint name */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_SP_NAME),
	    (PTR *) &qef_rcb->qef_spoint, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

    }
;

sp_name:	    NAME
    {
	QEF_RCB		       *qef_rcb;

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;

	/* Fill in the savepoint name */
	STmove($1, ' ', sizeof(DB_SP_NAME), (char *) qef_rcb->qef_spoint);

    }
	|	    intconst
    {
	QEF_RCB		       *qef_rcb;
	char		       numbuf[25];

	/* Fill in the QEF control block */
    	qef_rcb = (QEF_RCB *) cb->pss_object;

	/* Fill in the savepoint name */
	CVla((i4) $1, numbuf);
	STmove(numbuf, ' ', sizeof(DB_SP_NAME), (char *) qef_rcb->qef_spoint);
    }
;

setaggr:	    SETAGGR strsetparam
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_SAGGR;

	/* Possible parameters are "project" and "noproject" */
	if (!STcasecmp($2, "project"))
	{
	    cb->pss_ses_flag |= PSS_PROJECT;  /* pss_project = TRUE */
	}
	else if (!STcasecmp($2, "noproject"))
	{
	    cb->pss_ses_flag &= ~PSS_PROJECT;	/* pss_project = FALSE */
	}
	else
	{
	    (VOID) psf_error(5971L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

setautocommit:		SETAUTOCOMMIT st_auto
    {
	i4                err_code;

	/* "set autocommit" is not legal in QUEL. Issue warning */
	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* "set autocommit" is not supported for quel */
	    (VOID) psf_error(5974L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	}
    }
;

st_auto:	ON
    {
	$$ = 1;
    }
	|	nonkeyword
    {
	i4	    err_code;

	if (STcompare($1, "off") == 0)
	    $$ = 2;
	else  /* syntax error */
	{
	    /* set autocommit syntax error */
	    (VOID) psf_error(2677L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;

setcpufact:	    SETCPUFACT intsetparam
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SCPUFACT;

	/* Create control block for setting cpu factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_alter = OPF_CPUFACTOR;
	opf_cb->opf_value = $2;
    }
;

/* SET NOCREATE_COMPRESSION is the important one here, it allows
** copydb / unloaddb to operate in the traditional mode where the
** session default is not to compress.  SET CREATE_COMPRESSION is
** somewhat bogus, but does allow the session to operate with
** the create table default -> data compression.  (not hidata.)
*/
setcrecomp:	    SETCREATECOMPRESSION
    {
	psq_cb->psq_mode = PSQ_CREATECOMP;

	if ($1 == PSL_ONSET)
	    cb->pss_create_compression = DMU_C_ON;	/* compression = DATA */
	else
	    cb->pss_create_compression = DMU_C_OFF;	/* compression NONE */
    }
;

setdatefmt:	    SETDATEFMT strconst
    {
	i4                err_code;
	i4		  date_fmt;

	psq_cb->psq_mode = PSQ_SDATEFMT;

	/*
	** Possible formats determined in adu_date_format (kibro01) b119318
	*/
	date_fmt = adu_date_format((char*)$2);
	if (date_fmt == -1)
	{
	    (VOID) psf_error(5934L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength((char *) $2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	psq_cb->psq_dtefmt = date_fmt;
    }
;

setdecimal:	    SETDECIMAL strconst
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_SDECIMAL;

	/* Period and comma are only allowable decimal markers */
	if (STcompare((char *) $2, ",") && STcompare((char *) $2, "."))
	{
	    (VOID) psf_error(5936L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength((char *) $2),
		(char *) $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Give new decimal character back to caller */
	psq_cb->psq_decimal.db_decspec = TRUE;
	psq_cb->psq_decimal.db_decimal = *((char *) $2);

	/* Change decimal character in session control block */
	cb->pss_decimal = *((char *) $2);
    }
;

setiotrace:	    SETIOTRACE
    {
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_IOTRACE;
	debug_cb->db_value_count = 0;
	if ($1 == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;
    }
;

setjoinop:	    SETJOINOP
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* Set [no]joinop no longer supported */
	    (VOID) psf_error(5933L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	}
    }
;

setjournal:	    SETJOURNAL
    {
	psq_cb->psq_mode = PSQ_ALLJOURNAL;

	if ($1 == PSL_ONSET)
	    cb->pss_ses_flag |= PSS_JOURNALING; /* pss_journaling = TRUE */
	else
	    cb->pss_ses_flag &= ~PSS_JOURNALING; /* pss_journaling = FALSE */
    }
	  |	    SETJOURNAL ON NAME
    {
	i4             err_code, err_num = 0L;
	DB_STATUS	    status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMT_CB		    *dmt_cb;
	PSS_RNGTAB	    *rngvar;
	DB_TAB_NAME	    tabname;
	DMT_CHAR_ENTRY	    *chr;

	psq_cb->psq_mode = PSQ_SJOURNAL;

	/* Look up the table id */
	STmove($3, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb, FALSE,
	    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info, NULL);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/* Disallow SET JOURNALING on catalogs. */
	if (rngvar->pss_tabdesc->tbl_status_mask &
	    	    (DMT_CATALOG | DMT_EXTENDED_CAT)
	    || rngvar->pss_tabdesc->tbl_2_status_mask)
	{
	    err_num = 2762L;
	}
	/* Disallow SET JOURNALING on indices */
	else if (rngvar->pss_tabdesc->tbl_status_mask & DMT_IDX)
	{
	    err_num = 2766L;
	}
	else if (MEcmp((PTR) &rngvar->pss_ownname, (PTR) &cb->pss_user,
	               sizeof(DB_OWN_NAME)))
	{
	    /* disallow SET [NO]JOURNALING on someone else's tables */
	    (VOID) psf_error(2753L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		sizeof("SET [NO]JOURNALING") - 1, "SET [NO]JOURNALING",
		STlength($3), $3);
	    return(E_DB_ERROR);
	}

	if (err_num != 0L)
	{
	    (VOID) psf_error(err_num, 0L, PSF_USERERR,&err_code,
		&psq_cb->psq_error, 1,
		psf_trmwhite(sizeof(DB_TAB_NAME), 
		    (char *) &rngvar->pss_tabname),
		&rngvar->pss_tabname);
	    return (E_DB_ERROR);
	}

	/* Allocate QEU_CB for SET JOURNALING and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = (PTR) dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the journaled bit */
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id = DMT_C_JOURNALED;
	if ($1 == PSL_ONSET)
	    chr->char_value = DMT_C_ON;
	else
	    chr->char_value = DMT_C_OFF;

	STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, dmt_cb->dmt_id);
    }
;

setjtimeout:	    SETJOINOP nonkeyword setjint
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;
	i4			flag;

	psq_cb->psq_mode = PSQ_JTIMEOUT;

	if (STcompare($2, "timeout") == 0)
	    flag = OPF_TIMEOUT;
	else if (STcompare($2, "notimeout") == 0)
	    flag = OPF_NOTIMEOUT;
	else if ((STcompare($2, "newenum") == 0 ||
		STcompare($2, "greedy") == 0) && $3 == 0)
	    flag = OPF_NEWENUM;
	else if ((STcompare($2, "nonewenum") == 0 ||
		STcompare($2, "nogreedy") == 0) && $3 == 0)
	    flag = OPF_NONEWENUM;
	else
	{
	    i4	    err_code;

	    /* set joinop [no]timeout syntax error */
	    (VOID) psf_error(2682L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 2,
		(i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		(i4) STlength($2), $2);
	    return (E_DB_ERROR);
	}
	/* Create control block for setting cpu factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_alter = flag;
	opf_cb->opf_value = $3;
    }
;

setjint:   int2_int4
	|
    {
	$$ = 0;
    }
;

setltrace:	    SETLTRACE
    {
	DB_STATUS	    ret_val;
	DB_DEBUG_CB	    *debug_cb;

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_trace_point = DM_LOCKTRACE;
	debug_cb->db_value_count = 0;
	if ($1 == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;
    }
;

/*
** Yacc production:	setlogging	- Enable/disable logging
** Statement syntax:
**			SET [NO]LOGGING
**
** Statement to Enable/Disable Logging in current session.
** Must be DBA to execute this statement.
**
** Parse action is to allocate a DMC_CB structure for a DMC_ALTER call
** which will be executed by the PSQ_SLOGGING statement.
**
** Return State:
**	psq_mode				PSQ_SLOGGING
**	dmc_cb->dmc_char_entry[0].char_id	DMC_C_LOGGING
**	dmc_cb->dmc_char_entry[0].char_value	DMC_C_ON/DMC_C_OFF
*/
setlogging:	    SETLOGGING
    {
	DB_STATUS	    status;
	DMC_CB		    *dmc_cb;
	DMC_CHAR_ENTRY	    *dmc_char;
	i4		    err_code;

	psq_cb->psq_mode = PSQ_SLOGGING;

	/*
	** Check for priviledge to turn off logging.
	** User must be the DBA to enable or disable logging.
	*/
	if (MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
	       sizeof(DB_OWN_NAME)))
	{
	    _VOID_ psf_error(E_PS0F81_SETLG_PRIV_ERR, 0L, PSF_USERERR,
			     &err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	/*
	** Create control block for DMC_ALTER call for Set [No]Logging
	*/
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CB), (PTR *) &dmc_cb,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) dmc_cb, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	/*
	** Format Alter Control Block.
	*/
	cb->pss_object	    = (PTR) dmc_cb;
	dmc_cb->type	    = DMC_CONTROL_CB;
	dmc_cb->length	    = sizeof (DMC_CB);
	dmc_cb->dmc_op_type = DMC_SESSION_OP;
	dmc_cb->dmc_session_id	= (PTR)cb->pss_sessid;
	dmc_cb->dmc_db_id   = cb->pss_dbid;
	dmc_cb->dmc_flags_mask = 0;

	/*
	** Allocate characteristics array with entry for Set Logging.
	*/
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMC_CHAR_ENTRY),
	     (PTR *) &dmc_char, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	dmc_cb->dmc_char_array.data_in_size = sizeof(DMC_CHAR_ENTRY);
	dmc_cb->dmc_char_array.data_address = (char *) dmc_char;
	dmc_char->char_id = DMC_C_LOGGING;
	dmc_char->char_value = ($1 == PSL_ONSET) ? DMC_C_ON : DMC_C_OFF;
    }
;

/*
** Yacc production:	setlogtrace	- Trace log write operations
** Statement syntax:
**			SET [NO]LOG_TRACE
**
** Statement to toggle tracing of log writes.
**
** Operation is treated like a SET TRACE POINT DMnnn to set the DM_LOGTRACE
** trace point.
**
** Return State:
**	psq_mode				PSQ_DMFTRACE
**	debug_cb->db_trace_point		DM_LOGTRACE
**	debug_cb->db_trswitch			DB_TR_ON/DB_TR_OFF
*/
setlogtrace:	    SETLOGTRACE
    {
	DB_STATUS	    status;
	DB_DEBUG_CB	    *debug_cb;

	psq_cb->psq_mode = PSQ_DMFTRACE;

	/* Allocate the debug control block */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	status = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return (status);

	debug_cb->db_trace_point = DM_LOGTRACE;
	debug_cb->db_value_count = 0;

	debug_cb->db_trswitch = ($1 == PSL_ONSET) ? DB_TR_ON : DB_TR_OFF;
    }
;

setlockmode:	    setlockstmnt setlockscope WHERE setlockparms
;

setlockstmnt:	    SETLOCKMODE
    {
	DB_STATUS		status;

	status = psl_lm1_setlockstmnt(cb, psq_cb);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

setlockscope:	    nonkeyword
    {
	i4			err_code;
	DMC_CB			*dmc_cb;

	/* "session" is the only parameter acceptable here */
	if (STcasecmp($1, "session"))
	{
	    (VOID) psf_error(5970L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($1), $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	dmc_cb	= (DMC_CB*) cb->pss_object;
	dmc_cb->dmc_sl_scope = DMC_SL_SESSION;
    }
	  |	    ON NAME
    {
	DB_STATUS		status;
	i4			rngvar_info;
	DMC_CB			*dmc_cb;
	PSS_RNGTAB	       *rngvar;
	DB_TAB_NAME	       tabname;

	dmc_cb	= (DMC_CB*) cb->pss_object;
	dmc_cb->dmc_sl_scope = DMC_SL_TABLE;

	/* Look up the table id */
	STmove($2, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb, FALSE,
	    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info, NULL);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, dmc_cb->dmc_table_id);
    }
;

setlockparms:	    setlockparm
	|	    setlockparms COMMA setlockparm
;

setlockparm:	    setlockkey ISOP nonkeyword
    {
	DB_STATUS		status;

	status = psl_lm3_setlockparm_name($1, $3, cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
	  |	    setlockkey ISOP intsetparam
    {
	DB_STATUS		status;

	status = psl_lm4_setlockparm_num($1, $3, cb, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
    }
;

setlockkey:	    nonkeyword
    {
	i4			    lockkey_type;
	DB_STATUS		    status;

	status = psl_lm2_setlockkey(cb, $1, &lockkey_type, &psq_cb->psq_error);

	if (DB_FAILURE_MACRO(status))
	{
	    return(status);
	}
	else
	{
	    $$ = lockkey_type;
	}
    }
        |           LEVEL
    {
        i4                      lockkey_type;
        DB_STATUS               status;
 
        status = psl_lm2_setlockkey(cb, "level", &lockkey_type,
                                    &psq_cb->psq_error);
 
        if (DB_FAILURE_MACRO(status))
        {
            return(status);
        }
        else
        {
            $$ = lockkey_type;
        }
    }
;

setmnyfmt:	    SETMNYFMT strconst
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_SMNFMT;

	/* First character of parameter must specify leading or trailing */
	if (((char *) $2)[0] == 't' || ((char *) $2)[0] == 'T')
	{
	    /* Give trailing indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_TRAIL_MONY;
	}
	else if (((char *) $2)[0] == 'l' || ((char *) $2)[0] == 'L')
	{
	    /* Give leading indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_LEAD_MONY;
	}
	else if ( (((char *) $2)[0] == 'n' || ((char *) $2)[0] == 'N') &&
	          (((char *) $2)[1] == 'o' || ((char *) $2)[1] == 'O') &&
	          (((char *) $2)[2] == 'n' || ((char *) $2)[2] == 'N') &&
	          (((char *) $2)[3] == 'e' || ((char *) $2)[3] == 'E') )
	{
	    /* Give leading indicator back to caller */
	    psq_cb->psq_mnyfmt.db_mny_lort = DB_NONE_MONY;
	    psq_cb->psq_mnyfmt.db_mny_sym[0] = EOS;
	}
	else
	{
	    (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STlength((char *) $2), (char *) $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

 	if ( (psq_cb->psq_mnyfmt.db_mny_lort == DB_LEAD_MONY) ||
 	     (psq_cb->psq_mnyfmt.db_mny_lort == DB_TRAIL_MONY) )
	{
	    /* Second character of parameter must be a colon */
	    if ( ((char *) $2)[1] != ':') 
	    {
	        (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, STlength((char *) $2), (char *) $2);
	        return (E_DB_ERROR);    /* non-zero return means error */
	    }

	    /* Next 0 - 4 characters is the currency symbol */
	    if (STlength(&((char *) $2)[2]) > DB_MAXMONY)
	    {
	        (VOID) psf_error(5935L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, STlength((char *) $2), $2);
	        return (E_DB_ERROR);
	    }

	    /* Give money symbol back to caller */
	    STcopy(&((char *) $2)[2], psq_cb->psq_mnyfmt.db_mny_sym);
	}
    }
;

setmnyprec:	    SETMNYPREC intsetparam
    {
	i4                err_code;

	psq_cb->psq_mode = PSQ_SMNPREC;

	/* Specified precision must be between 0 and 2, inclusive */
	if ($2 < 0 || $2 > 2)
	{
	    (VOID) psf_error(5937L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, sizeof($2), &$2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Give money precision back to caller */
	psq_cb->psq_mnyfmt.db_mny_prec = $2;
    }
;

setmxio:	    setmxio_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QDIO_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QDIO_LIMIT;
	psy_cb->psy_qdio_limit  = $2;

    }
		|   setmxio_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  = DBPR_QDIO_LIMIT;
    }
;

setmxio_kwd:	    SETMXIO
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxrow:	    setmxrow_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QROW_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QROW_LIMIT;
	psy_cb->psy_qrow_limit  = $2;

    }
		|   setmxrow_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QROW_LIMIT;
    }
;

setmxrow_kwd:	    SETMXROW
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxcpu:	    setmxcpu_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QCPU_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QCPU_LIMIT;
	psy_cb->psy_qcpu_limit  = $2;

    }
		|   setmxcpu_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QCPU_LIMIT;
    }
;

setmxcpu_kwd:	    SETMXCPU
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxpage:	    setmxpage_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QPAGE_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QPAGE_LIMIT;
	psy_cb->psy_qpage_limit = $2;

    }
		|   setmxpage_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QPAGE_LIMIT;
    }
;

setmxpage_kwd:	    SETMXPAGE
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setmxcost:	    setmxcost_kwd intsetparam
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_ONSET)
	{
	    (VOID) psf_error(6236L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv |= DBPR_QCOST_LIMIT;
	psy_cb->psy_fl_dbpriv  |= DBPR_QCOST_LIMIT;
	psy_cb->psy_qcost_limit = $2;

    }
		|   setmxcost_kwd
    {
	i4                err_code;
	PSY_CB		       *psy_cb;

	psy_cb = (PSY_CB *) cb->pss_object;

	if ($1 != PSL_OFFSET)
	{
	    (VOID) psf_error(6237L, 0L, PSF_USERERR, 
		&err_code, &psq_cb->psq_error, 0);
	    return (E_DB_ERROR);
	}

	psy_cb->psy_ctl_dbpriv  |= DBPR_QCOST_LIMIT;
    }
;

setmxcost_kwd:	    SETMXCOST
    {
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_MXQUERY;

	if ((status = psy_qminit(cb, psq_cb, &cb->pss_ostream)) != E_DB_OK)
	    return(status);

	$$ = $1;
    }
;

setprintqry:	    SETPRINTQRY
    {
	DB_DEBUG_CB	       *debug_cb;
	DB_STATUS	       ret_val;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
	    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;
	if ($1 == PSL_ONSET)
	    debug_cb->db_trswitch = DB_TR_ON;
	else
	    debug_cb->db_trswitch = DB_TR_OFF;

	debug_cb->db_trace_point = 129;	    /* 128 + 1 - first trace flag
					    ** of session trace flags.
					    */
	psq_cb->psq_mode = PSQ_PSFTRACE;
    }
;
	

setoptimizeonly:    SETOPTIMIZEONLY
    {
	/*
	** It has been decided to implement thsi statement by acting as if user
	** entered "set [no]trace point op160"
	*/

	DB_DEBUG_CB	*debug_cb;
	DB_STATUS	ret_val;

	/* Allocate the debug control block */
	ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
	    (PTR *) &debug_cb, &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
			    &psq_cb->psq_error);
	if (ret_val != E_DB_OK)
	    return (ret_val);
	debug_cb->db_value_count = 0;

	debug_cb->db_trswitch = ($1 == PSL_ONSET) ? DB_TR_ON : DB_TR_OFF;

	/*
	** since we are supplying the tracepoint name, we'd like to hope that
	** getfacil() doesn't get too excited over it.  It will supply us with
	** both the query mode and the trace point number.
	*/
	(VOID) getfacil("op160", &psq_cb->psq_mode,
			(i4 *) &debug_cb->db_trace_point);
    }
;

setqep:	    SETQEP
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;

	/* Create control block for setting cpu factor in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_QEP;
	else
	    opf_cb->opf_alter = OPF_NOQEP;
}

setflatten:	SETFLATTEN
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: SQEP suffices for all
					** OPF session alter values */

	/* Create control block for setting subselect flattening in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_NOSUBSELECT; 
	else
	    opf_cb->opf_alter = OPF_SUBSELECT;
}

sethash:	    SETHASH
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting hash operations indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_HASH;
	else
	    opf_cb->opf_alter = OPF_NOHASH;
    }
;

setojflatten:	    SETOJFLATTEN
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting OJ flattening indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_OJSUBSELECT;
	else
	    opf_cb->opf_alter = OPF_NOOJSUBSELECT;
    }
;

setparallel:	    SETPARALLEL parconst
    {
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;

	psq_cb->psq_mode = PSQ_SQEP;	/* NOTE: PSQ_SQEP does for any OPF
					** alter values */

	/* Create control block for setting parallel query indicator in OPF */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_value = $2;
	if ($1 == PSL_ONSET)
	    opf_cb->opf_alter = OPF_PARALLEL;
	else
	{
	    opf_cb->opf_alter = OPF_NOPARALLEL;
	    opf_cb->opf_value = -1;
	}
    }
;

parconst:   int2_int4
    {
    }
	|
    {
	$$ = 4;
    }
;


setrandomseed:	    SETRANDOMSEED intsetparam
    {
	psq_cb->psq_mode = PSQ_SETRANDOMSEED;
	psq_cb->psq_random_seed = $2;
    }
    |		    SETRANDOMSEED
    {
	u_i4	tmppid;
	u_i4	tmpnow = TMsecs();

	PCpid(&tmppid);
	psq_cb->psq_mode = PSQ_SETRANDOMSEED;
	psq_cb->psq_random_seed = tmppid * tmpnow; 
    }
;

setretinto:	    SETRETINTO strsetparam
    {
	i4                err_code;
	DB_STATUS	       status;
	OPF_CB		       *opf_cb;
	char		*val = $2;

	psq_cb->psq_mode = PSQ_SRINTO;

	/* Allocate OPF control block for set ret_into command */
	status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(OPF_CB), (PTR *) &opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	status = psf_mroot(cb, &cb->pss_ostream, (PTR) opf_cb,
	    &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	/* Fill in OPF control block */
	opf_cb->opf_length = sizeof(opf_cb);
	opf_cb->opf_type = OPFCB_CB;
	opf_cb->opf_owner = (PTR)DB_PSF_ID;
	opf_cb->opf_ascii_id = OPFCB_ASCII_ID;
	opf_cb->opf_alter = OPF_RET_INTO;
	opf_cb->opf_level = OPF_SESSION;
	opf_cb->opf_compressed = FALSE;

	/* Decode storage structure.  Error if unknown. */

	if (CMcmpnocase(val, "c") == 0)
	{
	    opf_cb->opf_compressed = TRUE;
	    CMnext(val);
	}
	opf_cb->opf_value = uld_struct_xlate(val);
	if (opf_cb->opf_value == 0 || opf_cb->opf_value == DB_RTRE_STORE)
	{
	    (VOID) psf_error(5915L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($2), $2);
	}
    }
;

/*
** Yacc production:     setsession      - set session parameters
** Statement syntax:
**                      SET SESSION
**			    [WITH session_param = param_value] 
**			    [READ ONLY]
**			    [READ WRITE]
*/
setsession:         setsessstmt setsessparm
;

setsessstmt:        SETSESSION
    {
        DB_STATUS               status;
        QEF_RCB                 *qef_rcb;

        psq_cb->psq_mode = PSQ_SET_SESSION;

        /* Allocate control block for QEC_ALTER call for set session */
        status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

        status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), (PTR *) &qef_rcb,
            &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

        status = psf_mroot(cb, &cb->pss_ostream, (PTR) qef_rcb, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

        cb->pss_object = (PTR) qef_rcb;

        /*
        ** Fill in the QEF control block.
        ** The acutal session alter parameters will be formatted in
        ** productions below.
        */
        qef_rcb->qef_length     = sizeof(QEF_RCB);
        qef_rcb->qef_type       = QEFRCB_CB;
        qef_rcb->qef_owner      = (PTR)DB_PSF_ID;
        qef_rcb->qef_ascii_id   = QEFRCB_ASCII_ID;
        qef_rcb->qef_eflag      = QEF_INTERNAL;
        qef_rcb->qef_asize      = 0;
	qef_rcb->qef_sess_id    = cb->pss_sessid;
    }
;

setsessparm:	    WITH setsesswith
	|	    setsessam
	|	    ISOLATION LEVEL isolation_level
    {
	psq_cb->psq_ret_flag |= PSQ_SET_ISOLATION;
	psq_cb->psq_isolation = $3;
    }
;

setsesswith:	    setsesstype ISOP setsessaction
;

setsesstype:        nonkeyword
    {
        DB_STATUS               status;
        i4                 err_code;
        QEF_RCB                 *qef_rcb;

        qef_rcb = (QEF_RCB *) cb->pss_object;

        /*
        ** Validate session option.
        **
        ** Currently, the only supported option is "on_error".
        */
        if (STcasecmp($1, "on_error"))
        {
            _VOID_ psf_error(E_PS0F82_SET_SESSION_STMT, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1, (i4) STlength($1), $1);
            return (E_DB_ERROR);    /* non-zero return means error */
        }

        /*
        ** Can only specify this once
        */
        if(psq_cb->psq_ret_flag & PSQ_SET_ON_ERROR)
        {
            (VOID) psf_error(6351L, 0L, PSF_USERERR, &err_code,
                &psq_cb->psq_error, 2,
                (i4) sizeof("SET SESSION")-1, "SET SESSION",
                (i4) sizeof("ON_ERROR")-1, "ON_ERROR");
 
            return E_DB_ERROR;
        }
 
        psq_cb->psq_ret_flag|= PSQ_SET_ON_ERROR;
 

        /*
        ** Allocate memory for alter control block.
        */
        status = psf_malloc(cb, &cb->pss_ostream, (i4) sizeof(QEF_ALT),
            (PTR *) &qef_rcb->qef_alt, &psq_cb->psq_error);
        if (DB_FAILURE_MACRO(status))
            return (status);

        qef_rcb->qef_asize = 1;
        qef_rcb->qef_alt->alt_code = 0;
    }
;

setsessaction:      nonkeyword nonkeyword
    {
        QEF_RCB                 *qef_rcb;
        i4                 err_code;

        /*
        ** Rollback statement on error option.
        */
        qef_rcb = (QEF_RCB *) cb->pss_object;

	/*
	** Verify that specified option is ROLLBACK.
	*/
        if (STcasecmp($1, "rollback") != 0)
	{
            _VOID_ psf_error(E_PS0F84_SET_ONERROR_STMT, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1, (i4) STlength($1), $1);
            return (E_DB_ERROR);
	}

        /*
        ** Validate rollback type - must be STATEMENT or TRANSACTION.
        ** Fill in on_error type in qef_rcb control block.
        */
        if (STcasecmp($2, "statement") == 0)
        {
            qef_rcb->qef_alt->alt_code = QEC_ONERROR_STATE;
            qef_rcb->qef_alt->alt_value.alt_i4 = QEF_STMT_ROLLBACK;
        }
        else if (STcasecmp($2, "transaction") == 0)
        {
            qef_rcb->qef_alt->alt_code = QEC_ONERROR_STATE;
            qef_rcb->qef_alt->alt_value.alt_i4 = QEF_XACT_ROLLBACK;
        }
        else
        {
            _VOID_ psf_error(E_PS0F84_SET_ONERROR_STMT, 0L, PSF_USERERR,
                &err_code, &psq_cb->psq_error, 1, (i4) STlength($2), $2);
            return (E_DB_ERROR);
        }
    }
;

setsessam:	    READ ONLY
	{
	    psq_cb->psq_ret_flag |=  PSQ_SET_ACCESSMODE;
	    psq_cb->psq_accessmode = DMC_C_READ_ONLY;
	}
	    |	    READ WRITE
	{
	    psq_cb->psq_ret_flag |=  PSQ_SET_ACCESSMODE;
	    psq_cb->psq_accessmode = DMC_C_READ_WRITE;
	}
;

setsql:	    SETSQL
    {
	psq_cb->psq_mode = PSQ_SSQL;

	/* Change query language in session control block */
	cb->pss_lang = DB_SQL;
    }
;

setrstruct:	    SETRSTRUCT strsetparam
    {
	i4                err_code;

	/* "set result_structure" is not legal in QUEL. Issue warning */
	psq_cb->psq_mode = PSQ_OBSOLETE;

	if (cb->pss_ses_flag & PSS_WARNINGS)
	{
	    /* "set result_structure" is not supported for quel */
	    (VOID) psf_error(5977L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 0);
	}
    }
;

setstats:	    SETSTATS strsetparam
    {
	DB_STATUS	    status;
	i4		    rngvar_info;
	QEU_CB		    *qeu_cb;
	DMT_CB		    *dmt_cb;
	PSS_RNGTAB	    *rngvar;
	DB_TAB_NAME	    tabname;
	DMT_CHAR_ENTRY	    *chr;
	DB_ERROR	    e_error;
	i4		    err_code;

	psq_cb->psq_mode = PSQ_SSTATS;

	status = psy_ckdbpr(psq_cb, (u_i4) DBPR_TABLE_STATS);

	if (DB_FAILURE_MACRO(status))
	{
	    /*
	    ** Not allowed to change table stats
	    */
	    if ( Psf_srvblk->psf_capabilities & PSF_C_C2SECURE )
	    {
		(VOID)  psy_secaudit(FALSE, cb, 
			$2,
			NULL, 
			STlength($2),
			SXF_E_TABLE, I_SX273C_TABLE_STATS,
			SXF_A_FAIL | SXF_A_CONTROL, 
			&e_error);
	    }

	     (VOID) psf_error(E_PS035B_CANT_ACCESS_TBL_STATS, 
			0L, PSF_USERERR, &err_code, &psq_cb->psq_error, 0);
	    return E_DB_ERROR;
	}

	/* Allocate QEU_CB for SET STATISTICS and initialize its header */
	status = psl_qeucb(cb, DMT_ALTER, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);

	qeu_cb = (QEU_CB *) cb->pss_object;

	/* Allocate a DMT control block */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CB),
	    (PTR *) &dmt_cb, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	qeu_cb->qeu_d_cb = (PTR) dmt_cb;

	/* Fill in the DMT control block header */
	dmt_cb->type = DMT_TABLE_CB;
	dmt_cb->length = sizeof(DMT_CB);
	dmt_cb->dmt_db_id = (char*) cb->pss_dbid;
        dmt_cb->dmt_mustlock = FALSE;

	/* Allocate the characteristics array */
	status = psf_malloc(cb, &cb->pss_ostream, sizeof(DMT_CHAR_ENTRY),
	    (PTR *) &dmt_cb->dmt_char_array.data_address, &psq_cb->psq_error);
	if (status != E_DB_OK)
	    return (status);
	dmt_cb->dmt_char_array.data_in_size = sizeof(DMT_CHAR_ENTRY);

	/* Make the characteristic being changed the journaled bit */
	chr = (DMT_CHAR_ENTRY *) dmt_cb->dmt_char_array.data_address;
	chr->char_id = DMT_C_ZOPTSTATS;
	if ($1 == PSL_ONSET)
	    chr->char_value = DMT_C_ON;
	else
	    chr->char_value = DMT_C_OFF;

	/* Look up the table id */
	STmove($2, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	status = psl_rngent(&cb->pss_auxrng, -1, "", &tabname, cb, FALSE,
	    &rngvar, psq_cb->psq_mode, &psq_cb->psq_error, &rngvar_info, NULL);
	if (status != E_DB_OK)
	    return (status);
	STRUCT_ASSIGN_MACRO(rngvar->pss_tabid, dmt_cb->dmt_id);
    }
;

settrace:	    settracestmnt strsetparam
    {
	i4                err_code;
	SCF_CB		       scf_cb;
	SCF_SCI		       sci_list;
	DB_TERM_NAME	       termname;
	CL_ERR_DESC	       cl_error;
	DB_STATUS	       status;

	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** Possible single parameters are "terminal", "output", "input",
	** "point".  Error is anything else.
	*/
	if (!STcasecmp($2, "terminal"))
	{
	    if ($1 == PSL_ONSET)
	    {
		/* Get user's terminal name */
	        scf_cb.scf_length = sizeof(SCF_CB);
	        scf_cb.scf_type = SCF_CB_TYPE;
	        scf_cb.scf_facility = DB_PSF_ID;
	        scf_cb.scf_session = DB_NOSESSION;
		scf_cb.scf_len_union.scf_ilength = 1;
		/* may cause lint message */
		scf_cb.scf_ptr_union.scf_sci = (SCI_LIST*) &sci_list;
		sci_list.sci_code = SCI_UTTY;
		sci_list.sci_length = sizeof(termname);
		sci_list.sci_aresult = (PTR) &termname;
		sci_list.sci_rlength = NULL;
		status = scf_call(SCU_INFORMATION, &scf_cb);
		if (status == E_DB_OK)
		{
		    /* set trace terminal */
                    if (TRset_file(TR_T_OPEN, termname.db_term_name,
                        sizeof(termname), &cl_error))
                    {
                        (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
                                &psq_cb->psq_error, 1,
                                sizeof (termname.db_term_name),
                                termname.db_term_name);
                    }
		}
		else
		{
		    (VOID) psf_error(E_PS0378_SCF_TERM_ERR,
			scf_cb.scf_error.err_code, PSF_INTERR,
			&err_code, &psq_cb->psq_error, 0);
		}
	    }
	    else
	    {
		/* set notrace terminal */
		TRset_file(TR_T_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp($2, "output"))
	{
	    /* "set trace output" without filename not allowed */
	    if ($1 == PSL_ONSET)
	    {
		(VOID) psf_error(5973L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set notrace output */
		TRset_file(TR_F_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp($2, "input"))
	{
	    /* "set trace input" without filename not allowed */
	    if ($1 == PSL_ONSET)
	    {
		(VOID) psf_error(5973L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set notrace input */
		TRset_file(TR_I_CLOSE, NULL, 0, &cl_error);
	    }
	}
	else if (!STcasecmp($2, "point"))
	{
	    /* "set trace point" without facility code not allowed */
	    (VOID) psf_error(5965L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
	else
	{
	    (VOID) psf_error(5962L, 0L,  PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($2), $2);
	    return (E_DB_ERROR);	/* non-zero return means error */
	}
    }
	  |	    settracestmnt strsetparam strsetparam
    {
	i4                err_code;
	CL_ERR_DESC	       cl_error;

	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** Valid parameters are "terminal", "output", "input", "point".
	** Error if none of these.
	*/
	if (!STcasecmp($2, "terminal"))
	{
	    /* "set notrace terminal" must not have a second parm */
	    if ($1 == PSL_OFFSET)
	    {
		(VOID) psf_error(5963L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace terminal termname */
                if (TRset_file(TR_T_OPEN, $3, STlength($3), &cl_error))
                {
                    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
                        &psq_cb->psq_error, 1,
                        STlength ($3), $3);
                }
	    }
	}
	else if (!STcasecmp($2, "output"))
	{
	    /* "set notrace output" must not have a second parm */
	    if ($1 == PSL_OFFSET)
	    {
		(VOID) psf_error(5964L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace output filename */
                if (TRset_file(TR_F_SAFEOPEN, $3, STlength($3), &cl_error))
                {
                    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
                        &psq_cb->psq_error, 1,
                        STlength ($3), $3);
                }
	    }
	}
	else if (!STcasecmp($2, "input"))
	{
	    /* "set notrace input" must not have a second parm */
	    if ($1 == PSL_OFFSET)
	    {
		(VOID) psf_error(5964L, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 0);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		/* set trace input filename */
                if (TRset_file(TR_I_OPEN, $3, STlength($3), &cl_error))
                {
                    (VOID) psf_error(5988L, 0L, PSF_USERERR, &err_code,
                        &psq_cb->psq_error, 1,
                        STlength ($3), $3);
                }
	    }
	}
	else if (!STcasecmp($2, "point"))
	{
	    PSQ_MODE           facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_DEBUG_CB	       *debug_cb;
	    DB_STATUS	       ret_val;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 0;
	    if ($1 == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code.  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    ** FIXME - facility code is not set */
	    if ((status = getfacil($3, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STlength($3), $3);
		return (E_DB_ERROR);	/* non-zero return means error */
	    }
	    else
	    {
		debug_cb->db_trace_point = flagno;
		psq_cb->psq_mode = facility;

	    	if (   facility == PSQ_QEFTRACE && flagno == QEF_T_NORULES
		    && MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
			    sizeof(DB_OWN_NAME)) != 0
		   )
		{
		    _VOID_ psf_error(E_US18AA_6314_SET_NORULES, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
	  |	    settracestmnt strsetparam strsetparam intconst
    {
	i4	    err_code;

	/*
	** This form of the "set [no]trace command makes sense only with
	** "set [no]trace point".
	*/
	if (!STcasecmp($2, "terminal") ||
	    !STcasecmp($2, "output")   ||
	    !STcasecmp($2, "input"))
	{
	    (VOID) psf_error(5968L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else if (!STcasecmp($2, "point"))
	{
	    PSQ_MODE	       facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_STATUS	       ret_val;
	    DB_DEBUG_CB	       *debug_cb;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 1;
	    debug_cb->db_vals[0] = $4;
	    if ($1 == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code.  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    */
	    if ((status = getfacil($3, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STlength($3), $3);
		return (E_DB_ERROR);
	    }
	    else
	    {
		psq_cb->psq_mode = facility;
		debug_cb->db_trace_point = flagno;

	    	if (   facility == PSQ_QEFTRACE && flagno == QEF_T_NORULES
		    && MEcmp((PTR)&cb->pss_user, (PTR)&cb->pss_dba,
			    sizeof(DB_OWN_NAME)) != 0
		   )
		{
		    _VOID_ psf_error(E_US18AA_6314_SET_NORULES, 0L, PSF_USERERR,
				     &err_code, &psq_cb->psq_error, 0);
		    return (E_DB_ERROR);
		}
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
	  |	    settracestmnt strsetparam strsetparam intconst intconst
    {
	i4	    err_code;

	/*
	** This form of the "set [no]trace" command makes sense only with
	** "set [no]trace point".
	*/
	if (!STcasecmp($2, "terminal") ||
	    !STcasecmp($2, "output")   ||
	    !STcasecmp($2, "input"))
	{
	    (VOID) psf_error(5968L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 0);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
	else if (!STcasecmp($2, "point"))
	{
	    PSQ_MODE	       facility;	/* facility code */
	    i4		       flagno;		/* flag number w/i facility */
	    i4	       status;
	    DB_STATUS	       ret_val;
	    DB_DEBUG_CB	       *debug_cb;

	    /* Allocate the debug control block */
	    ret_val = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_malloc(cb, &cb->pss_ostream, sizeof(DB_DEBUG_CB),
		(PTR *) &debug_cb, &psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    ret_val = psf_mroot(cb, &cb->pss_ostream, (PTR) debug_cb,
		&psq_cb->psq_error);
	    if (ret_val != E_DB_OK)
		return (ret_val);
	    debug_cb->db_value_count = 2;
	    debug_cb->db_vals[0] = $4;
	    debug_cb->db_vals[1] = $5;
	    if ($1 == PSL_ONSET)
		debug_cb->db_trswitch = DB_TR_ON;
	    else
		debug_cb->db_trswitch = DB_TR_OFF;

	    /*
	    ** Decode the facility code.  getfacil() returns an error code
	    ** for psf_error if the facility code doesn't make sense.
	    */
	    if ((status = getfacil($3, &facility, &flagno)) != E_PS0000_OK)
	    {
		(VOID) psf_error(status, 0L, PSF_USERERR, &err_code,
		    &psq_cb->psq_error, 1, (i4) STlength($3), $3);
		return (E_DB_ERROR);
	    }
	    else
	    {
		psq_cb->psq_mode = facility;
		debug_cb->db_trace_point = flagno;
	    }
	}
	else
	{
	    (VOID) psf_error(5962L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) STlength($2), $2);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}
    }
;
	
settracestmnt:	    SETTRACE
    {
	psq_cb->psq_mode = PSQ_STRACE;

	/*
	** "set trace" is allowed in distributed, even though the current
	** spec doesn't list it.
	*/
	$$ = $1;
    }
;

settransaction:     settranstmnt settranmodes
    {
        DB_STATUS               status;
 
        status = psl_st0_settransaction(cb, psq_cb);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;
settranstmnt:       SETTRANSACTION
    {
        DB_STATUS               status;
 
        status = psl_st1_settranstmnt(cb, psq_cb);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;

settranmodes:	    settranmode
	    |	    settranmode COMMA settranmode
;

settranmode:	    settranisolation_level
	   |	    settranaccess_mode
;

settranisolation_level:     ISOLATION LEVEL isolation_level
    {
        DB_STATUS               status;
 
        status = psl_st2_settranisolation_level(cb, &psq_cb->psq_error, 
		(i4)$3);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;

isolation_level:    READ COMMITTED
    {
	$$ = (i4)DMC_C_READ_COMMITTED;
    }
        |           READ UNCOMMITTED
    {
	$$ = (i4)DMC_C_READ_UNCOMMITTED;
    }
        |           REPEATABLE READ
    {
	$$ = (i4)DMC_C_REPEATABLE_READ;
    }
        |           SERIALIZABLE
    {
	$$ = (i4)DMC_C_SERIALIZABLE;
    }
;

settranaccess_mode:  access_mode
    {
        DB_STATUS               status;
 
        status = psl_st3_accessmode(cb, &psq_cb->psq_error, $1);
        if (DB_FAILURE_MACRO(status))
            return(status);
    }
;

access_mode :       READ ONLY
    {
	$$ = (i4)DMC_C_READ_ONLY;
    }
	|           READ WRITE
    {
	$$ = (i4)DMC_C_READ_WRITE; 
    }
;

intsetparam:	    intconst
    {
	$$ = $1;
    }
	  |	    sconst
    {
	i4                     num;
	i4		       err_code;

	/*
	** If a string used in place of an integer can't be converted to an
	** integer, give an error.
	*/
	if (CVal(sconvert($1), &num) != OK)
        {
	    (VOID) psf_error(5969L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, STlength((char *) $1), (char *) $1);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	$$ = num;
    }
;

strsetparam:	    strconst
    {
	$$ = $1;
    }
	  |	    NAME
    {
	$$ = $1;
    }
;

setupdrowcnt:       SETUPDROWCNT changed_or_qualified
    {
        DB_STATUS               status;
        QEF_RCB                 *qef_rcb;

        psq_cb->psq_mode = PSQ_UPD_ROWCNT;

        /* Allocate QEF control block for update_rowcount */
        status = psf_mopen(cb, QSO_QP_OBJ, &cb->pss_ostream, &psq_cb->psq_error);
        if (status != E_DB_OK)
           return (status);
        status = psf_malloc(cb, &cb->pss_ostream, sizeof(QEF_RCB), &cb->pss_object,
                &psq_cb->psq_error);
        if (status != E_DB_OK)
           return (status);
        status = psf_mroot(cb, &cb->pss_ostream, cb->pss_object,
                        &psq_cb->psq_error);
        if (status != E_DB_OK)
           return (status);

        /* Fill in the QEF control block */
        qef_rcb = (QEF_RCB *) cb->pss_object;
        qef_rcb->qef_length = sizeof(QEF_RCB);
        qef_rcb->qef_type = QEFRCB_CB;
        qef_rcb->qef_owner = (PTR)DB_PSF_ID;
        qef_rcb->qef_ascii_id = QEFRCB_ASCII_ID;
	qef_rcb->qef_sess_id = cb->pss_sessid;
        qef_rcb->qef_upd_rowcnt = $2;
      }
;

changed_or_qualified:    nonkeyword 
    {
        i4         err_code;

        if (STcompare($1, "changed") == 0)
           $$ = QEF_ROWCHGD;

        else if (STcompare($1, "qualified") == 0)
           $$ = QEF_ROWQLFD;

        else  /* syntax error */
        {
            /* set update_rowcount syntax error */
            (void) psf_error(E_PS0F85_SET_UPDATE_ROWCOUNT_STMT, 0L, PSF_USERERR, &err_code,
                &psq_cb->psq_error, 1, (i4) STlength($1), $1);
            return (E_DB_ERROR);    /* non-zero return means error */
        }
    }
;

defview:           viewclause tlclause qualclause
    {
	DB_STATUS              status;
	PST_QNODE	       *rootnode;
	PST_RT_NODE	       root;

	/* Make the ROOT node */
	root.pst_rtuser = TRUE;
	root.pst_union.pst_next  = 0;
	root.pst_dups   = PST_ALLDUPS;

	status = pst_node(cb, &cb->pss_ostream, $2, $3, PST_ROOT, (PTR) &root,
	    sizeof(PST_RT_NODE), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
	    &rootnode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	status = psl_cv1_create_view(cb, psq_cb, (PST_QNODE *) NULL, rootnode,
	    (i4) TRUE, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

viewclause:        viewstmnt crname
    {
	PST_STATEMENT	    *snode = (PST_STATEMENT *) cb->pss_object;
	PST_CREATE_VIEW     *crt_view = &snode->pst_specific.pst_create_view;
	QEUQ_CB		    *qeuq_cb = (QEUQ_CB *) crt_view->pst_qeuqcb;
	DMU_CB		    *dmu_cb = (DMU_CB *) qeuq_cb->qeuq_dmf_cb;

	/* Copy the table name into PST_CREATE_VIEW and DMU_CB */
	STmove($2, ' ', sizeof(DB_TAB_NAME), (char *) &crt_view->pst_view_name);
	STRUCT_ASSIGN_MACRO(crt_view->pst_view_name, dmu_cb->dmu_table_name);
    }
;

viewstmnt:	    DEFVIEW
    {
	DB_STATUS	       status;

	status = psl_cv2_viewstmnt(cb, psq_cb, yyvarsp);
	if (DB_FAILURE_MACRO(status))
	    return(status);
    }
;

tlclause:          LPAREN tlist RPAREN
    {
	DB_STATUS	    status;

	if (status = pst_trfix(cb, &cb->pss_ostream, $2, &psq_cb->psq_error))
	    return (status);

	$$ = $2;
    }
;

tlist:		    tlelm
          |	    tlist COMMA tlelm
    {
	/*
	** Attach bulk of target list to leftmost node of new element.
	*/
	$$ = pst_tlprpnd($1, $3);
    }
;

/* For retrieves (not retrieve into), if a list element is "tid", ie
** attribute number DB_IMTID, and if we're in i4-tid compatability mode,
** hack the returned length to the traditional i4 instead of the r3 i8.
** This allows programs (like qbf) which manipulate tids to work across
** Ingres-Net from older version clients.
*/
tlelm:             NAME is afcn
    {
	DB_STATUS              status;
	PST_QNODE	       *resdomnode;
	PST_QNODE	       *varnode;
        DB_ATT_NAME	       colname;

	/* normalize the attribute name */
	STmove((char *)$1, ' ', (u_i4)sizeof(DB_ATT_NAME), (char *)&colname);

	varnode = $3;
	if (cb->pss_parser_compat & PSQ_I4_TIDS)
	{
	    if ( psq_cb->psq_mode == PSQ_RETRIEVE
	      && varnode->pst_sym.pst_type == PST_VAR
	      && varnode->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id == DB_IMTID
	      && varnode->pst_sym.pst_dataval.db_datatype == DB_TID8_TYPE)
	    {
		varnode->pst_sym.pst_dataval.db_length = DB_TID_LENGTH;
	    }
	}
	status = pst_adresdom((char *) &colname, (PST_QNODE *) NULL, $3, cb, 
	    psq_cb, &resdomnode);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = resdomnode;
    }
          |	    attrib
    {
	DB_STATUS	status;
	PST_QNODE	*resdomnode;
	PST_QNODE	*varnode;

	varnode = $1;
	if (cb->pss_parser_compat & PSQ_I4_TIDS)
	{
	    if ( psq_cb->psq_mode == PSQ_RETRIEVE
	      && varnode->pst_sym.pst_type == PST_VAR
	      && varnode->pst_sym.pst_value.pst_s_var.pst_atno.db_att_id == DB_IMTID
	      && varnode->pst_sym.pst_dataval.db_datatype == DB_TID8_TYPE)
	    {
		varnode->pst_sym.pst_dataval.db_length = DB_TID_LENGTH;
	    }
	}
	status =
	  pst_adresdom($1->pst_sym.pst_value.pst_s_var.pst_atname.db_att_name,
	    (PST_QNODE *) NULL, $1, cb, psq_cb, &resdomnode);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = resdomnode;
    }
          |	    var PERIOD ALL
    {
	i4                err_code;
	PST_VAR_NODE	       var;
	DMT_ATT_ENTRY	       **attribute;
	i4		       i;
	PST_QNODE	       *varnode;
	PST_QNODE	       *rsdmnode = (PST_QNODE *) NULL;
	DB_STATUS	       status;

	/* ".all" not allowed in target list for replace */
	if (psq_cb->psq_mode == PSQ_REPLACE)
	{
	    (VOID) psf_error(2123L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Start at first attribute */
	for (i = 0, attribute = $1->pss_attdesc + 1;
	     i < $1->pss_tabdesc->tbl_attr_count;
	     i++, attribute++)
	{
	    if ((*attribute)->att_flags & DMU_F_HIDDEN)
		continue;

	    /* Set up var node for copy into tree */
	    var.pst_vno = $1->pss_rgno;
	    var.pst_atno.db_att_id = (*attribute)->att_number;
	    cui_move((*attribute)->att_nmlen, (*attribute)->att_nmstr, ' ',
		DB_ATT_MAXNAME, var.pst_atname.db_att_name);

	    /* Create the PST_VAR_NODE */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
		(DB_DT_ID) (*attribute)->att_type, (i2) (*attribute)->att_prec,
		(i4) (*attribute)->att_width, (DB_ANYTYPE *) NULL, &varnode,
		&psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /* Create the corresponding result domain node */
	    status = pst_adresdom(var.pst_atname.db_att_name, rsdmnode,
		varnode, cb, psq_cb, &rsdmnode);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

	$$ = rsdmnode;
    }
;

is:                 IS
          |	    BY
	  |	    ISOP /* for compatibility */
;

qualclause:        where qual
    {
	cb->pss_qualdepth--;

	$$ = $2;
    }
          |
    {
	DB_STATUS	status;
	PST_QNODE	*nonode = (PST_QNODE *) NULL;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &nonode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	$$ = nonode;
    }
;

where:             WHERE
    {
	cb->pss_qualdepth++;
    }
;

qual:		    LPAREN qual RPAREN
    {
	$$ = $2;
    }
          |	    NOT qual
    {
	PST_QNODE              *newnode;
	DB_STATUS	       status;

	status = pst_node(cb, &cb->pss_ostream, $2, (PST_QNODE *) NULL, PST_NOT,
	    (PTR) NULL, 0, DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    qual LBOP qual
    {
	PST_QNODE              *newnode;
	DB_STATUS	       status;

	status = pst_node(cb, &cb->pss_ostream, $1, $3, $2,
	    (PTR) NULL, sizeof(PST_OP_NODE), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    clause
    {
	bool result;

	/* Convert a constant-folded clause back into an operator */

	/* Pre-check for a real constant, not ii_true or ii_false. */
	if ($1 && $1->pst_sym.pst_type == PST_CONST
	  && $1->pst_left == NULL
	  && pst_is_const_bool($1, &result))
	{
	    DB_STATUS status;
	    PST_OP_NODE op;
	    PST_QNODE *newnode;

	    MEfill(sizeof(op), 0, &op);
	    op.pst_opno = ADI_IIFALSE_OP;
	    if (result)
		op.pst_opno = ADI_IITRUE_OP;
	    op.pst_opmeta = PST_NOMETA;
	    op.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	    /* No OJ's in quel */
	    /* A shame we can't reuse the true/false node, which was probably
	    ** created out of an operator node anyway!  but it's not worth
	    ** putting in a constant-node flag to figure it out.
	    */
	    status = pst_node(cb,&cb->pss_ostream, NULL, NULL,
			PST_COP, (char *) &op, sizeof(op),
			DB_BOO_TYPE, 0, DB_BOO_LEN, NULL,
			&newnode, &psq_cb->psq_error, 0);
	    if (status != E_DB_OK)
		return (status);
	    $1 = newnode;
	}
	$$ = $1;
    }
;

clause:            afcn relop afcn
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	opnode.pst_opno = $2;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $1, $3, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|    	attrib ISNULL
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	opnode.pst_opno = ADI_ISNUL_OP;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $1, (PST_QNODE*) NULL, PST_UOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	attrib IS NOTNULL
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	opnode.pst_opno = ADI_NONUL_OP;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $1, (PST_QNODE*) NULL, PST_UOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
;

relop:		    EOP
    {
	$$ = $1;
    }
          |	    ISOP
    {
	$$ = $1;
    }
          |	    BDOP
    {
	$$ = $1;
    }
;

afcn:              aggrfcn
    {
	  /* Indicate that there is an aggregate in this tree */
	  cb->pss_stmt_flags |= PSS_AGINTREE;  /* pss_agintree = TRUE */

	/*
	** if processing DEFINE VIEW and this aggregate occurred outside of a
	** view's qualification, remember that this view will be non-updatable
	** and why
	*/
	if (psq_cb->psq_mode == PSQ_VIEW && cb->pss_qualdepth == 0)
	{
	    $Ynonupdt = TRUE;
	    
	    /* ok, ok - so we ARE using SQL terminology... */
	    $Ynonupdt_reason |= PSS_SET_FUNC_IN_OUTERMOST_SUBSEL;
	}
    }
          |	    attribfcn
          |	    afcn BAOP afcn
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	opnode.pst_opno = $2;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $1, $3, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}


	$$ = newnode;
    }
	  |	    afcn BAOPH afcn
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	opnode.pst_opno = $2;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $1, $3, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
	  |	    afcn UAOP afcn
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	opnode.pst_opno = $2;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $1, $3, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}


	$$ = newnode;
    }
          |	    LPAREN afcn RPAREN
    {
	$$ = $2;
    }
          |	    uop afcn            %prec unaryop
    {
	PST_QNODE              *newnode;
	PST_OP_NODE	       opnode;
	DB_STATUS	       status;

	opnode.pst_opno = $1;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $2, (PST_QNODE *) NULL, PST_UOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    func LPAREN afcn RPAREN
    {
	PST_OP_NODE	       opnode;
	PST_QNODE	       *newnode;
	PST_QNODE	       *dec_node = NULL;
	DB_STATUS	       status;


	/* This is a necessary hack for setting default precision and scale
	** for the decimal() conversion function.
	*/
	if ($1 == ADI_DEC_OP)
	{
	    PST_CNST_NODE	cconst;
	    DB_DT_ID		type;
	    i4			len;
	    i2			ps;
	    i4		err_code;


	    type = $3->pst_sym.pst_dataval.db_datatype;
	    len  = $3->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);

	    switch (abs(type))
	    {
	      case DB_FLT_TYPE:
	      case DB_DEC_TYPE:
	      case DB_MNY_TYPE:
	        ps = DB_PS_ENCODE_MACRO(AD_FP_TO_DEC_PREC, AD_FP_TO_DEC_SCALE);
	    	break;

	      case DB_INT_TYPE:
		switch (len)
		{
		  case 1:
		    ps = DB_PS_ENCODE_MACRO(AD_I1_TO_DEC_PREC,
					    AD_I1_TO_DEC_SCALE);
		    break;
		  case 2:
		    ps = DB_PS_ENCODE_MACRO(AD_I2_TO_DEC_PREC,
					    AD_I2_TO_DEC_SCALE);
		    break;
		  case 4:
		    ps = DB_PS_ENCODE_MACRO(AD_I4_TO_DEC_PREC,
					    AD_I4_TO_DEC_SCALE);
		    break;
		}
		break;

	      default:
	        {
		    ADI_DT_NAME		dt_name;

		    /* can't default precision/scale for this datatype */
		    status = adi_tyname((ADF_CB *) cb->pss_adfcb, 
					abs(type), &dt_name);

		    (VOID) psf_error(E_PS0C80_NO_DEFLT_ON_DT, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &dt_name), 
			&dt_name);
		    return (E_DB_ERROR);
		}
	    }

	    /* Now we have the default precision and scale; build a const
	    ** node and put prec_scale in as an i2
	    */
	    cconst.pst_tparmtype = PST_USER;
	    cconst.pst_parm_no = 0;
	    cconst.pst_pmspec  = PST_PMNOTUSED;
	    cconst.pst_cqlang = DB_SQL;
	    cconst.pst_origtxt = (char *) NULL;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
		sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 2,
		(DB_ANYTYPE *) &ps, &dec_node, &psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}
	    
	opnode.pst_opno = $1;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $3, dec_node,
	    (dec_node == NULL)  ?  PST_UOP  :  PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}


	$$ = newnode;
    }
	|	    func LPAREN afcn COMMA afcn RPAREN
    {
	PST_OP_NODE	       opnode;
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

    	/*
        ** The second argument of the two argument version of
    	** ascii(), text(), char() or varchar() functions have to
    	** be a constant.
    	*/
    	if ($1 == ADI_ASCII_OP || $1 == ADI_TEXT_OP || $1 == ADI_CHAR_OP ||
    	    $1 == ADI_VARCH_OP)
        {
    	    DB_DT_ID  type;
    	    i4   err_code;


    	    type  = $5->pst_sym.pst_dataval.db_datatype;

    	    if ($5->pst_sym.pst_type != PST_CONST || abs(type) != DB_INT_TYPE)
    	    {
    	    	(VOID) psf_error(E_PS0C90_MUSTBE_CONST_INT, 0L,
    	    	    PSF_USERERR, &err_code, &psq_cb->psq_error, 0);
    	    	    return (E_DB_ERROR);
    	    }
    	}

	/* This is a necessary hack for setting default scale for the
	** decimal() conversion function.
	*/
	if ($1 == ADI_DEC_OP)
	{
	    DB_DT_ID		type;
	    i4			plen;
	    i4			len;
	    PTR			pdata;
	    i2			ps;
	    i4			err_code;
	    i8			prec;

	    /* must be a const node */
	    if ($5->pst_sym.pst_type != PST_CONST)
	    {
		(VOID) psf_error(E_PS0C81_MUST_BE_CONST, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    type  = $5->pst_sym.pst_dataval.db_datatype;
	    plen  = $5->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	    pdata = $5->pst_sym.pst_dataval.db_data;

	    /* must be an i2 with valid precision */
	    if (abs(type) != DB_INT_TYPE ||
		(prec = (plen == 2 ? *(i2 *)pdata :
		 plen == 4 ? *(i4 *)pdata :
		 plen == 8 ? *(i8 *)pdata :0)) < 1 ||
		prec > DB_MAX_DECPREC
		)
	    {
		(VOID) psf_error(E_PS0C82_BAD_PRECISION, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    /* check input type and get default scale based on it */
	    type = $3->pst_sym.pst_dataval.db_datatype;
	    len  = $3->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);

	    switch (abs(type))
	    {
	      case DB_FLT_TYPE:
	      case DB_DEC_TYPE:
	      case DB_MNY_TYPE:
	        ps = DB_PS_ENCODE_MACRO(*(i2 *)pdata, AD_FP_TO_DEC_SCALE);
		break;

	      case DB_INT_TYPE:
		switch (len)
		{
		  case 1:
		    ps = DB_PS_ENCODE_MACRO(prec, AD_I1_TO_DEC_SCALE);
		    break;
		  case 2:
		    ps = DB_PS_ENCODE_MACRO(prec, AD_I2_TO_DEC_SCALE);
		    break;
		  case 4:
		    ps = DB_PS_ENCODE_MACRO(prec, AD_I4_TO_DEC_SCALE);
		    break;
		  case 8:
		    ps = DB_PS_ENCODE_MACRO(prec, AD_I8_TO_DEC_SCALE);
		    break;
		}
		break;

	      default:
	        {
		    ADI_DT_NAME		dt_name;

		    /* can't default precision/scale for this datatype */
		    status = adi_tyname((ADF_CB *) cb->pss_adfcb, 
					abs(type), &dt_name);

		    (VOID) psf_error(E_PS0C80_NO_DEFLT_ON_DT, 0L, PSF_USERERR,
			&err_code, &psq_cb->psq_error, 1,
			psf_trmwhite(sizeof(ADI_DT_NAME), (char *) &dt_name), 
			&dt_name);
		    return (E_DB_ERROR);
		}
	    }

	    /*
	    ** store precision and scale back in const node representing the
	    ** second argument
	    */
	    if (plen != sizeof(i2))
	    {
		/* Fixup data length to i2 */
		$5->pst_sym.pst_dataval.db_length = sizeof(i2);
		if (type < 0)
		{
		    pdata[sizeof(i2)] = pdata[plen];
		    $5->pst_sym.pst_dataval.db_length++;
		}
	    }
	    *(i2 *)pdata = ps;
	}

	opnode.pst_opno = $1;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $3, $5, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    func LPAREN RPAREN
    {
	PST_OP_NODE	       opnode;
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

	opnode.pst_opno = $1;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_COP, (char *) &opnode, sizeof(opnode),
	    DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL, &newnode,
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}


	$$ = newnode;
    }
	|	    func LPAREN afcn COMMA afcn COMMA afcn RPAREN
    {
	PST_OP_NODE	       opnode;
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

	/* This is a necessary hack for getting precision and scale
	** combined into one const node for the decimal() conversion function.
	*/
	if ($1 == ADI_DEC_OP)
	{
	    DB_DT_ID		type;
	    i4			plen;
	    i4			slen;
	    PTR			pdata;
	    PTR			sdata;
	    i4			err_code;
	    i4			prec;
	    i4			scale;

	    /* must be a const node */
	    if (    $5->pst_sym.pst_type != PST_CONST
		||  $7->pst_sym.pst_type != PST_CONST
	       )
	    {
		(VOID) psf_error(E_PS0C81_MUST_BE_CONST, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    type  = $5->pst_sym.pst_dataval.db_datatype;
	    plen  = $5->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	    pdata = $5->pst_sym.pst_dataval.db_data;

	    /* must be an int with valid precision */
	    if (abs(type) != DB_INT_TYPE ||
		(prec = (plen == 2 ? *(i2 *)pdata :
			 plen == 4 ? *(i4 *)pdata :
			 plen == 8 ? *(i8 *)pdata :0)) < 1 ||
		prec > DB_MAX_DECPREC
		)
	    {
		(VOID) psf_error(E_PS0C82_BAD_PRECISION, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 0);
		return (E_DB_ERROR);
	    }

	    type  = $7->pst_sym.pst_dataval.db_datatype;
	    slen   = $7->pst_sym.pst_dataval.db_length - ((type < 0) ? 1 : 0);
	    sdata = $7->pst_sym.pst_dataval.db_data;

	    /* must be an int with valid scale */
	    if (abs(type) != DB_INT_TYPE  ||
		(scale = (slen == 2 ? *(i2 *)sdata :
			  slen == 4 ? *(i4 *)sdata :
			  slen == 8 ? *(i8 *)sdata :-1)) < 0 ||
		scale > prec
		)
	    {
		(VOID) psf_error(E_PS0C83_BAD_SCALE, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 1, plen, pdata);
		return (E_DB_ERROR);
	    }

	    /*
	    ** store precision and scale back in const node representing the
	    ** second argument
	    */
	    if (plen != sizeof(i2))
	    {
		/* Fixup data length to i2 */
		$5->pst_sym.pst_dataval.db_length = sizeof(i2);
		if (type < 0)
		{
		    pdata[sizeof(i2)] = pdata[plen];
		    $5->pst_sym.pst_dataval.db_length++;
		}
	    }
	    /* combine prec and scale into second node and orphan the
	    ** scale's CONST node
	    */
	    *(i2 *)pdata = DB_PS_ENCODE_MACRO(prec, scale);
	}

	opnode.pst_opno = $1;
	opnode.pst_opmeta = PST_NOMETA;
	opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	status = pst_node(cb, &cb->pss_ostream, $3, $5, PST_BOP,
	    (char *) &opnode, sizeof(opnode), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
;

func:		    NAME
    {
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	       status;
	i4		       err_code;

	STmove($1, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	status = adi_opid(adf_scb, &funcname, &opid);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STlength($1), $1);
	    return (E_DB_ERROR);
	}

	$$ = opid;
    }
;

aggrfcn:           AGOP LPAREN aggtarg BY domseq aggfcnwhere qual RPAREN
    {
	PST_OP_NODE            operator;
	PST_RT_NODE	       aghead;
	PST_QNODE	       *agopnode;
	PST_QNODE	       *byheadnode;
	PST_QNODE	       *agheadnode;
	PST_QNODE	       *treenode;
	DB_STATUS	       status;
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	i4		       err_code;

	/* mark that aggregate function exists */
	$Yagg_func = 1;

	cb->pss_qualdepth--;

	/* Assign the result domain numbers */
	pst_windup($5);

	/* Create the aggregate operator node */

	/* Get the operator id for this function */
	STmove($1, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	status = adi_opid(adf_scb, &funcname, &opid);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STlength($1), $1);
	    return (E_DB_ERROR);
	}

	operator.pst_opno = opid;
	operator.pst_retnull = FALSE;
	operator.pst_opmeta = PST_NOMETA;
	operator.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	if (($1)[STlength($1)-1] == 'u')
	    operator.pst_distinct = PST_DISTINCT;
	else if (!MEcmp((PTR) $1,(PTR) "min", 3) ||
		 !MEcmp((PTR) $1,(PTR) "max", 3)	||
		 !MEcmp((PTR) $1,(PTR) "any", 3)
		)
	    operator.pst_distinct = PST_DONTCARE;
	else
	    operator.pst_distinct = PST_NDISTINCT;

	status = pst_node(cb, &cb->pss_ostream, $3, (PST_QNODE *) NULL, PST_AOP,
	    (char *) &operator, sizeof(operator), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &agopnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* Create the byhead node */
	status = pst_node(cb, &cb->pss_ostream, $5, agopnode, PST_BYHEAD,
	    (PTR) NULL, sizeof(PST_RSDM_NODE),
	    agopnode->pst_sym.pst_dataval.db_datatype,
	    agopnode->pst_sym.pst_dataval.db_prec,
	    agopnode->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &byheadnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* Create the aghead node */
	aghead.pst_union.pst_next  = 0;
	aghead.pst_dups   = PST_ALLDUPS;

	status = pst_node(cb, &cb->pss_ostream, byheadnode, $7, PST_AGHEAD,
	    (PTR) &aghead, sizeof(PST_RT_NODE),
	    agopnode->pst_sym.pst_dataval.db_datatype,
	    agopnode->pst_sym.pst_dataval.db_prec,
	    agopnode->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &agheadnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* pst_project is set to FALSE in pst_node(); here we reset it to $6 */
	agheadnode->pst_sym.pst_value.pst_s_root.pst_project = $6;

	/* Create the tree node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &treenode, &psq_cb->psq_error,
	    (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* Prepend the tree node to the aggregate result domain list */
	$$ = pst_tlprpnd(treenode, agheadnode);
    }
	  |	    AGOP LPAREN aggtarg BY domseq RPAREN
    {
	PST_OP_NODE            operator;
	PST_RT_NODE	       aghead;
	PST_QNODE	       *agopnode;
	PST_QNODE	       *byheadnode;
	PST_QNODE	       *agheadnode;
	PST_QNODE	       *treenode;
	PST_QNODE	       *nonode = (PST_QNODE *) NULL;
	DB_STATUS	       status;
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	i4		       err_code;

	/* mark that aggregate function exists */
	$Yagg_func = 1;
	/* Assign the result domain numbers */
	pst_windup($5);

	/* Create the aggregate operator node */

	/* Get the operator id for this function */
	STmove($1, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	status = adi_opid(adf_scb, &funcname, &opid);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STlength($1), $1);
	    return (E_DB_ERROR);
	}

	operator.pst_opno = opid;
	operator.pst_retnull = FALSE;
	operator.pst_opmeta = PST_NOMETA;
	operator.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	if (($1)[STlength($1)-1] == 'u')
	    operator.pst_distinct = PST_DISTINCT;
	else if (!MEcmp((PTR) $1,(PTR) "min", 3) ||
		!MEcmp((PTR) $1,(PTR) "max", 3))
	    operator.pst_distinct = PST_DONTCARE;
	else
	    operator.pst_distinct = PST_NDISTINCT;
	status = pst_node(cb, &cb->pss_ostream, $3, (PST_QNODE *) NULL, PST_AOP,
	    (char *) &operator, sizeof(operator), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &agopnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* Create the byhead node */
	status = pst_node(cb, &cb->pss_ostream, $5, agopnode, PST_BYHEAD,
	    (PTR) NULL, sizeof(PST_RSDM_NODE),
	    agopnode->pst_sym.pst_dataval.db_datatype,
	    agopnode->pst_sym.pst_dataval.db_prec,
	    agopnode->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &byheadnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_QLEND, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &nonode, &psq_cb->psq_error, (i4) 0);
	if (DB_FAILURE_MACRO(status))
	{
	    return (status);
	}

	/* Create the aghead node */
	/* don't project since there is no qualification in aggregate */
	aghead.pst_union.pst_next  = 0;
	aghead.pst_dups   = PST_ALLDUPS;

	status = pst_node(cb, &cb->pss_ostream, byheadnode, nonode, PST_AGHEAD,
	    (PTR) &aghead, sizeof(PST_RT_NODE),
	    agopnode->pst_sym.pst_dataval.db_datatype,
	    agopnode->pst_sym.pst_dataval.db_prec,
	    agopnode->pst_sym.pst_dataval.db_length,
	    (DB_ANYTYPE *) NULL, &agheadnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* Create the tree node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_TREE, (PTR) NULL, 0, DB_NODT, (i2) 0,
	    (i4) 0, (DB_ANYTYPE *) NULL, &treenode, &psq_cb->psq_error,
	    (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* Prepend the tree node to the aggregate result domain list */
	$$ = pst_tlprpnd(treenode, agheadnode);
    }
          |	    AGOP LPAREN aggtarg qualclause RPAREN
    {
	PST_OP_NODE            operator;
	PST_QNODE	       *agopnode;
	PST_QNODE	       *aghdnode;
	PST_RT_NODE	       aghead;
        DB_STATUS	       status;
	ADI_OP_NAME	       funcname;
	ADI_OP_ID	       opid;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	i4		       err_code;

	/* Allocate the aggregate operator node */
	STmove($1, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	status = adi_opid(adf_scb, &funcname, &opid);
	if (status != E_DB_OK)
	{
	    (VOID) psf_error(2906L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) STlength($1), $1);
	    return (E_DB_ERROR);
	}

	operator.pst_opno = opid;
	operator.pst_retnull = FALSE;
	operator.pst_opmeta = PST_NOMETA;
	operator.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	if (($1)[STlength($1)-1] == 'u')
	    operator.pst_distinct = PST_DISTINCT;
	else if (!MEcmp((PTR) $1,(PTR) "min", 3) ||
		!MEcmp((PTR) $1,(PTR) "max", 3))
	    operator.pst_distinct = PST_DONTCARE;
	else
	    operator.pst_distinct = PST_NDISTINCT;
	status = pst_node(cb, &cb->pss_ostream, $3, (PST_QNODE *) NULL, PST_AOP,
	    (char *) &operator, sizeof(operator), DB_NODT, (i2) 0, (i4) 0,
	    (DB_ANYTYPE *) NULL, &agopnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	aghead.pst_union.pst_next  = 0;
	aghead.pst_dups   = PST_ALLDUPS;

	/* Allocate the aghead node */
	status = pst_node(cb, &cb->pss_ostream, agopnode, $4, PST_AGHEAD, 
	    (PTR) &aghead,
	    sizeof(PST_RT_NODE), agopnode->pst_sym.pst_dataval.db_datatype,
	    agopnode->pst_sym.pst_dataval.db_prec,
	    agopnode->pst_sym.pst_dataval.db_length, (DB_ANYTYPE *) NULL,
	    &aghdnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = aghdnode;
    }
;

aggtarg:	    afcn
    {
	$$ = $1;
    }
	|	    var PERIOD ALL
    {
	PST_VAR_NODE	       var;
	DMT_ATT_ENTRY	       **attribute;
	PST_QNODE	       *varnode;
	DB_STATUS	       status;

	/* just use first attribute */
	attribute = &$1->pss_attdesc[1];
	/* Set up var node for copy into tree */
	var.pst_vno = $1->pss_rgno;
	var.pst_atno.db_att_id = (*attribute)->att_number;
	cui_move((*attribute)->att_nmlen, (*attribute)->att_nmstr, ' ',
		DB_ATT_MAXNAME, var.pst_atname.db_att_name);

	/* Create the PST_VAR_NODE */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
	    (DB_DT_ID) (*attribute)->att_type,
	    (i2) (*attribute)->att_prec, (i4) (*attribute)->att_width,
	    (DB_ANYTYPE *) NULL, &varnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}
	$$ = varnode;
    }
;

aggfcnwhere:	    WHERE
    {
	cb->pss_qualdepth++;
	$$ = (cb->pss_ses_flag & PSS_PROJECT);
    }
	  |	    ONLYWHERE
    {
	cb->pss_qualdepth++;
	$$ = FALSE;
    }
;

domseq:		    targdom
          |	    domseq COMMA targdom
    {
	$$ = pst_tlprpnd($1, $3);
    }
;

targdom:           afcn
    {
	PST_QNODE              *newnode;
	DB_STATUS	       status;
	PST_RSDM_NODE	       rsdom;

	rsdom.pst_rsno = 0;
	rsdom.pst_ntargno = rsdom.pst_rsno;
	rsdom.pst_ttargtype = PST_USER;
	rsdom.pst_rsupdt = FALSE;
	rsdom.pst_rsflags = PST_RS_PRINT;
	rsdom.pst_dmuflags = 0;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL, $1,
	    PST_RESDOM, (PTR) &rsdom, sizeof(PST_RSDM_NODE),
	    $1->pst_sym.pst_dataval.db_datatype, 
	    $1->pst_sym.pst_dataval.db_prec,
	    $1->pst_sym.pst_dataval.db_length, (DB_ANYTYPE *) NULL,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    var PERIOD ALL
    {
	PST_VAR_NODE	       var;
	DMT_ATT_ENTRY	       **attribute;
	i4		       i;
	PST_QNODE	       *varnode;
	PST_QNODE	       *rsdmnode = (PST_QNODE *) NULL;
	DB_STATUS	       status;
	PST_RSDM_NODE	       rsdom;

	rsdom.pst_rsno = 0;
	rsdom.pst_ntargno = rsdom.pst_rsno;
	rsdom.pst_ttargtype = PST_USER;
	rsdom.pst_rsupdt = FALSE;
	rsdom.pst_rsflags = PST_RS_PRINT;
	rsdom.pst_dmuflags = 0;

	/* Start at first attribute */
	for (i = 0, attribute = $1->pss_attdesc + 1;
	     i < $1->pss_tabdesc->tbl_attr_count;
	     i++, attribute++)
	{
	    if ((*attribute)->att_flags & DMU_F_HIDDEN)
		continue;

	    /* Set up var node for copy into tree */
	    var.pst_vno = $1->pss_rgno;
	    var.pst_atno.db_att_id = (*attribute)->att_number;
	    cui_move((*attribute)->att_nmlen, (*attribute)->att_nmstr, ' ',
		DB_ATT_MAXNAME, var.pst_atname.db_att_name);

	    /* Create the PST_VAR_NODE */
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_VAR, (char *) &var, sizeof(var),
		(DB_DT_ID) (*attribute)->att_type,
		(i2) (*attribute)->att_prec, (i4) (*attribute)->att_width,
		(DB_ANYTYPE *) NULL, &varnode, &psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }

	    /* Create the corresponding result domain node */
	    status = pst_node(cb, &cb->pss_ostream, rsdmnode, varnode,
		PST_RESDOM, (PTR) &rsdom, sizeof(PST_RSDM_NODE),
		(DB_DT_ID) (*attribute)->att_type,
		(i2) (*attribute)->att_prec, (i4) (*attribute)->att_width,
		(DB_ANYTYPE *) NULL, &rsdmnode,	&psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}

	$$ = rsdmnode;
    }
;

attrib:            var PERIOD NAME
    {
	DMT_ATT_ENTRY          *attribute;
	PST_VAR_NODE	       varnode;
	PST_QNODE	       *newnode;
	i4		       err_code;
	DB_STATUS	       status;

	/* Normalize the attribute name */
	STmove($3, ' ', sizeof(DB_ATT_NAME), (char *) &varnode.pst_atname);

	/* Look up the attribute */
	attribute = pst_coldesc($1, varnode.pst_atname.db_att_name, DB_ATT_MAXNAME);

	/* Check for attribute not found */
	if (attribute == (DMT_ATT_ENTRY *) NULL)
	{
	    (VOID) psf_error(2100L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 4, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno, (i4) sizeof(DB_TAB_NAME),
		&($1->pss_tabname), (i4) sizeof(DB_OWN_NAME),
		&($1->pss_ownname), (i4) STlength($3), $3);
	    return (E_DB_ERROR);
	}
		
	/* Set up var node for copy into tree */
	varnode.pst_vno = $1->pss_rgno;
	varnode.pst_atno.db_att_id = attribute->att_number;

	/* Create the node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode, sizeof(varnode),
	    (DB_DT_ID) attribute->att_type,
	    (i2) attribute->att_prec, (i4) attribute->att_width,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
	|	    var PERIOD COLNO
    {
	DMT_ATT_ENTRY          *attribute;
	PST_VAR_NODE	       varnode;
	PST_QNODE	       *newnode;
	DB_STATUS	       status;

	/* (schka24) I don't think there's any way to generate a COLNO
	** token???  so I don't think you can get here...
	*/

	/* Get the attribute */
	attribute = $1->pss_attdesc[$3];

	/* Normalize the attribute name */
	cui_move(attribute->att_nmlen, attribute->att_nmstr, ' ',
		DB_ATT_MAXNAME, varnode.pst_atname.db_att_name);
		
	/* Set up var node for copy into tree */
	varnode.pst_vno = $1->pss_rgno;
	varnode.pst_atno.db_att_id = attribute->att_number;

	/* Create the node */
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode, sizeof(varnode),
	    (DB_DT_ID) attribute->att_type,
	    (i2) attribute->att_prec, (i4) attribute->att_width,
	    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
;

var:               NAME
    {
	DB_STATUS              status;
	PSS_RNGTAB	       *rngtab;
	DB_TAB_NAME	       tabname;

	/* Look for an already-existing range var of this name */
	status = pst_rglook(cb, &cb->pss_usrrange, -1, $1, TRUE, 
	    &rngtab, psq_cb->psq_mode, &psq_cb->psq_error);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/* If not found, try entering it */
	if (rngtab == (PSS_RNGTAB *) NULL)
	{
	    i4	    rngvar_info;
	    
	    /* normalize the table name */
	    STmove($1, ' ', sizeof(DB_TAB_NAME), (char *) &tabname);
	    status = psl_rngent(&cb->pss_usrrange, -1, $1, &tabname, cb,
		FALSE, &rngtab, psq_cb->psq_mode, &psq_cb->psq_error,
		&rngvar_info, NULL);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}
	$$ = rngtab;
    }
	|	    VAR
    {
	PSS_RNGTAB	       *rngvar = cb->pss_usrrange.pss_rngtab;
	i4			i;
	i4			err_code;

	/* Scan the range table looking for the range variable */
	for (i = 0; i < PST_NUMVARS; i++)
	{
	    if (rngvar->pss_used && rngvar->pss_rgno == *$1)
	    {
		$$ = rngvar;
		break;
	    }

	    rngvar++;
	}

	/* Internal error if we didn't find it */
	if (i >= PST_NUMVARS)
	{
	    (VOID) psf_error(E_PS0908_RANGE_VAR_MISSING, 0L, PSF_INTERR,
		&err_code, &psq_cb->psq_error, 2, sizeof(cb->pss_lineno),
		&cb->pss_lineno, sizeof(*$1), $1);
	    return (E_DB_SEVERE);
	}
    }
;

attribfcn:         I2CONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* Non-parameter i2 constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 2, (DB_ANYTYPE *) $1,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    I4CONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* Non-parameter i4 constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_INT_TYPE, (i2) 0, (i4) 4, (DB_ANYTYPE *) $1,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
		|	DECCONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;
	i2			prec;

	/* Non-parameter decimal constant node */
	I2ASSIGN_MACRO(*$1, prec);
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_DEC_TYPE, (i2) prec,
	    (i4) DB_PREC_TO_LEN_MACRO(DB_P_DECODE_MACRO(prec)),
	    (DB_ANYTYPE *) ((u_char *)$1 + sizeof(i2)),
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    F4CONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* Non-parameter f4 constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_FLT_TYPE, (i2) 0, (i4) 4, (DB_ANYTYPE *) $1,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    F8CONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* Non-parameter f8 constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_FLT_TYPE, (i2) 0, (i4) 8, (DB_ANYTYPE *) $1,
	    &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    SCONST
    {
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	i4		reqs = 0;
	i4		lines = 0;
	bool		pmchars;
	i4		err_code;
	DB_STATUS	status;
	DB_DATA_VALUE	dv;
	DB_TEXT_STRING	*str;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;

	str = $1;

	dv.db_data = (PTR) str;
	dv.db_length = str->db_t_count + DB_CNTSIZE;
	dv.db_datatype = DB_VCH_TYPE;
	dv.db_prec = 0;

	reqs |= (ADI_DO_BACKSLASH | ADI_DO_MOD_LEN);
	if (cb->pss_qualdepth)
	{
	    reqs |= ADI_DO_PM;
	}

	status = adi_pm_encode(adf_scb, reqs, &dv, &lines, &pmchars);
	cb->pss_lineno += lines;

	if (DB_FAILURE_MACRO(status))
	{
	    switch (adf_scb->adf_errcb.ad_errcode)
	    {
		case E_AD1015_BAD_RANGE:
		case E_AD3050_BAD_CHAR_IN_STRING:
		    {
			(VOID) psf_adf_error(&adf_scb->adf_errcb, 
					     &psq_cb->psq_error, cb);
			break;
		    }
		default:
		    {
			(VOID) psf_error(E_PS0377_ADI_PM_ERR,
			    adf_scb->adf_errcb.ad_errcode, PSF_INTERR,
			    &err_code, &psq_cb->psq_error, 0);
		    }
	    }
	    return (status);
	}

	/* Non-parameter text constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;

	if (pmchars == TRUE)
	{
	    cconst.pst_pmspec  = PST_PMUSED;
	}

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_VCH_TYPE, (i2) 0,
	    (i4) ($1->db_t_count + DB_CNTSIZE), (DB_ANYTYPE *) $1, &newnode,
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    HEXCONST
    {
	DB_STATUS              status;
	PST_CNST_NODE	       cconst;
	PST_QNODE	       *newnode;

	/* hex constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;
	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), DB_VCH_TYPE, (i2) 0,
	    (i4) ($1->db_t_count + DB_CNTSIZE),
	    (DB_ANYTYPE *) $1, &newnode, &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = newnode;
    }
          |	    QDATA
    {
	PST_CNST_NODE	cconst;
	PST_QNODE	*newnode;
	DB_DATA_VALUE	*dbval;
	i4		reqs = 0;
	i4		lines = 0;
	bool		pmchars = FALSE;
	i4		err_code;
	DB_STATUS	status;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;

	dbval = (DB_DATA_VALUE*) $1;

	/*
	** In case of data coming from host lang. variable, no
	** modifications must be made, except for PM in qualifications.
	*/
	if (cb->pss_qualdepth)
	{
	    reqs |= ADI_DO_PM;
	    status = adi_pm_encode(adf_scb, reqs, dbval, &lines, &pmchars);
	    cb->pss_lineno += lines;

	    if (DB_FAILURE_MACRO(status))
	    {
		switch (adf_scb->adf_errcb.ad_errcode)
		{
		    case E_AD1015_BAD_RANGE:
		    case E_AD3050_BAD_CHAR_IN_STRING:
			{
			    (VOID) psf_adf_error(&adf_scb->adf_errcb,
						 &psq_cb->psq_error, cb);
			    break;
			}
		    default:
			{
			    (VOID) psf_error(E_PS0377_ADI_PM_ERR,
				adf_scb->adf_errcb.ad_errcode, PSF_INTERR,
				&err_code, &psq_cb->psq_error, 0);
			}
		}
		return (status);
	    }
	}

	/* Non-parameter arbitrary constant node */
	cconst.pst_tparmtype = PST_USER;
	cconst.pst_parm_no = 0;
	cconst.pst_pmspec  = (pmchars) ? PST_PMUSED : PST_PMNOTUSED;
	cconst.pst_cqlang = DB_QUEL;
	cconst.pst_origtxt = (char *) NULL;

	status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	    (PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
	    sizeof(cconst), dbval->db_datatype, dbval->db_prec,
	    (i4) (dbval->db_length), (DB_ANYTYPE *) dbval->db_data, &newnode,
	    &psq_cb->psq_error, (i4) 0);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** if parsing a repeat query, remember that it contained a non-repeat
	** parameter - this query will not be shareable
	*/
	if (cb->pss_defqry == PSQ_DEFQRY)
	{
	    $Yqry_mask |= PSS_NONREPEAT_PARAM;

	    /*
	    ** As a part of the algorithm for verifying shareability of QUEL
	    ** repeat queries, we save query text; once we know that the query
	    ** will not be shareable, we might as well stop saving its text
	    */
	    cb->pss_stmt_flags &= ~PSS_QUEL_RPTQRY_TEXT;
	}

	$$ = newnode;
    }
	  |	    NAME
    {
	PST_OP_NODE	       opnode;
	PST_QNODE	       *newnode = (PST_QNODE *) NULL;
	ADI_OP_NAME	       funcname;
	ADF_CB		       *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_STATUS	       status;
        i4		       err_code;

	/*
	** If we are doing a "replace cursor", look for a column in the
	** table/view over which the cursor was defined (as opposed to the
	** column in the FOR UPDATE list, as it used to do)
	*/
	if (psq_cb->psq_mode == PSQ_REPCURS)
	{
	    DB_ATT_NAME		colname;
	    DMT_ATT_ENTRY	*att_entry;

	    STmove($1, ' ', sizeof(DB_ATT_NAME), colname.db_att_name);
	    att_entry = pst_coldesc(cb->pss_resrng, colname.db_att_name, 
			DB_ATT_MAXNAME);

	    if (att_entry != (DMT_ATT_ENTRY *) NULL)
	    {
		PST_VAR_NODE	    varnode;

		varnode.pst_vno	= cb->pss_resrng->pss_rgno;
		varnode.pst_atno.db_att_id = att_entry->att_number;

		status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		    (PST_QNODE *) NULL, PST_VAR, (char *) &varnode,
		    sizeof(varnode), (DB_DT_ID) att_entry->att_type,
		    (i2) att_entry->att_prec, (i4) att_entry->att_width,
		    (DB_ANYTYPE *) NULL, &newnode, &psq_cb->psq_error, (i4) 0);
		if (status != E_DB_OK)
		{
		    return (status);
		}
	    }
	}

	/* check to see if NULL */
	if (!cb->pss_qualdepth && MEcmp((PTR) "null", (PTR) $1, 4) == 0)
	{
	    DB_STATUS               status;
	    PST_CNST_NODE	    cconst;
	    DB_DATA_VALUE	    db_data;
	    char		    buf[5];

	    db_data.db_datatype = -DB_LTXT_TYPE;
	    db_data.db_prec	= 0;
	    db_data.db_length	= DB_CNTSIZE + 1;
	    db_data.db_data	= (PTR) buf;

	    status = adc_getempty ((ADF_CB *) cb->pss_adfcb, &db_data);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	    /* NULL constant node */
	    cconst.pst_tparmtype = PST_USER;
	    cconst.pst_parm_no = 0;
	    cconst.pst_pmspec  = PST_PMNOTUSED;
	    cconst.pst_cqlang = DB_QUEL;
	    cconst.pst_origtxt = (char *) NULL;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
		(PST_QNODE *) NULL, PST_CONST, (char *) &cconst,
		sizeof(cconst), -DB_LTXT_TYPE, (i2) 0, (i4) (1 + DB_CNTSIZE),
		(DB_ANYTYPE *) db_data.db_data, &newnode, &psq_cb->psq_error,
		(i4) 0);
	    if (status != E_DB_OK)
	    {
		return (status);
	    }
	}
	/* If it's not a cursor column, look for a non-ary function */
	else if (newnode == (PST_QNODE *) NULL)
	{
	    STmove($1, '\0', sizeof(ADI_OP_NAME), (char *) &funcname);
	    status = adi_opid(adf_scb, &funcname, &opnode.pst_opno);
	    if (status != E_DB_OK)
	    {
		(VOID) psf_error(2906L, 0L, PSF_USERERR,
		    &err_code, &psq_cb->psq_error, 2,
		    (i4) sizeof(cb->pss_lineno), &cb->pss_lineno,
		    (i4) STlength($1), $1);
		return (E_DB_ERROR);
	    }

	    opnode.pst_opmeta = PST_NOMETA;
	    opnode.pst_pat_flags = AD_PAT_DOESNT_APPLY;
	    status = pst_node(cb, &cb->pss_ostream, (PST_QNODE *) NULL,
	        (PST_QNODE *) NULL, PST_COP, (char *) &opnode,
		sizeof(opnode), DB_NODT, (i2) 0, (i4) 0, (DB_ANYTYPE *) NULL,
		&newnode, &psq_cb->psq_error, (i4) 0);
	    if (status != E_DB_OK)
	    {
	        return (status);
	    }

	}

	$$ = newnode;
    }
          |	    param
          |	    attrib
;

param:             DOLLAR I2CONST is NAME
    {
	i4                err_code;
	PST_QNODE	       *parmnode;
	DB_STATUS	       status;

	/* parameters not allowed in non-repeat queries */
	if (cb->pss_defqry == 0)
	{
	    (VOID) psf_error(2110L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a constant node with a parameter number */
	status = pst_adparm(cb, psq_cb, &cb->pss_ostream, *$2 + 1, $4,
	    &parmnode, &cb->pss_highparm);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	$$ = parmnode;
    }
	    |		DOLLAR I2CONST ISOP QDATA
    {
	i4                err_code;
	PST_QNODE	       *parmnode;
	DB_STATUS	       status;

	/* parameters not allowed in non-repeat queries */
	if (cb->pss_defqry == 0)
	{
	    (VOID) psf_error(2110L, 0L, PSF_USERERR, &err_code,
		&psq_cb->psq_error, 1, (i4) sizeof(cb->pss_lineno),
		&cb->pss_lineno);
	    return (E_DB_ERROR);    /* non-zero return means error */
	}

	/* Allocate a constant node with a parameter number */
	status = pst_2adparm(cb, psq_cb, &cb->pss_ostream, *$2, $4,
	    &parmnode, &cb->pss_highparm);
	if (status != E_DB_OK)
	{
	    return (status);
	}

	/*
	** if this is a repeat query, remember if the current parameter contains
	** pattern-matching characters; if so, the query will NOT be shareable
	*/
	if (cb->pss_defqry == PSQ_DEFQRY &&
	    parmnode->pst_sym.pst_value.pst_s_cnst.pst_pmspec == PST_PMUSED)
	{
	    $Yqry_mask |= PSS_PM_IN_REPEAT_PARAM;

	    /*
	    ** As a part of the algorithm for verifying shareability of QUEL
	    ** repeat queries, we save query text; once we know that the query
	    ** will not be shareable, we might as well stop saving its text
	    */
	    cb->pss_stmt_flags &= ~PSS_QUEL_RPTQRY_TEXT;
	}

	$$ = parmnode;
    }
;

uop:               UAOP                %prec unaryop
    {
	/*
	** The scanner is unable to distinguish between unary and binary +,
	** and unary and binary -.  Therefore, translate the binary operator
	** ids to unary ones here.
	*/
	if ($1 == ADI_ADD_OP)
	    $$ = ADI_PLUS_OP;
	else if ($1 == ADI_SUB_OP)
	    $$ = ADI_MINUS_OP;
    }
;

locationname:      NAME COLON crname
    {
	$Ywith_location = 1;

 	/* Remember location and table name */

	STmove($1, ' ', sizeof(DB_LOC_NAME),
	    (char *) cb->pss_restab.pst_resloc.data_address);
	cb->pss_restab.pst_resloc.data_in_size = sizeof(DB_LOC_NAME);

 	/* Remember table name */
	STmove($3, ' ', sizeof(DB_TAB_NAME),
	    (char *) &cb->pss_restab.pst_resname);

    }
          |	    crname
    {
 	/* Remember table name */
	STmove($1, ' ', sizeof(DB_TAB_NAME),
	    (char *) &cb->pss_restab.pst_resname);
    }
;

intconst:          int2_int4
    {
	$$ = $1;
    }
	  | 	    QDATA
    {
	i4		    value;
	ADF_CB		    adf_cb;
	ADF_CB		    *adf_scb = (ADF_CB*) cb->pss_adfcb;
	DB_DATA_VALUE	    tdv;
	ADI_DT_NAME	    dt_fname;
	ADI_DT_NAME	    dt_tname;
	i4		    err_code;
	
	/* Copy the session ADF block into local one */
	STRUCT_ASSIGN_MACRO(*adf_scb, adf_cb);

	adf_cb.adf_errcb.ad_ebuflen = 0;
	adf_cb.adf_errcb.ad_errmsgp = 0;
	tdv.db_length		    = 4;
	tdv.db_prec		    = 0;
	tdv.db_datatype		    = DB_INT_TYPE;
	tdv.db_data		    = (PTR) &value;
	    
	if (adc_cvinto(&adf_cb, $1, &tdv) != E_DB_OK)
	{
	    (VOID) adi_tyname(&adf_cb, $1->db_datatype, &dt_fname);
	    (VOID) adi_tyname(&adf_cb, (DB_DT_ID) DB_INT_TYPE, &dt_tname);
	    (VOID) psf_error(2911L, 0L, PSF_USERERR,
		&err_code, &psq_cb->psq_error, 3, sizeof (cb->pss_lineno),
		&cb->pss_lineno, sizeof (dt_fname), &dt_fname, 
		sizeof (dt_tname), &dt_tname);
	    return (E_DB_ERROR);
	}
	$$ = value;
    }
;

int2_int4:          I4CONST
    {
	$$ = *$1;
    }
          |	    I2CONST
    {
	$$ = *$1;
    }
;

sconst:		    SCONST
    {
	i4		reqs = 0;
	i4		lines = 0;
	bool		pmchars;
	i4		err_code;
	DB_STATUS	status;
	DB_DATA_VALUE	dv;
	DB_TEXT_STRING	*str;
	ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;

	str = $1;

	dv.db_data = (PTR) str;
	dv.db_length = str->db_t_count + DB_CNTSIZE;
	dv.db_datatype = DB_VCH_TYPE;
	dv.db_prec = 0;

	reqs |= (ADI_DO_BACKSLASH | ADI_DO_MOD_LEN);
	if (cb->pss_qualdepth)
	{
	    reqs |= ADI_DO_PM;
	}

	status = adi_pm_encode(adf_scb, reqs, &dv, &lines, &pmchars);
	cb->pss_lineno += lines;

	if (DB_FAILURE_MACRO(status))
	{
	    switch (adf_scb->adf_errcb.ad_errcode)
	    {
		case E_AD1015_BAD_RANGE:
		case E_AD3050_BAD_CHAR_IN_STRING:
		    {
			(VOID) psf_adf_error(&adf_scb->adf_errcb,
					     &psq_cb->psq_error, cb);
			break;
		    }
		default:
		    {
			(VOID) psf_error(E_PS0377_ADI_PM_ERR,
			    adf_scb->adf_errcb.ad_errcode, PSF_INTERR,
			    &err_code, &psq_cb->psq_error, 0);
		    }
	    }
	    return (status);
	}

	$$ = $1;
    }
;

strconst:          sconst
    {
	$$ = sconvert($1);
    }
	  |	    QDATA
    {
	DB_TEXT_STRING		*value;
	DB_STATUS		status;
	DB_DT_ID		totype;
	    
	/*
	** before we call qdata_cvt() to convert input value into longtext, make
	** sure that the input value is of "character type", i.e. c, char, text,
	** varchar, or longtext
	*/

	status = psl_must_be_string(cb, $1, &psq_cb->psq_error);
	if (DB_FAILURE_MACRO(status))
	    return(status);

	/*
	** if the input datatype was nullable, so must be the output datatype
	*/

	totype = ($1->db_datatype < 0) ? -DB_LTXT_TYPE : DB_LTXT_TYPE;

	if (qdata_cvt(cb, psq_cb, $1, totype, (PTR *) &value) != E_DB_OK)
	{
	    return (E_DB_ERROR);
	}

	$$ = sconvert(value);
    }
;

/*
** generic identifier shall be used for any user-defined object;
** generic identifier can be either a NAME or DELIM_IDENT
*/
generic_ident:	    NAME
    {
	$Yid_type = PSS_ID_REG;
	$$ = $1;
    }
             |      DELIM_IDENT
    {
	$Yid_type = PSS_ID_DELIM;
	$$ = $1;
    }
;

nonkeyword:	NAME
    {
	char	*letter;
	/*
	** Translate nonkeywords to lower case
	*/
	for (letter =  $1; *letter != EOS; CMnext(letter))
	    CMtolower(letter, letter);

	$$ = $1;
    }
;

/*[@yacc_rule@]*//*...*/

%%


/*{
** Name: getfacil	- Decode a facility code from a "set trace point"
**			    command.
**
** Description:
**      This function decodes a facility code from a "set trace point" command.
**	The codes come as strings, of the form "ffnnnn", where "ff" is a
**	two-letter code standing for a facility, and "nnnn" is a number from 0
**	to 9999, standing for the trace flag to be set within the facility.
**	The possible facilities are:
**
**	  Facility Code		Meaning
**	    dm			DMF
**	    ps			PSF
**	    sc			SCF
**	    rd			RDF
**	    qe			QEF
**	    op			OPF
**	    qs			QSF
**	    ad			ADF
**
**	The facility code can be in either upper-case or lower-case.
**
** Inputs:
**      code                            String to be decoded
**	facility			Place to put facility code
**	flagno				Place to put flag number
**
** Outputs:
**      facility                        Filled in with facility code
**      flagno                          Filled in with flag number
**	Returns:
**	    E_PS0000_OK			Success
**	    5966L	Bad facility in facility code
**	    5967L	Bad flag number in facility code
**
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	25-feb-86 (jeff)
**          written
**      6-sep-86 (seputis)
**          fixed parameters to compare routines
**	16-jun-93 (robf)
**	    Added SXF to facilities
**	05-Feb-2009 (kiria01) b121607
**	    Changed 'facility' to reflect the change from i4 to PSQ_MODE
*/
i4
getfacil(
	char               *code,
	PSQ_MODE	   *facility,
	i4                 *flagno)
{
    char                facstring[3];

    STncpy(facstring, code, 2);
    facstring[2] = '\0';
    if (STlen(facstring) != 2)
    {
	return (5966L);
    }

    if (CVal(code + 2, flagno) != OK)
    {
	return (5967L);
    }

    if (*flagno < 0 || *flagno > 9999)
    {
	return (5967L);
    }

    CMtoupper((char *) facstring, (char *) facstring);
    CMtoupper((char *) (facstring + 1), (char *) (facstring + 1));

    if (!STcompare(facstring, "DM"))
    {
	*facility = PSQ_DMFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "PS"))
    {
	*facility = PSQ_PSFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "SC"))
    {
	*facility = PSQ_SCFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "RD"))
    {
	*facility = PSQ_RDFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "QE"))
    {
	*facility = PSQ_QEFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "OP"))
    {
	*facility = PSQ_OPFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "QS"))
    {
	*facility = PSQ_QSFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "AD"))
    {
	*facility = PSQ_ADFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "GW"))
    {
	*facility = PSQ_GWFTRACE;
	return (E_PS0000_OK);
    }

    if (!STcompare(facstring, "SX"))
    {
	*facility = PSQ_SXFTRACE;
	return (E_PS0000_OK);
    }

    return (5966L);
}

/*{
** Name: sconvert	- Convert a text string to a null-terminated string.
**
** Description:
**      This function takes a text string (of type DB_TEXT_STRING) and converts
**	it to a null-terminated string.  It does the conversion in place.  It
**	returns a pointer to the converted string.
**
** Inputs:
**      string                          The string to be converted.
**
** Outputs:
**      string                          The string is converted in place.
**	Returns:
**	    Pointer to the converted string.
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	25-feb-86 (jeff)
**	    adapted from pre-Jupiter version
*/
char *
sconvert(
	DB_TEXT_STRING     *string)
{
    i4                  count;

    count = string->db_t_count;
    MEcopy((PTR) string->db_t_text, count, (PTR) string);
    ((char *) string)[count] = '\0';
    return ((char *) string);
}

/*{
** Name: qdata_cvt - Convert data passed as DB_DATA_VALUE to a text string.
**
** Description:
**      This function takes data in DB_DATA_VALUE and converts it to
**	a text string (of type DB_TEXT_STRING).
** Inputs:
**	cb		session control block
**	psq_cb		query control block
**	fval		db_data_value with data to be converted.
**	totype		dbms data type to which convert
**      value		address of pointer, which will point to
**			DB_TEXT_STRING with converted data upon return.
**
** Outputs:
**      value		Pointer to DB_TEXT_STRING with converted data.
**	Returns:
**	    status.
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	11-mar-88 (stec)
**	    STtrmwhite call removed.
**	04-mar-96 (mckba01)
**	    Fix #74286, varchar string truncation problem, initialise
**	    db_datatype field of resultant DB_DATA_VALUE before call
**	    to adi_0calclen. Not specifying a resultant db_datatype 
**	    when calling this function with a Nullable source causes
**	    the length returned to be 1 short.
**	19-mar-96 (pchang)
**	    Fixed bug 70204.  Incorrect test on the next symbol location for
**	    byte alignment prevented a new symbol block to be allocated when
**	    there are exactly 2 bytes left on the current symbol table, and
**	    subsequent alignment operation on the next symbol pointer caused
**	    it to advance beyond the current symbol block and thus, corrupting
**	    adjacent object when the next symbol was assigned.  SEGVIO followed
**	    when the trashed object was later referenced.
**	22-Feb-1999 (shero03)
**	    Support 4 operands in adi_0calclen
**	19-Aug-2010 (kschendel) b124282
**	    Make sure fi-desc is initialized.  Use pat-flags instead of
**	    obsolete isescape.
*/
DB_STATUS
qdata_cvt(
	PSS_SESBLK	*cb,
	PSQ_CB		*psq_cb,
	DB_DATA_VALUE	*fval,
	DB_DT_ID	totype,
	PTR		*value)
{
    DB_STATUS		status;
    ADF_CB	    	adf_cb;
    ADF_CB		*adf_scb = (ADF_CB*) cb->pss_adfcb;
    ADF_FN_BLK	    	adffn;
    i4		    	dv_size;
    i2			dv_prec;
    ADI_DT_NAME		dt_fname;
    ADI_DT_NAME		dt_tname;
    i4		err_code;
    i4			left;

    if (fval->db_datatype == totype)
	dv_size = fval->db_length;
    else
	dv_size = 0;

    /* Copy the session ADF block into local one */
    STRUCT_ASSIGN_MACRO(*adf_scb, adf_cb);

    adf_cb.adf_errcb.ad_ebuflen	   = 0;
    adf_cb.adf_errcb.ad_errmsgp	   = 0;

    /* get the function instance id for this conversion */
    status = adi_ficoerce(&adf_cb, fval->db_datatype, totype, &adffn.adf_fi_id);
    if (status != E_DB_OK)
    {
	goto exit;
    }         
    status = adi_fidesc(&adf_cb, adffn.adf_fi_id, &adffn.adf_fi_desc);
    if (status != E_DB_OK)
    {
	goto exit;
    }

    /* determine the result size. */
    if (!dv_size)
    {
	/* Now lets fill in the datatype length info and
	** allocate space for the data.
	*/

	/*	Initialise resultant datatype (used by adi_0calclen)   */

	adffn.adf_r_dv.db_datatype = totype;

	status = adi_0calclen(&adf_cb, &adffn.adf_fi_desc->adi_lenspec, 1, &fval, 
		&adffn.adf_r_dv);
	dv_size = adffn.adf_r_dv.db_length;
	dv_prec = adffn.adf_r_dv.db_prec;

	if (status != E_DB_OK)
	{
	     goto exit;
	}
    }
# ifdef BYTE_ALIGN
    left = &cb->pss_symblk->pss_symdata[PSS_SBSIZE] - cb->pss_symnext;
    /* 
    ** If not aligned and it is not possible to align or
    ** it doesn't make sense to align, allocate symbol memory block
    */
    if ((((PSS_SBSIZE - DB_CNTSIZE - left) % DB_ALIGN_SZ) != 0) &&
	(left <= DB_ALIGN_SZ)
       )
    {
	status = psf_symall(cb, psq_cb, PSS_SBSIZE);
	if (DB_FAILURE_MACRO(status))
	{
	    return(E_DB_ERROR);	/* error */
	}
    }
    /* always start with aligned values */
    cb->pss_symnext = (u_char *) ME_ALIGN_MACRO(cb->pss_symnext, DB_ALIGN_SZ);
# endif /* BYTE_ALIGN */
    /* Make sure there's room for piece pointer */
    /* add null terminator in case conv to string. */
    if ((((char*) cb->pss_symnext) + dv_size + 1) >=
	(char *)&cb->pss_symblk->pss_symdata[PSS_SBSIZE - 1])
    {
	status = psf_symall(cb, psq_cb, PSS_SBSIZE);
	if (DB_FAILURE_MACRO(status))
	{
	    return(E_DB_ERROR);	/* error */
	}
    }
    *value = (PTR) cb->pss_symnext;
    cb->pss_symnext = (u_char *)((char*)cb->pss_symnext) + dv_size +  1;
    
    ((char*)*value)[dv_size] = EOS;
    adffn.adf_dv_n		= 1;
    adffn.adf_r_dv.db_datatype	= totype;
    adffn.adf_r_dv.db_length	= dv_size;
    adffn.adf_r_dv.db_prec	= dv_prec;
    adffn.adf_r_dv.db_data	= *value;
    STRUCT_ASSIGN_MACRO(*fval, adffn.adf_1_dv);
    adffn.adf_pat_flags		= AD_PAT_DOESNT_APPLY;    /* not the LIKE op, so no esc */
    if ((status = adf_func(&adf_cb, &adffn)) != E_DB_OK)
    {
	goto exit;
    }

exit:
    if (status != E_DB_OK)
    {
	(VOID) adi_tyname(&adf_cb, fval->db_datatype, &dt_fname);
	(VOID) adi_tyname(&adf_cb, totype, &dt_tname);
	(VOID) psf_error(2911L, 0L, PSF_USERERR,
	    &err_code, &psq_cb->psq_error, 3,
	    sizeof (cb->pss_lineno), &cb->pss_lineno,
	    psf_trmwhite(sizeof(dt_fname), (char *) &dt_fname), &dt_fname, 
	    psf_trmwhite(sizeof (dt_tname), (char *) &dt_tname), &dt_tname);
        return (E_DB_ERROR);    
    }
    return (status);
}

/*
** Name: psl_quel_shareable - Apply QUEL-specific checking to determine if a
**			      given QUEL repeat query is shareable
**
** Description: QUEL repeat query will be deemed shareable if it meets the
**		requirements for an SQL repeat query (this was checked before
**		psy_qrymod() was called) AND all of the following
**		hold:
**		    - the query contained no non-repeat parameters,
**		    - repeat query parameters contained no pattern matching
**		      characters, and
**		    - permits required for the query to proceed did not have
**		      qualifications 
**
** Input:
**	sess_cb		session CB
**	qry_mask	mask used to contain all sorts of useful info about a
**			query
**
** Output:
**	*shareable	indicator of whether the query is shareable
**
** Returns:
**	none
**
** History:
**
**	01-21-91 (andre)
**	    written
**	11-oct-93 (swm)
**	    Bug #56448
**	    Declared trbuf for psf_display() to pass to TRformat.
**	    TRformat removes `\n' chars, so to ensure that psf_scctrace()
**	    outputs a logical line (which it is supposed to do), we allocate
**	    a buffer with one extra char for NL and will hide it from TRformat
**	    by specifying length of 1 byte less. The NL char will be inserted
**	    at the end of the message by psf_scctrace().
*/
VOID
psl_quel_shareable(
	PSS_SESBLK	*sess_cb,
	i4		qry_mask,
	bool		*shareable)
{
    i4	val1 = 0, val2 = 0;
    char	trbuf[PSF_MAX_TEXT + 1]; /* last char for `\n' */

    /*
    ** In addition to the requirements currently imposed on SQL queries, we need
    ** to ascertain that all of the following held:
    **  - the query contained no non-repeat parameters,
    **  - repeat query parameters contained no pattern matching characters,
    **    and
    **  - permits required for the query to proceed did not have
    **    qualifications.
    */

    if (!(*shareable))
    {
	/*
	** looks like the query is not shareable, and the caller has not
	** realized it
	*/
    }
    else if (qry_mask & PSS_NONREPEAT_PARAM)
    {
	*shareable = FALSE;

	if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
	{
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"\nQUEL repeat query is not shareable\n");
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"because it involves non-repeat parameters.\n");
	}
    }
    else if (qry_mask & PSS_PM_IN_REPEAT_PARAM)
    {
	*shareable = FALSE;

	if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
	{
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"\nQUEL repeat query is not shareable\n");
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"because it involves repeat parameters with pattern matching characters.\n");
	}
    }
    else if (sess_cb->pss_stmt_flags & PSS_QUAL_IN_PERMS)
    {
	*shareable = FALSE;

	if (ult_check_macro(&sess_cb->pss_trace, 4, &val1, &val2))
	{
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"\nQUEL repeat query is not shareable\n");
	    psf_display(psf_scctrace, 0, trbuf, sizeof(trbuf) - 1,
		"because permits with qualifications were used.\n");
	}
    }

    return;
}

/*
** Name: psl_rptqry_tblids - build a list of ids of tables used in this query
**
** Description: build an ORDERED list of ids of tables used in this query.
**		Order is determined by the position in the LRU list of range
**		variable entries in this range variable table.  Order is
**		important since this list will be used to determine if a given
**		query is IDENTICAL to another query, which determination will be
**		based on comparison of texts and lists of table ids of the two
**		queries.  This relies entirely on the fact that whenever a range
**		variable is used, it is brought to the head of the list, thus
**		(I am almost certain that this is so) ensuring that the order of
**		range variable entries after a given query will ALWAYS be the
**		same.
**
** Input:
**	sess_cb		    pointer to sessions' PSS_SESBLK
**	rngtab		    range variable table
**	    pss_qhead	    head of the LRU list
**	    pss_rsrng	    contains the result variable (used for target of
**			    APPEND)
**	    pss_maxrng	    indicates how many range variables were used (count
**			    starts at 0 and may include the variable in
**			    pss_rsrng if qry_mode == PSQ_APPEND)
**	mstream		    memory stream to be used whwn allocting a list of
**			    table ids
**	qry_mode	    query mode (actual query mode, not PSQ_DEFCURS)
**
** Output:
**	num_ids		    number of ids in the list
**	id_list		    ORDERED list of ids of tables used in the query
**	err_blk		    will be filled in if an error occurs
**
** Returns:
**	E_DB_OK		    success
**	E_DB_ERROR	    allocation of memory for table id list failed, or
**			    the assumption that the first N entries in the LRU
**			    range entry list were used in the query was wrong;
**			    the algorithm for determining if a given QUEL repeat
**			    query is shareable esta descompuesto (is broken)
**	
** History:
**
**	25-jan-91 (andre)
**	    written.
**	08-may-91 (rog)
**	    If *num_ids is zero, set *id_list to NULL and return.
**	    (fix for bug 37410)
*/
DB_STATUS
psl_rptqry_tblids(
	PSS_SESBLK	*sess_cb,
	PSS_USRRANGE	*rngtab,
	PSF_MSTREAM     *mstream,
	i4		qry_mode,
	i4		*num_ids,
	DB_TAB_ID	**id_list,
	DB_ERROR        *err_blk)
{
    DB_STATUS		    status;
    register i4	    id_num;
    register DB_TAB_ID	    *idp;
    register PSS_RNGTAB	    *rngvar;

    /*
    ** If *num_ids is zero, we don't have any table ids to process.
    */
    if (!(*num_ids = rngtab->pss_maxrng + 1))
    {
	*id_list = (DB_TAB_ID *) NULL;
	return(E_DB_OK);
    }

    status = psf_malloc(sess_cb, mstream, *num_ids * sizeof(DB_TAB_ID), (PTR *) id_list,
	err_blk);

    if (DB_FAILURE_MACRO(status))
    {
	return(status);
    }

    idp = *id_list;
    id_num = 0;

    /* for APPEND, the first table id will come from rngtab->pss_rsrng */
    if (qry_mode == PSQ_APPEND)
    {
	idp->db_tab_base  = rngtab->pss_rsrng.pss_tabid.db_tab_base;
	idp->db_tab_index = rngtab->pss_rsrng.pss_tabid.db_tab_index;
	id_num++;
	idp++;
    }

    for (rngvar = (PSS_RNGTAB *) rngtab->pss_qhead.q_next;
         id_num < *num_ids;
	 rngvar = (PSS_RNGTAB *) rngvar->pss_rngque.q_next, id_num++, idp++)
    {
	if (!rngvar->pss_used || rngvar->pss_rgno == -1)
	{
	    i4	    err_code;

	    /* We are in deep ... ah ... trouble */
	    (VOID) psf_error(E_PS0521_BAD_TBLID_LIST, 0L, PSF_INTERR,
		&err_code, err_blk, 0);
	    return(E_DB_ERROR);
	}

	idp->db_tab_base  = rngvar->pss_tabid.db_tab_base;
	idp->db_tab_index = rngvar->pss_tabid.db_tab_index;
    }

    return(E_DB_OK);
}
