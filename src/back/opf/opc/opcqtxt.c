/*
**Copyright (c) 2004, 2010 Ingres Corporation
**
NO_OPTIM = i64_aix
**
*/

#include    <compat.h>
#include    <gl.h>
#include    <cs.h>
#include    <iicommon.h>
#include    <dbdbms.h>
#include    <ddb.h>
#include    <ulm.h>
#include    <ulf.h>
#include    <adf.h>
#include    <ade.h>
#include    <adfops.h>
#include    <dmf.h>
#include    <dmtcb.h>
#include    <dmrcb.h>
#include    <scf.h>
#include    <qsf.h>
#include    <qefrcb.h>
#include    <rdf.h>
#include    <psfparse.h>
#include    <qefnode.h>
#include    <qefact.h>
#include    <qefqp.h>
#include    <qefqeu.h>
#include    <qefmain.h>
#include    <me.h>
#include    <bt.h>
#include    <st.h>
#include    <cv.h>
/* beginning of optimizer header files */
#include    <opglobal.h>
#include    <opdstrib.h>
#include    <opfcb.h>
#include    <opgcb.h>
#include    <opscb.h>
#include    <ophisto.h>
#include    <opboolfact.h>
#include    <oplouter.h>
#include    <opeqclass.h>
#include    <opcotree.h>
#include    <opvariable.h>
#include    <opattr.h>
#include    <openum.h>
#include    <opagg.h>
#include    <opmflat.h>
#include    <opcsubqry.h>
#include    <opsubquery.h>
#include    <opcstate.h>
#include    <opstate.h>
#include    <opckey.h>
#include    <opcd.h>
#include    <opxlint.h>
#include    <opclint.h>

/**
**
**  Name: OPCQTXT.C - Compile a query plan into query text.
**
**  Description:
**      Compile a query plan for distributed INGRES into a set of actions 
**	that consist of query text strings (i.e  SQL statements).
**	If the query being compiled is common (gateway) SQL, then the
**	query text generated by the compiler will also be common SQL.
**
**
**
**  History:
**      14-oct-88 (robin)
**          Created.
**	20-jan=89 (robin)
**	    Incorporated code review comments.
**	24-jan-91 (stec)
**	    General cleanup of spacing, identation, lines shortened to 80 chars.
**	    Changed code to make certain that BT*() routines use initialized
**	    size of bitmaps, when applicable.
**	12-jul-91 (seputis)
**	    Added fixes for LIKE problem bug 7381
**	14-apr-92 (fpang)
**	    In opc_drop(), don't set qryptr->qeq_q8_dv_cnt, it causes QEF to 
**	    send parameters along with the 'DROP' to the LDB.
**	    Fixes B43689 (DROP table and paramters cause IMS gateway errors).
**	22-aug-92 (rickh)
**	    Function prototypes:  declared several routines as static.
**	15-feb-93 (ed)
**	    fix several prototype warnings
**	13-mar-1993 (fpang)
**	    Added NO_OPTIM=su4_u42 to work around ACC compiler bug.
**	14-jul-93 (ed)
**	    replacing <dbms.h> by <gl.h> <sl.h> <iicommon.h> <dbdbms.h>
**	30-jun-93 (rickh)
**	    Added CV.H.
**	15-sep-93 (swm)
**	    Moved cs.h include above other header files which need its
**	    definition of CS_SID.
**	20-may-94 (davebf)
**	    Added support for singlesite nested queries
**	08-dec-94 (rudtr01)
**	    BUG 49905 - modified opc_qtxt() to force SELECT portion of 
**	    QEA_D3_XFR (TRANSFER) through the priviliged CDB association
**	    when the query references only CDB tables.
**	03-apr-95 (rudtr01)
**	    BUGS 52601 & 49905 - removed previous fix for 49905 in order
**	    implement more correct and complete fix in opd_bflag() (opdcost.c)
**	    to fix more of the Star self-deadlock bugs.
**	07-jun-95 (rudtr01)
**	    Bug 68449. CREATE TABLE T1 AS SELECT * FROM IITABLES used to cause
**	    a self-deadlock in Star due to a conflict between the subselect 
**	    and the registration.  After fixing 49905 and 52601 as noted above,
**	    the symptom changed so that the stmt failed with "E_QE0902 cannot 
**	    register nonexistent LDB table."  Really hacked the code to force 
**	    OPC to cause a TRANSFER from the privileged CDB association to the 
**	    regular CDB association so that the table would be created under 
**	    the correct userid instead of $ingres.  Added new bool for special 
**	    case to TX_STATE and inserted code into opc_qtxt(), opc_subproc(), 
**	    opc_drop() to check for the special case and hammer the 
**	    DD_LDB_DESC structure in the action headers.
**	10-jun-96 (abowler)
**	    Add spaces around commas when inserting constants into 
**	    LDB query text, to get around ambiguities when II_DECIMAL is 
**	    ','. Fixes bugs 76041, and 76047.
**	18-dec-98 (stephenb)
**	    Compiling this module with normal optimization causes a SEGV
**	    in the QA handoff star tests because of stack corruption
**	    (the guard page is hit in the stack). Either no optimization
**	    or level1 optimization fixes the problem, indicating that it
**	    is probably a compiler bug. Set level1 optimization for this
**	    module.
**	23-mar-00 (i4jo01)
**	    When assigning a site to a constant expression in a union, use 
**	    the parents' operation site to ensure that the constant node 
**	    is placed in the data flow. (b100982)
**	21-jan-1999 (hanch04)
**	    replace nat and longnat with i4
**	31-aug-2000 (hanch04)
**	    cross change to main
**	    replace nat and longnat with i4
**	16-aug-2001 (toumi01)
**	    speculative i64_aix NO_OPTIM change for beta xlc_r - FIXME !!!
**	07-jan-2002 (toumi01)
**	    Replace DD_300_MAXCOLUMN with DD_MAXCOLUMN (1024).
**      14-Nov-2002 (hanch04)
**          Removed NO_OPTIM for Solaris
**	06-Jul-06 (kiria01) b116230
**	    psl_print becomes PSL_RS_PRINT bit in new field psl_rsflags
**	    to allow for extra flags in PST_RSDM_NODE
**      13-sep-06 (stial01)
**          opc_sagg() alloc aligned db_data memory for agg results (b116627)
**	13-May-2009 (kschendel) b122041
**	    Compiler warning fixes.
**      01-apr-2010 (stial01)
**          Changes for Long IDs
**	08-Nov-2010 (kiria01) SIR 124685
**	    Rationalise function prototypes
**/

/*
** Forward Structure Definitions:
*/
typedef struct _QTX_STATE QTX_STATE;

/* TABLE OF CONTENTS */
static void opc_tbflg_ch(
	struct _QTX_STATE *txtstate,
	OPV_BMVARS *bmvars,
	OPD_ITEMP flagval);
static void opc_endstring(
	struct _QTX_STATE *txtstate,
	DD_PACKET *pktptr);
static void opc_copy(
	struct _QTX_STATE *txtstate,
	QEQ_D1_QRY *qryptr);
static void opc_drop(
	struct _QTX_STATE *txstate,
	OPCTABHD *tblptr,
	bool is_view);
static void opc_crtable(
	struct _QTX_STATE *txtstate,
	QEQ_D1_QRY *qryptr,
	i4 tempno);
static void opc_link(
	struct _QTX_STATE *txtstate);
static void opc_query(
	struct _QTX_STATE *txtstate,
	QEQ_D1_QRY *qact,
	bool remdup);
static void opc_ntemp(
	struct _QTX_STATE *txt_state,
	i4 *tempno);
static void opc_addtowhere(
	struct _QTX_STATE *txstate);
static void opc_nonsel(
	struct _QTX_STATE *txstate);
static void opc_crsel(
	struct _QTX_STATE *txtstate,
	QEQ_D1_QRY *qryptr,
	i4 tempno,
	DD_LDB_DESC *ldb_create_loc,
	bool is_union,
	bool make_view);
static void opc_sagg(
	struct _QTX_STATE *txstate,
	QEQ_D1_QRY *qptr);
static void opc_addand(
	struct _QTX_STATE *txstate,
	QEQ_TXT_SEG *qptr);
static void opc_qtxt(
	OPO_CO *conode,
	struct _QTX_STATE *txstate);
static DD_PACKET *opc_packet(
	struct _QTX_STATE *txstate,
	char *stringptr,
	OPD_ITEMP tempno,
	DD_PACKET **pktloc);
static void opc_dproj(
	struct _QTX_STATE *txstate,
	OPS_SUBQUERY *proj_subq,
	OPD_ITEMP proj_tempno,
	OPS_SUBQUERY *fagg_subq,
	OPD_ITEMP fagg_tempno);
static void opc_psagg(
	OPS_SUBQUERY *subquery);
static void opc_subproc(
	OPS_SUBQUERY *subq_ptr,
	struct _QTX_STATE *txstate,
	OPS_SUBQUERY **prev_subq);
static void opc_subunion(
	OPS_SUBQUERY *union_list,
	struct _QTX_STATE *txstate);
static void opc_evaluv(
	OPS_SUBQUERY *subquery,
	struct _QTX_STATE *txstatep,
	bool isunion);
void opc_pltext(
	OPS_STATE *global);

/*}
** Name: QTX_STATE - State of query text conversion
**
** Description:
**
** History:
**      09-oct-88 (robin)
**          Created.
*/
struct _QTX_STATE
{
    OPS_SUBQUERY    *qtx_subq;		/* subuqery currently being processed */
    OPS_STATE	    *qtx_global;		/* global state variable */
    i4              qtx_tempno;         /* result temp no. to use next*/
    QEQ_TXT_SEG	    *qtx_where;		/* query text for the WHERE clause */
    QEQ_TXT_SEG	    *qtx_drop;		/* drop list */
    OPCQHD	    qtx_qthd;		/* info on tables in query */
    DB_DATA_VALUE   *qtx_dv_p;		/* parm value array, simple aggs */
    
    OPO_CO	    *qtx_conode;	/* current conode */
    bool	    qtx_xfer;		/* result must be xferd to diff node */
    bool	    qtx_remdup;		/* remove duplicates */
    bool	    qtx_maketemp;	/* generate temporary for result */
    bool	    qtx_isroot;		/* conode is tree root */
    bool	    qtx_makeqry;	/* generate query for this node */
    bool	    qtx_link;		/* need to generate create link */
    bool	    qtx_sagg;		/* generate simple aggregate action */
    bool	    qtx_nonpresd;	/* non-printing resdoms in target list*/
    bool	    qtx_forcexfer;	/* special case (from coord to coord)
					** FIXME (hack for 68449) */
};

/*{
** Name: opc_tbflg_ch	-   Change the 'use base table' flag
**
** Description:
**      Set the flag in each local range table entry to
**	the value provided by the caller. This value can be
**	OPD_NOTEMP meaning use the base table for all
**	table references, or it can be a temporary table number
**	which will be used when a temp table is created for a
**	CO node.  This flag setting may be changed more than once 
**	during the text generation process 
**	as temporary tables are created that should be used instead. 
**	Note that this routine uses a bit map from the root node
**	provided by the caller to identify the range table
**	entries to be changed.
**
** Inputs:
**      txtstate                        global state variable
**	bmvars				bit map of tables (vars)
**	flagval				Value to set flag to.
**
** Outputs:
**	Returns:
**	    VOID
**	Exceptions:
**	    none.
**
** Side Effects:
**	    none.
**
** History:
**      13-oct-88 (robin)
**          Created.
**      20-jan-89 (robin)
**          Changed to expect a bit map as an input parameter
**	    instead of the root CO node. Code cleanup.
**      26-mar-91 (fpang)
**          Renamed opdistributed.h to opdstrib.h
**      30-Jan-92 (jillb/Farzin--DGC)
**          bmvars must be a pointer to OPV_BMVARS.
**          This bug would cause createdb xxx/star to fail at
**          upgradefe.
[@history_line@]...
[@history_template@]...
*/
static VOID
opc_tbflg_ch(
	QTX_STATE   *txtstate,
	OPV_BMVARS  *bmvars,
	OPD_ITEMP   flagval )
{
    OPS_SUBQUERY    *subqry = txtstate->qtx_subq;
    OPV_RT	    *rt_el_ptr;	/* range table element array pointer */
    OPV_IVARS	    varno;

    rt_el_ptr = txtstate->qtx_subq->ops_vars.opv_base;
    for (varno = -1;
	 (varno = BTnext((i4)varno, (char *) bmvars,
			 (i4)subqry->ops_vars.opv_rv))
	    >= 0;)
    {
	rt_el_ptr->opv_rt[varno]->opv_itemp = flagval;
    }

    return;
}


static VOID
opc_endstring(
QTX_STATE   *txtstate,
DD_PACKET   *pktptr )
{
    DD_PACKET	*newpkt;

    if (pktptr == NULL)
	return;

    /*  Find the last packet on the list */
    for (; pktptr->dd_p3_nxt_p != NULL; pktptr = pktptr->dd_p3_nxt_p );

    /*
    **  Allocate a new packet to hold a single blank and add it to the
    **  end of the packet list.  This is a hack to get around a bug
    **  in the INGRES LDB parser that requires a statement to end
    **  in an 'extra' character.
    **  This should be removed when that bug is fixed! DRHFIXME
    */

    newpkt = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, 
	( sizeof( DD_PACKET ) + 1 ));
    newpkt->dd_p1_len = 1;
    newpkt->dd_p3_nxt_p = NULL;
    newpkt->dd_p4_slot = DD_NIL_SLOT;
    newpkt->dd_p2_pkt_p = (PTR) (((PTR) newpkt) + sizeof(DD_PACKET));
    *newpkt->dd_p2_pkt_p = ' ';

    pktptr->dd_p3_nxt_p = newpkt;    

    return;
}

/*{
** Name: opc_copy	- Generate a copy for a transfer action
**
** Description:
**      Build the copy half of a transfer action. 
**
** Inputs:
**      txtstate                        global state variable
**	qryptr				sink query to fill in
**	tempno				temp table number
**
** Outputs:
**	Returns:
**	    VOID
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      13--oct-88 (robin)
**          Created.
**	24-aug-92 (rickh)
**	    Removed tempno parameter, which wasn't used.
[@history_template@]...
*/
static VOID
opc_copy(
	QTX_STATE	    *txtstate,
	QEQ_D1_QRY	   *qryptr )
{
    OPCTABHD	*tblptr;
    QEQ_TXT_SEG	*segptr;
    DD_PACKET	*nxtpkt;
    DD_PACKET	*pktptr;    
    i4		stringlen;
    char    *cstring1 = "COPY TABLE ";
    char    *cstring2 = " () FROM STAR ";

    tblptr = txtstate->qtx_qthd.opq_q8_curtable;

    qryptr->qeq_q1_lang = txtstate->qtx_qthd.opq_q3_qlang;
    qryptr->qeq_q2_quantum = 0;
    qryptr->qeq_q3_read_b = FALSE;
    qryptr->qeq_q3_ctl_info = 0;
    qryptr->qeq_q5_ldb_p = txtstate->qtx_qthd.opq_q6_dest_ldb;
    qryptr->qeq_q6_col_cnt = 0;
    qryptr->qeq_q7_col_pp = NULL;
    qryptr->qeq_q8_dv_cnt = txtstate->qtx_subq->ops_dist.opd_dv_cnt;
    qryptr->qeq_q9_dv_p = txtstate->qtx_dv_p;
    qryptr->qeq_q10_agg_size = 0;
    qryptr->qeq_q11_dv_offset = txtstate->qtx_subq->ops_dist.opd_dv_base;
    qryptr->qeq_q12_qid_first = TRUE;    
    qryptr->qeq_q13_csr_handle = NULL; 

    stringlen = STlength( cstring1 );

    segptr = (QEQ_TXT_SEG *) opu_qsfmem(  txtstate->qtx_global, 
	sizeof (QEQ_TXT_SEG ));
    qryptr->qeq_q4_seg_p = segptr;
    segptr->qeq_s1_txt_b = TRUE;
    segptr->qeq_s3_nxt_p = NULL;
    segptr->qeq_s2_pkt_p = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, 
	sizeof( DD_PACKET ));
    pktptr = segptr->qeq_s2_pkt_p;
    
    pktptr->dd_p1_len = stringlen;
    pktptr->dd_p2_pkt_p = (PTR) opu_qsfmem( txtstate->qtx_global, stringlen );
    pktptr->dd_p3_nxt_p = (DD_PACKET *) NULL;
    pktptr->dd_p4_slot = DD_NIL_SLOT;
    MEcopy( cstring1, stringlen, pktptr->dd_p2_pkt_p );

    nxtpkt = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, sizeof(DD_PACKET));
    pktptr->dd_p3_nxt_p = nxtpkt;
    pktptr = nxtpkt;
    pktptr->dd_p1_len = 0;
    pktptr->dd_p2_pkt_p = NULL;
    pktptr->dd_p3_nxt_p = NULL;
    pktptr->dd_p4_slot = tblptr->opq_t2_tnum;    

    stringlen = STlength( cstring2 );
    nxtpkt= (DD_PACKET *) opu_qsfmem(  txtstate->qtx_global, 
	sizeof(DD_PACKET) );
    pktptr->dd_p3_nxt_p = nxtpkt;
    pktptr = nxtpkt;
    
    pktptr->dd_p1_len = stringlen;
    pktptr->dd_p2_pkt_p = (PTR) opu_qsfmem( txtstate->qtx_global, stringlen );
    pktptr->dd_p3_nxt_p = (DD_PACKET *) NULL;
    pktptr->dd_p4_slot = DD_NIL_SLOT;
    MEcopy( cstring2, stringlen, pktptr->dd_p2_pkt_p );

    return;

}

/*{
** Name: opc_drop	- Add a temp table to the DROP list for QEF.
**
** Description:
**      Add a temporary table to the DROP list so that QEF can clean
**	up if the query is aborted.
**
** Inputs:
**      txtstate                        global state variable
**	tblptr				Ptr to temp table descriptor
**
** Outputs:
**	Returns:
**	    VOID
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      07-dec-88 (robin)
**          Created.
**      12-jan-89 (robin)
**	    Modified to build a separate drop action for each table
**	    (to handle the fact that the tables can have been created
**	    on different nodes)
**	10-jul-89 (robin)
**	    Added is_view flag to handle temporary views created for
**	    unions.
**	14-apr-92 (fpang)
**	    Don't set qryptr->qeq_q8_dv_cnt, it causes QEF to send 
**	    parameters along with the 'DROP' to the LDB.
**	    Fixes B43689 (DROP table and paramters cause IMS gateway errors).
[@history_template@]...
*/
static VOID
opc_drop(
	QTX_STATE	*txstate,
	OPCTABHD	*tblptr,
	bool		is_view )
{
	QEF_QP_CB	*qp;
	QEQ_TXT_SEG	*segptr;
	QEF_AHD		*actionhdr;
	QEF_AHD		*actptr;
	QEQ_D1_QRY	*qryptr;
	DD_PACKET	*pktptr;
	char		*drop0 = "drop view ";
	char		*drop1 = "drop table ";
	char		*dropstr;	
	i4		len;

	qp = txstate->qtx_global->ops_cstate.opc_qp;
    
	/*
	** Build a drop action for the table
	*/

	actionhdr = (QEF_AHD *) opu_qsfmem( txstate->qtx_global, 
	    sizeof( QEF_AHD ));
	actionhdr->ahd_prev = NULL;
	actionhdr->ahd_next = NULL;
	actionhdr->ahd_atype = QEA_D1_QRY;

	qryptr = &actionhdr->qhd_obj.qhd_d1_qry;
	qryptr->qeq_q1_lang = txstate->qtx_qthd.opq_q3_qlang;
	qryptr->qeq_q2_quantum = 0;
	qryptr->qeq_q3_read_b = FALSE;
	qryptr->qeq_q3_ctl_info = 0;
	qryptr->qeq_q5_ldb_p = tblptr->opq_t3_ldb;
	/* 
	** FIXME (hack for 68449)
	*/
	if (txstate->qtx_forcexfer == TRUE)
	{
	    DD_LDB_DESC tmpldb;
	    STRUCT_ASSIGN_MACRO(*qryptr->qeq_q5_ldb_p, tmpldb);
	    tmpldb.dd_l1_ingres_b = FALSE;
	    opc_dldbadd(txstate->qtx_global, &tmpldb, &qryptr->qeq_q5_ldb_p);
	}
	qryptr->qeq_q6_col_cnt = 0; 
	qryptr->qeq_q7_col_pp = NULL;
	qryptr->qeq_q8_dv_cnt = 0;   /* Drop has no parameters */
	qryptr->qeq_q9_dv_p = txstate->qtx_dv_p;
	qryptr->qeq_q10_agg_size = 0;
	qryptr->qeq_q11_dv_offset = txstate->qtx_subq->ops_dist.opd_dv_base;
	qryptr->qeq_q12_qid_first = TRUE;
	qryptr->qeq_q13_csr_handle = NULL; 
	
	if (is_view )
	{
	    dropstr = drop0;
    	}
	else
	    dropstr = drop1;
	segptr = (QEQ_TXT_SEG *) opu_qsfmem( txstate->qtx_global, 
	    sizeof(QEQ_TXT_SEG));
	qryptr->qeq_q4_seg_p = segptr;
	segptr->qeq_s1_txt_b = TRUE;
	segptr->qeq_s3_nxt_p = NULL;

	pktptr = (DD_PACKET *) opu_qsfmem( txstate->qtx_global, 
	    sizeof(DD_PACKET));
	segptr->qeq_s2_pkt_p = pktptr;
	len = STlength( dropstr );
	pktptr->dd_p1_len = len;
	pktptr->dd_p2_pkt_p = (char *) opu_qsfmem( txstate->qtx_global, len);
	pktptr->dd_p3_nxt_p = NULL;
	pktptr->dd_p4_slot = DD_NIL_SLOT;
	MEcopy( dropstr, len, pktptr->dd_p2_pkt_p );

	pktptr->dd_p3_nxt_p = (DD_PACKET *) opu_qsfmem( txstate->qtx_global, 
	    sizeof(DD_PACKET));
	pktptr = pktptr->dd_p3_nxt_p;
	pktptr->dd_p1_len = 0;
	pktptr->dd_p2_pkt_p = NULL;
	pktptr->dd_p3_nxt_p = NULL;
	pktptr->dd_p4_slot = tblptr->opq_t2_tnum;

	qp->qp_ddq_cb.qeq_d3_elt_cnt += (1 + tblptr->opq_t5_ncols);

	/*
	**  Add the drop action to the action list
	**  If a view is being dropped, add it to the beginning of
	**  the list, so that it will be dropped before any underlying
	**  tables and/or views are dropped.  If a table is being dropped,
	**  add it to the end of the list.
	*/

	if ( qp->qp_ddq_cb.qeq_d1_end_p != NULL )
	{
	    if (is_view)
	    {
		actionhdr->ahd_next = qp->qp_ddq_cb.qeq_d1_end_p;
		actionhdr->ahd_prev = NULL;
		actionhdr->ahd_next->ahd_prev = actionhdr;
		qp->qp_ddq_cb.qeq_d1_end_p = actionhdr;
		
	    }
	    else
	    {
		for ( actptr = qp->qp_ddq_cb.qeq_d1_end_p;
		    actptr->ahd_next != NULL;
		    actptr = actptr->ahd_next )
		    ;
		actionhdr->ahd_prev = actptr;
		actionhdr->ahd_next = NULL;
		actptr->ahd_next = actionhdr;
	    }
	}
	else
	    qp->qp_ddq_cb.qeq_d1_end_p = actionhdr;

	return;
}



/*{
** Name: opc_crtable	- Generate a create table for a transfer action
**
** Description:
**      Build the create table portion of a transfer action. 
**
** Inputs:
**      txtstate                        global state variable
**	qryptr				create temp struct to fill in
**	tempno				temp table number
**
** Outputs:
**	Returns:
**	    VOID
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      13--oct-88 (robin)
**          Created.
**      06-mar-96 (nanpr01)
**          initialized the pagesize for create table.
**	29-sep-1997 (nanpr01)
**	    Union of simple aggregate function gets segv. Star # 5779284.
**	    bug # 85922 & 86002.
[@history_template@]...
*/
static VOID
opc_crtable(
	QTX_STATE	    *txtstate,
	QEQ_D1_QRY	   *qryptr,
	i4		   tempno )
{
    char	*cstring = "CREATE TABLE ";
    OPCTABHD	*tblptr;
    QEQ_TXT_SEG	*segptr;
    DD_PACKET	*pktptr;    
    DD_PACKET	*nxtpkt;
    char	**colptr;
    i4		stringlen;
    i4		colno;

    tblptr = txtstate->qtx_qthd.opq_q8_curtable;

    /*
    **  Fill in the query action for CREATE TABLE
    */

    qryptr->qeq_q1_lang = txtstate->qtx_qthd.opq_q3_qlang;
    qryptr->qeq_q2_quantum = 0;
    qryptr->qeq_q3_read_b = FALSE;
    qryptr->qeq_q3_ctl_info = 0;
    qryptr->qeq_q5_ldb_p = txtstate->qtx_qthd.opq_q6_dest_ldb;
    qryptr->qeq_q6_col_cnt = tblptr->opq_t5_ncols;
    qryptr->qeq_q8_dv_cnt = txtstate->qtx_subq->ops_dist.opd_dv_cnt;
    qryptr->qeq_q9_dv_p = txtstate->qtx_dv_p;
    qryptr->qeq_q10_agg_size = 0;
    qryptr->qeq_q11_dv_offset = txtstate->qtx_subq->ops_dist.opd_dv_base;
    qryptr->qeq_q12_qid_first = TRUE;
    qryptr->qeq_q13_csr_handle = NULL; 
    if (txtstate->qtx_subq->ops_bestco)
        qryptr->qeq_q14_page_size = 
	  txtstate->qtx_subq->ops_bestco->opo_cost.opo_pagesize; 
    else
	qryptr->qeq_q14_page_size = opc_pagesize(
				txtstate->qtx_global->ops_cb->ops_server, 
				txtstate->qtx_subq->ops_width);

    stringlen = STlength( cstring );
    segptr = (QEQ_TXT_SEG *) opu_qsfmem(  txtstate->qtx_global, 
	sizeof( QEQ_TXT_SEG ) );
    qryptr->qeq_q4_seg_p = segptr;
    segptr->qeq_s1_txt_b = TRUE;
    segptr->qeq_s3_nxt_p = NULL;
    pktptr = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, 
	sizeof( DD_PACKET ));
    segptr->qeq_s2_pkt_p = (DD_PACKET *) pktptr;
    
    pktptr->dd_p1_len = stringlen;
    pktptr->dd_p2_pkt_p = (PTR) opu_qsfmem( txtstate->qtx_global, stringlen );
    pktptr->dd_p3_nxt_p = (DD_PACKET *) NULL;
    pktptr->dd_p4_slot = DD_NIL_SLOT;
    MEcopy( cstring, stringlen, pktptr->dd_p2_pkt_p );

    colptr = (char **) opu_qsfmem( txtstate->qtx_global, 
	( qryptr->qeq_q6_col_cnt * sizeof( PTR )));
    qryptr->qeq_q7_col_pp = (DD_ATT_NAME **) colptr;
    for ( colno = 0; colno < qryptr->qeq_q6_col_cnt; colno++ )
    {
	*colptr = tblptr->opq_t6_tcols[colno].opq_c1_col_name;
	colptr++;
    }

    nxtpkt = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, 
	sizeof( DD_PACKET ));
    pktptr->dd_p3_nxt_p = nxtpkt;
    pktptr = nxtpkt;
    pktptr->dd_p1_len = 0;
    pktptr->dd_p2_pkt_p = NULL;
    pktptr->dd_p3_nxt_p = NULL;
    pktptr->dd_p4_slot = tblptr->opq_t2_tnum;    

    /*  Add the table to the drop list */

    opc_drop( txtstate, tblptr, (bool) FALSE );

    return;

}

/*{
** Name: opc_link	- Generate a link query action
**
** Description:
**      Generate a create link query action 
**
** Inputs:
**      txtstate                        global state variable
**
** Outputs:
**	Returns:
**	    VOID
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      13-oct-88 (robin)
**          Created.
[@history_template@]...
*/
static VOID
opc_link(
	QTX_STATE	*txtstate )
{
    /* stubbed for now */
    return;
}

/*{
** Name: opc_query	- Generate query action
**
** Description:
{@comment_line@}...
**
** Inputs:
**      txstate                         Text conversion state block
**	qact				Query action to be filled in
**	remdup				Flag - remove duplicates
**
** Outputs:
**	Returns:
**	    VOID
**	Exceptions:
**	    None.
**
** Side Effects:
**	    None.
**
** History:
**      09-oct-88 (robin)
**          Created.
**	11-nov-92 (barbara)
**	    Small change for delete cursor.
[@history_template@]...
*/
static VOID	
opc_query(
	QTX_STATE   *txtstate,
	QEQ_D1_QRY  *qact,
	bool	    remdup )
{
    /* Initialize the query action data structure */    

    qact->qeq_q1_lang = txtstate->qtx_global->ops_qheader->
	pst_qtree->pst_sym.pst_value.pst_s_root.pst_qlang;
    qact->qeq_q2_quantum = 0;
    qact->qeq_q3_read_b = FALSE;
    qact->qeq_q3_ctl_info = 0;
    qact->qeq_q4_seg_p = NULL;
    qact->qeq_q5_ldb_p = NULL;
    qact->qeq_q6_col_cnt = 0;
    qact->qeq_q7_col_pp = NULL;

    opc_treetext( txtstate->qtx_subq, txtstate->qtx_conode, (bool) FALSE, 
	remdup, &txtstate->qtx_where, &qact->qeq_q4_seg_p, &txtstate->qtx_qthd);

    /*
    **  Need to finish filling in the QEQ_D1_qry
    */

    /*
    ** DRHFIXME
    **	qact->qeq_q3_read_b = TRUE;
    */
    qact->qeq_q5_ldb_p = txtstate->qtx_qthd.opq_q5_src_ldb; 
    qact->qeq_q8_dv_cnt = txtstate->qtx_subq->ops_dist.opd_dv_cnt;
    qact->qeq_q9_dv_p = txtstate->qtx_dv_p;
    qact->qeq_q11_dv_offset = txtstate->qtx_subq->ops_dist.opd_dv_base;

    /*
    **  Hack a blank onto the end of the query to get around
    **  the parser bug! DRHFIXME
    **	Now that the parser does not generate text, this call is
    **  probably unnecessary (barbara).
    */

    if (txtstate->qtx_subq->ops_mode != PSQ_DELCURS)
    	opc_endstring( txtstate, qact->qeq_q4_seg_p->qeq_s2_pkt_p );
    
    return;
}

/*{
** Name: opc_ntemp	- Get a number for a new result temp table
**
** Description:
**      Get a new result temporary table number.  The numbers
**	are used by QEF as offsets into QEF's temp table name
**	array, so temp numbers start with zero.
**
**
** Inputs:
**      txtstate                        State block
**	tempno				Ptr to a i4  to hold the
**					new temp no.
**
** Outputs:
**      tempno                          Will hold new temp no.
**	Returns:
**	    VOID
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      09-oct-88 (robin)
**          Created.
[@history_template@]...
*/
static VOID
opc_ntemp(
	QTX_STATE   *txt_state,
	i4	    *tempno )
{
    if ( txt_state->qtx_tempno < 0 )
    {
	/*  This is the first result temp */

	txt_state->qtx_tempno = 0;
    }
    *tempno = (txt_state->qtx_tempno)++;

    return;
}

static VOID
opc_addtowhere(
QTX_STATE   *txstate )
{



   opc_treetext( txstate->qtx_subq, txstate->qtx_conode, (bool) TRUE, 
	(bool) FALSE, &txstate->qtx_where, &txstate->qtx_where, 
	&txstate->qtx_qthd);
    return;
}

/*{
** Name:  opc_nonsel	- Modify CO tree for non-select queries
**
** Description:
**	If this query is not a select (i.e. it is an insert, delete, or update)
**	AND the target and operation sites for the 'root' conode are different,
**	then a new conode will be created to be the root of the cotree by
**	copying the old root, and changing a few things in it.
**	The node that was previously the root will cause opc_qtxt to generate
**	a transfer action to the final site.
**	The new conode at the root will cause opc_qtxt to generate the
**	appropriate non-select statement at the final site that will return
**	results to the user, using the results of the preceding transfer..
**
** Inputs:
**      txstate                         global state variable 
**
** Outputs:
**	Returns:
**	    None.
**	Exceptions:
**	    None.
**
** Side Effects:
**	    The cotree will be modified with a new root node.
**
** History:
**      09-jan-89  (robin)
**	    Created.
**      19-may-89  (robin)
**	    Changed test from OPD_TOUSER to OPD_NOFIXEDSITE. Partial fix
**	    for bug 5481.
**	15-feb-94 (ed)
**	    cannot assume PTR is a pointer to a one byte item so use alternate
**	    way of referencing end of structure
[@history_template@]...
*/
static void
opc_nonsel(
	QTX_STATE   *txstate )
{

	OPS_SUBQUERY	*subqry = txstate->qtx_subq;
	OPO_CO		*cop = subqry->ops_bestco;
	OPO_CO		*newnode;
	OPO_CO		*oldroot;	
	OPD_LOCAL	*locptr;

	if ( subqry->ops_bestco != NULL &&
	     subqry->ops_sqtype == OPS_MAIN &&
	     !(subqry->ops_global->ops_gdist.opd_gmask & OPD_NOFIXEDSITE) &&
	     cop->opo_variant.opo_local->opo_target == OPD_TSITE &&
	     cop->opo_variant.opo_local->opo_operation != OPD_TSITE )
	{
	    /*  Need to make a new root node  */

	    oldroot = txstate->qtx_subq->ops_bestco;
	    newnode = (OPO_CO *) opu_qsfmem( txstate->qtx_global, sizeof( OPO_CO) );	    
	    MEcopy( (PTR)oldroot, sizeof( OPO_CO ), (PTR)newnode);

	    newnode->opo_outer = oldroot;
	    newnode->opo_inner = (OPO_CO *) NULL;
	    newnode->opo_sjpr = 0;   /* DRHFIXME - need new 'fake' node type */


	    locptr = (OPD_LOCAL *) opu_qsfmem( txstate->qtx_global, sizeof( OPD_LOCAL) + sizeof( OPB_BMBF) );
	    MEcopy( (PTR)oldroot->opo_variant.opo_local, sizeof( OPD_LOCAL), (PTR)locptr );
	    locptr->opo_bmbf = (OPB_BMBF *)&locptr[1];
	    MEfill( OPB_BITMAPBF,( u_char) 0, (PTR)locptr->opo_bmbf );
	    newnode->opo_variant.opo_local = locptr;
	    newnode->opo_variant.opo_local->opo_operation = OPD_TSITE;

	    txstate->qtx_subq->ops_bestco = newnode;
	}
}

/*{
** Name: opc_crsel	- Generate a 'create as select' action
**
** Description:
**	Generate a 'create as select' action.  These are used internally to
**	create temporary tables or views as part of a query plan, typically for
**	the materialization of aggregates, and for duplicate handling.
**	The tables created are similar to those created by XFER
**	actions - named by QEF, invisible to the user, and destroyed
**	at the completion of the query.   Note that user-specified
**	'create as select' is different - it's query must be followed
**	by a 'create link'action to make the new table known to Star,
**	since it is a permanent table.
**
**
** Inputs:
**      txtstate            global state variable
**	qryptr		    partially complete query action 
**	tempno		    temp table number to use
**	ldb_create_loc	    ldb to create on
**	is_union	    TRUE if this is a UNION, FALSE otherwise
**	make_view	    TRUE if a view, not a table, should be created
**				    
**
** Outputs:
**	Returns:
**	    VOID
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      19-feb-89 (robin)
**          Created.
**      27-apr-89 (robin)
**	    Added ldb_create_loc parameter to fix bug 5474,where
**	    we tried to create on site 0.  Instead of always creating
**	    on the target site (which will be site 0 at the top of the
**	    CO tree when results are returned to the user), let the caller
**	    specify where the temp will be created.
**	07-jul-89 (robin)
**	    Added is_union parameter to support the internal create as select
**	    statement that joins together all temp table components of a
**	    UNION select. Added make_view parameter since unions are only
**	    allowed in views.
**	18-jan-93 (ed)
**	    - disallow use of views, since views cannot reference temporary
**	    tables, ... FIXME - real fix is to implement temporary views
**	14-apr-94 (peters)
**	    Added 'with nojournaling' clause when creating temporary tables
**	    if INGRES version is 6.5, since the default is with journaling
**	    in INGRES 6.5, which can lead to logfile overflow (Bug 60237).
**      06-mar-96 (nanpr01)
**          initialized the pagesize for create table as select.
**	29-sep-1997 (nanpr01)
**	    Union of simple aggregate function gets segv. Star # 5779284.
**	    bug # 85922 & 86002.
*/
static VOID
opc_crsel(
	QTX_STATE	    *txtstate,
	QEQ_D1_QRY	   *qryptr,
	i4		   tempno,
	DD_LDB_DESC	    *ldb_create_loc,
	bool		    is_union,
	bool		    make_view )
{
    char	*cstring = "CREATE TABLE ";
    char	*cstring1 = "CREATE VIEW ";
    char	*cstring2 = " AS ";
    char	*cstring3 = " WITH NOJOURNALING ";
    OPCTABHD	*tblptr;
    OPCTABHD	*tabptr;
    QEQ_TXT_SEG	*segptr;
    DD_PACKET	*pktptr;    
    DD_PACKET	*nxtpkt;
    DD_PACKET	*holdpkt;
    i4		stringlen;

    make_view = FALSE;	    /* FIXME, since views cannot access temporary
			    ** tables, views cannot be used, perhaps 
			    ** temporary views can eventually be used */
	    tabptr = txtstate->qtx_qthd.opq_q7_tablist;
	    if (tabptr != NULL)
	    {
		for (; tabptr->opq_t4_tnext != NULL;
			tabptr = tabptr->opq_t4_tnext);
	    }

	    txtstate->qtx_qthd.opq_q2_type = OPQ_XFER;
	    txtstate->qtx_qthd.opq_q8_curtable = (OPCTABHD *) 
		opu_qsfmem( txtstate->qtx_global, sizeof(OPCTABHD));
	    txtstate->qtx_qthd.opq_q8_curtable->opq_t2_tnum = tempno;
	    txtstate->qtx_qthd.opq_q8_curtable->opq_t3_ldb = ldb_create_loc;
	    txtstate->qtx_qthd.opq_q8_curtable->opq_t4_tnext = NULL;
	    txtstate->qtx_qthd.opq_q8_curtable->opq_t5_ncols = 0;

	    if (tabptr == NULL)
		txtstate->qtx_qthd.opq_q7_tablist =
		    txtstate->qtx_qthd.opq_q8_curtable;
	    else
		tabptr->opq_t4_tnext = txtstate->qtx_qthd.opq_q8_curtable;

	    opcu_getrange( &txtstate->qtx_qthd, (i4) (OPV_MAXVAR + tempno),
		txtstate->qtx_qthd.opq_q8_curtable->opq_t1_rname);

	    if ( !is_union )
	    {
		opc_query( txtstate, qryptr, txtstate->qtx_remdup );
	    }
	    else
	    {
		/*
		**  Build a union select to join all temp table
		**  components of the union.
		*/

		DD_PACKET	workpkt1;
		bool		first;
		OPS_SUBQUERY	*subqptr = txtstate->qtx_subq;
		bool		union_all;

		first = TRUE;
		pktptr = (DD_PACKET * ) &workpkt1;
		if (subqptr->ops_root->pst_sym.pst_value.pst_s_root.
			pst_union.pst_dups == PST_ALLDUPS )
		    union_all = TRUE;
		else
		    union_all = FALSE;

		for (subqptr = txtstate->qtx_subq; subqptr != NULL;
		     subqptr = subqptr->ops_union )
		{
		    if ( subqptr->ops_compile.opc_distrib.opc_subqtemp 
							    != OPD_NOTEMP )
		    {
			if ( first == TRUE )
			    first = FALSE;
			else
			{
			    if ( union_all )
			    {
				pktptr = opc_packet( txtstate, " union all ",
				    OPD_NOTEMP, &pktptr->dd_p3_nxt_p);
			    }
			    else
			    {
				pktptr = opc_packet( txtstate, " union ",  
				    OPD_NOTEMP, &pktptr->dd_p3_nxt_p);
			    }
			}
			pktptr = opc_packet( txtstate, " ( select * from ",
			    OPD_NOTEMP, &pktptr->dd_p3_nxt_p);
			pktptr = opc_packet( txtstate, (char *) NULL,
			    subqptr->ops_compile.opc_distrib.opc_subqtemp,
			    &pktptr->dd_p3_nxt_p);
			pktptr = opc_packet( txtstate, " ) ",  OPD_NOTEMP, 
			    &pktptr->dd_p3_nxt_p);
		    }
		}

		/*
		** Build ORDER BY clause for union, if needed
		*/

		segptr = (QEQ_TXT_SEG *) opu_qsfmem( txtstate->qtx_global,
		    sizeof(QEQ_TXT_SEG));
		qryptr->qeq_q4_seg_p = segptr;
		segptr->qeq_s2_pkt_p = workpkt1.dd_p3_nxt_p;
		txtstate->qtx_qthd.opq_q4_retrow_flg = FALSE;
	    }

	    opc_qrybld( txtstate->qtx_global, &txtstate->qtx_qthd.opq_q3_qlang, 
		txtstate->qtx_qthd.opq_q4_retrow_flg, qryptr->qeq_q4_seg_p,
		txtstate->qtx_qthd.opq_q5_src_ldb, qryptr);


    tblptr = txtstate->qtx_qthd.opq_q8_curtable;

    /*
    **  Fill in the query action for CREATE TABLE
    */

    qryptr->qeq_q1_lang = txtstate->qtx_qthd.opq_q3_qlang;
    qryptr->qeq_q2_quantum = 0;
    qryptr->qeq_q3_read_b = FALSE;
    qryptr->qeq_q3_ctl_info = 0;
    qryptr->qeq_q5_ldb_p = ldb_create_loc;
    qryptr->qeq_q6_col_cnt = tblptr->opq_t5_ncols;
    qryptr->qeq_q8_dv_cnt = txtstate->qtx_subq->ops_dist.opd_dv_cnt;
    qryptr->qeq_q9_dv_p = txtstate->qtx_dv_p;
    qryptr->qeq_q10_agg_size = 0;
    qryptr->qeq_q11_dv_offset = txtstate->qtx_subq->ops_dist.opd_dv_base;
    qryptr->qeq_q12_qid_first = TRUE;
    qryptr->qeq_q13_csr_handle = NULL; 
    if (txtstate->qtx_subq->ops_bestco)
        qryptr->qeq_q14_page_size = 
	  txtstate->qtx_subq->ops_bestco->opo_cost.opo_pagesize; 
    else
	qryptr->qeq_q14_page_size = opc_pagesize(
				txtstate->qtx_global->ops_cb->ops_server,
				txtstate->qtx_subq->ops_width);

    segptr = qryptr->qeq_q4_seg_p;
    holdpkt = segptr->qeq_s2_pkt_p;

    segptr->qeq_s1_txt_b = TRUE;
    segptr->qeq_s3_nxt_p = NULL;
    pktptr = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, 
	sizeof( DD_PACKET ));
    segptr->qeq_s2_pkt_p = (DD_PACKET *) pktptr;
    
    /*
    **  Create packet for 'CREATE TABLE'
    */
    
    if ( make_view )
	stringlen = STlength( cstring1 );
    else
	stringlen = STlength( cstring );
    pktptr->dd_p1_len = stringlen;
    pktptr->dd_p2_pkt_p = (PTR) opu_qsfmem( txtstate->qtx_global, stringlen );
    pktptr->dd_p3_nxt_p = (DD_PACKET *) NULL;
    pktptr->dd_p4_slot = DD_NIL_SLOT;

    if (make_view)
	MEcopy( cstring1, stringlen, pktptr->dd_p2_pkt_p );
    else
	MEcopy( cstring, stringlen, pktptr->dd_p2_pkt_p );

    /*
    **  Create packet for the temp table id 
    */

    nxtpkt = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, 
	sizeof( DD_PACKET ));
    pktptr->dd_p3_nxt_p = nxtpkt;
    pktptr = nxtpkt;
    pktptr->dd_p1_len = 0;
    pktptr->dd_p2_pkt_p = NULL;
    pktptr->dd_p3_nxt_p = NULL;
    pktptr->dd_p4_slot = tblptr->opq_t2_tnum;    

    /*
    **  Create packet for ' AS '
    */
    
    nxtpkt = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global, 
	sizeof( DD_PACKET ));
    pktptr->dd_p3_nxt_p = nxtpkt;
    pktptr = nxtpkt;
    stringlen = STlength( cstring2 );
    pktptr->dd_p1_len = stringlen;
    pktptr->dd_p2_pkt_p = (PTR) opu_qsfmem( txtstate->qtx_global, stringlen );

    pktptr->dd_p4_slot = DD_NIL_SLOT;
    MEcopy( cstring2, stringlen, pktptr->dd_p2_pkt_p );
    pktptr->dd_p3_nxt_p = holdpkt;

    /* If LDB is INGRES 6.5, add "with nojournaling" at end of query text */
    if (txtstate->qtx_subq->ops_bestco)
    {
        DD_CAPS	*cap_ptr;   /* ptr to LDB capabilities */
        OPD_SITE	*sitedesc;
        OPD_ISITE  	site;

        site = txtstate->qtx_subq->ops_bestco->opo_variant.opo_local->opo_operation;
        sitedesc = txtstate->qtx_global->ops_gdist.opd_base->opd_dtable[site];
        cap_ptr =  &sitedesc->opd_dbcap->dd_p3_ldb_caps;

	if (cap_ptr->dd_c1_ldb_caps & DD_2CAP_INGRES &&
	    cap_ptr->dd_c4_ingsql_lvl >= DD_605CAP_LEVEL )
	{
            while (pktptr->dd_p3_nxt_p != (DD_PACKET *)0)
	        pktptr = pktptr->dd_p3_nxt_p;

            nxtpkt = (DD_PACKET *) opu_qsfmem( txtstate->qtx_global,
		sizeof( DD_PACKET ));
            pktptr->dd_p3_nxt_p = nxtpkt;
            nxtpkt->dd_p4_slot = pktptr->dd_p4_slot;
            pktptr = nxtpkt;
            stringlen = STlength( cstring3 );
            pktptr->dd_p1_len = stringlen;
            pktptr->dd_p2_pkt_p = (PTR) opu_qsfmem( txtstate->qtx_global, stringlen );
            pktptr->dd_p3_nxt_p = (DD_PACKET *) NULL;
            MEcopy( cstring3, stringlen, pktptr->dd_p2_pkt_p );
	}
    }

    /*  Add the table to the drop list */

    opc_drop( txtstate, tblptr, make_view );

    return;
}

/*{
** Name: opc_sagg	- Complete simple aggregate query action
**
** Description:
**	Build the parameter array for a simple aggregate query action.
**	This array will be used by QEF to pass the values of simple
**	aggregates to subsequent actions in the query plan.
**
** Inputs:
**      txstate                         State control block
**	qptr				Query action pointer
**
** Outputs:
**	Returns:
**	    void
**	Exceptions:
**	    none.
**
** Side Effects:
**	    none
**
** History:
**      21-feb-89 (robin)
**	    created.
**      20-apr-89 (seputis)
**	    remove simple aggregate parameter order assumption
**	16-may-89 (robin)
**	    Changed to copy the db data value of the constant node
**	    (since it's length is being used to compute the total size),
**	    rather than that of the resdom node. In fact, both should be
**	    the same.
**	17-may-89 (robin)
**	    Initialize qeq_q8_dv_cnt properly, in a manner similar to non-saggs.
**	    Fix for bug 5482.
**	23-may-89 (seputis) fixed b5483 - make sure target list is in same
**	    order as DB_DATA_VALUE array
**	18-apr-90 (seputis) fixed simple aggregate problem, set read_b to TRUE
**	21-aug-01 (inkdo01)
**	    Change for AOP's - with binary aggs, AOP pst_right no longer addresses
**	    fake parmno.
*/
static VOID
opc_sagg(
	QTX_STATE   *txstate,
	QEQ_D1_QRY  *qptr )
{
    DB_DATA_VALUE   *target_dbv;
    i4		    total_size;	    /* total size of all aggregates */
    PST_QNODE	    *resdomp;	    /* current resdom being analyzed */
    OPS_PNUM	    minparm;	    /* min const parm number expected */
    i4		    dbdatasize;
    i4		    agg_count;	    /* number of aggregate nodes analyzed */
    DB_DATA_VALUE   *datap;	    /* ptr to datavalue of current AOP */
    PST_QNODE	    *rootp;	    /* ptr to root node of query tree */
    OPS_PNUM	    lastparm;

    qptr->qeq_q3_read_b = TRUE;	    /* simple aggregate is a retrieval */

    /* bug 5482 fix */
    qptr->qeq_q8_dv_cnt = txstate->qtx_subq->ops_dist.opd_dv_cnt;
    qptr->qeq_q6_col_cnt = txstate->qtx_subq->ops_dist.opd_sagg_cnt;
    minparm = 
    qptr->qeq_q11_dv_offset = txstate->qtx_subq->ops_dist.opd_dv_base;
    lastparm = minparm + qptr->qeq_q6_col_cnt-1;
    dbdatasize = qptr->qeq_q6_col_cnt * sizeof(DB_DATA_VALUE);
    target_dbv = (DB_DATA_VALUE *) opu_qsfmem( txstate->qtx_global, dbdatasize);
    MEfill(dbdatasize, (u_char)0, (PTR)target_dbv);
    qptr->qeq_q9_dv_p = target_dbv;    
    txstate->qtx_dv_p = target_dbv; /* save for subsequent actions */
    total_size = 0;
    agg_count = 0;
    rootp = txstate->qtx_subq->ops_root;
    for (resdomp = rootp->pst_left; resdomp; resdomp = resdomp->pst_left)
    {
	PST_QNODE	    *aop_node;
	aop_node = resdomp->pst_right;
	if ((resdomp->pst_sym.pst_type == PST_RESDOM)
	    &&
	    (aop_node->pst_sym.pst_type == PST_AOP )
	    )
	{
	    i4	    parmno;

	    parmno = aop_node->pst_sym.pst_value.pst_s_op.pst_opparm;
					/* parm no lives in AOP */
	    if ((parmno < minparm)
		||
		(parmno != (lastparm--)))
	    {   /* make sure it is in expected range */
		opx_error( E_OP0A8B_OPCPARM);
	    }
	    datap = &target_dbv[parmno-minparm];
	    if (datap->db_length > 0)
	    {   /* make sure it has not been initialized already */
		opx_error( E_OP0A8B_OPCPARM);
	    }
	    agg_count += 1;
	    total_size += 
		DB_ALIGN_MACRO(aop_node->pst_sym.pst_dataval.db_length);
	    STRUCT_ASSIGN_MACRO( aop_node->pst_sym.pst_dataval, *datap);
	}
    }
    if (agg_count != qptr->qeq_q6_col_cnt)
    {   /* make sure all columns have been processed */
	opx_error( E_OP0A8B_OPCPARM);
    }
    qptr->qeq_q10_agg_size = total_size;
}

static VOID
opc_addand(
QTX_STATE   *txstate,
QEQ_TXT_SEG *qptr )
{
    DD_PACKET	*pktptr;
    DD_PACKET	*newpkt;
    char	*andstring = " and ";

    /*
    **  Find the end of the text segment pkt list
    */
    
    for ( pktptr = qptr->qeq_s2_pkt_p; pktptr->dd_p3_nxt_p != NULL;
	  pktptr = pktptr->dd_p3_nxt_p)
	  ;

    newpkt = (DD_PACKET *) opu_qsfmem( txstate->qtx_global, sizeof( DD_PACKET));
    newpkt->dd_p1_len = STlength( andstring );
    newpkt->dd_p3_nxt_p = NULL;
    newpkt->dd_p4_slot = DD_NIL_SLOT;
    newpkt->dd_p2_pkt_p = ( char *) opu_qsfmem( txstate->qtx_global, 
	newpkt->dd_p1_len );
    MEcopy( andstring, newpkt->dd_p1_len, newpkt->dd_p2_pkt_p );

    pktptr->dd_p3_nxt_p = newpkt;        

    return;
}


/*{
** Name: opc_qtxt	- Generate query text for a CO tree node
**
** Description:
{@comment_line@}...
**
** Inputs:
[@PARAM_DESCR@]...
**
** Outputs:
@PARAM_DESCR@]...
**	Returns:
**	    [@return_description@}
**	Exceptions:
**	    [@description_or_none@]
**
** Side Effects:
**	    [@description_or_none@]
**
** History:
**      03-may-88 (robin)
**	    Added fix for bug 5702 - in an update query send results
**	    directly to the target site.
**      19-may-89 (robin)
**	    Changed test from OPD_TOUSER to OPD_NOFIXEDSITE.  Partial fix
**	    for bug 5481.
**      12-jun-89 (robin)
**	    Always copy the DD_PACKETs of the WITH clause out of the area
**	    allocated by PSF into OPC's area.  Fix for bug 5487.
**	5-jun-90 (seputis)
**	    - check for null CO node for b21822
**      20-jun-90 (seputis)
**          fix b30453 - move check of OPD_DISTINCT out of opctreeutil.c
**	7-oct-91 (barbara)
**	    Star bug #40024.  Queries with no FROM list were always being 
**	    sent to the CDB.  Check for null table list before forcing
**	    query through CDB.
**	30-jan-92 (barbara)
**	    Refix above bug.  Check to opq_q7_tablist was unreliable so
**	    instead check for RETINTO types of query.  Original bug occurs
**	    only on CREATE AS SELECT with no from clause.
**	11-nov-92 (barbara)
**	    For delete cursor, keep track of open cursor's dsh, same as
**	    for update cursor.  Also, set action type as QEA_RDEL.
**	10-nov-93 (barbara)
**	    To support delimited ids and mixed case names, PSF will now
**	    pass user's column list.  This must be copied into the newly
**	    allocated QEL_DDL_INFO for passing to QEF.  (Fixes bug 56660)
**	20-may-94 (davebf)
**	    Added support for singlesite nested queries
**	08-dec-94 (rudtr01)
**	    BUG 49905 - modified opc_qtxt() to force SELECT portion of 
**	    QEA_D3_XFR (TRANSFER) through the priviliged CDB association
**	    when the query references only CDB tables.
**	03-apr-95 (rudtr01)
**	    BUGS 52601 & 49905 - removed previous fix for 49905 in order
**	    implement more correct and complete fix in opd_bflag() (opdcost.c)
**	    to fix more of the Star self-deadlock bugs.
**      03-mar-2004 (huazh01)
**          Modify the fix for 100982. We cannot use the parent's operation
**          site if the query that contains a PST_AGHEAD node. 
**          This fixes b111171, INGSTR60.
**	31-Aug-2006 (kschendel)
**	    Watch for HFAGG as well as RFAGG.  The generated action just
**	    sends a subquery fragment elsewhere, so hash vs sorted agg is
**	    irrelevant here.
**	16-Apr-2007 (kschendel) b122118
**	    Remove expr-LIKE code, flag triggering it was never set.  Ingres
**	    is now able to do "expr LIKE" anyway.
**      14-feb-08 (rapma01)
**          SIR 119650
**          Removed qeq_g1_firstn since first n is not currently
**          supported in star
**
*/
static VOID
opc_qtxt(
	OPO_CO	    *conode,
	QTX_STATE   *txstate )
{
    i4		res_temp;
    i4		hold_mode;
    QEF_AHD	*actionhdr;
    OPCTABHD	*tabptr;
    OPD_ISITE	site;
    QEQ_D1_QRY	*qptr;
    QED_DDL_INFO    *ddl_ptr;
    QEQ_TXT_SEG	*outwhere = NULL;
    OPS_SUBQUERY	*isubqry = txstate->qtx_subq; 
    OPS_STATE		*global = isubqry->ops_global;
    OPO_CO		*co;
    OPS_SUBQUERY	*subqry;
    OPV_VARS		*opvvar;
    OPV_SUBSELECT	*opvsub;
    OPV_GRV		*opvgrv;
    OPV_GSUBSELECT	*opvgsub;
    OPS_SUBQUERY	*prev_subq = (OPS_SUBQUERY *)NULL;
    QEF_AHD		*actptr;
    QEF_AHD		**prev_act;
    i4			saved_cnt;

    if ( conode != NULL )
    {   
 
	if ( conode->opo_outer != NULL )
	{
	    opc_qtxt( conode->opo_outer, txstate);
	}

	if(!(conode->opo_sjpr == DB_SJ &&
	      conode->opo_variant.opo_local->opo_jtype == OPO_SEJOIN))
	{
	    /* all exept sejoin */
	    if (conode->opo_inner != NULL)
	    {
		if (txstate->qtx_where != NULL)
		{
		    /* If there is a WHERE clause from
		    ** the outer child, save it while
		    ** we process the inner.
		    */
		    outwhere = txstate->qtx_where;
		    txstate->qtx_where = NULL;
		}
		opc_qtxt( conode->opo_inner, txstate);
		if (txstate->qtx_where == NULL)
		    txstate->qtx_where = outwhere;
		else if (outwhere != NULL )
		{
		    opc_addand( txstate, txstate->qtx_where );
		    opcu_joinseg( &txstate->qtx_where, outwhere );
		}
	    }
	}
	else	/* special processing for sejoin */
	{
	    QTX_STATE	local_txstate;   /* txstate for recursive calldown */

	    co = conode->opo_inner;  /* DB_ORIG inner to SEJOIN */

	    opvvar = isubqry->ops_vars.opv_base->opv_rt[co->opo_union.opo_orig];

	    for (opvsub = opvvar->opv_subselect;
		 opvsub != NULL;
		 opvsub = opvsub->opv_nsubselect)
	    {
		/* translate the subselect indirectly referenced thru opvsub */
		opvgrv = 
		    global->ops_rangetab.opv_base->opv_grv[opvsub->opv_sgvar];
		opvgsub = opvgrv->opv_gsubselect;
		subqry = opvgsub->opv_subquery;

		if(subqry->ops_compile.opc_ahd != (QEF_AHD *)NULL)
		{
		    /* ahd must have been built from an preceeding subquery */
		    /* must take it out of action chain */

		    for(actptr = global->ops_cstate.opc_qp->qp_ahd,
			prev_act = &global->ops_cstate.opc_qp->qp_ahd;
			actptr && actptr != subqry->ops_compile.opc_ahd;
			prev_act = &actptr->ahd_next,
			actptr = actptr->ahd_next);

		    if(actptr)
		    {
			/* chain around action(s) */

			if(actptr->ahd_next 
			   && actptr->ahd_next->ahd_atype == QEA_D2_GET)
			{
			    *prev_act = actptr->ahd_next->ahd_next;
			    global->ops_cstate.opc_qp->qp_ahd_cnt -= 2;
			}
			else
			{
			    *prev_act = actptr->ahd_next;
			    global->ops_cstate.opc_qp->qp_ahd_cnt -= 1;
			}

		    }
		    else    /* we didn't find it */
			/* meaningless instruction in order to set a break */
			actptr = (QEF_AHD *)NULL; 

/* may need to send back a consistency check error */

		    /* capture action header in gsubselect */
		    opvgsub->opv_ahd = subqry->ops_compile.opc_ahd;

		}
		else
		{
		    /* find last pair of actions currently in QP chain */
		    for(actptr = global->ops_cstate.opc_qp->qp_ahd;
			actptr && actptr->ahd_next;   /* actptr may be null */
			actptr = actptr->ahd_next);

		    /* keep current ahd count */
		    saved_cnt = global->ops_cstate.opc_qp->qp_ahd_cnt;

		    local_txstate.qtx_global = global;
		    local_txstate.qtx_tempno = OPD_NOTEMP;
		    local_txstate.qtx_dv_p = NULL;
		    local_txstate.qtx_qthd.opq_q1_ntemps = 0;
		    local_txstate.qtx_qthd.opq_q3_qlang = 
			    global->ops_qheader->pst_qtree->
				pst_sym.pst_value.pst_s_root.pst_qlang;
		    local_txstate.qtx_qthd.opq_q7_tablist = NULL;

		    /* build subselect text */
		    opc_subproc( subqry, &local_txstate, &prev_subq);

		    /* upon return, QEF_AHDs have been chained to the QP.
		    The first one has the text we want.
		    We have to unchain it and attach it to the gsubselect. */

		    if(!actptr)	    /* if this was the first action */
		    {
			opvgsub->opv_ahd = global->ops_cstate.opc_qp->qp_ahd;
			global->ops_cstate.opc_qp->qp_ahd = (QEF_AHD *)NULL;
		    }
		    else	        /* there were already actions chained */
		    {
			opvgsub->opv_ahd = actptr->ahd_next;
			actptr->ahd_next = (QEF_AHD *)NULL;
		    }
		
		    /* restore count */
		    global->ops_cstate.opc_qp->qp_ahd_cnt = saved_cnt;
		}
	    }

	}

	if ( conode->opo_sjpr == DB_RISAM ||
	    conode->opo_sjpr == DB_RHASH ||
	    conode->opo_sjpr == DB_RBTREE )
	    return;

	if ( conode->opo_sjpr == DB_ORIG &&
	       conode->opo_variant.opo_local->opo_bmbf == NULL)
	    return;

    }

    txstate->qtx_conode = conode;

    /*
    **  Add ldb's for this conode to the ldb list for QEF
    */

    if (conode != NULL )
    {
	if(global->ops_qheader->pst_distr->pst_stype & PST_1SITE)
	{
	    /* if this is a single-site query,
	    ** the operation site must be the highest indexed site.
	    ** This will be either the coordinator or a user remote */
	    /* This over-ride is necessary because the optimizer gets	
	    ** confused sometimes on the single-site case */

	    conode->opo_variant.opo_local->opo_operation =
		global->ops_gdist.opd_dv - 1;

	    /* also target will equal operation except when target is
	    ** "return to user" */	    
	    if(conode->opo_variant.opo_local->opo_target != OPD_TSITE)
		conode->opo_variant.opo_local->opo_target =
		conode->opo_variant.opo_local->opo_operation;
	}


    
        site = conode->opo_variant.opo_local->opo_operation;
	opc_dldbadd( txstate->qtx_global,
	    txstate->qtx_global->ops_gdist.opd_base->
		opd_dtable[site]->opd_ldbdesc,
	    &txstate->qtx_qthd.opq_q5_src_ldb );
	site = conode->opo_variant.opo_local->opo_target;
	opc_dldbadd( txstate->qtx_global, 
	    txstate->qtx_global->ops_gdist.opd_base->
		opd_dtable[site]->opd_ldbdesc,
	    &txstate->qtx_qthd.opq_q6_dest_ldb );
    }
    else
    {
	if ((txstate->qtx_subq->ops_sqtype == OPS_MAIN)
	    &&
	    (txstate->qtx_global->ops_qheader->pst_restab.pst_resvno >= 0
	    || 
	    txstate->qtx_global->ops_qheader->pst_mode==PSQ_RETINTO) /* b40024 */ )
	{
		site = OPD_TSITE;   /* this is an update or a create as select 
				    ** with no from list so send directly to 
				    ** the target site */
	}
	else
	{
		/* make sure the expression doesn't disjoint (b100982) */
		if ((txstate->qtx_subq->ops_sqtype == OPS_UNION ||
                     txstate->qtx_subq->ops_sqtype == OPS_VIEW) &&
                    (txstate->qtx_global->ops_subquery->ops_root->
                            pst_sym.pst_type != PST_AGHEAD))
			site = txstate->qtx_global->ops_subquery->ops_bestco->
					opo_variant.opo_local->opo_operation;
	    /* operation site is coordinator db */
		else
			site = txstate->qtx_global->ops_gdist.opd_coordinator;   
	}
	opc_dldbadd( txstate->qtx_global, 
	    txstate->qtx_global->ops_gdist.opd_base->
		opd_dtable[site]->opd_ldbdesc,
	    &txstate->qtx_qthd.opq_q5_src_ldb );
	if (txstate->qtx_subq->ops_sqtype == OPS_MAIN)
	    site = OPD_TSITE;   /* target site is 'return results to user' */
				/* fix bug 21822, make sure constant union view
				**  partition get evaluated on the coordinator
				*/
	opc_dldbadd( txstate->qtx_global, 
	    txstate->qtx_global->ops_gdist.opd_base->
		opd_dtable[site]->opd_ldbdesc,
	    &txstate->qtx_qthd.opq_q6_dest_ldb );
    }

    /*
    ** Initialize local flags.  Note that qtx_sagg is set by opc_subproc.
    */

    txstate->qtx_xfer = FALSE;
    txstate->qtx_remdup = FALSE;
    txstate->qtx_maketemp = FALSE;
    txstate->qtx_isroot = FALSE;
    txstate->qtx_makeqry = FALSE;
    txstate->qtx_link = FALSE;
    txstate->qtx_nonpresd = FALSE;
    txstate->qtx_qthd.opq_q16_expr_like = OPQ_NOELIKE;
 
    if (conode == NULL)
    {
	txstate->qtx_isroot = TRUE;
    }
    else 
    {
	if ( txstate->qtx_subq->ops_bestco == conode )
	{
	    /* this node is the root of the tree */
	    txstate->qtx_isroot = TRUE;
	}

	/*
	**  If the site where this operation is being performed differs
	**  from the 'target site' where the operation result is
	**  required, then a transfer action will be needed.
	**  The only exception, for select/retrieve only, 
	**   is when the target is 'site 0'.
	**  Site 0 means 'return results to the user'.
	*/

	if (conode->opo_variant.opo_local->opo_target 
	    !=
	    conode->opo_variant.opo_local->opo_operation)
	{
	    if (! ( txstate->qtx_subq->ops_sqtype == OPS_MAIN &&
		    (txstate->qtx_subq->ops_global->ops_gdist.opd_gmask & 
							OPD_NOFIXEDSITE) &&
		    txstate->qtx_isroot == TRUE
		  ))
	    {
		txstate->qtx_xfer = TRUE;
	    }
	}	
    }
    
    if (txstate->qtx_isroot == TRUE && 
	txstate->qtx_subq->ops_sqtype == OPS_MAIN )
    {
	if ( txstate->qtx_subq->ops_mode == PSQ_RETINTO )
	{
	    /*
	    ** User-specified CREATE LINK stmt
	    ** Query must be followed by action to 
	    ** define link to the new table, so it
	    ** will be known to Star
	    */
	    txstate->qtx_link = TRUE;
	}
	if ((txstate->qtx_subq->ops_duplicates == OPS_DREMOVE)
	    &&
	    (txstate->qtx_subq->ops_global->ops_gdist.opd_gmask & OPD_DISTINCT)
	    )
	    txstate->qtx_remdup = TRUE;	/* sorting was done explicitly to
					** remove duplicates, not only for 
					** other reasons
					*/
    }
    else if ( conode && conode->opo_pdups)
    {
	/*
	**  See if duplicate semantics of the statement require that
	**  duplicates be removed.
	*/
	txstate->qtx_remdup = TRUE;
    }


    if ((txstate->qtx_subq->ops_sqtype == OPS_FAGG ||
	 txstate->qtx_subq->ops_sqtype == OPS_PROJECTION ||
	 txstate->qtx_subq->ops_sqtype == OPS_UNION ||
	 txstate->qtx_subq->ops_sqtype == OPS_VIEW )
	 && txstate->qtx_isroot == TRUE )
    {
	/*
	** This is a function or projection subquery 
	** so always materialize the subquery
	** into a temp table.
	*/
	txstate->qtx_maketemp = TRUE;
    }

    if (txstate->qtx_isroot &&
	(txstate->qtx_subq->ops_dist.opd_smask & OPD_DUPS) &&
	(txstate->qtx_subq->ops_global->ops_gdist.opd_gmask & OPD_NOFIXEDSITE))
    {
	txstate->qtx_nonpresd = TRUE;
    }


    if ( txstate->qtx_xfer || 
	 (txstate->qtx_remdup && !(txstate->qtx_isroot)))
    {
	txstate->qtx_maketemp = TRUE;
    }

    if ( txstate->qtx_isroot || txstate->qtx_maketemp )
	txstate->qtx_makeqry = TRUE;

    if ( !txstate->qtx_maketemp && !txstate->qtx_makeqry )
    {
	/*
	**  Don't generate a query (or an action) for this CO node.  Simply
	**  add the join/qualification info from the node to the WHERE
	**  clause that is being built in the parameter block.
	*/

	opc_addtowhere(txstate);
    }
    else
    {
	if (txstate->qtx_nonpresd)
	{
	    /*  Create a temp to include non-printing resdoms, so that
	    **  duplicates are retained.  
	    **  
	    */
	    opc_dahd( txstate->qtx_global, &actionhdr );

	    /*  Get temporary number for result table */
	    opc_ntemp( txstate, &res_temp);

	    txstate->qtx_qthd.opq_q11_duplicate = OPQ_1DUP;
	    txstate->qtx_remdup = TRUE;
	    actionhdr->ahd_atype = QEA_D8_CRE;
	    hold_mode = txstate->qtx_subq->ops_mode;
	    txstate->qtx_subq->ops_mode = PSQ_RETRIEVE;
	    qptr = &actionhdr->qhd_obj.qhd_d1_qry;

	    opc_crsel( txstate, qptr, res_temp, 
		txstate->qtx_qthd.opq_q5_src_ldb, (bool) FALSE, (bool) FALSE );

	    opc_tbflg_ch( txstate, conode->opo_variant.opo_local->opo_bmvars,
		res_temp );
	    txstate->qtx_where = NULL;

	    txstate->qtx_subq->ops_dist.opd_create = res_temp;

	    /*
	    **  Reset flags, and generate the 'real' query
	    */

	    txstate->qtx_subq->ops_mode = hold_mode;
	    txstate->qtx_remdup = FALSE;	    
    	    txstate->qtx_qthd.opq_q11_duplicate = OPQ_2DUP;
	}		    


	/*
	**  Allocate an action header.
	*/
	opc_dahd( txstate->qtx_global, &actionhdr );

	if (txstate->qtx_maketemp)
	{
	    /*  Get temporary number for result table */
	    opc_ntemp( txstate, &res_temp);
	}
	if (txstate->qtx_maketemp && !txstate->qtx_xfer )
	{
	    /*
	    **  Used to be an error - now use 'create table
	    **  as select' to create a temp table on the
	    **  same site as the operation.
	    */

	    actionhdr->ahd_atype = QEA_D8_CRE;
	    qptr = &actionhdr->qhd_obj.qhd_d1_qry;

    	    opc_crsel( txstate, qptr, res_temp,
		txstate->qtx_qthd.opq_q5_src_ldb, (bool) FALSE, (bool) FALSE );
	}
	else if ( txstate->qtx_xfer )
	{
	    actionhdr->ahd_atype = QEA_D3_XFR;

	    /*  
	    **  This is a data transfer
	    */
	    tabptr = txstate->qtx_qthd.opq_q7_tablist;
	    if (tabptr != NULL)
	    {
		for (; tabptr->opq_t4_tnext != NULL;
			tabptr = tabptr->opq_t4_tnext);
	    }

	    txstate->qtx_qthd.opq_q2_type = OPQ_XFER;
	    txstate->qtx_qthd.opq_q8_curtable = (OPCTABHD *) 
		opu_qsfmem( txstate->qtx_global, sizeof(OPCTABHD));
	    txstate->qtx_qthd.opq_q8_curtable->opq_t2_tnum = res_temp;
	    txstate->qtx_qthd.opq_q8_curtable->opq_t3_ldb = 
		txstate->qtx_qthd.opq_q6_dest_ldb;
	    txstate->qtx_qthd.opq_q8_curtable->opq_t4_tnext = NULL;
	    txstate->qtx_qthd.opq_q8_curtable->opq_t5_ncols = 0;

	    if (tabptr == NULL)
		txstate->qtx_qthd.opq_q7_tablist = 
		    txstate->qtx_qthd.opq_q8_curtable;
	    else
		tabptr->opq_t4_tnext = txstate->qtx_qthd.opq_q8_curtable;

	    opcu_getrange( &txstate->qtx_qthd, (i4) (OPV_MAXVAR + res_temp),
		txstate->qtx_qthd.opq_q8_curtable->opq_t1_rname);

	    qptr = &actionhdr->qhd_obj.qhd_d3_xfr.qeq_x1_srce;
	    opc_query( txstate, qptr, txstate->qtx_remdup );
	    qptr->qeq_q8_dv_cnt = txstate->qtx_subq->ops_dist.opd_dv_cnt;
	    qptr->qeq_q9_dv_p = txstate->qtx_dv_p;
	    qptr->qeq_q11_dv_offset = txstate->qtx_subq->ops_dist.opd_dv_base;
	    opc_crtable( txstate, &actionhdr->qhd_obj.qhd_d3_xfr.qeq_x2_temp, 
		res_temp );
	    /* 
	    ** FIXME (hack for 68449)
	    */
	    if (txstate->qtx_forcexfer == TRUE)
	    {
		DD_LDB_DESC tmpldb;
		qptr = &actionhdr->qhd_obj.qhd_d3_xfr.qeq_x2_temp;
		STRUCT_ASSIGN_MACRO(*qptr->qeq_q5_ldb_p, tmpldb);
		tmpldb.dd_l1_ingres_b = FALSE;
		opc_dldbadd(txstate->qtx_global, &tmpldb, &qptr->qeq_q5_ldb_p);
	    }

	    opc_copy( txstate, &actionhdr->qhd_obj.qhd_d3_xfr.qeq_x3_sink );
	    /* 
	    ** FIXME (hack for 68449)
	    */
	    if (txstate->qtx_forcexfer == TRUE)
	    {
		DD_LDB_DESC tmpldb;
		qptr = &actionhdr->qhd_obj.qhd_d3_xfr.qeq_x3_sink;
		STRUCT_ASSIGN_MACRO(*qptr->qeq_q5_ldb_p, tmpldb);
		tmpldb.dd_l1_ingres_b = FALSE;
		opc_dldbadd(txstate->qtx_global, &tmpldb, &qptr->qeq_q5_ldb_p);
	    }
	}
	else
	{
	    /*
	    ** It is a simple query, simple aggregate or a cursor definition
	    */
	    if ( txstate->qtx_subq->ops_mode == PSQ_DEFCURS )
	    {
		actionhdr->ahd_atype = QEA_D7_OPN;
	    }
	    else if ( txstate->qtx_subq->ops_mode == PSQ_REPCURS )
	    {
		actionhdr->ahd_atype = QEA_D9_UPD;
	    }
	    else if ( txstate->qtx_subq->ops_mode == PSQ_DELCURS )
	    {
		actionhdr->ahd_atype = QEA_RDEL;
	    }
	    else if (isubqry->ops_sqtype == OPS_SAGG
		     || isubqry->ops_sqtype == OPS_RSAGG
		     || isubqry->ops_sqtype == OPS_HFAGG
		     || isubqry->ops_sqtype == OPS_RFAGG)
	    {
		actionhdr->ahd_atype = QEA_D6_AGG;

		if(isubqry->ops_next 	/* if not main query */
		&& isubqry->ops_agg.opa_father->ops_sqtype == OPS_SELECT)
		{
		    /* save this action pointer in select subquery */
		    isubqry->ops_agg.opa_father->ops_compile.opc_ahd = 
			actionhdr;
		}
		else if(isubqry->ops_next
		&& isubqry->ops_next->ops_sqtype == OPS_MAIN
	        && (global->ops_qheader->pst_distr->pst_stype & PST_1SITE))
		{
		    /* change action type */
		    actionhdr->ahd_atype = QEA_D1_QRY;
		}
	    }
	    else
	    {
		actionhdr->ahd_atype = QEA_D1_QRY;
	    }

	    qptr = &actionhdr->qhd_obj.qhd_d1_qry;
	    opc_query( txstate, qptr, txstate->qtx_remdup );
	    opc_qrybld( txstate->qtx_global, &txstate->qtx_qthd.opq_q3_qlang, 
		txstate->qtx_qthd.opq_q4_retrow_flg, qptr->qeq_q4_seg_p,
		txstate->qtx_qthd.opq_q5_src_ldb, qptr);
	    /* 
	    ** FIXME (hack for 68449)
	    */
	    if (txstate->qtx_forcexfer == TRUE)
	    {
		DD_LDB_DESC tmpldb;
		STRUCT_ASSIGN_MACRO(*qptr->qeq_q5_ldb_p, tmpldb);
		tmpldb.dd_l1_ingres_b = FALSE;
		opc_dldbadd(txstate->qtx_global, &tmpldb, &qptr->qeq_q5_ldb_p);
	    }

	    if (txstate->qtx_sagg || 
		txstate->qtx_subq->ops_mode == PSQ_RETRIEVE)
	    {
		qptr->qeq_q3_ctl_info |= QEQ_001_READ_TUPLES;
	    }

	    if (txstate->qtx_isroot && 
		txstate->qtx_subq->ops_sqtype == OPS_MAIN && 
		!(txstate->qtx_subq->ops_global->ops_gdist.opd_gmask 
							& OPD_NOFIXEDSITE))
	    { 
#if 0
 not sure why this check is needed? it always should be an update
		if ((	(conode != NULL) 
			&& 
			(conode->opo_variant.opo_local->opo_operation 
								== OPD_TSITE)
		    )
		    || 
		    (conode == NULL)  ) /* FIXME why does a constant 
					** query need an update? 
					*/
#endif
		{
		    qptr->qeq_q3_ctl_info |= QEQ_002_USER_UPDATE;
		}
	    }

	    if ( txstate->qtx_sagg )
	    {
		opc_sagg( txstate, qptr );
	    }
	    else
	    {
		qptr->qeq_q8_dv_cnt = txstate->qtx_subq->ops_dist.opd_dv_cnt;
		qptr->qeq_q9_dv_p = txstate->qtx_dv_p;
		qptr->qeq_q11_dv_offset = 
		    txstate->qtx_subq->ops_dist.opd_dv_base;
		if ( txstate->qtx_subq->ops_mode == PSQ_DEFCURS )
		{
		    qptr->qeq_q12_qid_first = FALSE; /* the 3 parameters for the
						    ** cursor come last */
		}
		else if (   txstate->qtx_subq->ops_mode == PSQ_REPCURS
			 || txstate->qtx_subq->ops_mode == PSQ_DELCURS)
		{
		    qptr->qeq_q12_qid_first = FALSE;
		    qptr->qeq_q13_csr_handle = txstate->qtx_subq->ops_global
			->ops_caller_cb->opf_parent_qep.qso_handle; 
		}
		if ( txstate->qtx_subq->ops_mode != PSQ_DEFCURS )
		{
		    qptr->qeq_q3_ctl_info |= QEQ_003_ROW_COUNT_FROM_LDB;
		}
		if (txstate->qtx_link)
		{
		    
		    /*
		    **  If there are 'with clause' strings to be added to
		    **  the query, add them to the end of the packet list
		    */
		    
		    qptr->qeq_q3_read_b = FALSE; /* treat like an update */
		    if (txstate->qtx_global->ops_qheader->pst_distr->pst_qtext
									!= NULL)
    		    {
			DD_PACKET   *ddp;
			DD_PACKET   *newpkt;
			DD_PACKET   *last_ddp;

			last_ddp = qptr->qeq_q4_seg_p->qeq_s2_pkt_p;
			for(;last_ddp->dd_p3_nxt_p != NULL;
			    last_ddp = last_ddp->dd_p3_nxt_p )
			    ;

			/* Copy WITH clause packets - fix for bug 5487 */

			for ( ddp = txstate->qtx_global->ops_qheader->
				    pst_distr->pst_qtext;
				ddp != NULL; ddp = ddp->dd_p3_nxt_p )
			{
			    newpkt = (DD_PACKET *) opu_qsfmem( 
				txstate->qtx_global,
				(i4) (sizeof(DD_PACKET) + ddp->dd_p1_len));
			    newpkt->dd_p1_len = ddp->dd_p1_len;
			    newpkt->dd_p2_pkt_p = (char *) newpkt
							+ sizeof( DD_PACKET);
			    newpkt->dd_p4_slot = DD_NIL_SLOT;
			    MEcopy( (PTR) ddp->dd_p2_pkt_p,
				ddp->dd_p1_len,
				(PTR) newpkt->dd_p2_pkt_p );
			    newpkt->dd_p3_nxt_p = (DD_PACKET *) NULL;
			    last_ddp->dd_p3_nxt_p = newpkt;
			    last_ddp = newpkt;
			}
		    }

		    /*
		    ** Need a 'create link' action
		    */
		    opc_dahd( txstate->qtx_global, &actionhdr );
		    actionhdr->ahd_atype = QEA_D4_LNK;
		    ddl_ptr = (QED_DDL_INFO *) opu_qsfmem(
			txstate->qtx_global, sizeof( QED_DDL_INFO));
		    actionhdr->qhd_obj.qhd_d4_lnk.qeq_l1_lnk_p = ddl_ptr;
		    STRUCT_ASSIGN_MACRO(*txstate->qtx_global->ops_qheader->
			pst_distr->pst_ddl_info,
			*ddl_ptr);
		    /* 
		    ** FIXME (hack for 68449)
		    */
		    if (txstate->qtx_forcexfer == TRUE)
		    {
			DD_LDB_DESC tmpldb, *ddldbp;
			ddldbp = &ddl_ptr->qed_d6_tab_info_p->
						dd_t9_ldb_p->dd_i1_ldb_desc;
			STRUCT_ASSIGN_MACRO(*ddldbp, tmpldb);
			tmpldb.dd_l1_ingres_b = TRUE;
			opc_dldbadd(txstate->qtx_global, &tmpldb, &ddldbp);
		    }
		    {
			/*
			** Copy the underlying structures into the QP ,
			** remember that the PSF query tree object gets
			** deleted so that all structures which are
			** allocated within that structure must be copied,
			** except perhaps the DDL info from RDF which remains
			** permanently in memory FIXME - remove this
			** assumption
			*/
			DD_2LDB_TAB_INFO    *old_tab_info_p;

			/*
			** NULL out the structures which are probably not
			** needed hopefully? so that we access violation on
			** a NULL dereference rather than look at deallocated
			** memory
			*/
			/* not needed */
			ddl_ptr->qed_d5_qry_info_p = (QED_QUERY_INFO *)NULL;
			/* not needed */
			ddl_ptr->qed_d4_ddb_cols_pp = (DD_COLUMN_DESC **)NULL;
			old_tab_info_p = ddl_ptr->qed_d6_tab_info_p;
			ddl_ptr->qed_d6_tab_info_p = (DD_2LDB_TAB_INFO *) 
			    opu_qsfmem( txstate->qtx_global,
				sizeof( DD_2LDB_TAB_INFO ));
			STRUCT_ASSIGN_MACRO(*old_tab_info_p ,
			    *ddl_ptr->qed_d6_tab_info_p);
		    }
		    {
			/*
			** Copy the user's column list, if any
			*/
			DD_COLUMN_DESC	**old_col_desc_pp =
					txstate->qtx_global->ops_qheader->
					pst_distr->pst_ddl_info->
					qed_d4_ddb_cols_pp;
			int i;

			if (   old_col_desc_pp != (DD_COLUMN_DESC **)NULL
			    && old_col_desc_pp[1] != (DD_COLUMN_DESC *)NULL
			   )
			{
			    ddl_ptr->qed_d4_ddb_cols_pp = (DD_COLUMN_DESC **)
				opu_qsfmem (txstate->qtx_global,
				(ddl_ptr->qed_d3_col_count+1)
				    * sizeof(DD_COLUMN_DESC *));

			    for (i=1; i <= ddl_ptr->qed_d3_col_count;
				 i++)
			    {
				ddl_ptr->qed_d4_ddb_cols_pp[i] =
					(DD_COLUMN_DESC *)opu_qsfmem
					( txstate->qtx_global, 
					    sizeof( DD_COLUMN_DESC ));
				STRUCT_ASSIGN_MACRO(*old_col_desc_pp[i],
				    *ddl_ptr->qed_d4_ddb_cols_pp[i]);
			    }
			}	
		    }
		    if (ddl_ptr->qed_d9_reg_info_p)
		    {	/* copy the iiregistrations information */
			QED_QUERY_INFO	*old_reg_info;
			DD_PACKET	**packetpp;

			old_reg_info = ddl_ptr->qed_d9_reg_info_p;
			ddl_ptr->qed_d9_reg_info_p = (QED_QUERY_INFO *) 
			    opu_qsfmem( txstate->qtx_global,
				sizeof( QED_QUERY_INFO ));
			STRUCT_ASSIGN_MACRO(*old_reg_info ,
			    *ddl_ptr->qed_d9_reg_info_p);
			/*PSF does not init this field */
			ddl_ptr->qed_d9_reg_info_p->qed_q5_dv_cnt = 0;
			ddl_ptr->qed_d9_reg_info_p->qed_q6_dv_p =
			    (DB_DATA_VALUE *) NULL; /*
						    ** PSF does not init
						    ** this field
						    */
			for (packetpp = 
				&ddl_ptr->qed_d9_reg_info_p->qed_q4_pkt_p;
			    *packetpp; packetpp = &(*packetpp)->dd_p3_nxt_p)
			{   /* copy the packet info into QP memory */
			    DD_PACKET	    *newpacketp;
			    newpacketp = (DD_PACKET *) opu_qsfmem(
				txstate->qtx_global,
				(sizeof(DD_PACKET) + (*packetpp)->dd_p1_len));
			    STRUCT_ASSIGN_MACRO(**packetpp, *newpacketp);
			    newpacketp->dd_p2_pkt_p = (char *) newpacketp
				+ sizeof( DD_PACKET);
			    MEcopy( (PTR) (*packetpp)->dd_p2_pkt_p,
				(*packetpp)->dd_p1_len,
				(PTR) newpacketp->dd_p2_pkt_p );
			    *packetpp = newpacketp;	/* save the address of
							** new packet in
							** previous pointer */
			}
		    }
		    {	/* copy the underlying DDB info */
			DD_1LDB_INFO	*old_1ldb_p;
			/* not needed */
			ddl_ptr->qed_d6_tab_info_p->dd_t8_cols_pp =
			    (DD_COLUMN_DESC  **)NULL;
			old_1ldb_p = ddl_ptr->qed_d6_tab_info_p->dd_t9_ldb_p;
			ddl_ptr->qed_d6_tab_info_p->dd_t9_ldb_p =
			    (DD_1LDB_INFO *) opu_qsfmem( txstate->qtx_global, 
				sizeof( DD_1LDB_INFO ));
			STRUCT_ASSIGN_MACRO(*old_1ldb_p , 
			    *ddl_ptr->qed_d6_tab_info_p->dd_t9_ldb_p);
		    }
		}		
		else if (txstate->qtx_qthd.opq_q4_retrow_flg && 
			 actionhdr->ahd_atype != QEA_D7_OPN)
		{
		    /* need to generate a 'get' action too */
    
		    opc_dahd( txstate->qtx_global, &actionhdr );
		    actionhdr->ahd_atype = QEA_D2_GET;
		    actionhdr->qhd_obj.qhd_d2_get.qeq_g1_ldb_p 
					= txstate->qtx_qthd.opq_q5_src_ldb;
		}

	    }
	}	    

	if (txstate->qtx_maketemp && conode)
	{
	    /*
	    **  Label all range variables in the subtree with the result
	    **  table number.  The temp will be referenced in subsequent
	    **  query actions instead of the base table.
	    */
	    
	    opc_tbflg_ch( txstate, conode->opo_variant.opo_local->opo_bmvars, 
		res_temp );
	}

	/*
	**  Since a query was generated that used the where clause we
	**  were carrying in the state variable, reset the
	**  where clause to be empty;
	*/

	txstate->qtx_where = NULL;

    }

    return;    

}

static DD_PACKET *
opc_packet( 
QTX_STATE	*txstate,
char		*stringptr,
OPD_ITEMP	tempno,
DD_PACKET	**pktloc )
{
    DD_PACKET	*pktptr;

    pktptr = (DD_PACKET	*) opu_qsfmem( txstate->qtx_global, 
	sizeof( DD_PACKET ));
    pktptr->dd_p3_nxt_p = (DD_PACKET *) NULL;

    if ( tempno == OPD_NOTEMP )
    {
	pktptr->dd_p1_len = STlength( stringptr );
	pktptr->dd_p2_pkt_p = (PTR) opu_qsfmem( txstate->qtx_global, 
	    pktptr->dd_p1_len );
	pktptr->dd_p4_slot = DD_NIL_SLOT;
	MEcopy( stringptr, pktptr->dd_p1_len, pktptr->dd_p2_pkt_p );
    }
    else
    {
	pktptr->dd_p1_len = 0;
	pktptr->dd_p2_pkt_p = NULL;
	pktptr->dd_p4_slot = tempno;
    }
    if (pktloc != NULL)
    {
	*pktloc = pktptr;
    }

    return( pktptr );
}


/*{
** Name: opc_dproj	- Projection subquery
**
** Description:
{@comment_line@}...
**
** Inputs:
[@PARAM_DESCR@]...
**
** Outputs:
@PARAM_DESCR@]...
**	Returns:
**	    [@return_description@}
**	Exceptions:
**	    [@description_or_none@]
**
** Side Effects:
**	    [@description_or_none@]
**
** History:
**      12-jun-89 (robin)
**	    Added OPG_SCOUNT to test for insertion (like OPG_COUNT and
**	    OPG_ANY).  Fixes bug 5486.
**	03-aug-89 (robin)
**	    Added compile and lint changes from Unix.
**      28-nov-92 (ed)
**          There can be more than 9 columns/resdoms, check for this
**	10-sep-93 (ed)
**	    fixed lint error
[@history_line@]...
[@history_template@]...
*/
static VOID
opc_dproj(
	QTX_STATE	*txstate,
	OPS_SUBQUERY	*proj_subq,
	OPD_ITEMP	proj_tempno,
	OPS_SUBQUERY	*fagg_subq,
	OPD_ITEMP	fagg_tempno )
{

    	QEF_AHD		*actionhdr;
	QEQ_D1_QRY	*qryptr;
	OPCTABHD	*projtab;
	OPCTABHD	*faggtab;
	OPCTABHD	*tabptr;
	DD_PACKET	*pktptr;
	DD_PACKET	*holdpkt;
	DD_PACKET	*inspkts;
	PST_QNODE	*nodearray[ DD_MAXCOLUMN ];
	PST_QNODE	*resdomp;
	i4		nnodes;
	i4		idx;
	i4		plen;
	i4		flen;
	i4		clen;
	char		colname[ DB_ATT_MAXNAME];
	char		tbuf[80];
	char		*tbufptr;
	char		ibuf[80];
	char		*ibufptr;
	bool		first;
	bool		printzero;
	bool		skippit;


	char		*d1 = "delete from ";
	char		*d2 = " where exists ( select 1 from ";
	char		*d3 = " where ( ";
	char		*d4 = " ) and ( ";
	char		*d5 = " or ( ";
	char		*d6 = " is null and ";
	char		*d7 = " is null ) ";
	char		*in1 = "insert into ";
	char		*in2 = " ( ";
	char		*in3 = " ) select ";
	char		*in4 = " from ";

    /*
    ** Find the table entries for the temp tables that were
    ** created for the projection and the function aggregate
    ** subqueries.
    */
    projtab = NULL;
    faggtab = NULL;
    tabptr = txstate->qtx_qthd.opq_q7_tablist;
    for (; tabptr != NULL; tabptr = tabptr->opq_t4_tnext)
    {
	if ( tabptr->opq_t2_tnum == proj_tempno )
	    projtab = tabptr;
	if ( tabptr->opq_t2_tnum == fagg_tempno )
	    faggtab = tabptr;    
    }

    if ( projtab == NULL || faggtab == NULL ||
         projtab->opq_t3_ldb != faggtab->opq_t3_ldb )
    {
	    opx_error( E_OP0A94_OPCFPROJ );
    }

    /*
    **  The projection temp was created to contain the same
    **  columns as the BY list in the function aggregate
    **  subquery.  Create an array of all the resdoms in
    **  the function agg by list.  Note that this array must
    **  be processed in reverse order.
    */

    opcu_arraybld( fagg_subq->ops_byexpr, (i4) PST_RESDOM, (PST_QNODE *) NULL,
	nodearray, &nnodes );

    if ( nnodes <= 0 )
    {
	    opx_error( E_OP0A95_OPCBYTARGET);
    }

    flen = STlength( faggtab->opq_t1_rname );
    plen = STlength( projtab->opq_t1_rname );

    /*
    **  Create a DELETE query action to remove from the projection
    **  temp table any tuples that are already in the function aggregate
    **  temporary.
    */

    opc_dahd( txstate->qtx_global, &actionhdr );    
    actionhdr->ahd_atype = QEA_D1_QRY;
    qryptr = &actionhdr->qhd_obj.qhd_d1_qry;

    qryptr->qeq_q1_lang = txstate->qtx_qthd.opq_q3_qlang;
    qryptr->qeq_q2_quantum = 0;
    qryptr->qeq_q3_read_b = FALSE;
    qryptr->qeq_q3_ctl_info = 0;
    qryptr->qeq_q5_ldb_p = projtab->opq_t3_ldb;
    qryptr->qeq_q6_col_cnt = 0;
    qryptr->qeq_q7_col_pp = NULL;
    qryptr->qeq_q8_dv_cnt = txstate->qtx_subq->ops_dist.opd_dv_cnt;
    qryptr->qeq_q9_dv_p = txstate->qtx_dv_p;
    qryptr->qeq_q10_agg_size = 0;
    qryptr->qeq_q11_dv_offset = txstate->qtx_subq->ops_dist.opd_dv_base;
    qryptr->qeq_q12_qid_first = TRUE;    
    qryptr->qeq_q13_csr_handle = NULL; 
    qryptr->qeq_q4_seg_p = (QEQ_TXT_SEG *) opu_qsfmem(  txstate->qtx_global, 
	sizeof (QEQ_TXT_SEG ));
    qryptr->qeq_q4_seg_p ->qeq_s1_txt_b = TRUE;
    qryptr->qeq_q4_seg_p ->qeq_s3_nxt_p = NULL;

    pktptr = opc_packet( txstate, d1, (OPD_ITEMP) OPD_NOTEMP, 
	&qryptr->qeq_q4_seg_p->qeq_s2_pkt_p );
    pktptr = opc_packet( txstate, NULL, proj_tempno, &pktptr->dd_p3_nxt_p );
    tbuf[0] = ' ';
    MEcopy( projtab->opq_t1_rname, plen, &tbuf[1] );
    tbuf[ plen+1 ] = '\0';
    pktptr = opc_packet( txstate, &tbuf[0], (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p);
    pktptr = opc_packet( txstate, d2, (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );
    pktptr = opc_packet( txstate, NULL, fagg_tempno, &pktptr->dd_p3_nxt_p );
    tbuf[0] = ' ';
    MEcopy( faggtab->opq_t1_rname, flen, &tbuf[1] );
    tbuf[ flen+1 ] = '\0';
    pktptr = opc_packet( txstate, &tbuf[0], (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );
    pktptr = opc_packet( txstate, d3, (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );

    /*
    **  Build a where clause to join the projection temp and aggregate temp:
    **	... proj_temp_rngvar.proj_col_n = fagg_temp_rngvar.proj_col_n
    */

    for (first = TRUE, idx = nnodes - 1; idx >= 0 ; idx--)
    {
	tbufptr = &tbuf[0];
	if (first)
	    first = FALSE;
	else
	{
	    pktptr = opc_packet( txstate, d4, (OPD_ITEMP) OPD_NOTEMP, 
		&pktptr->dd_p3_nxt_p );	    
	}

	resdomp = nodearray[ idx ];
	colname[0] = 'a';
	CVla( (i4) resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsno,
	       (char *) &colname[1] );
	clen = STlength(colname);

	*tbufptr++ = ' ';
	MEcopy( projtab->opq_t1_rname, plen, tbufptr);
	tbufptr += plen;
	*tbufptr++ = '.';
	MEcopy( (PTR) &colname[0], clen, tbufptr );
	tbufptr += clen;
	*tbufptr++ = '=';
	MEcopy( faggtab->opq_t1_rname, flen, tbufptr  );
	tbufptr += flen;
	*tbufptr++ = '.';
	MEcopy( (PTR) &colname[0], clen, tbufptr );
	tbufptr += clen;

	*tbufptr = '\0';
	pktptr = opc_packet( txstate, &tbuf[0], (OPD_ITEMP) OPD_NOTEMP, 
	    &pktptr->dd_p3_nxt_p );

	if (resdomp->pst_sym.pst_dataval.db_datatype < 0 )
	{
	    /*
	    **  Column is nullable, so add nulljoin code
	    */
	    pktptr = opc_packet( txstate, d5, (OPD_ITEMP) OPD_NOTEMP, 
		&pktptr->dd_p3_nxt_p );	    

	    tbufptr = &tbuf[0];
	    MEcopy( projtab->opq_t1_rname, plen, tbufptr);
	    tbufptr += plen;
	    *tbufptr++ = '.';
	    MEcopy( (PTR) &colname[0], clen, tbufptr );
	    tbufptr += clen;	    
	    *tbufptr = '\0';
	    pktptr = opc_packet( txstate, &tbuf[0], (OPD_ITEMP) OPD_NOTEMP, 
		&pktptr->dd_p3_nxt_p );
	    pktptr = opc_packet( txstate, d6, (OPD_ITEMP) OPD_NOTEMP, 
		&pktptr->dd_p3_nxt_p );
	    tbufptr = &tbuf[0];
	    MEcopy( faggtab->opq_t1_rname, flen, tbufptr);
	    tbufptr += plen;
	    *tbufptr++ = '.';
	    MEcopy( (PTR) &colname[0], clen, tbufptr );
	    tbufptr += clen;	    
	    *tbufptr = '\0';
	    pktptr = opc_packet( txstate, &tbuf[0], (OPD_ITEMP) OPD_NOTEMP,
		&pktptr->dd_p3_nxt_p );
	    pktptr = opc_packet( txstate, d7, (OPD_ITEMP) OPD_NOTEMP, 
		&pktptr->dd_p3_nxt_p );
	}
    }

    pktptr = opc_packet( txstate, ") ) ", (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );

    /*
    **  Now build an INSERT query action to add to the function temp any 
    **  tuples from the projection temp that it did not contain already
    **  (simulating outer join).
    */

    opc_dahd( txstate->qtx_global, &actionhdr );    
    actionhdr->ahd_atype = QEA_D1_QRY;
    qryptr = &actionhdr->qhd_obj.qhd_d1_qry;

    qryptr->qeq_q1_lang = txstate->qtx_qthd.opq_q3_qlang;
    qryptr->qeq_q2_quantum = 0;
    qryptr->qeq_q3_read_b = FALSE;
    qryptr->qeq_q3_ctl_info = 0;
    qryptr->qeq_q5_ldb_p = projtab->opq_t3_ldb;
    qryptr->qeq_q6_col_cnt = 0;
    qryptr->qeq_q7_col_pp = NULL;
    qryptr->qeq_q8_dv_cnt = txstate->qtx_subq->ops_dist.opd_dv_cnt;
    qryptr->qeq_q9_dv_p = txstate->qtx_dv_p;
    qryptr->qeq_q10_agg_size = 0;
    qryptr->qeq_q11_dv_offset = txstate->qtx_subq->ops_dist.opd_dv_base;
    qryptr->qeq_q12_qid_first = TRUE;    
    qryptr->qeq_q13_csr_handle = NULL; 
    qryptr->qeq_q4_seg_p = (QEQ_TXT_SEG *) opu_qsfmem(  txstate->qtx_global, 
	sizeof (QEQ_TXT_SEG ));
    qryptr->qeq_q4_seg_p ->qeq_s1_txt_b = TRUE;
    qryptr->qeq_q4_seg_p ->qeq_s3_nxt_p = NULL;

    pktptr = opc_packet( txstate, in1, (OPD_ITEMP) OPD_NOTEMP, 
	&qryptr->qeq_q4_seg_p->qeq_s2_pkt_p );
    pktptr = opc_packet( txstate, NULL, fagg_tempno, &pktptr->dd_p3_nxt_p );
    pktptr = opc_packet( txstate, in2, (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );

    /*
    **	Build an array of all resdoms in the function aggregate subquery
    **  target list.
    */

    opcu_arraybld( fagg_subq->ops_root->pst_left, (i4) PST_RESDOM, 
	(PST_QNODE *) NULL, nodearray, &nnodes );

    if ( nnodes <= 0 )
    {
	    opx_error( E_OP0A95_OPCBYTARGET);
    }

    /*
    **  Create list of columns to be inserted into, and in parallel, 
    **  of the columns in the projection temp to be inserted from.  
    */

    for (first = TRUE, idx = nnodes - 1; idx >= 0 ; idx--)
    {

	resdomp = nodearray[ idx ];
	colname[0] = 'a';
	CVla( (i4) resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsno,
	       &colname[1] );
	clen = STlength(colname);

	tbufptr = &tbuf[0];
	ibufptr = &ibuf[0];
	printzero = FALSE;
	skippit = FALSE;
	if (!(resdomp->pst_sym.pst_value.pst_s_rsdm.pst_rsflags&PST_RS_PRINT))
	{
	    skippit = TRUE;
	}
	else if ( resdomp->pst_right->pst_sym.pst_type == PST_AOP )
	{
	    if( resdomp->pst_right->pst_sym.pst_value.pst_s_op.pst_opno ==
		txstate->qtx_global->ops_cb->ops_server->opg_any || 
	        resdomp->pst_right->pst_sym.pst_value.pst_s_op.pst_opno ==
		txstate->qtx_global->ops_cb->ops_server->opg_count ||
	        resdomp->pst_right->pst_sym.pst_value.pst_s_op.pst_opno ==
		txstate->qtx_global->ops_cb->ops_server->opg_scount )

	    {
		/*  
		** Need to specifically insert a 0 value for this
		** column
		*/
		printzero = TRUE;
	    }
	    else
	    {
		skippit = TRUE; /* omitted aops get default val */
	    }
	}

	if ( !skippit )
	{
	    if (!first)
	    {
		*ibufptr++ = ',';
		*tbufptr++ = ',';
	    }
	    MEcopy((PTR)colname,  clen, (PTR)tbufptr);
	    tbufptr += clen;
	    *tbufptr++ = '\0';

	    if (printzero)
	    {
		*ibufptr++ = ' ';
		*ibufptr++ = '0';
		*ibufptr++ = '\0';
	    }
	    else
	    {
		MEcopy(projtab->opq_t1_rname  , plen, ibufptr );
		ibufptr += plen;
		*ibufptr++ = '.';
		MEcopy((PTR)colname, clen, (PTR)ibufptr);
		ibufptr += clen;
		*ibufptr++ = '\0';
	    }
	    pktptr = opc_packet( txstate, &tbuf[0], (OPD_ITEMP) OPD_NOTEMP, 
		&pktptr->dd_p3_nxt_p );
	    if (first)
	    {
		holdpkt = opc_packet( txstate, &ibuf[0], 
		    (OPD_ITEMP) OPD_NOTEMP, NULL );
		inspkts = holdpkt;
	    }
	    else
	    {
		inspkts = opc_packet( txstate, &ibuf[0], 
		    (OPD_ITEMP) OPD_NOTEMP, &inspkts->dd_p3_nxt_p );
	    }
	    first = FALSE;
	}
    }

    pktptr = opc_packet( txstate, in3, (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );
    pktptr->dd_p3_nxt_p = holdpkt;
    pktptr = inspkts;		/* last packet in list */
    pktptr = opc_packet( txstate, in4, (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );
    pktptr = opc_packet( txstate, NULL, proj_tempno, &pktptr->dd_p3_nxt_p );
    tbufptr = &tbuf[0];
    *tbufptr++ = ' ';
    MEcopy( projtab->opq_t1_rname, flen, tbufptr  );
    tbufptr += flen;
    *tbufptr++ = ' ';
    *tbufptr++ = '\0';
    pktptr = opc_packet( txstate, &tbuf[0], (OPD_ITEMP) OPD_NOTEMP, 
	&pktptr->dd_p3_nxt_p );

    return;
}

/*{
** Name: opc_psagg	- preprocess a simple aggregate query
**
** Description:
**      This routine will ensure that the order of the target list is the 
**      same order as parameter numbers for the respective constants since 
**      QEF assumes this order 
**
** Inputs:
**      subquery                        ptr to simple aggregate subquery
**
** Outputs:
**	Returns:
**	    {@return_description@}
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**      26-MAY-89 (seputis)
**          initial creation
**	26-may-89 (seputis) fixed b5483 - make sure target list is in same
**	    order as DB_DATA_VALUE array
**	21-aug-01 (inkdo01)
**	    Change for AOP's - with binary aggs, AOP pst_right no longer addresses
**	    fake parmno.
[@history_template@]...
*/
static VOID
opc_psagg(
	OPS_SUBQUERY       *subquery )
{   /* rearrange simple aggregate results to be in the same
    ** order as the tuple to be returned from the LDB */
    PST_QNODE	    **resdompp;
    OPS_PNUM	    lastparmno;

    lastparmno = subquery->ops_global->ops_parmtotal;
    for (resdompp = &subquery->ops_root->pst_left;
	*resdompp;)
    {
	PST_QNODE	    *aop_node;
	aop_node = (*resdompp)->pst_right;
	if (((*resdompp)->pst_sym.pst_type == PST_RESDOM)
	    &&
	    (aop_node->pst_sym.pst_type == PST_AOP )
	    )
	{
	    OPS_PNUM	parmno;

	    parmno = aop_node->pst_sym.pst_value.pst_s_op.pst_opparm;
					/* parm no lives in AOP */
	    if (lastparmno < parmno)
	    {	/* this parameter is out of order so place it into order */
		PST_QNODE	*resdomp;
		PST_QNODE	*temp;
		resdomp = *resdompp;
		*resdompp = (*resdompp)->pst_left; /* remove resdom from list
				    ** so that it can be place in order
				    ** later */
		for (temp = subquery->ops_root; 
		    temp && (temp != (*resdompp)); temp=temp->pst_left)
		{
		    if ((temp->pst_left->pst_sym.pst_type == PST_RESDOM)
			&&
			(temp->pst_left->pst_right->pst_sym.pst_type
								    == PST_AOP )
			&&
			(temp->pst_left->pst_right->pst_sym.pst_value.
				pst_s_op.pst_opparm < parmno)
			)
		    {
			/* found the correct insertion point for the parm */
			resdomp->pst_left = temp->pst_left;
			temp->pst_left = resdomp;
			resdomp = (PST_QNODE *)NULL;
			break;
		    }
		}
		if (resdomp)
		    opx_error (E_OP0A8A_OPCSAGG); /* expected to insert the
						** simple aggregate */
	    }
	    else
	    {
		lastparmno = parmno;		/* this parameter is in the
						** correct position so update
						** the count */
		resdompp = &(*resdompp)->pst_left;	/* get next node */
	    }
	}
	else
	{
	    resdompp = &(*resdompp)->pst_left;	/* get next node */
	}
    }
}


/*{
** Name: opc_subproc	-   process a subquery
**
** Description:
**
** Inputs:
**	subq_ptr		    Ptr to the subuqery to process
**      txstate			    Global state variable
**	prev_subq		    Subquery processed before current one
**
** Outputs:
**
**	prev_subq		    Will be updated to be the subquery just
**				    processed
**	Returns:
**	    VOID
**	Exceptions:
**	    none.
**
** Side Effects:
**	    none.
**
** History:
**      07-jun-89 (robin)
**          Created.
[@history_template@]...
*/
static VOID
opc_subproc(
	OPS_SUBQUERY	*subq_ptr,
	QTX_STATE	*txstate,
	OPS_SUBQUERY	**prev_subq )
{

	OPS_STATE   *global;
	i4	    prev_tempno;

	global = txstate->qtx_global;

	/*
	**  Initialize the state parameter block for this subquery
	*/

	txstate->qtx_subq = subq_ptr;
	txstate->qtx_conode = NULL;
	txstate->qtx_where = NULL;
	txstate->qtx_drop = NULL;
	txstate->qtx_xfer = FALSE;
	txstate->qtx_remdup = FALSE;
	txstate->qtx_maketemp = FALSE;
	txstate->qtx_isroot = FALSE;
	txstate->qtx_makeqry = FALSE;
	txstate->qtx_link = FALSE;
	txstate->qtx_forcexfer = FALSE; /* FIXME (hack for 68449) */
	
	if (subq_ptr->ops_sqtype == OPS_SAGG  
	&& !(global->ops_qheader->pst_distr->pst_stype & PST_1SITE))
	{
	    txstate->qtx_sagg = TRUE;
	}
	else
	{
	    txstate->qtx_sagg = FALSE;
	}

	if (( *prev_subq) != NULL &&
	    (*prev_subq)->ops_sqtype == OPS_PROJECTION &&
	    subq_ptr->ops_sqtype == OPS_FAGG )
	{
	    txstate->qtx_qthd.opq_q13_projfagg = TRUE;
	}
	else
	{
	    txstate->qtx_qthd.opq_q13_projfagg = FALSE;
	}

	txstate->qtx_qthd.opq_q2_type = 0;
	txstate->qtx_qthd.opq_q5_src_ldb = NULL;
	txstate->qtx_qthd.opq_q6_dest_ldb = NULL;
	txstate->qtx_qthd.opq_q9_flattened = FALSE;
	txstate->qtx_qthd.opq_q10_sort_node = NULL;
	txstate->qtx_qthd.opq_q11_duplicate = OPQ_NODUP;
	txstate->qtx_qthd.opq_q14_need_close = FALSE;
	txstate->qtx_qthd.opq_q16_expr_like = OPQ_NOELIKE;

	/*
	** Initialize the temp table type flag for the subquery
	*/

	subq_ptr->ops_dist.opd_create = OPD_NOTEMP;

	if (subq_ptr->ops_bestco != NULL &&
	    subq_ptr->ops_bestco->opo_sjpr == DB_RSORT)
	{
	    /*
	    **  Save the sort node in the state structure,
	    **  and remove it from the CO tree.
	    **  Check that the target site for the sort is the same as
	    **  the target site for its child.  If they are not the same,
	    **  change the child's target site to be the sort's target
	    **  site(bug 5467).
	    */
	
	    txstate->qtx_qthd.opq_q10_sort_node = subq_ptr->ops_bestco;
	    subq_ptr->ops_bestco = txstate->
		qtx_qthd.opq_q10_sort_node->opo_outer;
	    if ( subq_ptr->ops_bestco == NULL )	
	    {
		subq_ptr->ops_bestco = txstate->
		    qtx_qthd.opq_q10_sort_node->opo_inner;	    
	    }
	    if ( txstate->qtx_qthd.opq_q10_sort_node->
		    opo_variant.opo_local->opo_target !=
		 subq_ptr->ops_bestco->opo_variant.opo_local->opo_target )
	    {
		/*
		**  The sort node specified site movement.
		**  Copy it into the new root node.
		*/

		subq_ptr->ops_bestco->opo_variant.opo_local->opo_target = 
	        txstate->qtx_qthd.opq_q10_sort_node->
		    opo_variant.opo_local->opo_target;
	    }
	}    

	if (global->ops_qheader->pst_mode == PSQ_RETRIEVE ||
	    global->ops_qheader->pst_mode == PSQ_RETINTO )
	{
	    txstate->qtx_qthd.opq_q4_retrow_flg = TRUE;
	}
	else
	{
	    txstate->qtx_qthd.opq_q4_retrow_flg = FALSE;
	}

	/*
	**  If necessary, fix up a 'fake' conode to be the root of a
	**  non-retrieve query.  This node may be needed to
	**  generate the 'insert', 'delete', 'update', or
	**  'create as select' query.
	*/
	if (subq_ptr->ops_sqtype == OPS_MAIN)
	{
	    if ( global->ops_qheader->pst_mode == PSQ_RETINTO &&
		 global->ops_qheader->pst_mask1 & PST_CDB_IIDD_TABLES &&
		 subq_ptr->ops_bestco->opo_variant.opo_local->opo_target == OPD_TSITE &&
		 subq_ptr->ops_bestco->opo_variant.opo_local->opo_operation == OPD_TSITE 
		)
	    {
		subq_ptr->ops_bestco->opo_variant.opo_local->opo_operation 
						= OPD_CSITE;
		txstate->qtx_forcexfer = TRUE;
	    }

	    opc_nonsel( txstate );
	}

	if ( subq_ptr->ops_sqtype == OPS_MAIN && 
	    ( global->ops_gdist.opd_gmask & OPD_EXISTS))
	{	
	    /*
	    **  This is not a query that simply returns tuples to the user.
	    **  It is an update, insert, delete, or non-readonly cursor
	    **  definition.
	    **  What makes these queries special is that the final query must
	    **  always refer to the base table to be modified, not to a temp
	    **  (which is fine for retrieval).  Also, although the queries may
	    **  only modifiy a single table, their where clauses may contain
	    **  nested subselects which will have been flattened by OPF.
	    **  Some of this testing may be redundant since OPF set OPD_EXISTS.
	    */

	    i4	    nvars;
	    i4	    varno;

	    nvars = 0;
	    if ( subq_ptr->ops_bestco != NULL )
	    {
		nvars = BTcount( (char *) subq_ptr->ops_bestco->
			opo_variant.opo_local->opo_bmvars,
		    (i4) subq_ptr->ops_vars.opv_rv);
	    }

	    /*
	    **  See if the query references more than one table.  If so, it
	    **  has been flattened.
	    */

	    if (nvars == 1 && subq_ptr->ops_localres != OPV_NOVAR )
	    {	
	        varno = -1;
	        varno = BTnext((i4)varno,
		    (char *)subq_ptr->ops_bestco->
			opo_variant.opo_local->opo_bmvars,
		    subq_ptr->ops_vars.opv_rv);
	        if (varno != subq_ptr->ops_localres)
	        {
			/*
			**  The table to be updated is different from the table
			**  referenced by the CO tree (implying there will be
			**  a tid join in the final query).  At any rate, the
			**  table still references multiple tables.
			*/

			txstate->qtx_qthd.opq_q9_flattened = TRUE;
	        }
	    }
	    else if (nvars > 1)
	    {		    		
	        txstate->qtx_qthd.opq_q9_flattened = TRUE;
	    }
	}

	/*
	**  Initialize the 'use base table' flag in all
	**  local range variables referenced in this
	**  subquery.
	*/

	if ( subq_ptr->ops_bestco != NULL )
	{
	    opc_tbflg_ch( txstate, subq_ptr->ops_bestco->
		opo_variant.opo_local->opo_bmvars, 
		(OPD_ITEMP) OPD_NOTEMP );
	}

	/*
	**  Generate query text and actions
	*/

	prev_tempno = txstate->qtx_tempno - 1;

	opc_qtxt( subq_ptr->ops_bestco, txstate);    

	if (subq_ptr->ops_sqtype == OPS_FAGG ||
	    subq_ptr->ops_sqtype == OPS_UNION ||
	    subq_ptr->ops_sqtype == OPS_VIEW )
	{
	    /*
	    **  This is a function aggregate, union, or union view  that has 
	    **  been materialized into a temp table.  Save the temp table no.
	    **	in the subquery structure.
	    */

	    subq_ptr->ops_compile.opc_distrib.opc_subqtemp 
						= txstate->qtx_tempno - 1;
	}

	if ( txstate->qtx_qthd.opq_q13_projfagg == TRUE )
	{
	    /*
	    ** Do special processing to produce empty partitions for the
	    ** projection.
	    */

	    opc_dproj( txstate, *prev_subq, prev_tempno, subq_ptr,
		txstate->qtx_tempno - 1 );
	}

	*prev_subq = subq_ptr;

    return;
}

/*{
** Name: opc_subunion	- Compile union or union view subqueries
**
** Description:
{@comment_line@}...
**
** Inputs:
**      global                          control block
[@PARAM_DESCR@]...
**
** Outputs:
[@PARAM_DESCR@]...
**	Returns:
**	    {@return_description@}
**	Exceptions:
**	    [@description_or_none@]
**
** Side Effects:
**	    [@description_or_none@]
**
** History:
**      07-jun-89 (robin)
**	    Created.
**      31-may-90 (seputis)
**          used dest instead of src to select the union of the temps
[@history_template@]...
*/
static VOID
opc_subunion(
	OPS_SUBQUERY	*union_list,
	QTX_STATE	*txstate)
{
    OPS_SUBQUERY	*subq_ptr;
    QEF_AHD		*actionhdr;
    OPD_ITEMP		res_temp;
    OPS_SUBQUERY	*prev_subq;

    subq_ptr = union_list;
    txstate->qtx_qthd.opq_q15_union = TRUE;
    prev_subq = NULL;
    /*
    ** Process all subqueries in the union list
    */

    for ( ; subq_ptr != NULL;
	    subq_ptr = subq_ptr->ops_union )
    {
	switch (subq_ptr->ops_sqtype)
	{
	case OPS_FAGG:
	case OPS_PROJECTION:
	case OPS_UNION:
	case OPS_VIEW:
	case OPS_MAIN:
	    break;
	case OPS_SAGG:
	    opc_psagg(subq_ptr);
	    break;
	default:
	    /* can't handle OPS_RFAGG */
	   opx_error( E_OP0A96_OPCSUBQTYPE );
	}

	/* Generate text for the subquery */

	opc_subproc( subq_ptr, txstate, &prev_subq );

    } /* end of for loop */



    /*
    **  Generate an internal 'create as select' to UNION together
    **  all the temp table components of the UNION.
    */

	    txstate->qtx_subq = union_list;  /* point to start of list again */
	    txstate->qtx_conode = union_list->ops_bestco;
	    opc_dahd( txstate->qtx_global, &actionhdr );

	    /*  Get temporary number for result table */
	    opc_ntemp( txstate, &res_temp);

	    actionhdr->ahd_atype = QEA_D8_CRE;
	    
	    opc_crsel( txstate, &actionhdr->qhd_obj.qhd_d1_qry, res_temp, 
		txstate->qtx_qthd.opq_q6_dest_ldb, (bool) TRUE, (bool) TRUE );

	    if ( txstate->qtx_conode != NULL )
	    {
		opc_tbflg_ch( txstate, 
		    txstate->qtx_conode->opo_variant.opo_local->opo_bmvars, 
		    res_temp );
	    }

	    txstate->qtx_subq->ops_compile.opc_distrib.opc_subqtemp = res_temp;

    return;
}

/*{
** Name: opc_evaluv	- evaluate union views in subquery
**
** Description:
**      evaluate all union views referenced in the subquery before evaluating
**	the subquery,... need to take of nested union views, and evaluate 
**	them in correct order.
**
** Inputs:
**      subquery                        ptr to subquery about to be evaluated
**      txstatep                        OPC state variable needed for evaluation
**
** Outputs:
**
**	Returns:
**	    
**	Exceptions:
**
** Side Effects:
**
** History:
**      20-jan-94 (ed)
**          initial creation to remove distributed specific code in OPF, since
**	in local the union queries are not contained in the main query list
**	but in distributed they are
[@history_template@]...
*/
static VOID
opc_evaluv(
    OPS_SUBQUERY	*subquery,
    QTX_STATE		*txstatep,
    bool		isunion)
{
    OPV_IVARS	    varno;
    OPS_SUBQUERY    *unionp;
    for (unionp = subquery; unionp; unionp = unionp->ops_union)
    {	/* check range table for union views and generate text
	** if necessary */
	for (varno = unionp->ops_vars.opv_prv; --varno >= 0;)
	{
	    OPV_GRV	*gvarp;
	    gvarp = unionp->ops_vars.opv_base->opv_rt[varno]->opv_grv;
	    if ((gvarp->opv_created == OPS_VIEW)
		&&
		!(gvarp->opv_gmask & OPV_UVEVALUATED))
	    {
		opc_evaluv(gvarp->opv_gquery, txstatep, TRUE);
		gvarp->opv_gmask |= OPV_UVEVALUATED;
	    }
	}
    }
    if (isunion)
	opc_subunion( subquery, txstatep);
}

/*{
** Name: opc_pltext	- Compile query plan into query text
**
** Description:
{@comment_line@}...
**
** Inputs:
**      global                          control block
[@PARAM_DESCR@]...
**
** Outputs:
[@PARAM_DESCR@]...
**	Returns:
**	    {@return_description@}
**	Exceptions:
**	    [@description_or_none@]
**
** Side Effects:
**	    [@description_or_none@]
**
** History:
**      20-apr-89 (robin)
**	    Fixed bug 5467 - handle site movement in the sort node
**	    at the root of a projection subquery.
**      28-apr-89 (robin)
**	    Fixed bug 5643 - use OPD_TOUSER to determine when to check for
**	    flattening.
**      18-may-89 (robin)
**	    Changed test from OPD_TOUSER to the new OPD_EXISTS flag to
**	    check for flattening (using OPD_TOUSER did not work for
**	    'create as select', since it was TRUE, but in fact the
**	    query was not flattened).  Moved opc_nonsel call out of
**	    the OPD_EXISTS test, since it may be needed for 'create
**	    as select'.  Fix for bug 5481.
**	26-may-89 (seputis) fixed b5483 - make sure target list is in same
**	    order as DB_DATA_VALUE array
**	01-sep-92 (rickh)
**	    Corrected a call to opc_subunion to pass in a pointer to a
**	    OPS_SUBQUERY, not the real item.
**	20-may-94 (davebf)
**	    Added support for singlesite nested queries
**	 3-mar-05 (hayke02)
**	    Check flattening (ops_gmask & OPS_QUERYFLATTEN) before setting
**	    multi-site (PST_NSITE). This change fixes problem INGSTR 70, bug
**	    114009.
**	31-Aug-2006 (kschendel)
**	    Watch for HFAGG as well as RFAGG.
*/
VOID
opc_pltext(
	OPS_STATE          *global )
{
    OPS_SUBQUERY	*subq_ptr;
    QTX_STATE		txstate;
    OPS_SUBQUERY	*prev_subq;

    /*
    **  Process the subquery list in order.  Typically this means
    **  process the subqueries for aggregates first, and the main
    **  subquery last.  Initialize once for the entire query.
    */

	prev_subq = NULL;
	txstate.qtx_global = global;
	txstate.qtx_tempno = OPD_NOTEMP;
	txstate.qtx_dv_p = NULL;
	txstate.qtx_qthd.opq_q1_ntemps = 0;
	txstate.qtx_qthd.opq_q3_qlang = 
	    global->ops_qheader->pst_qtree->
		pst_sym.pst_value.pst_s_root.pst_qlang;
	txstate.qtx_qthd.opq_q7_tablist = NULL;


    for ( subq_ptr = global->ops_subquery; subq_ptr != NULL;
	    subq_ptr = subq_ptr->ops_next )
    {
	/* first check for any unprocessed union view subqueries
	** being referenced in this table */
	if (subq_ptr->ops_mask & OPS_UVREFERENCE)
	    opc_evaluv(subq_ptr, &txstate, FALSE);
	switch (subq_ptr->ops_sqtype)
	{
	case OPS_FAGG:
	case OPS_PROJECTION:
	    /* query was flattened, so guarantee not 1SITE */
	    if (!(global->ops_gmask & OPS_QUERYFLATTEN))
		global->ops_qheader->pst_distr->pst_stype = PST_NSITE;
	    break;
	case OPS_MAIN:
	    if((global->ops_qheader->pst_distr->pst_stype & PST_1SITE)
	    && subq_ptr != global->ops_subquery       /* not only subquery */
	    && subq_ptr->ops_bestco == (OPO_CO *)NULL)  /* no cotree */
		continue;
	    else
		break;
	case OPS_SAGG:
	    opc_psagg(subq_ptr);
	    break;
	case OPS_HFAGG:
	case OPS_RFAGG:
	case OPS_RSAGG:
	    if(global->ops_qheader->pst_distr->pst_stype & PST_1SITE)
		break;
	default:
	   opx_error( E_OP0A96_OPCSUBQTYPE );
	}
	opc_subproc( subq_ptr, &txstate, &prev_subq);
    } /* end of for loop */

    if(global->ops_qheader->pst_distr->pst_stype & PST_1SITE)
    {
	/* reset ops_parmtotal to it's original value */
	global->ops_parmtotal = global->ops_gdist.opd_user_parameters;
    }
}
