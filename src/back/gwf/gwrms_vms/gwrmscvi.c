/*
** Copyright (c) 1990, 2001  Ingres Corporation
** All Rights Reserved
*/

#include    <compat.h>
#include    <gl.h>
#include    <tm.h>
#include    <tmtz.h>
#include    <cv.h>
#include    <st.h>
#include    <me.h>
#include    <cm.h>
#include    <dbms.h>
#include    <descrip.h>
#include    <ssdef.h>
#include    <libdef.h>
#include    <adf.h>
#include    <add.h>
#include    <adudate.h>
#include    "gwrmsdt.h"
#include    "gwrmsdtmap.h"
#include    "gwrmserr.h"

/**
**
**  Name: GWRMSCVI.C - Routines to convert various RMS types to INGRES types
**
**  Description:
**      This file contains routines to implement coercions necessary to
**	convert RMS data values to INGRES data values.
**
**          rms_iintcvt - Convert RMS types to INGRES i1, i2, or i4
**          rms_ifltcvt - Convert RMS types to INGRES f4 or f8
**          rms_istrcvt - Convert RMS types to INGRES string types
**          rms_idtecvt - Convert RMS types to INGRES date type
**          rms_imnycvt - Convert RMS types to INGRES money type
**          rms_cvttoidec - convert RMS types to INGRES decimal type
[@func_list@]...
**
**
**  History:
**      27-mar-90 (jrb)
**	    Created.
**	14-jun-90 (jrb)
**	    Added support for blank-padded strings (RMSGW_BL_FIXSTR) in all
**	    conversions.
**	19-jun-90 (edwin)
**	    Add rms_0numstr_digit() and rms_1numstr_sign(), to impose bounds-
**	    checking on Rms_numstr_map.  Check syntax of incoming
**	    character-numeric (zoned, leading-sign, etc) string.
**	22-jun-90 (edwin)
**	    Reassign RMS f- and d-float to foreign data types, rather than
**	    native data types, to allow automatic coercion of f- and d-float
**	    to string types.
**	26-jun-90 (edwin)
**	    Revised g- & h-float -> string conversions, to avoid truncated
**	    exponents.
**	26-jun-90 (linda)
**	    Added support for blank-padded and null-padded varying string types.
**	    Actually, for conversion purposes the so-called RMS varying string
**	    type is identical to a fixed string type; only place it makes a
**	    difference is on output to a file with varying record lengths, where
**	    trailing pad characters are truncated on output.  But we need to
**	    have the type so that we know when to do that.
**	7-sep-90 (linda)
**	    Added support for "trailing separate numeric" datatype.  This type
**	    is a string type, one byte per ascii digit, with a separate sign
**	    byte at the end.  It is generated by COBOL PIC statements.  Its
**	    internal type definition is RMSGW_TRL_NUM.
**	26-mar-91 (rickh)
**	    Bug fix caught by the new C compiler.
**      18-may-92 (schang)
**          GW merge.
**	    9-dec-91 (rickh)
**	        Use RMS_MAX_FLOAT instead of FMAX as upper bound on f8.
**      17-dec-1992 (schang)
**          prototype
**	18-feb-93 (walt)
**		Prototypes of rms_0num_digit(), rms_1num_sign(), and rms_2num_check()
**		didn't include their arguments.  Compile errors on Alpha.
**      03-feb-1993 (schang)
**          adds rms_cvttoidec
**      30-mar-1993 (schang)
**          add support for negative time zone
**      07-jun-1993 (schang)
**          add read-only repeating group to RMS GW
**	24-aug-93 (ed)
**	    added missing includes
**      19-may-99 (chash01)
**        integrate oping12 changes.
**        30-jul-96 (schang) roll in 6.4 fix
**	  13-jan-94 (jimg)
**          Fix for bug#57399, conversion of VMS date to Ingres date datatype.
**          See detailed comments at routine "rms_idtecvt()" ahead.
**      21-mar-2000 (chash01)
**        modify rms numerical datype conversion to ingres decimal datatype.
**      04-apr-2000 (chash01)
**        date<->rms integer conversion should encode/decode 3 digits for 
**        year, not 2 (bug 101150)
**	28-feb-2001	(kinte01)
**	    Bug 103393 - removed nat, longnat, u_nat, & u_longnat
**	    from RMS GW code as the use is no longer allowed
**      22-dec-2008 (stegr01)
**          Itanium VMS port.
**  16-Jun-2009 (thich01)
**      Treat GEOM type the same as LBYTE.
**  20-Aug-2009 (thich01)
**      Treat all spatial types the same as LBYTE.
**      24-nov-2009 (stegr01)
**          Replace ALPHA and IA64 by axm_vms and i64_vms
[@history_template@]...
**/


/*
**  Constants for g- and h-float -> string conversions.  As of June '90, the
**  VMS Runtime Library routines OTS$CNVOUT_G and OTS$CNVOUT_H, which we use
**  to convert G- and H-floating numbers to strings, always return 1) a leading
**  blank; 2) a blank or a minus; 3) a zero; 4) a decimal point;
**  5) however many digits of significance you ask for in the call;
**  6) an E; 7) a + or -; 8) a 2-digit exponent.  If the exponent is 3 or 4
**  digits, the E is suppressed and all digits of exponent appear.  Thus there
**  are always 8 characters plus the (varying, user-specified) number of digits
**  to the right of the decimal point, unless there's a 4-digit exponent, in
**  which case the significance is reduced by 1 so the whole exponent can
**  appear.   NONE of this is documented; we can only
**  hope that future VMS releases continue to do the same...
*/
#define  MAXGOUT    23	    /* longest G conversion it makes sense to make */
#define  MAXHOUT    41	    /* longest H conversion "    "     "   "   "   */
#define  ALLGHOUT   8	    /* count of chars besides significant mantissa */
#define  LEADGHOUT  1	    /* irrelevant leading blanx in G/H string	   */
/*
**  Forward and/or External function references.
*/

FUNC_EXTERN DB_STATUS	rms_dterr();		    /* datatype error */
FUNC_EXTERN VOID	rms_intcmpl();		    /* complement integer */
FUNC_EXTERN DB_STATUS	rms_movestring();	    /* move to INGRES string */
FUNC_EXTERN DB_STATUS	rms_straddr();		    /* get address of string */

static	short	rms_0numstr_digit(char byte);	/* low numeric byte -> digit */
static	short	rms_1numstr_sign(char byte);	/* low numeric byte -> sign */
static  i4	ghmaklen();

/* These are all simple functions written in MACRO to take advantage of VAX
** instructions not available in C.
*/
#if (!defined(axm_vms) && !defined(i64_vms))
FUNC_EXTERN i4		rms_mcvt_g_l();
FUNC_EXTERN i4		rms_mcvt_h_l();
FUNC_EXTERN i4          rms_mcvt_s_p();
#endif

GLOBALREF   RMS_ADFFI_CVT   Rms_adffi_arr[];


/*
[@function_reference@]...
[@#defines_of_other_constants@]
[@type_definitions@]
[@global_variable_definitions@]
[@static_variable_or_function_definitions@]
*/

/*{
** Name: cvt_s2f - Convert sfloat (axp specific type) to ffloat
** 
** Description:
**      This routine convert sfloat (axp type) to ffloat (vax type),
**      treating sfloat as an arry of bytes.
**
** Inputs:
**      src                        sfloat data as PTR
**
** Outputs:
**      dst                        ffloat as PTR
** 
** Returns:
**      E_DB_OK
**      E_DB_ERROR
**
** Side Effects:
**      None.
**
** History:
**     sep-02-1997 (chash01) created
*/

static STATUS cvt_s2f (PTR src, PTR dst)
{
    u_i2 exponent = 0;
    char tmpsrc[4];

    MEcopy(src, 4, (PTR)&tmpsrc);
    /*
    ** extract 7 bits of exponent (the lease sig bit not included)
    ** then increment by one.
    */
    exponent = tmpsrc[3] & 0x7F;
    exponent++;
    /*
    ** prserve the sign bit then OR together with modified
    ** exponent.
    */
    tmpsrc[3] = tmpsrc[3] & 0x80;
    tmpsrc[3] = tmpsrc[3] | exponent;

    MEcopy((PTR)&tmpsrc, 2, dst+2);
    MEcopy((PTR)(&tmpsrc)+2, 2, dst);

    return(E_DB_OK);
}

/*{
** Name: cvt_t2d - Convert tfloat to dfloat (vax specific type)
** 
** Description:
**      This routine convert tfloat (axp type) to dfloat (vax type),
**
** Inputs:
**      src                        addr of tfloat (f8) data.
**
** Outputs:
**      dst                        addr of dfloat 
** 
** Returns:
**      E_DB_OK
**      E_DB_ERROR
**
** Side Effects:
**      None.
**
** History:
**     sep-02-1997 (chash01) created
*/

static STATUS cvt_t2d (PTR src, PTR dst)
{
    struct dsc$descriptor  srcdsc;
    struct dsc$descriptor  dstdsc;
    char gform[8];
    STATUS cond;
    i4     len;
    u_i2 exponent;
    /*
    ** first convert to a g_floating then do the lib$cvt to Dfloat
    */
    MEcopy(src+6, 2, (PTR)&gform);
    MEcopy(src+4, 2, ((PTR)&gform)+2);
    MEcopy(src+2, 2, ((PTR)&gform)+4);
    MEcopy(src,   2, ((PTR)&gform)+6);
    
    exponent=gform[1] & 0x007F;
    exponent = (exponent << 8) | (gform[0] & 0x00F0);
    exponent = exponent >> 5;
    exponent++;
    exponent = exponent << 5;
    gform[1] = (gform[1] & 0x0080) | (exponent >> 8);
    exponent = exponent & 0x00F0;
    gform[0] = (gform[0] &0x001F) | exponent;

    srcdsc.dsc$a_pointer = gform;
    srcdsc.dsc$b_class = DSC$K_CLASS_S;
    srcdsc.dsc$b_dtype = DSC$K_DTYPE_G;

    dstdsc.dsc$a_pointer = (PTR)dst;
    dstdsc.dsc$b_class = DSC$K_CLASS_S;
    dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
    cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
    if (cond == SS$_NORMAL)
        return(E_DB_OK);
    else
        return(E_DB_ERROR);
}


/*{
** Name: rms_iintcvt - Convert RMS data value to INGRES i1, i2, or i4
**
** Description:
**	This routine takes a variety of RMS data values and converts them
**	to INGRES i1, i2, or i4.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	03-apr-90 (jrb)
**	    Created.
**	14-jun-90 (jrb)
**	    Added support for blank-padded strings (RMSGW_BL_FIXSTR).
**	22-jun-90 (edwin)
**	    Reimplemant f- & d-float as foreign, not native, datatypes.
**	7-sep-90 (linda)
**	    Added support for RMSGW_TRL_NUM (trailing separate numeric)
**	    datatype.
**      07-jun-1993 (schang)
**          add read-only repeating group to RMS GW
*/
DB_STATUS
rms_iintcvt
(
    ADF_CB        *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    i4		    temp;
    STATUS	    stat;
    bool	    overflow = FALSE;
    bool            underflow = FALSE;

    switch (indv->db_datatype)
    {
      /*
      ** RMSGW_IMAGINE is treated as integer with value of 0
      */
      case RMSGW_IMAGINE:
          temp = 0;
          break;

      case RMSGW_INT:
      {
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    temp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
	    break;

	  case 2:
	    temp = *(i2 *)indv->db_data;
	    break;
	    
	  case 4:
	    temp = *(i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    temp = qp->quad_chunk[0];

	    if (temp >= 0)
	    {
		if (qp->quad_chunk[1] != 0)
		    overflow = TRUE;
	    }
	    else
	    {
		if (qp->quad_chunk[1] != 0xffffffff)
		    overflow = TRUE;
	    }
	    break;

	  case 16:
	    op = indv->db_data;
	    temp = op->octa_chunk[0];

	    if (temp >= 0)
	    {
		if ((op->octa_chunk[3] | op->octa_chunk[2] | op->octa_chunk[1])
			!= 0
		   )
		{
		    overflow = TRUE;
		}
	    }
	    else
	    {
		if ((op->octa_chunk[3] & op->octa_chunk[2] & op->octa_chunk[1])
			!= 0xffffffff
		   )
		{
		    overflow = TRUE;
		}
	    }
	    break;
	}
	break;
      }

      case RMSGW_UNSINT:
      {
	u_i4		utemp;
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    utemp = *(u_i1 *)indv->db_data;
	    break;

	  case 2:
	    utemp = *(u_i2 *)indv->db_data;
	    break;

	  case 4:
	    utemp = *(u_i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    utemp = qp->quad_chunk[0];

	    if (qp->quad_chunk[1] != 0)
		overflow = TRUE;
	    break;

	  case 16:
	    op = indv->db_data;
	    utemp = op->octa_chunk[0];

	    if ((op->octa_chunk[3] | op->octa_chunk[2] | op->octa_chunk[1])
		    != 0
	       )
	    {
		overflow = TRUE;
	    }
	    break;
	}
	
	if (utemp > MAXI4)
	    overflow = TRUE;

	temp = utemp;
	break;
      }

      case RMSGW_SFLOAT:
      case RMSGW_TFLOAT:
      case RMSGW_FFLOAT:
      case RMSGW_DFLOAT:
      case RMSGW_GFLOAT:
      case RMSGW_HFLOAT:
      {
          struct dsc$descriptor  srcdsc;
          struct dsc$descriptor  dstdsc;
          double ftemp;
          i4  cond;
          i4  len;

          srcdsc.dsc$b_class = DSC$K_CLASS_S;
          switch (indv->db_datatype)
          {
#if defined(axm_vms) || defined(i64_vms)
            case RMSGW_SFLOAT:
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_FS;
                break;
            case RMSGW_TFLOAT:
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
                break;
#else /* VAX */
            /*
            ** convert to f- and g- float, not to worry loss of
            ** precision, but does error out for loss of significance
            */
            case RMSGW_SFLOAT:
                cond = cvt_s2f(indv->db_data, &ftemp);
                if (cond)
	            return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                break;

            case RMSGW_TFLOAT:
                cond = cvt_t2d(indv->db_data, &ftemp);
                if (cond)
	            return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                break;
#endif
            case RMSGW_FFLOAT:
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_F;
                break;
            case RMSGW_DFLOAT:
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
                break;
            case RMSGW_GFLOAT:
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_G;
                break;
            case RMSGW_HFLOAT:
                srcdsc.dsc$b_dtype = DSC$K_DTYPE_H;
                break;
          }

          if (indv->db_datatype == RMSGW_SFLOAT ||
                  indv->db_datatype == RMSGW_TFLOAT)
              srcdsc.dsc$a_pointer = &ftemp;
          else
              srcdsc.dsc$a_pointer = indv->db_data;

          dstdsc.dsc$a_pointer = &temp;
          dstdsc.dsc$b_class = DSC$K_CLASS_S;
          dstdsc.dsc$b_dtype = DSC$K_DTYPE_L;

          cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);

	  switch (cond)
          {
              case SS$_NORMAL:
                  break;
              case LIB$_FLTOVF:
                  overflow = TRUE;
                  break;
              case LIB$_FLTUND:
                  underflow = TRUE;
                  break;
              case LIB$_INTOVF:
	          return(rms_dterr(scb, E_GW7000_INTEGER_OVF, 1, 4,
                         &outdv->db_length));
                  break;
              default:
	          return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                  break;
          }
          break;
      }    

      case RMSGW_BL_FIXSTR:
      case RMSGW_NL_FIXSTR:
      case RMSGW_BL_VARSTR:
      case RMSGW_NL_VARSTR:
      {
	struct dsc$descriptor	    dsc;
	char			    *p;

	p = (char *)indv->db_data + indv->db_length - 1;

	switch (indv->db_datatype)
	{
	    case    RMSGW_BL_FIXSTR:
	    case    RMSGW_BL_VARSTR:
		while (p > indv->db_data  &&  *p == ' ')
		    p--;
		break;

	    case    RMSGW_NL_FIXSTR:
	    case    RMSGW_NL_VARSTR:
		while (p > indv->db_data  &&  *p == NULLCHAR)
		    p--;
		break;
	}

	dsc.dsc$a_pointer = indv->db_data;
	dsc.dsc$b_dtype = DSC$K_DTYPE_T;
	dsc.dsc$b_class = DSC$K_CLASS_S;
	dsc.dsc$w_length = p - (char *)indv->db_data + 1;

	if (OTS$CVT_TI_L(&dsc, &temp, 4, 1) != SS$_NORMAL)
	{
	    return(rms_dterr(scb, E_GW7012_BAD_STR_TO_INT, 1,
					    dsc.dsc$w_length, indv->db_data));
	}
        break;
      }

      case RMSGW_PACKED_DEC:
	if (CVpkl(indv->db_data,
		    DB_P_DECODE_MACRO(indv->db_prec),
		    DB_S_DECODE_MACRO(indv->db_prec),
		&temp) == CV_OVERFLOW)
	{
	    overflow = TRUE;
	}
	break;

      case RMSGW_LEADING_NUM:
      case RMSGW_ZONED_NUM:
      case RMSGW_OVR_NUM:
      case RMSGW_UNS_NUM:
      {
	char	    buf[256];
	char	    *sd;
	i4	    digits;

	MEcopy(indv->db_data, indv->db_length, buf+1);

	/* point sd at last digit */
	sd = &buf[indv->db_length];

        if (indv->db_datatype == RMSGW_UNS_NUM)
            buf[0] = '+';
        else
        {
	  /* translate last digit into sign and normal ascii digit */
	  buf[0] = rms_1numstr_sign(*sd);
	  *sd = rms_0numstr_digit(*sd);
        }
	digits = DB_P_DECODE_MACRO(indv->db_prec) -
			DB_S_DECODE_MACRO(indv->db_prec);
	buf[digits + 1 + (indv->db_datatype == RMSGW_LEADING_NUM)] = EOS;

	if (digits == 0)
	{
	    temp = 0;
	    break;
	}

	if ((stat = CVal(buf, &temp)) != OK)
	{
	    if (stat == CV_OVERFLOW)
		overflow = TRUE;
	    else
		return(rms_dterr(scb, E_GW7013_BAD_NUM_TO_INT, 0));
	}
	break;
      }
      break;

      case RMSGW_TRL_NUM:
      {
	char	    buf[256];
	i4	    digits;

	MEcopy(indv->db_data, indv->db_length, buf+1);

	/* last byte (sign) goes to first in string buffer */
	buf[0] = buf[indv->db_length];
	digits = DB_P_DECODE_MACRO(indv->db_prec) -
			DB_S_DECODE_MACRO(indv->db_prec);
	buf[digits + 1] = EOS;

	if (digits == 0)
	{
	    temp = 0;
	    break;
	}

	if ((stat = CVal(buf, &temp)) != OK)
	{
	    if (stat == CV_OVERFLOW)
		overflow = TRUE;
	    else
		return(rms_dterr(scb, E_GW7013_BAD_NUM_TO_INT, 0));
	}
	break;
      }
      break;
    }


    /* Now temp is a signed i4 representation of the destination integer */
    switch (outdv->db_length)
    {
      case 1:
        if (temp > MAXI1  ||  temp < MINI1)
	    overflow = TRUE;

	*(i1 *)outdv->db_data = temp;
	break;
	
      case 2:
        if (temp > MAXI2  ||  temp < MINI2)
	    overflow = TRUE;

	*(i2 *)outdv->db_data = temp;
	break;
	
      case 4:
	*(i4 *)outdv->db_data = temp;
	break;
    }

    if (overflow)
	return(rms_dterr(scb, E_GW7000_INTEGER_OVF, 1, 4, &outdv->db_length));

    return(E_DB_OK);
}


/*{
** Name: rms_ifltcvt - Convert RMS data value to INGRES f4 or f8
**
** Description:
**	This routine takes a variety of RMS data values and converts them
**	to INGRES f4 or f8.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	11-apr-90 (jrb)
**	    Created.
**	14-jun-90 (jrb)
**	    Added support for blank-padded strings (RMSGW_BL_FIXSTR).
**	22-jun-90 (edwin)
**	    Reimplemant f- & d-float as foreign, not native, datatypes.
**	7-sep-90 (linda)
**	    Added support for RMSGW_TRL_NUM (trailing separate numeric)
**	    datatype.
**	14-oct-91 (rickh)
**	    Correct conversion of trailing separate numeric.
**	9-dec-91 (rickh)
**	    Use RMS_MAX_FLOAT instead of FMAX as upper bound on f8.
*/
DB_STATUS
rms_ifltcvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    f8		    temp = 0.0;
    bool	    overflow = FALSE;
    bool	    underflow = FALSE;

    switch (indv->db_datatype)
    {
      case RMSGW_INT:
      {
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    temp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
	    break;

	  case 2:
	    temp = *(i2 *)indv->db_data;
	    break;
	    
	  case 4:
	    temp = *(i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    if (qp->quad_chunk[1] & 0x80000000)
	    {
		RMS_QUADWORD	tqw;

		rms_intcmpl(qp, 2, &tqw);
		temp = tqw.quad_chunk[1] * -4294967296e0
			- tqw.quad_chunk[0];
	    }
	    else
	    {
		temp = qp->quad_chunk[1] * 4294967296e0
			+ qp->quad_chunk[0];
	    }
	    break;

	  case 16:
	    op = indv->db_data;
	    if (op->octa_chunk[3] & 0x80000000)
	    {
		RMS_OCTAWORD	tow;

		rms_intcmpl(op, 4, &tow);
		temp = tow.octa_chunk[3] * -7.92281625e28
			- tow.octa_chunk[2] * 1.844674407e19
			- tow.octa_chunk[1] * 4294967296e0
			- tow.octa_chunk[0];
	    }
	    else
	    {
		temp = op->octa_chunk[3] * 7.92281625e28
			+ op->octa_chunk[2] * 1.844674407e19
			+ op->octa_chunk[1] * 4294967296e0
			+ op->octa_chunk[0];
	    }
	}
	break;
      }

      case RMSGW_UNSINT:
      {
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    temp = *(u_i1 *)indv->db_data;
	    break;

	  case 2:
	    temp = *(u_i2 *)indv->db_data;
	    break;

	  case 4:
	    temp = *(u_i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    temp = qp->quad_chunk[1] * 4294967296e0
		    + qp->quad_chunk[0];
	    break;

	  case 16:
	    op = indv->db_data;

	    /* if high bit set, we know we'll overflow for sure */
	    if (op->octa_chunk[3] & 0x80000000)
	    {
		overflow = TRUE;
	    }
	    else
	    {
		temp = op->octa_chunk[3] * 7.92281625e28
			+ op->octa_chunk[2] * 1.844674407e19
			+ op->octa_chunk[1] * 4294967296e0
			+ op->octa_chunk[0];
	    }
	    break;
	}
	
	break;
      }

      case RMSGW_GFLOAT:
      case RMSGW_HFLOAT:
      {
          struct dsc$descriptor  srcdsc;
          struct dsc$descriptor  dstdsc;
      
          i4 cond;
          i4 len;

          srcdsc.dsc$b_class = DSC$K_CLASS_S;
          if (indv->db_datatype == RMSGW_GFLOAT)
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_G;
          else
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_H;
          srcdsc.dsc$a_pointer = indv->db_data;
          dstdsc.dsc$a_pointer = &temp;
          dstdsc.dsc$b_class = DSC$K_CLASS_S;
#if defined(axm_vms) || defined(i64_vms)
          dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
#else
          dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
#endif
          cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
	  switch (cond)
          {
              case SS$_NORMAL:
                  break;
              case LIB$_FLTOVF:
                  overflow = TRUE;
                  break;
              case LIB$_FLTUND:
                  underflow = TRUE;
                  break;
              default:
	          return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                  break;
          }
          break;
      }    

      case RMSGW_FFLOAT:
      case RMSGW_DFLOAT:
#ifdef VAX
          /*
          ** f- and d- float are natural on VAX
          */
          if (indv->db_datatype == RMSGW_FFLOAT)
	      temp = *(f4 *)indv->db_data;
          else
	      temp = *(f8 *)indv->db_data;
          
          break;
#else /* alpha or itanium */
            /*
            ** f- and d-float are not natural on alpha, must be converted
            */
      {
          struct dsc$descriptor  srcdsc;
          struct dsc$descriptor  dstdsc;
          i4  cond;
          i4  len;

          srcdsc.dsc$b_class = DSC$K_CLASS_S;
          if (indv->db_datatype == RMSGW_FFLOAT)
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_F;
          else
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
          srcdsc.dsc$a_pointer = indv->db_data;

          dstdsc.dsc$a_pointer = &temp;
          dstdsc.dsc$b_class = DSC$K_CLASS_S;
          dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;

          cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);

	  switch (cond)
          {
              case SS$_NORMAL:
                  break;
              case LIB$_FLTOVF:
                  overflow = TRUE;
                  break;
              case LIB$_FLTUND:
                  underflow = TRUE;
                  break;
              default:
	          return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                  break;
          }
          break;
      }    
#endif
 
      case RMSGW_SFLOAT:
      case RMSGW_TFLOAT:
#ifdef VAX
      {
          i4  cond;
          /*
          ** not natural datatype on VAX, use convert
          */
          if (indv->db_datatype == RMSGW_SFLOAT)
              cond = cvt_s2f(indv->db_data, &temp);
          else
              cond = cvt_t2d(indv->db_data, &temp);

          if (cond)
	      return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));

          break;
      }
#else /* alpha natural type */
          if (indv->db_datatype == RMSGW_SFLOAT)
              temp = (f8)*(f4 *)indv->db_data;
          else
              temp = *(f8 *)indv->db_data;
          break;
#endif
      case RMSGW_BL_FIXSTR:
      case RMSGW_NL_FIXSTR:
      case RMSGW_BL_VARSTR:
      case RMSGW_NL_VARSTR:
      {
	/* Note- we have to put an unnatural limit on the length of the
	** RMS string because the ADF coercion can't handle string larger
	** than DB_MAXSTRING
	*/
	char		*p;
	char	    decimal;
	i4	    len;
	char	    buf[DB_MAXSTRING + 1];

	decimal = scb->adf_decimal.db_decspec
		    ?  scb->adf_decimal.db_decimal
		    :  '.';

	p = (char *)indv->db_data + indv->db_length - 1;

	switch (indv->db_datatype)
	{
	    case    RMSGW_BL_FIXSTR:
	    case    RMSGW_BL_VARSTR:
		while (p > indv->db_data  &&  *p == ' ')
		    p--;
		break;

	    case    RMSGW_NL_FIXSTR:
	    case    RMSGW_NL_VARSTR:
		while (p > indv->db_data  &&  *p == NULLCHAR)
		    p--;
		break;
	}

	len = p - (char *)indv->db_data + 1;
	
	/* ADF can handle only strings of length DB_MAXSTRING or smaller */
	if (len > DB_MAXSTRING)
	    return(rms_dterr(scb, E_GW702A_FLT_STR_TOO_LONG, 0));

	/* this is a pain, but we need a NULL-terminated string */
	MEcopy(indv->db_data, len, buf);
	buf[len] = EOS;

	switch (CVaf(buf, decimal, &temp))
	{
	  case OK:
	    break;
	  case CV_OVERFLOW:
	    overflow = TRUE;
	    break;
	  case CV_UNDERFLOW:
	    underflow = TRUE;
	    break;
	  default:
	    return(rms_dterr(scb, E_GW7020_BAD_STR_TO_FLT, 1, 0, buf));
	    break;
	}
        break;
      }

      case RMSGW_PACKED_DEC:
	_VOID_ CVpkf(indv->db_data,
		DB_P_DECODE_MACRO(indv->db_prec),
		DB_S_DECODE_MACRO(indv->db_prec),
		&temp);
	break;
      case RMSGW_LEADING_NUM:
      case RMSGW_ZONED_NUM:
      case RMSGW_UNS_NUM:
      case RMSGW_OVR_NUM:
      {
	char	    buf[260];
	char	    *sd;
	i4	    scale;

	MEcopy(indv->db_data, indv->db_length, buf+1);

	/* point sd at last digit */
	sd = &buf[indv->db_length];

	/* translate last digit into sign and normal ascii digit */
	buf[0] = rms_1numstr_sign(*sd);
	*sd = rms_0numstr_digit(*sd);
	*++sd = 'e';
	*++sd = '-';
	scale = DB_S_DECODE_MACRO(indv->db_prec);
	*++sd = scale/10 + '0';
	*++sd = scale%10 + '0';
	*++sd = EOS;
	switch (CVaf(buf, '.', &temp))
	{
	  case OK:
	    break;
	  case CV_OVERFLOW:
	    overflow = TRUE;
	    break;
	  case CV_UNDERFLOW:
	    underflow = TRUE;
	    break;
	  default:
	    return(rms_dterr(scb, E_GW7021_BAD_NUM_TO_FLT, 0));
	    break;
	}
	break;
      }
      case RMSGW_TRL_NUM:
      {
	char	    buf[260];
	char	    *sd;
	i4	    scale;

	MEcopy(indv->db_data, indv->db_length, buf+1);

	/* point sd at last (sign) byte */
	sd = &buf[indv->db_length];

	/* translate last digit into sign and normal ascii digit */
	buf[0] = *sd;
	*sd = 'e';
	*++sd = '-';
	scale = DB_S_DECODE_MACRO(indv->db_prec);
	*++sd = scale/10 + '0';
	*++sd = scale%10 + '0';
	*++sd = EOS;

	switch (CVaf(buf, '.', &temp))
	{
	  case OK:
	    break;
	  case CV_OVERFLOW:
	    overflow = TRUE;
	    break;
	  case CV_UNDERFLOW:
	    underflow = TRUE;
	    break;
	  default:
	    return(rms_dterr(scb, E_GW7021_BAD_NUM_TO_FLT, 0));
	    break;
	}
	break;
      }
    }
	
 
    /* Now temp is a signed f8 representation of the destination float */
    if (temp > RMS_MAX_FLOAT ||  temp < -RMS_MAX_FLOAT )
    {
	overflow = TRUE;
    }
    else
    {
	if (outdv->db_length == 4)
	    *(f4 *)outdv->db_data = temp;
	else
	    *(f8 *)outdv->db_data = temp;
    }

    if (overflow)
	return(rms_dterr(scb, E_GW7001_FLOAT_OVF, 1, 4, &outdv->db_length));

    if (underflow)
	return(rms_dterr(scb, E_GW7002_FLOAT_UND, 1, 4, &outdv->db_length));

    return(E_DB_OK);
}


/*{
** Name: rms_istrcvt - Convert RMS data value to INGRES string types
**
** Description:
**	This routine takes a variety of RMS data values and converts them
**	to INGRES string types (c, text, char, or varchar).
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	12-apr-90 (jrb)
**	    Created.
**	7-jun-90 (edwin)
**	    Be sure 'isneg' correctly set on non-negative quadwords &
**	    octawords.
**	14-jun-90 (jrb)
**	    Added support for blank-padded strings (RMSGW_BL_FIXSTR).
**	15-jun-90 (edwin)
**	    Use DEC's ots$cvt_l_tu, rather than CL's CVla, to convert
**	    from unsigned 1, 2, and 4-byte ints, to eliminate negative
**	    results.
**	20-jun-90 (edwin)
**	    Do syntax checking on incoming character-numeric (zoned,
**	    overpunched, leading sign, or unsigned) string.
**	22-jun-90 (edwin)
**	    Reimplemant f- & d-float as foreign, not native, datatypes.
**	26-jun-90 (edwin)
**	    Revised g- & h-float -> string conversions, to avoid truncated
**	    exponents.
**	7-sep-90 (linda)
**	    Added support for RMSGW_TRL_NUM (trailing separate numeric)
**	    datatype.
**	14-oct-91 (rickh)
**	    Correct conversion of trailing separate numeric.  Also corrected
**	    general problem when both the value and scale are 0.
**      12-nov_96 (schang)
**          Add lvch, byte, vbyte, and lbyte
*/
DB_STATUS
rms_istrcvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    char	    buf[DB_MAXSTRING+1];
    bool	    from_str = FALSE;
    i4		    slen;
    char	    *styp;
    char	    *p = buf;
    bool            overflow=FALSE, underflow=FALSE;
    /*
    **  For converting unsigned bytes, shorts, and longs, DEC's OTS$CVT_L_TU
    **  will right-justify the char result in the given field, with blank
    **  padding on the left.  So, give it the shortest possible buffer to
    **  fill -- largest possible unsigned long, which is 4,294,967,295,
    **  has 10 decimal digits -- and leave room for a trailing zero-byte.
    */
#define  MAX_UNSIGNED_DIGITS	10

    char	uns_buf[MAX_UNSIGNED_DIGITS + 1];
    $DESCRIPTOR(uns_desc, uns_buf);

    switch (indv->db_datatype)
    {
      case RMSGW_INT:
      {
	RMS_QUADWORD	*qp;
	RMS_QUADWORD    qw;
	RMS_OCTAWORD	*op;
	RMS_OCTAWORD    ow;
	i4		tmp;
	i4		carry;
	i4		i,j;
	bool		isneg;

	switch (indv->db_length)
	{
	  case 1:
	    CVla((i4)I1_CHECK_MACRO(*(i1 *)indv->db_data), p);
	    slen = STlength(p);
	    break;

	  case 2:
	    CVla((i4)*(i2 *)indv->db_data, p);
	    slen = STlength(p);
	    break;

	  case 4:
	    CVla(*(i4 *)indv->db_data, p);
	    slen = STlength(p);
	    break;

	  case 8:
	  {
	    char	*endp = &buf[100];
	    u_i2	*cp;
	    
	    p = endp;
	    qp = indv->db_data;

	    if (qp->quad_chunk[1] & 0x80000000)
	    {
		rms_intcmpl(qp, 2, &qw);
		isneg = TRUE;
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO(*qp, qw);
		isneg = FALSE;
	    }

	    /* now we look at the quadword as an array of u_i2's instead of
	    ** u_i4's; the VAX byte-swapping let's us do this without having
	    ** to move things around
	    */
	    cp = &qw;
	    *p = EOS;
	    for (j=3; j>=0;)
	    {
		carry = cp[j] % 10;
		cp[j] /= 10;
		
		for (i=j-1; i>=0; i--)
		{
		    tmp = cp[i] + carry * 65536;
		    carry = tmp % 10;
		    cp[i] = tmp / 10;
		}
		*--p = carry + '0';

		while (cp[j] == 0)
		    j--;
	    }

	    if (isneg)
		*--p = '-';

	    slen = endp - p;
	    break;
	  }

	  case 16:
	  {
	    char	*endp = &buf[100];
	    u_i2	*cp;

	    p = endp;
	    op = indv->db_data;

	    if (op->octa_chunk[3] & 0x80000000)
	    {
		rms_intcmpl(op, 4, &ow);
		isneg = TRUE;
	    }
	    else
	    {
		STRUCT_ASSIGN_MACRO(*op, ow);
		isneg = FALSE;
	    }

	    /* now we look at the octaword as an array of u_i2's instead of
	    ** u_i4's; the VAX byte-swapping let's us do this without having
	    ** to move things around
	    */
	    cp = &ow;
	    *p = EOS;
	    for (j=7; j>=0;)
	    {
		carry = cp[j] % 10;
		cp[j] /= 10;
		
		for (i=j-1; i>=0; i--)
		{
		    tmp = cp[i] + carry * 65536;
		    carry = tmp % 10;
		    cp[i] = tmp / 10;
		}
		*--p = carry + '0';

		while (cp[j] == 0)
		    j--;
	    }

	    if (isneg)
		*--p = '-';

	    slen = endp - p;
	    break;
	  }
	}
	break;
      }

      case RMSGW_UNSINT:
      {
	RMS_QUADWORD	*qp;
	RMS_QUADWORD    qw;
	RMS_OCTAWORD	*op;
	RMS_OCTAWORD    ow;
	i4		tmp;
	i4		carry;
	i4		i,j;

	switch (indv->db_length)
	{
	  case 1:
	  case 2:
	  case 4:
	    /*
	    **  Ignoring possibility of error return -- would happen if string
	    **  was too short to hold entire converted value, but longest
	    **  possible conversion is only 10 digits; we defined the buffer
	    **  to hold that.  '1' for minimum number of chars to return.
	    */
	    OTS$CVT_L_TU(indv->db_data, &uns_desc, (long) 1,
		(long) indv->db_length);
	    /*  Point beyond the leading blanks, calculate length */
	    slen = MAX_UNSIGNED_DIGITS;
	    for (p = uns_buf; *p == ' '; p++)
		slen--;
	    /* with p & slen set, we're done */
	    break;

	  case 8:
	  {
	    char	*endp = &buf[100];
	    u_i2	*cp;
	    
	    p = endp;
	    qp = indv->db_data;
	    STRUCT_ASSIGN_MACRO(*qp, qw);

	    /* now we look at the quadword as an array of u_i2's instead of
	    ** u_i4's; the VAX byte-swapping let's us do this without having
	    ** to move things around
	    */
	    cp = &qw;
	    *p = EOS;
	    for (j=3; j>=0;)
	    {
		carry = cp[j] % 10;
		cp[j] /= 10;
		
		for (i=j-1; i>=0; i--)
		{
		    tmp = cp[i] + carry * 65536;
		    carry = tmp % 10;
		    cp[i] = tmp / 10;
		}
		*--p = carry + '0';

		while (cp[j] == 0)
		    j--;
	    }

	    slen = endp - p;
	    break;
	  }

	  case 16:
	  {
	    char	*endp = &buf[100];
	    u_i2	*cp;

	    p = endp;
	    op = indv->db_data;
	    STRUCT_ASSIGN_MACRO(*op, ow);

	    /* now we look at the octaword as an array of u_i2's instead of
	    ** u_i4's; the VAX byte-swapping let's us do this without having
	    ** to move things around
	    */
	    cp = &ow;
	    *p = EOS;
	    for (j=7; j>=0;)
	    {
		carry = cp[j] % 10;
		cp[j] /= 10;
		
		for (i=j-1; i>=0; i--)
		{
		    tmp = cp[i] + carry * 65536;
		    carry = tmp % 10;
		    cp[i] = tmp / 10;
		}
		*--p = carry + '0';

		while (cp[j] == 0)
		    j--;
	    }

	    slen = endp - p;
	    break;
	  }
	}
	break;
      }

      case RMSGW_GFLOAT:
      case RMSGW_HFLOAT:
      {
	/* Note- we are not honoring adf fields about width, precision, or
	** style (e.g. e, f, g, or n format for floats).
	**
	** This (of course) happens only if we are registering a g_float or
	** h_float as a string.  It would be better (if possible) to register
	** it as a f_float or d_float so you get all the fancy formatting
	** stuff -- EXCEPT that then you loose values with exponents > 37.
	**
	** This will hopefully be fixed "in a future release".
	*/
	i4		    cond;
	i4		    outlen;
	$DESCRIPTOR(outdsc, buf);
	i4		    ghmaklen();

	if (indv->db_datatype == RMSGW_GFLOAT)
	{
	    outlen = ghmaklen(MAXGOUT, outdv);
	    outdsc.dsc$w_length = outlen;
	    cond = OTS$CNVOUT_G(indv->db_data, &outdsc,
		(long) (outlen - ALLGHOUT));
	}
	else
	{
	    outlen = ghmaklen(MAXHOUT, outdv);
	    outdsc.dsc$w_length = outlen;
	    cond = OTS$CNVOUT_H(indv->db_data, &outdsc,
		(long) (outlen - ALLGHOUT));
	}
	if (cond != SS$_NORMAL)
	    return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));

	/* OTS$CNVOUT_x always hands us an unnecessary leading blank -- */
	slen = outdsc.dsc$w_length - LEADGHOUT;
	p += LEADGHOUT;

	break;
      }

      case RMSGW_FFLOAT:
      case RMSGW_DFLOAT:
      case RMSGW_SFLOAT:
      case RMSGW_TFLOAT:
      {
          struct dsc$descriptor  srcdsc;
          struct dsc$descriptor  dstdsc;
          i4  cond;
          i4  len;
          f8    temp;
	  char  decimal = (scb->adf_decimal.db_decspec ?
				(char) scb->adf_decimal.db_decimal : '.');
	  i2	slen_as_i2;	    /* CVfa definitively returns an i2!!! */
#ifdef VAX
	  switch (indv->db_datatype)
          {
            case RMSGW_FFLOAT:
                temp = *(f4 *)indv->db_data;
                break;
            case RMSGW_DFLOAT:
                temp = *(f8 *)indv->db_data;
                break;
            case RMSGW_SFLOAT:
            case RMSGW_TFLOAT:
                if (indv->db_datatype == RMSGW_SFLOAT)
                    cond = cvt_s2f(indv->db_data, &temp);
                else
                    cond = cvt_t2d(indv->db_data, &temp);

                if (cond)
	            return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                break;
          }
#else  /* alpha or itanium */

          switch (indv->db_datatype)
          {
            case RMSGW_SFLOAT:
              temp = *(f4 *)indv->db_data;
              break;
            case RMSGW_TFLOAT:
              temp = *(f8 *)indv->db_data;
              break;
            case RMSGW_FFLOAT:
            case RMSGW_DFLOAT:
              srcdsc.dsc$b_class = DSC$K_CLASS_S;
              if (indv->db_datatype == RMSGW_FFLOAT)
                  srcdsc.dsc$b_dtype = DSC$K_DTYPE_F;
              else
                  srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
              srcdsc.dsc$a_pointer = indv->db_data;

              dstdsc.dsc$a_pointer = &temp;
              dstdsc.dsc$b_class = DSC$K_CLASS_S;
              dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;

              cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);

	      switch (cond)
              {
                  case SS$_NORMAL:
                    break;
                  case LIB$_FLTOVF:
                    overflow = TRUE;
                    break;
                  case LIB$_FLTUND:
                    underflow = TRUE;
                    break;
                  default:
	             return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                     break;
              }
              break;
          }
#endif      
	    
          if (indv->db_datatype == RMSGW_FFLOAT ||
              indv->db_datatype == RMSGW_SFLOAT)
          {
              CVfa(temp,
	          scb->adf_outarg.ad_f4width,
	          scb->adf_outarg.ad_f4prec,
	          scb->adf_outarg.ad_f4style,
	          decimal, p, &slen_as_i2);
          }
          else
          {
              CVfa(temp,
                  scb->adf_outarg.ad_f8width,
      	          scb->adf_outarg.ad_f8prec,
      	          scb->adf_outarg.ad_f8style,
      	          decimal, p, &slen_as_i2);
          }
	  slen = slen_as_i2;
          break;
      }

      case RMSGW_BL_FIXSTR:
      case RMSGW_NL_FIXSTR:
      case RMSGW_BL_VARSTR:
      case RMSGW_NL_VARSTR:
      {
	/* Note: no warnings on conversion of non-printables to blanks
	** for C datatype and NULLs to blank for TEXT datatype.
	**
	** This isn't impossible, but does take some work.  Someone has to call
	** adx_checkwarn after the query has run and see if there were any
	** warnings.
	*/
	char	    *q;

	p = indv->db_data;
	q = p + indv->db_length - 1;

	switch (indv->db_datatype)
	{
	    case    RMSGW_BL_FIXSTR:
	    case    RMSGW_BL_VARSTR:
		while (q >= p  &&  *q == ' ')
		    q--;
		break;

	    case    RMSGW_NL_FIXSTR:
	    case    RMSGW_NL_VARSTR:
                if ( outdv->db_datatype != DB_BYTE_TYPE &&
                     outdv->db_datatype != DB_GEOM_TYPE &&
                     outdv->db_datatype != DB_POINT_TYPE &&
                     outdv->db_datatype != DB_MPOINT_TYPE &&
                     outdv->db_datatype != DB_LINE_TYPE &&
                     outdv->db_datatype != DB_MLINE_TYPE &&
                     outdv->db_datatype != DB_POLY_TYPE &&
                     outdv->db_datatype != DB_MPOLY_TYPE &&
                     outdv->db_datatype != DB_LBYTE_TYPE )
                {
                    /*
                    ** we want to keep the nulls for byte and lbyte types
                    */
		    while (q >= p  &&  *q == NULLCHAR)
		        q--;
                }
		break;
	}

	slen = q - p + 1;
        break;
      }

      case RMSGW_VAXDATE:
      {
	/* Note that II_DATE_FORMAT is not honored here; this is just the
	** currently-defined VAX date output format.
	*/

	struct dsc$descriptor	    timdsc;
	u_i2			    reslen;

	timdsc.dsc$a_pointer = p;
	timdsc.dsc$b_dtype = DSC$K_DTYPE_T;
	timdsc.dsc$b_class = DSC$K_CLASS_S;
	timdsc.dsc$w_length = 23;
	if (sys$asctim(&reslen, &timdsc, indv->db_data, 0) != SS$_NORMAL)
	    return(rms_dterr(scb, E_GW7011_BAD_VAXDATE_VAL, 0));

	slen = reslen;
	break;
      }

      case RMSGW_PACKED_DEC:
      {
	i4		pr = DB_P_DECODE_MACRO(indv->db_prec);
	i4		sc = DB_S_DECODE_MACRO(indv->db_prec);
	char		decimal = (scb->adf_decimal.db_decspec
				    ? (char) scb->adf_decimal.db_decimal
				    : '.'
			      );
			      
	_VOID_ CVpka((PTR)indv->db_data, pr, sc, decimal,
					50, sc, CV_PKLEFTJUST, p, &slen);
	break;
      }

      case RMSGW_LEADING_NUM:
	    styp = "leading sign";
	    goto numstr_begin;

      case RMSGW_ZONED_NUM:
	    styp = "zoned";
	    goto  numstr_begin;

      case RMSGW_UNS_NUM:
	    styp = "unsigned";
	    goto  numstr_begin;

      case RMSGW_OVR_NUM:
	    styp = "overpunched";
	    goto  numstr_begin;

      case RMSGW_TRL_NUM:
	    styp = "trailing";
	    goto  numstr_begin;

      numstr_begin: ;
      {
	i4		pr = DB_P_DECODE_MACRO(indv->db_prec);
	i4		sc = DB_S_DECODE_MACRO(indv->db_prec);
	i4		j;
	char		*ip, *jp;
	char		ch;
	char		decimal = (scb->adf_decimal.db_decspec
				    ? (char) scb->adf_decimal.db_decimal
				    : '.'
			      );

	/*
	**  Altho we do a lot of syntax checking on the incoming string, we
	**  are not quite exhaustive -- we don't check that the low-order byte
	**  is proper to its string type (zoned, overpunched, leading sign,
	**  or unsigned), but just accept any byte acceptable to any type as
	**  ok for any type.  Fix this someday --
	*/
	jp = indv->db_data;
	ip = p;

	/* leading numeric type is a special case because the sign is first */
	if (indv->db_datatype == RMSGW_LEADING_NUM)
	{
	    if (*jp == '-')
		*ip++ = '-';
	    else  if (*jp != '+'  &&  *jp != ' ')
		goto numstr_error;
	    jp++;
	}
	/* trailing numeric type is special because the sign byte is separate */
	else if (indv->db_datatype == RMSGW_TRL_NUM)
	{
	    ch = jp[indv->db_length - 1];
	    jp[indv->db_length - 1] = EOS;
	    if (ch == '-')
		*ip++ = '-';
	    else if (ch != '+')
		goto numstr_error;
	}
	else
	{
	    /* put in a minus sign if appropriate */
	    ch = rms_1numstr_sign(jp[indv->db_length - 1]);
	    if (ch == '-')
		*ip++ = '-';
	    else  if (ch == RMS_7NUMSTR_BAD)    /* invalid low-order byte */
	    {
		jp = jp + indv->db_length - 1;
		goto  numstr_error;
	    }
	}


	/* skip leading zeros if any */
	while (pr > sc  &&  *jp == '0')
	{
	    pr--;
	    jp++;
	}

	/* make sure we get at least one zero to the left of the decimal */
	if ( pr == sc )
	    *ip++ = '0';

	/* move all integral digits into string buffer */
	j = pr - sc;
	if ( sc == 0 &&
	   ( (indv->db_datatype != RMSGW_TRL_NUM) &&
	     ( indv->db_datatype != RMSGW_LEADING_NUM ) ) )
	    j--;    /* don't move sign/digit byte here */
	while (j-- > 0)
	{
	    if (! CMdigit(jp))
		goto  numstr_error;
	    *ip++ = *jp++;
	}

	/* add the decimal point */
	if (sc > 0)
	    *ip++ = decimal;

	/* copy fractional digits except last into string buffer */
	if   ( ( indv->db_datatype == RMSGW_TRL_NUM ) ||
	       ( indv->db_datatype == RMSGW_LEADING_NUM ) )
	    j = sc;
	else
	    j = sc - 1;
	for (; j > 0; j--)
	{
	    if (! CMdigit(jp))
		goto  numstr_error;
	    *ip++ = *jp++;
	}

	/*
	** translate last digit into correct ascii representation.
	** for leading and trailing numeric, the last digit has already
	** been copied.  also, if ALL the digits were 0 and the number
	** of decimal places is 0, then we've already accounted for all
	** the digits.
	*/

	if ( indv->db_datatype != RMSGW_TRL_NUM &&
	     indv->db_datatype != RMSGW_LEADING_NUM &&
	     ( pr != 0 || sc != 0 ) )
	{
	    *ip = rms_0numstr_digit(*jp);
	    if (*ip++ == RMS_7NUMSTR_BAD)
		goto  numstr_error;
	}
	slen = ip - p;
	break;

    numstr_error:
	return (rms_dterr(scb, E_GW7017_BAD_NUM_TO_STR, 3, STlength(styp), styp,
	    indv->db_length, indv->db_data, 1, jp));
      }
    }

    /* now p points to a null terminated string which needs to be transferred
    ** into the result area
    **
    ** slen indicates the length of the string to be moved; it would be bad if
    ** slen were not set correctly
    */
    if (!from_str)
	_VOID_ rms_movestring(p, slen, outdv);

    return(E_DB_OK);
}

/*
**  Logically internal to the above -- calculate the length of the string to
**  make for a G- or H-float number, based on 'mx', the longest string it
**  makes sense to make, and the ultimate output length and type as taken from
**  'outdv'.  Note:  we try hard to give the user as much significance as we
**  can, but no more than 16 (for G) or 34 (for H) digits [the 16th (34th) is
**  definitely unreliable], but we don't worry about the one digit of
**  significance sacrificed when there's a 4-digit exponent, which can
**  happen with H-float.
*/
static  i4
ghmaklen
(
    i4             mx,
    DB_DATA_VALUE  *outdv
)
{
    register  i4  maklen, outlen, outtyp;

    /* longest string it makes any sense to make -- */
    maklen = mx + LEADGHOUT;

    /*  Shorten it to fit output field, if necessary and possible.  Watch out
    /*  for leading count of varying-length fields. */
    outlen = outdv->db_length;
    outtyp = outdv->db_datatype;
    if (outtyp == DB_VCH_TYPE  ||  outtyp == DB_TXT_TYPE)
	outlen -= DB_CNTSIZE;
    if (outlen < mx  &&  outlen >= ALLGHOUT)
	maklen = outlen + LEADGHOUT;

    /* be utterly sure we're within bounds */
    if (maklen < ALLGHOUT + LEADGHOUT)
	maklen = ALLGHOUT + LEADGHOUT;
    if (maklen > mx + LEADGHOUT)
	maklen = mx + LEADGHOUT;
    return (maklen);
}


/*{
** Name: rms_idtecvt - Convert RMS data values to INGRES date
**
** Description:
**	This routine converts various data types to an INGRES date.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	13-apr-90 (jrb)
**	    Created.
**	14-jun-90 (jrb)
**	    Added support for blank-padded strings (RMSGW_BL_FIXSTR).
**      30-mar-1993 (schang)
**          add support for negative time zone
**      24-jan-94 (jimg)
**          case = RMSGW_VAXDATE:
**          One design issue:
**             An Ingres date without timestamp cannot be accurately converted
**             into a VAX/VMS internal format for absolute time.  The companion
**             routine to this one, rms_rdtecvt(),  therefore, uses a zero
**             timestamp and does not shift to GMT. This routine cannot tell the
**             difference between a date with no timestamp and a date with a
**             zero timestamp.  Both are converted to the same value.
**
**             The effect of this is to  at least allow such dates to appear
**             correct when entered and displayed from the same time zone.
**             Display of such  dates from a different time zone will be wrong
**             because the VAX internal format does not preserve the difference
**             between an Ingres GMT date converted to a VAX local date with
**             time=0 and an Ingres date without a timespec.
**
**          Algorithm changes:
**             Re-wrote entire conversion routine by copying method and code
**             used in rms_rdtecvt().
**             The algorithm now follows the same tack and keeps "time" units as
**             a composite when doing the shifts and when checking and
**             normalizing for any overflow or underflow.  Spills into the
**             "date" part of the data value is handled similar to the old
**             routine with some simplifications due to assuming a bounded range
**             on the server's time zone values (as returned by TMzone()).
**
**          Clarifications regarding use of TMzone():
**             The conversion algorithm is simplified by the fact that time zone
**             shifts are "naturally" defined within the bounds (-13,+14]
**             hours.  It is possible, however, for TMzone() to return values
**             outside of these bounds.  This can happen because the user is
**             allowed to set the II_TIMEZONE logical to values larger than
**             their natural bounds, and TMzone does no bounds checking.
**             Therefore, it is possible to break the conversion algorithms with
**             values outside the "natural" bounds.  Particularly, an
**             II_TIMEZONE value less than -546 or greater than +546 will cause
**             TMzone() to produce and return a  value near + or - 2**15.  These
**             values can cause any two-byte variable used in arithmetic
**             operations to overflow or underflow.
**
**             A decision was made NOT to check for this bound in these
**             routines.  The reasons are that performance of in-bound values
**             should not suffer a check against  exceptional values and that
**             users should be suitably constrained to set proper values for
**             II_TIMEZONE if their data is to have any natural meaning.
**
**      apr-19-97 (chash01) use new tm functions to get timezone offset
**      04-apr-2000 (chash01)
**        date<->rms integer conversion should encode/decode 3 digits for 
**        year, not 2 (bug 101150)
*/
DB_STATUS
rms_idtecvt
(
    ADF_CB		    *scb,
    DB_DATA_VALUE	    *indv,
    DB_DATA_VALUE	    *outdv
)
{
    AD_DATENTRNL	    *outp = outdv->db_data;
    bool		    from_date = FALSE;
    char		    *q;
    char		    buf[10];
    i4			    slen;
    i4			temp;

    switch (indv->db_datatype)
    {
      case RMSGW_INT:
      {
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    temp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
	    break;

	  case 2:
	    temp = *(i2 *)indv->db_data;
	    break;
	    
	  case 4:
	    temp = *(i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    temp = qp->quad_chunk[0];

	    if (temp >= 0)
	    {
		if (qp->quad_chunk[1] != 0)
		    temp = 0;
	    }
	    else
	    {
		if (qp->quad_chunk[1] != 0xffffffff)
		    temp = 0;
	    }
	    break;

	  case 16:
	    op = indv->db_data;
	    temp = op->octa_chunk[0];

	    if (temp >= 0)
	    {
		if ((op->octa_chunk[3] | op->octa_chunk[2] | op->octa_chunk[1])
			!= 0
		   )
		{
		    temp = 0;
		}
	    }
	    else
	    {
		if ((op->octa_chunk[3] & op->octa_chunk[2] & op->octa_chunk[1])
			!= 0xffffffff
		   )
		{
		    temp = 0;
		}
	    }
	    break;
	}

	break;
      }

      case RMSGW_UNSINT:
      {
	u_i4		utemp;
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    utemp = *(u_i1 *)indv->db_data;
	    break;

	  case 2:
	    utemp = *(u_i2 *)indv->db_data;
	    break;

	  case 4:
	    utemp = *(u_i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    utemp = qp->quad_chunk[0];

	    if (qp->quad_chunk[1] != 0)
		utemp = 0;
	    break;

	  case 16:
	    op = indv->db_data;
	    utemp = op->octa_chunk[0];

	    if ((op->octa_chunk[3] | op->octa_chunk[2] | op->octa_chunk[1])
		    != 0
	       )
	    {
		utemp = 0;
	    }
	    break;
	}
        temp = (i4)utemp;
	break;
      }

      case RMSGW_BL_FIXSTR:
      case RMSGW_NL_FIXSTR:
      case RMSGW_BL_VARSTR:
      case RMSGW_NL_VARSTR:
      {
	DB_DATA_VALUE	    dvs[2];
	char		*p;
	
	p = (char *)indv->db_data + indv->db_length - 1;

	switch (indv->db_datatype)
	{
	    case    RMSGW_BL_FIXSTR:
	    case    RMSGW_BL_VARSTR:
		while (p > indv->db_data  &&  *p == ' ')
		    p--;
		break;
	    case    RMSGW_NL_FIXSTR:
	    case    RMSGW_NL_VARSTR:
		while (p > indv->db_data  &&  *p == NULLCHAR)
		    p--;
		break;
	}

	slen = p - (char *)indv->db_data + 1;
	q = indv->db_data;

	STRUCT_ASSIGN_MACRO(*outdv, dvs[0]);
	dvs[1].db_datatype = DB_CHA_TYPE;
	dvs[1].db_length = slen;
	dvs[1].db_prec = 0;
	dvs[1].db_data = q;

        if (adf_exec_quick(scb, Rms_adffi_arr[RMS_00CHA2DTE_CVT].rms_fiid, dvs)
	    != E_DB_OK
	   )
	{
	    return(rms_dterr(scb, E_GW7022_BAD_INT_TO_DATE, 1,
					    indv->db_length, indv->db_data));
	}
	return(E_DB_OK);
      }

      case RMSGW_VAXDATE:
      {
	/* Note that once converted to an INGRES date we have the same
	** timezone anomolies that accompany all INGRES dates; also, over a
	** network (where nodes could be in different timezones), a vax date
	** may look different in the RMS application vs. in the INGRES RMS
	** gateway (this is because the local timezone shift is applied to the
	** date).
	**
	** For example, if the vax date is 16-APR-1990 16:10:25.20 then we
	** store the GMT date (for PDT) as 17-APR-1990 00:10:25 in INGRES date
	** format.  Then retrieving this date should give you the same date and
	** time as the original provided you are in the same timezone; if you
	** retrieved the date into a different timezone and then converted it
	** to display format (which is when the time shift is applied) then
	** you would see a different time from the one your RMS application
	** shows you.
	*/

        /* 
	** 24-jan-93 (jimg)
    	** For converting shifted values of "timestamp" that are negative.
	** The maximum negative value (in days) cannot exceed, in absolute value,
	** this value.
	**/
#define MAX_NEG_ADJUST  2

	static i1	daysin[][12] = {31,28,31,30,31,30,31,31,30,31,30,31,
					31,29,31,30,31,30,31,31,30,31,30,31};
	i2		timebuf[7];
	i4		tmshift;
	i4		yearsize;
        /*  Used for negative timeshift interval arithmetic. (jimg) */
        i4                 delta;
        /*   Used for combined time values.		     (jimg  */
        i4              time;
        PTR             tm_cb;
        char            tm_name[32];
        char            *string;
        /*
        ** 24-jan-94 (jimg)
        **  Assumptions:
        **  1) TMzone() returns the value that represents the shift west of GMT
        **     in minutes.  These values are based on political agreements  as
        **     well as by technical determination.  Daylight savings time, when
        **     observed in a certain zone, can also shift the upper bounds by an
        **     hour or so.  In any case, the "natural" range for time zone
        **     shifts seems to be within (-13, +14] hours, viz., (-780,+840]
        **     minutes.  The value need not be an even multiple of 60 (e.g., 30
        **     or 45 minutes are possible for some time zones).
        **     NOTE: ** No bounds check for this value is done here. **
        **
        **  2) Notes on interval arithmetic for date conversions: The numeric
        **     values for each of the date-time units are based on the format of
        **     the seven-word binary integer data structure specified by the VMS
        **     System Service companion routiner SYS$NUMTIME and LIB$CVT_VECTIM.
        **     SYS$NUMTIME converts a VAX VMS 64-bit binary system time to numeric
        **     time.  LIB$CVT_VECTIM provides the inverse function.
        **
        **      variable     description             interval
        **      -----------  --------------------    -----------------------
        **      timebuf[0]   year since 0            0..AD_24DTE_MAX_ABS_YR
        **      timebuf[1]   month of year           1..12
        **      timebuf[2]   day of month            1..daysin[yr][month]
        **      timebuf[3]   hour of day             0..23
        **      timebuf[4]   minute of hour          0..59
        **      timebuf[5]   second of minute        0..59
        **      timebuf[6]   hundredths of second    0..99
        **
        **      timebuf[6] is ignored in these calculations with the result
        **      that a VAX date with non-zero ms is effectively truncated to
        **      integer seconds.
        */

	/* Convert VAX date to time buffer values */
	if (sys$numtim(&timebuf, indv->db_data) != SS$_NORMAL)
	{
	    return(rms_dterr(scb, E_GW7011_BAD_VAXDATE_VAL, 0));
	}

	/* Set flags, always have a timespec */
	outp->dn_status = AD_DN_ABSOLUTE | AD_DN_YEARSPEC | AD_DN_MONTHSPEC
					 | AD_DN_DAYSPEC  | AD_DN_TIMESPEC;

	/* 
        ** Get the server's time zone value in minutes
        ** need date info to calculate GMT offset
        */

	outp->dn_year	 = timebuf[0];
	outp->dn_month   = timebuf[1];
	outp->dn_lowday  = timebuf[2];
	outp->dn_highday = 0;
        outp->dn_time    = 0;
        string = NULL;
        NMgtAt("II_TIMEZONE_NAME",&string);
        if (string != NULL)
           STcopy (string, tm_name);
        else 
           /* default to IIGMT */
           STcopy ("IIGMT", tm_name);

        TMtz_lookup(tm_name, &tm_cb);
        tmshift = TMtz_search(tm_cb, TM_TIMETYPE_GMT,
                                 adu_5time_of_date(outp));

        /*
        ** change tmshift to min
        */
        tmshift /= 60;
	from_date = TRUE;

        /*
        ** Shift by # of mins west of Greenwich and normalize date:
        **
        ** 24-jan-94 (jimg)
        **  My re-write of this routine.
        */

        /* First, combine the units needed for "time" (ignore "ms") */
        time    =   timebuf[3] * AD_8DTE_IMSPERHOUR +
                    timebuf[4] * AD_7DTE_IMSPERMIN  +
                    timebuf[5] * AD_6DTE_IMSPERSEC;

        if ( (time -= (tmshift * AD_7DTE_IMSPERMIN) ) > 0 )
        {
            /* Check if "hour" value overflowed */
            if ( time >= (24 * AD_8DTE_IMSPERHOUR) )
            {
                /*
                ** NOTE:Valid II_TIMEZONE values of (-13,14] ensure
                **      that the largest positive shift will
                **      produce 62:59:59 for:
                **          * user-entered time =  23:59:59 pm
                **          * pm adds in a value  +12
                **          * session time zone = +14
                **          * server time zone  = -13.
                **
                **      This means that 2 days is the maximum
                **      overflow that can be added to the "date".
                **
                **  WARNING: II_TIMEZONE values outside this range
                **      may break this algorithm and return a conversion
                **      error.
                */

                /*
                ** Add computed overflow to "day" and
                ** normalize "time" value.
                */
                timebuf[2] += time / (24 * AD_8DTE_IMSPERHOUR);
                time        = time % (24 * AD_8DTE_IMSPERHOUR);

                /* Check result for overflow out of "day of month" */
                TMyrsize(timebuf[0], &yearsize);
                if ( timebuf[2] > daysin[yearsize-365][timebuf[1]-1] )
                {
                    /* Normalize "day of month" with respect to "year" */
                    timebuf[2] -= daysin[yearsize-365][timebuf[1]-1];

                    /* Increment "month", check result for overflow */
                    if ( (++timebuf[1]) > 12)
                    {
                        /*
                        ** Only "month" overflow is
                        **   from   DEC "year"
                        **   to     JAN "year"+1.
                         */
                        timebuf[1]  = 1;
                        timebuf[0] += 1;
                    }
                }
            }
        }

        /* Check result for underflow out of "time" */
        else if ( time < 0 )
        {
            /*
            ** NOTE:Valid II_TIMEZONE values of (-13,14] ensure that
            **      the largest negative shift will produce -27:00:00
            **      for:
            **      * user-entered time =  00:00:00
            **      * session time zone = -13
            **      * server time zone  = +14.
            **
            **      This means that 2 days is the MAX_NEG_ADJUST
            **      needed to restore the "time" to a positive
            **      value using modulo arithmetic.
            **
            **  WARNING: II_TIMEZONE values outside this range may
            **      break this algorithm and return a conversion error.
            */

            /* Compute underflow into "date" as a negative integer */
            delta = ((time + MAX_NEG_ADJUST * 24*AD_8DTE_IMSPERHOUR) /
                                             (24*AD_8DTE_IMSPERHOUR))
                           - MAX_NEG_ADJUST;

            /* Normalize "time" value to a positive number */
            time =  (time + MAX_NEG_ADJUST *24*AD_8DTE_IMSPERHOUR) %
                                           (24*AD_8DTE_IMSPERHOUR);

            /* Add underflow to "day" and check result for further underflow */
            if ( (timebuf[2] += delta) <= 0 )
            {
                /* Decrement "month", check result for underflow */
                if ( (--timebuf[1] ) <= 0)
                {
                    /*
                    ** Only "month" underflow is
                    **   from   JAN "year"
                    **   to     DEC "year"-1.
                    */
                    timebuf[0] -= 1;
                    timebuf[1]  = 12;

                    /* Adjust "day" knowing month */
                    timebuf[2] += 31;
                }
                else
                {
                    /* All other underflows, do variable adjustment */
                    TMyrsize(timebuf[0], &yearsize);
                    timebuf[2] += daysin[yearsize-365][timebuf[1]-1];
                }
            }
        }

	/* convert into INGRES date format */
	outp->dn_year	 = timebuf[0];
	outp->dn_month   = timebuf[1];
	outp->dn_lowday  = timebuf[2];
	outp->dn_highday = 0;
        outp->dn_time    = time;    /* just assign this directly now (jimg) */

	if (outp->dn_year > AD_24DTE_MAX_ABS_YR)
	{
	    return(rms_dterr(scb, E_GW7003_DATE_OUT_OF_RANGE, 1,
						    2, &outp->dn_year));
	}
        break;
      }
    }
    /*
    ** chash01 -- this is only for rms_rint and rms_runs
    */
    if (!from_date)
    {
        int newt;

	/* Set flags, always have a timespec */
	outp->dn_status = AD_DN_ABSOLUTE | AD_DN_YEARSPEC 
                          | AD_DN_MONTHSPEC | AD_DN_DAYSPEC;
	outp->dn_highday = 0;
        outp->dn_time    = 0;
	if (scb->adf_dfmt == DB_ISO_DFMT)
	{
            outp->dn_year = temp/10000 + 1900;
            newt = temp % 10000;
            outp->dn_month = newt/100;
            outp->dn_lowday = newt % 100;
	}
	else if (scb->adf_dfmt == DB_GERM_DFMT)
	{
            outp->dn_lowday = temp/100000;
            newt = temp % 100000;
            outp->dn_month = newt/1000;
            outp->dn_year = newt%1000 + 1900;
	}
	else
	{
            outp->dn_month = temp/100000;
            newt = temp % 100000;
            outp->dn_lowday = newt/1000;
            outp->dn_year = newt%1000 + 1900;
	}

    }
    
    return(E_DB_OK);
}


/*{
** Name: rms_imnycvt - Convert RMS data value to the INGRES money type
**
** Description:
**	This routine takes a variety of RMS data values and converts them
**	to the INGRES money type.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**	17-apr-90 (jrb)
**	    Created.
**	14-jun-90 (jrb)
**	    Added support for blank-padded strings (RMSGW_BL_FIXSTR).
**	22-jun-90 (edwin)
**	    Reimplemant f- & d-float as foreign, not native, datatypes.
**	7-sep-90 (linda)
**	    Added support for RMSGW_TRL_NUM (trailing separate numeric)
**	    datatype.
**	9-oct-91 (rickh)
**	    Conversion to leading numeric was one byte off.
**	9-dec-91 (rickh)
**	    Use RMS_MAX_FLOAT instead of FMAX as upper bound on f8.
**
*/
DB_STATUS
rms_imnycvt
(
    ADF_CB	  *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    f8		    temp = 0.0;
    bool	    overflow = FALSE;
    bool	    underflow = FALSE;
    DB_DATA_VALUE   dvs[2];
    DB_STATUS	    stat;

    switch (indv->db_datatype)
    {
      case RMSGW_INT:
      {
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    temp = I1_CHECK_MACRO(*(i1 *)indv->db_data);
	    break;

	  case 2:
	    temp = *(i2 *)indv->db_data;
	    break;
	    
	  case 4:
	    temp = *(i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    if (qp->quad_chunk[1] & 0x80000000)
	    {
		RMS_QUADWORD	tqw;

		rms_intcmpl(qp, 2, &tqw);
		temp = tqw.quad_chunk[1] * -4294967296e0
			- tqw.quad_chunk[0];
	    }
	    else
	    {
		temp = qp->quad_chunk[1] * 4294967296e0
			+ qp->quad_chunk[0];
	    }
	    break;

	  case 16:
	    op = indv->db_data;
	    if (op->octa_chunk[3] & 0x80000000)
	    {
		RMS_OCTAWORD	tow;

		rms_intcmpl(op, 4, &tow);
		temp = tow.octa_chunk[3] * -7.92281625e28
			- tow.octa_chunk[2] * 1.844674407e19
			- tow.octa_chunk[1] * 4294967296e0
			- tow.octa_chunk[0];
	    }
	    else
	    {
		temp = op->octa_chunk[3] * 7.92281625e28
			+ op->octa_chunk[2] * 1.844674407e19
			+ op->octa_chunk[1] * 4294967296e0
			+ op->octa_chunk[0];
	    }
	}
	break;
      }

      case RMSGW_UNSINT:
      {
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    temp = *(u_i1 *)indv->db_data;
	    break;

	  case 2:
	    temp = *(u_i2 *)indv->db_data;
	    break;

	  case 4:
	    temp = *(u_i4 *)indv->db_data;
	    break;

	  case 8:
	    qp = indv->db_data;
	    temp = qp->quad_chunk[1] * 4294967296e0
		    + qp->quad_chunk[0];
	    break;

	  case 16:
	    op = indv->db_data;

	    /* if high bit set, we know we'll overflow for sure */
	    if (op->octa_chunk[3] & 0x80000000)
	    {
		overflow = TRUE;
	    }
	    else
	    {
		temp = op->octa_chunk[3] * 7.92281625e28
			+ op->octa_chunk[2] * 1.844674407e19
			+ op->octa_chunk[1] * 4294967296e0
			+ op->octa_chunk[0];
	    }
	    break;
	}
	
	break;
      }

      case RMSGW_GFLOAT:
      case RMSGW_HFLOAT:
      {
          struct dsc$descriptor  srcdsc;
          struct dsc$descriptor  dstdsc;
      
          i4  cond;
          i4  len;

          srcdsc.dsc$b_class = DSC$K_CLASS_S;
          if (indv->db_datatype == RMSGW_GFLOAT)
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_G;
          else
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_H;
          srcdsc.dsc$a_pointer = indv->db_data;
          dstdsc.dsc$a_pointer = &temp;
          dstdsc.dsc$b_class = DSC$K_CLASS_S;
#ifdef VAX
          dstdsc.dsc$b_dtype = DSC$K_DTYPE_D;
#else
          dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;
#endif
          cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);
	  switch (cond)
          {
              case SS$_NORMAL:
                  break;
              case LIB$_FLTOVF:
                  overflow = TRUE;
                  break;
              case LIB$_FLTUND:
                  underflow = TRUE;
                  break;
              default:
	          return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                  break;
          }
          break;
      }    

      case RMSGW_FFLOAT:
      case RMSGW_DFLOAT:
#ifdef VAX
        if (indv->db_datatype == RMSGW_FFLOAT)
            temp = *(f4 *)indv->db_data;
        else 
            temp = *(f8 *)indv->db_data;
        break;
#else  /* alpha or itanium */
      {
          struct dsc$descriptor  srcdsc;
          struct dsc$descriptor  dstdsc;
          i4  cond;
          i4  len;

          srcdsc.dsc$b_class = DSC$K_CLASS_S;
          if (indv->db_datatype == RMSGW_FFLOAT)
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_F;
          else
              srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
          srcdsc.dsc$a_pointer = indv->db_data;

          dstdsc.dsc$a_pointer = &temp;
          dstdsc.dsc$b_class = DSC$K_CLASS_S;
          dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;

          cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);

	  switch (cond)
          {
              case SS$_NORMAL:
                  break;
              case LIB$_FLTOVF:
                  overflow = TRUE;
                  break;
              case LIB$_FLTUND:
                  underflow = TRUE;
                  break;
              default:
	          return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                  break;
          }
          break;
      }    
#endif 

      case RMSGW_SFLOAT:
      case RMSGW_TFLOAT:
#ifdef VAX
          if (indv->db_datatype == RMSGW_SFLOAT)
              stat = cvt_s2f(indv->db_data, &temp);
          else
              stat = cvt_t2d(indv->db_data, &temp);

          if (stat)
	      return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
          break;
#else
        if (indv->db_datatype == RMSGW_SFLOAT)
            temp = *(f4 *)indv->db_data;
        else
            temp = *(f8 *)indv->db_data;
        break;
#endif

      case RMSGW_BL_FIXSTR:
      case RMSGW_NL_FIXSTR:
      case RMSGW_BL_VARSTR:
      case RMSGW_NL_VARSTR:
      {
	/* Note- we have to put an unnatural limit on the length of the
	** RMS string because the ADF coercion can't handle string larger
	** than DB_MAXSTRING
	*/
	char		*p;
	
	p = (char *)indv->db_data + indv->db_length - 1;

	switch (indv->db_datatype)
	{
	    case    RMSGW_BL_FIXSTR:
	    case    RMSGW_BL_VARSTR:
		while (p > indv->db_data  &&  *p == ' ')
		    p--;
		break;

	    case    RMSGW_NL_FIXSTR:
	    case    RMSGW_NL_VARSTR:
		while (p > indv->db_data  &&  *p == NULLCHAR)
		    p--;
		break;
	}

	STRUCT_ASSIGN_MACRO(*outdv, dvs[0]);
	dvs[1].db_datatype = DB_CHA_TYPE;
	dvs[1].db_length = p - (char *)indv->db_data + 1;
	dvs[1].db_prec = 0;
	dvs[1].db_data = indv->db_data;

	/* ADF can handle only strings of length DB_MAXSTRING or smaller */
	if (dvs[1].db_length > DB_MAXSTRING)
	    return(rms_dterr(scb, E_GW7027_MNY_STR_TOO_LONG, 0));

	if (adf_exec_quick(scb, Rms_adffi_arr[RMS_02CHA2MNY_CVT].rms_fiid, dvs)
	    != E_DB_OK
	   )
	{
	    return(rms_dterr(scb, E_GW7024_BAD_STR_TO_MNY, 1,
					dvs[1].db_length, dvs[1].db_data));
	}
	return(E_DB_OK);
        break;
      }

      case RMSGW_PACKED_DEC:
	_VOID_ CVpkf(indv->db_data,
		DB_P_DECODE_MACRO(indv->db_prec),
		DB_S_DECODE_MACRO(indv->db_prec),
		&temp);
	break;

      case RMSGW_LEADING_NUM:	/***REALLY??? (linda) 6-sep-90***/
      case RMSGW_ZONED_NUM:
      case RMSGW_UNS_NUM:
      case RMSGW_OVR_NUM:
      case RMSGW_TRL_NUM:
      {
	char	    buf[260];
	char	    *sd;
	i4	    scale;

	if (indv->db_datatype == RMSGW_LEADING_NUM)
	{
	    MEcopy(indv->db_data, indv->db_length, buf);
	    sd = &buf[indv->db_length - 1];
	}
	else
	{
	    MEcopy(indv->db_data, indv->db_length, buf+1);
	    sd = &buf[indv->db_length];
	}

	/* sd now points at last digit */

	/* translate last digit into sign and normal ascii digit */
	if (indv->db_datatype == RMSGW_TRL_NUM)
	{
	    buf[0] = *sd;
	    sd--;   /* so we'll overwrite the trailing sign byte */
	}
	else if (indv->db_datatype != RMSGW_LEADING_NUM)
	{
	    buf[0] = rms_1numstr_sign(*sd);
	    *sd = rms_0numstr_digit(*sd);
	}
	*++sd = 'e';
	*++sd = '-';
	scale = DB_S_DECODE_MACRO(indv->db_prec);
	*++sd = scale/10 + '0';
	*++sd = scale%10 + '0';
	*++sd = EOS;

	switch (CVaf(buf, '.', &temp))
	{
	  case OK:
	    break;
	  case CV_OVERFLOW:
	    overflow = TRUE;
	    break;
	  case CV_UNDERFLOW:
	    underflow = TRUE;
	    break;
	  default:
	    return(rms_dterr(scb, E_GW7025_BAD_NUM_TO_MNY, 0));
	    break;
	}
	break;
      }
    }

    /* Now temp is a signed f8 representation of the destination float */
    if (temp > RMS_MAX_FLOAT  ||  temp < -RMS_MAX_FLOAT )
    {
	overflow = TRUE;
    }

    if (overflow)
	return(rms_dterr(scb, E_GW7004_MONEY_OVF, 0));

    if (underflow)
	return(rms_dterr(scb, E_GW7005_MONEY_UND, 0));


    /* Now temp is a signed f8 representation of the money value; put into
    ** array of db_data_values and coerce float to money
    */
    STRUCT_ASSIGN_MACRO(*outdv, dvs[0]);
    dvs[1].db_datatype = DB_FLT_TYPE;
    dvs[1].db_length = 8;
    dvs[1].db_prec = 0;
    dvs[1].db_data = &temp;

    if ((stat =
	    adf_exec_quick(scb, Rms_adffi_arr[RMS_01FLT2MNY_CVT].rms_fiid, dvs))
	!= E_DB_OK
       )
    {
	return(stat);
    }

    return(E_DB_OK);
}


/*{
** Name: rms_cvttoidec -- converts rms datatype to ingres DECIMAL datatype.
**
** Description:
**      This routine converts supported RMS datatype to ingres DECIMAL datatype
**      The default RMS type is packed decimal with the same precision and
**      scale as the registered ingres precision and scale.  To show the 
**      difference in precision and scale, user must use extended format.
**
**      col_name decimal(10,5);  ingres and rms data are of the same precision
**                               and scale.
**
**      col_name decimal(10, 5) is 'packed_decimal(offset, 11,6)'; ingres and
**                               rms data are of different precision and scale.
**                               offset must be provided even if this data 
**                               follows immediately its previous column.
**
**      col_name decimal(10, 5) is 'd_floating(offset)'; ingres and
**                               rms data are of different type,
**                               offset must be provided even if this data 
**                               follows immediately its previous column.
**
** Inputs:
**	scb			    ADF session control block (needed for
**				    error reporting)
**	indv			    Data value to be converted
**	outdv			    Result data value after conversion
**
** Outputs:
**	scb			    Error may be set here if error occurred
**	outdv.db_data		    Result of conversion
**
**	Returns:
**	    E_DB_OK		    No problem
**	    E_DB_ERROR		    Conversion error occurred
**	    
**	Exceptions:
**	    none
**
** Side Effects:
**	    none
**
** History:
**    01-feb-1993 (schang)
**        created.
**      11-mar-2000 (chash01)
**        modify rms numerical datype conversion to ingres decimal datatype.
*/
DB_STATUS rms_cvttoidec
(
    ADF_CB        *scb,
    DB_DATA_VALUE *indv,
    DB_DATA_VALUE *outdv
)
{
    i4		    temp;
    STATUS	    stat;
    bool	    overflow = FALSE;
    bool            underflow = FALSE;

    switch (indv->db_datatype)
    {
      case RMSGW_INT:
      {
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    temp = I1_CHECK_MACRO(*(i1 *)indv->db_data);

	    if (CVlpk(temp,
	    	      DB_P_DECODE_MACRO(outdv->db_prec),
		      DB_S_DECODE_MACRO(outdv->db_prec),
		      outdv->db_data) == CV_OVERFLOW)
	    {
	        overflow = TRUE;
            }
            break;

	  case 2:
	    temp = *(i2 *)indv->db_data;
	    if (CVlpk(temp,
	    	      DB_P_DECODE_MACRO(outdv->db_prec),
		      DB_S_DECODE_MACRO(outdv->db_prec),
		      outdv->db_data) == CV_OVERFLOW)
	    {
	        overflow = TRUE;
            }
	    break;
	    
	  case 4:
	    temp = *(i4 *)indv->db_data;
	    if (CVlpk(temp,
	    	      DB_P_DECODE_MACRO(outdv->db_prec),
		      DB_S_DECODE_MACRO(outdv->db_prec),
		      outdv->db_data) == CV_OVERFLOW)
	    {
	        overflow = TRUE;
            }
	    break;

	  case 8:
          {
            bool negative = FALSE;
            u_i4 least_s, most_s;
            i4   sixteen_bit[4];
            i2  cnt;
            char buff1[40], buff2[40], buff3[40], buff4[40];
            i4  p, s;
            char *result;

	    qp = indv->db_data;

            /*
            ** take absolute value of this eight bytes
            ** integer.  The process looks pretty stupid.
            ** But, not everyone think the way I do and it
            ** is better write it plan and stupid for
            ** understanding.
            */
            least_s = (u_i4)qp->quad_chunk[0];
            most_s  = (u_i4)qp->quad_chunk[1];
            if (most_s & 0x80000000)
            {
                negative = TRUE;
                most_s = ~most_s;
                /*
                ** if the least significant portion is 0,
                ** its 2's complement is going to generate
                ** a carry and to be added to the complement
                ** of most significant portion.
                */
                if (least_s == 0x00000000)
                    most_s += 1;
                least_s = ~least_s + 1;
            }
            /*
            **  lets have something even more stupid, just watch
            **  the reason for this is that we want to convert 
            **  16 bits for each iteration.  we can not convert 32
            **  bits (4bytes) each time, because that causes
            **  overflow during conversion, how can you mutiply
            **  something with 2**32, 2**32 is an signed integer
            **  overflow for long. 
            */
            sixteen_bit[0] = (i4)(least_s & 0x0000ffff);
            sixteen_bit[1] = (i4)(((least_s & 0xffff0000) >> 16) & 0x0000ffff);
            sixteen_bit[2] = (i4)(most_s & 0x0000ffff);
            sixteen_bit[3] = (i4)(((most_s &0xffff0000) >> 16) & 0x0000ffff);

            /*
            ** get packed decimal representation of 64k (65536), this
            ** is the mutiplier to be used
            */
            CVlpk((long)0x00010000, (i4)31,(i4)0, (PTR)buff4);

            /*
            ** convert the most significant 16 bits first
            */
            CVlpk(sixteen_bit[3], (i4)31, (i4)0, (PTR)buff3);

            /*
            ** each iteration is equivalent to shifting 16 bits and
            ** add less significant 16 bits in binary integer arithmetic
            */
            for (cnt = 2; cnt >= 0; cnt--)
            {
                MHpkmul((PTR)buff3,31,0,(PTR)buff4,31,0,(PTR)buff2,&p,&s);
                CVlpk(sixteen_bit[cnt], (i4)31, (i4)0, (PTR)buff1);
                MHpkadd((PTR)buff2,31,0,(PTR)buff1,31,0,(PTR)buff3,&p,&s);
            }
            /*
            ** now append the sign if negative and convert to packed
            ** decimal format as requested, it may generate overflow
            */
            if (negative)
            {
                MHpkneg((PTR)buff3,31,0, (PTR)buff1);
                result = buff1;
            }
            else
                result = buff3;

            if (CVpkpk((PTR)result, 31, 0, DB_P_DECODE_MACRO(outdv->db_prec),
		       DB_S_DECODE_MACRO(outdv->db_prec), outdv->db_data
                      ) == CV_OVERFLOW)
	    {
	        overflow = TRUE;
            }
            break;
          }   
	  case 16:
          {
            bool negative = FALSE;
            u_i4 longwords[4];
            i4   sixteen_bit[8];
            i2  cnt;
            bool carry;
            char buff1[40], buff2[40], buff3[40], buff4[40];
            i4 p, s;
            char *result;

	    op = indv->db_data;

            /*
            ** take absolute value of this eight bytes
            ** integer.  The process looks pretty stupid.
            ** But, not everyone think the way I do and it
            ** is better write it plan and stupid for
            ** understanding.
            */
            longwords[0] = (u_i4)op->octa_chunk[0];
            longwords[1] = (u_i4)op->octa_chunk[1];
            longwords[2] = (u_i4)op->octa_chunk[2];
            longwords[3] = (u_i4)op->octa_chunk[3];
            /*
            ** complement a negative number and
            ** determined is carry generated and how
            ** it is propogated
            */
            if (longwords[3] & 0x80000000)
            {
                negative = TRUE;
                longwords[0] = ~longwords[0];
                if (longwords[0] == 0xffffffff)
                  carry = 1;
                else 
                  carry = 0;
                longwords[0] += 1;

                longwords[1] = ~longwords[1];                
                longwords[2] = ~longwords[2];                
                longwords[3] = ~longwords[3];
                longwords[1] += carry;
                if ((longwords[1] == 0x00000000) && carry)
                    carry= 1;
                else 
                    carry = 0;
                longwords[2] += carry;
                if ((longwords[2] == 0x00000000) && carry)
                    carry=1;
                else 
                    carry = 0;                
                longwords[3] += carry;
            }                 
            /*
            **  lets have something even more stupid, just watch
            **  the reason for this is that we want to convert 
            **  16 bits each iteration.  we can not convert 32
            **  bits (4bytes) each time, because that causes
            **  overflow during conversion, how can you mutiply
            **  something with 2**32, 2**32 is an signed integer
            **  overflow for long. 
            */
            sixteen_bit[0] = (i4)(longwords[0] & 0x0000ffff);
            sixteen_bit[1] = (i4)(((longwords[0] & 0xffff0000) >> 16)
                                   & 0x0000ffff);
            sixteen_bit[2] = (i4)(longwords[1] & 0x0000ffff);
            sixteen_bit[3] = (i4)(((longwords[1] & 0xffff0000) >> 16)
                                   & 0x0000ffff);
            sixteen_bit[4] = (i4)(longwords[2] & 0x0000ffff);
            sixteen_bit[5] = (i4)(((longwords[2] & 0xffff0000) >> 16) 
                                   & 0x0000ffff);
            sixteen_bit[6] = (i4)(longwords[3] & 0x0000ffff);
            sixteen_bit[7] = (i4)(((longwords[3] & 0xffff0000) >> 16) 
                                   & 0x0000ffff);

            /*
            ** get packed decimal representation of 64k (65536), this
            ** is the mutiplier to be used
            */
            CVlpk((long)0x00010000, (i4)31,(i4)0, (PTR)buff4);

            /*
            ** convert the most significant 16 bits first
            */
            CVlpk(sixteen_bit[7], (i4)31, (i4)0, (PTR)buff3);

            /*
            ** each iteration is equivalent to shifting 16 bits and
            ** add less significant 16 bits in binary integer arithmetic
            */
            for (cnt = 6; cnt >= 0; cnt--)
            {
                MHpkmul((PTR)buff3,31,0,(PTR)buff4,31,0,(PTR)buff2,&p,&s);
                CVlpk(sixteen_bit[cnt], (i4)31, (i4)0, (PTR)buff1);
                MHpkadd((PTR)buff2,31,0,(PTR)buff1,31,0,(PTR)buff3,&p,&s);
            }
            /*
            ** now append the sign if negative and convert to packed
            ** decimal format as requested, it may generate overflow
            */
            if (negative)
            {
                MHpkneg((PTR)buff3,31,0, (PTR)buff1);
                result = buff1;
            }
            else
                result = buff3;

            if (CVpkpk((PTR)result, 31, 0, DB_P_DECODE_MACRO(outdv->db_prec),
		       DB_S_DECODE_MACRO(outdv->db_prec), outdv->db_data
                      ) == CV_OVERFLOW)
	       {
	            overflow = TRUE;
               }
            break;
          }
          break;
        }
        break;   
      }
      case RMSGW_UNSINT:
      {
	u_i4		utemp;
	RMS_QUADWORD    *qp;
	RMS_OCTAWORD    *op;

	switch (indv->db_length)
	{
	  case 1:
	    utemp = *(u_i1 *)indv->db_data;
	    if (CVlpk((i4)utemp,
	    	      DB_P_DECODE_MACRO(outdv->db_prec),
		      DB_S_DECODE_MACRO(outdv->db_prec),
		      outdv->db_data) == CV_OVERFLOW)
	    {
	        overflow = TRUE;
            }
	    break;

	  case 2:
	    utemp = *(u_i2 *)indv->db_data;
	    if (CVlpk((i4)utemp,
	    	      DB_P_DECODE_MACRO(outdv->db_prec),
		      DB_S_DECODE_MACRO(outdv->db_prec),
		      outdv->db_data) == CV_OVERFLOW)
	    {
	        overflow = TRUE;
            }
	    break;

	  case 4:
          {
            i4   sixteen_bit[4];
            i4 p, s;
            char buff1[40], buff2[40], buff3[40], buff4[40];

            /*
            ** unsigned largest integer is 0xffffffff, which is overflow
            ** for 32 bits representation, thus we break it into two parts
            ** and handle it as larger (8, 16 bytes integer
            */
	    utemp = *(u_i4 *)indv->db_data;
            sixteen_bit[0] = (i4)(utemp & 0x0000ffff);
            sixteen_bit[1] = (i4)(((utemp & 0xffff0000) >> 16) & 0x0000ffff);
            /*
            ** get packed decimal representation of 64k (65536), this
            ** is the mutiplier to be used through iterations
            */
            CVlpk((long)0x00010000, (i4)31,(i4)0, (PTR)buff4);

            /*
            ** convert the most significant 16 bits first and multiplied
            ** by 65536
            */
            CVlpk(sixteen_bit[1], (i4)31, (i4)0, (PTR)buff3);
            MHpkmul((PTR)buff3,31,0,(PTR)buff4,31,0,(PTR)buff2,&p,&s);

            /*
            ** convert least significant 16 bits and add it to the
            ** most significant part 
            */
            CVlpk(sixteen_bit[0], (i4)31, (i4)0, (PTR)buff1);
            MHpkadd((PTR)buff2,31,0,(PTR)buff1,31,0,(PTR)buff3,&p,&s);
            if (CVpkpk((PTR)buff3, 31, 0, DB_P_DECODE_MACRO(outdv->db_prec),
		       DB_S_DECODE_MACRO(outdv->db_prec), outdv->db_data
                      ) == CV_OVERFLOW)
	    {
	        overflow = TRUE;
            }
	        break;
          }

	  case 8:
          {
            u_i4 least_s, most_s;
            i4   sixteen_bit[4];
            i2  cnt;
            char buff1[40], buff2[40], buff3[40], buff4[40];
            i4 p, s;

	    qp = indv->db_data;

            /*
            ** take absolute value of this eight bytes
            ** integer.  The process looks pretty stupid.
            */
            least_s = (u_i4)qp->quad_chunk[0];
            most_s  = (u_i4)qp->quad_chunk[1];
            sixteen_bit[0] = (i4)(least_s & 0x0000ffff);
            sixteen_bit[1] = (i4)(((least_s & 0xffff0000) >> 16) & 0x0000ffff);
            sixteen_bit[2] = (i4)(most_s & 0x0000ffff);
            sixteen_bit[3] = (i4)(((most_s & 0xffff0000) >> 16) & 0x0000ffff);

            /*
            ** get packed decimal representation of 64k (65536), this
            ** is the mutiplier to be used through iterations
            */
            CVlpk((long)0x00010000, (i4)31,(i4)0, (PTR)buff4);

            /*
            ** convert the most significant 16 bits first
            */
            CVlpk(sixteen_bit[3], (i4)31, (i4)0, (PTR)buff3);

            /*
            ** each iteration is equivalent to shifting 16 bits and
            ** add less significant 16 bits in binary integer arithmetic
            */
            for (cnt = 2; cnt >= 0; cnt--)
            {
                MHpkmul((PTR)buff3,31,0,(PTR)buff4,31,0,(PTR)buff2,&p,&s);
                CVlpk(sixteen_bit[cnt], (i4)31, (i4)0, (PTR)buff1);
                MHpkadd((PTR)buff2,31,0,(PTR)buff1,31,0,(PTR)buff3,&p,&s);
            }

            if (CVpkpk((PTR)buff3, 31, 0, DB_P_DECODE_MACRO(outdv->db_prec),
		       DB_S_DECODE_MACRO(outdv->db_prec), outdv->db_data
                      ) == CV_OVERFLOW)
	       {
	            overflow = TRUE;
               }
            break;
          }   
	  case 16:
          {
            u_i4 longwords[4];
            i4   sixteen_bit[8];
            i2  cnt;
            char buff1[40], buff2[40], buff3[40], buff4[40];
            i4 p,s;

	    op = indv->db_data;

            /*
            ** take absolute value of this 16 bytes
            ** integer.  The process looks pretty stupid.
            */
            longwords[0] = (u_i4)op->octa_chunk[0];
            longwords[1] = (u_i4)op->octa_chunk[1];
            longwords[2] = (u_i4)op->octa_chunk[2];
            longwords[3] = (u_i4)op->octa_chunk[3];
            /*
            **  lets have something even more stupid, just watch
            **  the reason for this is that we want to convert 
            **  16 bits each iteration.  we can not convert 32
            **  bits (4bytes) each time, because that causes
            **  overflow during conversion, how can you mutiply
            **  something with 2**32, 2**32 is an signed integer
            **  overflow for long. 
            */
            sixteen_bit[0] = (i4)longwords[0] & 0x0000ffff;
            sixteen_bit[1] = (i4)((longwords[0] & 0xffff0000) >> 16) & 0x0000ffff;
            sixteen_bit[2] = (i4)longwords[1] & 0x0000ffff;
            sixteen_bit[3] = (i4)((longwords[1] & 0xffff0000) >> 16) & 0x0000ffff;
            sixteen_bit[4] = (i4)longwords[2] & 0x0000ffff;
            sixteen_bit[5] = (i4)((longwords[2] & 0xffff0000) >> 16) & 0x0000ffff;
            sixteen_bit[6] = (i4)longwords[3] & 0x0000ffff;
            sixteen_bit[7] = (i4)((longwords[3] & 0xffff0000) >> 16) & 0x0000ffff;

            /*
            ** get packed decimal representation of 64k (65536), this
            ** is the mutiplier to be used
            */
            CVlpk((long)0x00010000, (i4)31,(i4)0, (PTR)buff4);

            /*
            ** convert the most significant 16 bits first
            */
            CVlpk(sixteen_bit[7], (i4)31, (i4)0, (PTR)buff3);

            /*
            ** each iteration is equivalent to shifting 16 bits and
            ** add less significant 16 bits in binary integer arithmetic
            */
            for (cnt = 6; cnt >= 0; cnt--)
            {
                MHpkmul((PTR)buff3,31,0,(PTR)buff4,31,0,(PTR)buff2,&p,&s);
                CVlpk(sixteen_bit[cnt], (i4)31, (i4)0, (PTR)buff1);
                MHpkadd((PTR)buff2,31,0,(PTR)buff1,31,0,(PTR)buff3,&p,&s);
            }

            if (CVpkpk((PTR)buff3, 31, 0, DB_P_DECODE_MACRO(outdv->db_prec),
		       DB_S_DECODE_MACRO(outdv->db_prec), outdv->db_data
                      ) == CV_OVERFLOW)
	       {
	            overflow = TRUE;
               }
            break;
          }
          break;
        }
        break;   
      }

      case RMSGW_GFLOAT:
      case RMSGW_HFLOAT:
      {
	i4		    cond;
	char		    *p;
	char		    outbuf[50], temp_out[50];
	$DESCRIPTOR(outdsc, temp_out);
        f8                  ftemp = 0.0;
        char                *ee, *neg, *tempp = temp_out;
        i4                  exp;
        bool                negative = FALSE;

        /*
        ** feb-28-97 (schang) surprise enough, the code for 
        ** g- and h-float are the same for both vax alpha because
        ** the conversionis to a string.
        */
	if (indv->db_datatype == RMSGW_GFLOAT)
	{
	    cond = OTS$CNVOUT_G(indv->db_data, &outdsc, 17);
	}
	else
	{
	    cond = OTS$CNVOUT_H(indv->db_data, &outdsc, 35);
	}

	if (cond != SS$_NORMAL)
	    return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));

	/* The OTS calls will fill the first 49 bytes of outdsc, so we can use
	** the 50th byte to NULL terminate this thing.
	*/
	temp_out[49] = EOS;
        
        /*
        **  find the letter e in the string from ots$cnvout_[gh]
        */
        ee = STindex(temp_out, "E", 0);

        /*
        **  if number is negative, set flag and turn it into positive
        */
        neg = STindex(temp_out, "-", 0);
        if (neg < ee && neg != NULL)
        {
            negative = TRUE;
            *neg = '0';
        }
        /*
        ** if found e, then find out exponent value
        */
        if (ee != NULL)
        {
            CVan(ee+1, &exp);
            if (exp > 0)
            {
                i4  i, ilen;
                char *pos;

                /*
                ** first we need to left justify this number so
                ** that we will have enough space to the right
                ** to shift and cancel the positive exponent
                */
                for (i = 0; temp_out[i] == ' '; i++);
                for (ilen= 0; temp_out[i] != 'E';i++, ilen++)
                     temp_out[ilen] = temp_out[i];
                temp_out[ilen]= '\0';

                /*
                **  find position of '.', copy all char's before '.'
                **  into outbuf, then jump over '.'
                */

                pos = STindex(temp_out, ".", 0);
                ilen = pos - tempp;
                STlcopy(temp_out, outbuf, ilen);
                pos++;

                /*
                ** shift as many char's after '.'  as indicated by
                ** the size of exponent
                */

                for (i = exp; i > 0; i--)
                {
                    outbuf[ilen++] = *pos;
                    pos++;
                }
                
                /*
                **  put the '.' then copy all char's up to 'e'
                */

                outbuf[ilen++] = '.';
                    for (; pos < ee; pos++)
                        outbuf[ilen++] = *pos;
                outbuf[ilen]= '\0'; 
            }
            else if (exp < 0)
            {
                /*
                ** we get a negative exponent number, first right adjust 
                ** the number without exponent and integer and decimal part
                */

                char *pos, *dot;

                dot = STindex(temp_out, ".", 0);
                for (--ee, pos = &temp_out[48]; ee > dot;)
                {
                    *pos = *ee;
                     pos--;
                     ee--;
                }
                /*
                ** put integer part into the string
                */
                *pos = *(dot-1);
                exp--;
                pos--;

                /*
                ** move to the left as many bytes as indicated by
                ** exp, then put a '.' 
                */
                for (ee = pos; exp < 0 && ee > &temp_out[1]; exp++)
                {
                     *ee-- = '0';
                }
                if (exp < 0)
                {
                  /*
                  ** underflow, shift out least significant fraction digit
                  */
                  STcopy(&temp_out[2], &outbuf[0] - exp + 2);
                  for (ee = &outbuf[0] - exp + 1; exp < 0; exp++)
                  {
                      *ee-- = '0';
                  }
                  *ee--= '.';    
                  *ee = '0';
                  for (tempp=outbuf; tempp != ee; tempp++)
                      *tempp = ' ';  
                }
                else 
                {
                  *ee--= '.';    
                  *ee = '0';
                  /*
                  ** put blank into rest of the string
                  */
                  for (tempp=temp_out; tempp != ee; tempp++)
                      *tempp = ' ';
                  STcopy(temp_out, outbuf);
                }  
            }
            else
            {
                STlcopy(temp_out, outbuf, ee - tempp);
                outbuf[ee-tempp] = '\0';
            }
        }                        
        else
           STcopy(temp_out,outbuf);

        /*
        ** strip out possible leading blank
        */
        for (tempp = outbuf; *tempp == ' '; tempp++);
        STcopy(tempp, temp_out);

        if (CVapk(temp_out, 0,
	    	  DB_P_DECODE_MACRO(outdv->db_prec),
		  DB_S_DECODE_MACRO(outdv->db_prec),
		  (negative)?outbuf:outdv->db_data
                 ) == CV_OVERFLOW)
                overflow = TRUE;
        if (negative)
            MHpkneg(outbuf, 
	    	    DB_P_DECODE_MACRO(outdv->db_prec),
		    DB_S_DECODE_MACRO(outdv->db_prec),
		    outdv->db_data);
	break;
      }

      case RMSGW_FFLOAT:
      case RMSGW_DFLOAT:
      {
        f8    ftemp = 0.0;
#ifdef VAX

        if (indv->db_datatype == RMSGW_FFLOAT)
	    ftemp = *(f4 *)indv->db_data;
        else
	    ftemp = *(f8 *)indv->db_data;
#else /* alpha or itanium */
            /*
            ** f- and d-float are not natural on alpha, must be converted
            */
        struct dsc$descriptor  srcdsc;
        struct dsc$descriptor  dstdsc;
        i4  cond;
        i4  len;

        srcdsc.dsc$b_class = DSC$K_CLASS_S;
        if (indv->db_datatype == RMSGW_FFLOAT)
            srcdsc.dsc$b_dtype = DSC$K_DTYPE_F;
        else
            srcdsc.dsc$b_dtype = DSC$K_DTYPE_D;
        srcdsc.dsc$a_pointer = indv->db_data;

        dstdsc.dsc$a_pointer = &ftemp;
        dstdsc.dsc$b_class = DSC$K_CLASS_S;
        dstdsc.dsc$b_dtype = DSC$K_DTYPE_FT;

        cond = lib$cvt_dx_dx(&srcdsc, &dstdsc, &len);

	switch (cond)
        {
            case SS$_NORMAL:
                break;
            case LIB$_FLTOVF:
                overflow = TRUE;
                break;
            case LIB$_FLTUND:
                underflow = TRUE;
                break;
            default:
	        return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));
                break;
        }
#endif

        if (CVfpk(ftemp,
	    	  DB_P_DECODE_MACRO(outdv->db_prec),
		  DB_S_DECODE_MACRO(outdv->db_prec),
		  outdv->db_data
                 ) == CV_OVERFLOW)
                overflow = TRUE;
        break;
      }
      case RMSGW_SFLOAT:
      case RMSGW_TFLOAT:
      {
          f8    ftemp = 0.0;
#ifdef VAX
            /*
            ** s- and t-float are not natural on VAX, must be converted
            */
          if (indv->db_datatype == RMSGW_SFLOAT)
              stat = cvt_s2f(indv->db_data, &ftemp);
          else
              stat = cvt_t2d(indv->db_data, &ftemp);

          if (stat)
	      return(rms_dterr(scb, E_GW7010_BAD_FLOAT_VAL, 0));

#else /* alpha or itanium */
        if (indv->db_datatype == RMSGW_SFLOAT)
	    ftemp = *(f4 *)indv->db_data;
        else
	    ftemp = *(f8 *)indv->db_data;
#endif

        if (CVfpk(ftemp,
	    	  DB_P_DECODE_MACRO(outdv->db_prec),
		  DB_S_DECODE_MACRO(outdv->db_prec),
		  outdv->db_data
                 ) == CV_OVERFLOW)
                overflow = TRUE;
        break;
      }
      case RMSGW_BL_FIXSTR:
      case RMSGW_NL_FIXSTR:
      case RMSGW_BL_VARSTR:
      case RMSGW_NL_VARSTR:
      {
	struct dsc$descriptor	    dsc;
	char			    *p;
        char                        str_buf[64];
	p = (char *)indv->db_data + indv->db_length - 1;

	switch (indv->db_datatype)
	{
	    case    RMSGW_BL_FIXSTR:
	    case    RMSGW_BL_VARSTR:
		while (p > indv->db_data  &&  *p == ' ')
		    p--;
		break;

	    case    RMSGW_NL_FIXSTR:
	    case    RMSGW_NL_VARSTR:
		while (p > indv->db_data  &&  *p == NULLCHAR)
		    p--;
		break;
	}
        STlcopy((char *)indv->db_data, str_buf, p - (char *)indv->db_data + 1);
        str_buf[p-(char *)indv->db_data+1] = '\0';
        if (CVapk(str_buf, 0,
	    	  DB_P_DECODE_MACRO(outdv->db_prec),
		  DB_S_DECODE_MACRO(outdv->db_prec),
		  outdv->db_data
                 ) == CV_OVERFLOW)
                overflow = TRUE;
        break;
      }

      case RMSGW_PACKED_DEC:
	if (CVpkpk(indv->db_data,
		    DB_P_DECODE_MACRO(indv->db_prec),
		    DB_S_DECODE_MACRO(indv->db_prec),
		    DB_P_DECODE_MACRO(outdv->db_prec),
		    DB_S_DECODE_MACRO(outdv->db_prec),
	            outdv->db_data) == CV_OVERFLOW)
	{
	    overflow = TRUE;
	}
	break;

      case RMSGW_LEADING_NUM:
      {
	char	    buf[256],sc_buff[40];
	i4	    digits;

#if (defined(axm_vms) || defined(i64_vms))
	MEcopy(indv->db_data, indv->db_length, &buf[0]);
	buf[indv->db_length] = EOS;
        /*
        ** copy the fractional part
        */
	digits = DB_S_DECODE_MACRO(indv->db_prec);
        if (digits > 0)
        {
            STlcopy(&buf[indv->db_length-digits],
                    sc_buff, digits);
        }
        else
            sc_buff[0] = 0;

        digits = DB_P_DECODE_MACRO(indv->db_prec) -
                  DB_S_DECODE_MACRO(indv->db_prec);
        /*
        ** whole number part already in buf, if any,
        ** put a '.' and null terminate.  Then cat buf and sc_buff
        */
        if (digits > 0)
        {
            if (DB_S_DECODE_MACRO(indv->db_prec) != 0)
            {
                buf[digits+1] = '.';
                buf[digits+2] = 0;
            }
        }
        else
        {
            buf[1] = '0';
            buf[2] = '.';
            buf[3] = 0;
        }
        STcat(buf, sc_buff);
	if (CVapk(buf, 0,
                  DB_P_DECODE_MACRO(outdv->db_prec),
		  DB_S_DECODE_MACRO(outdv->db_prec),
	          outdv->db_data) == CV_OVERFLOW)
	{
            overflow = TRUE;
	}
	break;
#else   /* old vax code */
        rms_mcvt_s_p(indv->db_data,DB_P_DECODE_MACRO(indv->db_prec),
                     outdv->db_data, DB_P_DECODE_MACRO(outdv->db_prec));
#endif
	break;
      }
      case RMSGW_ZONED_NUM:
      case RMSGW_OVR_NUM:
      case RMSGW_UNS_NUM:
      {
	char	    buf[256],sc_buff[40];
	char	    *sd;
	i4	    digits;
        char        least_s;

         

	/* point sd at last digit */
	sd = &indv->db_data[indv->db_length-1];

	/* translate last digit into sign and normal ascii digit */
	buf[0] = rms_1numstr_sign(*sd);
	least_s = rms_0numstr_digit(*sd);
        /*
        ** copy the fractional part, then update last byte
        */
	digits = DB_S_DECODE_MACRO(indv->db_prec);
        if (digits > 0)
        {
            STlcopy(&indv->db_data[indv->db_length-digits],
                    sc_buff, digits);
            sc_buff[digits-1]= least_s;
        }
        else
            sc_buff[0] = 0;

        digits = DB_P_DECODE_MACRO(indv->db_prec) -
                  DB_S_DECODE_MACRO(indv->db_prec);
        /*
        ** copy the whole number part into another buffer, if any,
        ** put a '.' and null terminate.  Then cat buf and sc_buff
        */
        if (digits > 0)
        {
            STlcopy(indv->db_data, &buf[1], digits);
            if (DB_S_DECODE_MACRO(indv->db_prec) == 0)
                buf[digits] = least_s;
            else
            {
                buf[digits+1] = '.';
                buf[digits+2] = 0;
            }
        }
        else
        {
            buf[1] = '0';
            buf[2] = '.';
            buf[3] = 0;
        }
        STcat(buf, sc_buff);

	if (CVapk(buf, 0,
                  DB_P_DECODE_MACRO(outdv->db_prec),
		  DB_S_DECODE_MACRO(outdv->db_prec),
	          outdv->db_data) == CV_OVERFLOW)
	{
            overflow = TRUE;
	}
	break;
      }
      case RMSGW_TRL_NUM:
      {
	char	    buf[256],sc_buff[40];
	char	    *sd;
	i4	    digits;

	MEcopy(indv->db_data, indv->db_length, &buf[1]);

	/* last byte (sign) goes to first in string buffer */
	buf[0] = indv->db_data[indv->db_length];
	buf[indv->db_length] = EOS;
#if (defined(axm_vms) || defined(i64_vms))
        /*
        ** copy the fractional part, then update last byte
        */
	digits = DB_S_DECODE_MACRO(indv->db_prec);
        if (digits > 0)
        {
            STlcopy(&buf[indv->db_length-digits],
                    sc_buff, digits);
        }
        else
            sc_buff[0] = 0;

        digits = DB_P_DECODE_MACRO(indv->db_prec) -
                  DB_S_DECODE_MACRO(indv->db_prec);
        /*
        ** whole number part already in buf, if any,
        ** put a '.' and null terminate.  Then cat buf and sc_buff
        */
        if (digits > 0)
        {
            if (DB_S_DECODE_MACRO(indv->db_prec) != 0)
            {
                buf[digits+1] = '.';
                buf[digits+2] = 0;
            }
        }
        else
        {
            buf[1] = '0';
            buf[2] = '.';
            buf[3] = 0;
        }
        STcat(buf, sc_buff);

	if (CVapk(buf, 0,
                  DB_P_DECODE_MACRO(outdv->db_prec),
		  DB_S_DECODE_MACRO(outdv->db_prec),
	          outdv->db_data) == CV_OVERFLOW)
	{
            overflow = TRUE;
	}
#else   /* old vax code */
        rms_mcvt_s_p(buf, DB_P_DECODE_MACRO(indv->db_prec),
                     outdv->db_data, DB_P_DECODE_MACRO(outdv->db_prec));
#endif
	break;
      }
    }

    if (overflow)
	return(rms_dterr(scb, E_GW7015_DECIMAL_OVF, 1, 4, &outdv->db_length));

    return(E_DB_OK);
}

/*{
** Name: rms_0numstr_digit & rms_1numstr_sign -- unpack zoned or overpunched
**	sign+value byte.
**
** Description:
**	These routines take the low-order byte of a zoned or overpunched
**	numeric field as argument.  This byte represents both the value of
**	the low-order digit and and sign of the entire multi-byte number.
**	Rms_0numstr_digit returns the low-order digit; rms_1numstr_sign
**	returns a representation of the sign as a character, '+', '-',
**	or blank.  Note that the translation of digits '0'-'9' into sign
**	blank allows this to work for leading-sign numeric and unsigned
**	numeric too; for leading-sign numeric the blank is placed in front
**	of the '+' or '-' and is ignored in the conversion, while for
**	unsigned numeric the blank sign is taken to mean '+'.
**
** Inputs:
**	byte			    The low-order byte of a zoned, overpunched,
**				    leading-sign, or unsigned numeric field.
**
** Outputs:
**	none.
**
**  Returns:
**	Rms_0numstr_digit:
**	    The low-order digit of the number, '0'-'9'.
**	Rms_1numstr_sign:
**	    Byte representing the sign of the number, '+', '-', or ' ' (meaning
**	    '+').
**	If the argument byte was invalid, both function return 'X'.  No
**	error is raised here.  We presume the 'X' will lead to an invalid
**	conversion further down the line.
**	    
**  Exceptions:
**	none.
**
**  Side Effects:
**	none.
**
** History:
**	19-jun-90 (edwin)
**	    Created, to impose bounds checking on Rms_numstr_map.
*/

static	short	rms_2numstr_check(char byte, int which); /* logically internal to	*/
					/* rms_0numstr_digit() and	*/
					/* rms_1numstr_sign().		*/

static  short
rms_0numstr_digit
(
    char  byte
)
{
    return (rms_2numstr_check(byte, 0));
}

static  short
rms_1numstr_sign
(
char	byte
)
{
    return (rms_2numstr_check(byte, 1));
}

static  short
rms_2numstr_check
(
    char byte,
    int  which
)
{
    byte &= 0xff;
    if (byte < RMS_8NUMSTR_MIN  ||  byte > RMS_9NUMSTR_MAX)
	return (RMS_7NUMSTR_BAD);
    return (Rms_numstr_map[byte - RMS_8NUMSTR_MIN][which]);
}
